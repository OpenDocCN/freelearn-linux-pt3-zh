<html><head></head><body><div id="sbo-rt-content" class="calibre1"><div id="_idContainer045" class="calibre2">
			<h1 id="_idParaDest-369" class="calibre5"><em class="italic"><a id="_idTextAnchor373" class="pcalibre calibre6 pcalibre1"/>Chapter 15</em>: Using the Reference Policy</h1>
			<p class="calibre3">Up until now, we've covered how to interact with the SELinux subsystem and gradually adjusted the SELinux policy to our liking. As we add more applications and users, we notice that developing custom SELinux policies might help us tune the system more to our liking. There are two main approaches to develop SELinux policies, and using reference policy style development is one of them. The other is discussed in <a href="B16276_16_Final_VK.xhtml#_idTextAnchor391" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 16</em></a>, <em class="italic">SELinux Common Intermediate Language</em>.</p>
			<p class="calibre3">To properly develop an SELinux policy, we'll learn how to use and understand the macros that the reference policy provides, and apply the main coding and development style patterns that the project requires to ensure consistency across SELinux policy modules. We then apply this to two main types of modules: application policies and user policies.</p>
			<p class="calibre3">In this chapter, we're going to cover the following main topics:</p>
			<ul class="calibre8">
				<li class="calibre9">Introducing the reference policy</li>
				<li class="calibre9">Using and understanding the policy macros</li>
				<li class="calibre9">Creating application-level policies</li>
				<li class="calibre9">Getting help with supporting tools</li>
			</ul>
			<h1 id="_idParaDest-370" class="calibre5"><a id="_idTextAnchor374" class="pcalibre calibre6 pcalibre1"/>Technical requirements</h1>
			<p class="calibre3">The code files for this chapter can be found in our Git repository at <a href="https://github.com/PacktPublishing/SELinux-System-Administration-Third-Edition" class="pcalibre calibre6 pcalibre1">https://github.com/PacktPublishing/SELinux-System-Administration-Third-Edition</a>.</p>
			<p class="calibre3">Check out the following video to see the Code in Action: <a href="https://bit.ly/3jcBDvI" class="pcalibre calibre6 pcalibre1">https://bit.ly/3jcBDvI</a></p>
			<h1 id="_idParaDest-371" class="calibre5"><a id="_idTextAnchor375" class="pcalibre calibre6 pcalibre1"/>Introducing the reference policy</h1>
			<p class="calibre3">The <a id="_idIndexMarker960" class="pcalibre calibre6 pcalibre1"/>reference policy, available through <a href="https://github.com/SELinuxProject/refpolicy" class="pcalibre calibre6 pcalibre1">https://github.com/SELinuxProject/refpolicy</a>, is the source SELinux policy for most, if not all, Linux distributions out there. While it is possible that the plain reference policy will not work out of the box for any Linux distribution (as many Linux distributions add their own touch to the policy, or adjust it so it fits the applications and support tooling installed), the development methodology, structure, and approach used by the reference policy are applicable to all major distribution policies.</p>
			<p class="calibre3">We <a id="_idIndexMarker961" class="pcalibre calibre6 pcalibre1"/>recommend checking out the SELinux policy of your distribution to see and easily modify SELinux policies for the system. In this chapter, we'll use a checkout of the reference policy:</p>
			<p class="source-code">$ git clone https://github.com/SELinuxProject/refpolicy.git</p>
			<p class="calibre3">The SELinux policy repositories for the Linux distributions should be documented by the distributions themselves. A few example repositories are listed next:</p>
			<ul class="calibre8">
				<li class="calibre9">For CentOS, the <a id="_idIndexMarker962" class="pcalibre calibre6 pcalibre1"/>policy repository can be found at <a href="https://github.com/fedora-selinux/selinux-policy" class="pcalibre calibre6 pcalibre1">https://github.com/fedora-selinux/selinux-policy</a>.</li>
				<li class="calibre9">For Gentoo Linux, the<a id="_idIndexMarker963" class="pcalibre calibre6 pcalibre1"/> policy repository can be found at <a href="https://gitweb.gentoo.org/proj/hardened-refpolicy.git/" class="pcalibre calibre6 pcalibre1">https://gitweb.gentoo.org/proj/hardened-refpolicy.git/</a>.</li>
				<li class="calibre9">For Debian, the policy<a id="_idIndexMarker964" class="pcalibre calibre6 pcalibre1"/> repository can be found at <a href="https://salsa.debian.org/cgzones/selinux-policy-debian" class="pcalibre calibre6 pcalibre1">https://salsa.debian.org/cgzones/selinux-policy-debian</a>.</li>
				<li class="calibre9">For Arch Linux, the <a id="_idIndexMarker965" class="pcalibre calibre6 pcalibre1"/>policy repository can be found at <a href="https://github.com/archlinuxhardened/selinux-policy-arch/" class="pcalibre calibre6 pcalibre1">https://github.com/archlinuxhardened/selinux-policy-arch/</a>.</li>
			</ul>
			<p class="calibre3">If the Linux distribution does not have a publicly reachable repository for its SELinux policy, we can often still obtain it through the packages themselves, as used in <a href="B16276_12_Final_VK.xhtml#_idTextAnchor312" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 12</em></a>, <em class="italic">Working with SELinux Policies</em>.</p>
			<p class="calibre3">While it is not the intention to do full policy rebuilds, we can easily copy over the necessary policy files to our own development environment and fine-tune or extend the policy as needed.</p>
			<h2 id="_idParaDest-372" class="calibre10"><a id="_idTextAnchor376" class="pcalibre calibre6 pcalibre1"/>Navigating the policy</h2>
			<p class="calibre3">At its base directory, the <a id="_idIndexMarker966" class="pcalibre calibre6 pcalibre1"/>reference policy hosts all the common files for building the policies, explaining how to install them, and so forth. The policy itself is in the <strong class="source-inline">policy</strong> folder, which contains three directories:</p>
			<ul class="calibre8">
				<li class="calibre9"><strong class="source-inline">flask</strong> contains the initial definitions used to jumpstart SELinux, such as listing the supported classes, creating initial security identifiers, and more. We will not touch this location further.</li>
				<li class="calibre9"><strong class="source-inline">modules</strong> contains the SELinux policy code and is the main location for all policy rules.</li>
				<li class="calibre9"><strong class="source-inline">support</strong> contains macros and definitions that are reused across the policy and are not associated with a single policy module.</li>
			</ul>
			<p class="calibre3">If we enter the <strong class="source-inline">modules</strong> directory further, we get directories that represent the type of modules or policies contained. This representation by itself is merely to have some structure across the hundreds of modules that are developed:</p>
			<ul class="calibre8">
				<li class="calibre9"><strong class="source-inline">admin</strong> contains system administration related policy modules.</li>
				<li class="calibre9"><strong class="source-inline">apps</strong> contains general application policy modules.</li>
				<li class="calibre9"><strong class="source-inline">kernel</strong> contains core system policy modules (not just kernel related ones).</li>
				<li class="calibre9"><strong class="source-inline">roles</strong> contains SELinux role definitions and default user domain policy modules.</li>
				<li class="calibre9"><strong class="source-inline">services</strong> contains general service policy modules (and is by far the largest set of policy modules).</li>
				<li class="calibre9"><strong class="source-inline">system</strong> contains common system related policy modules.</li>
			</ul>
			<p class="calibre3">The interpretation of which folder a policy is placed in is left to the reference policy project itself, and discussed on its mailing list when it is not obvious. As policy files are required to have a unique name, we can find the appropriate location easily. For instance, to see where the <strong class="source-inline">ipsec</strong> policy module is stored:</p>
			<p class="source-code">$ ls policy/modules/*/ipsec.te</p>
			<p class="source-code">policy/modules/system/ipsec.te</p>
			<p class="calibre3">While browsing, you'll notice that the policy modules are always represented by three files, which we describe next.</p>
			<h2 id="_idParaDest-373" class="calibre10"><a id="_idTextAnchor377" class="pcalibre calibre6 pcalibre1"/>Structuring policy modules</h2>
			<p class="calibre3">If we analyze an SELinux <a id="_idIndexMarker967" class="pcalibre calibre6 pcalibre1"/>policy module's code, such as for the <strong class="source-inline">dhcp</strong> module in the <strong class="source-inline">services</strong> folder, we'll notice that it has three files associated with it:</p>
			<ul class="calibre8">
				<li class="calibre9"><strong class="source-inline">dhcp.te</strong>, which contains the type enforcement rules, and is the main area of attention for most changes</li>
				<li class="calibre9"><strong class="source-inline">dhcp.fc</strong>, which contains the file context definitions, informing the policy which files or resources need to be labeled with <strong class="source-inline">dhcp</strong> related SELinux types</li>
				<li class="calibre9"><strong class="source-inline">dhcp.if</strong>, which contains interface definitions, which are reusable functions or macros that can be used in the <strong class="source-inline">dhcp</strong> SELinux policy code as well as elsewhere</li>
			</ul>
			<p class="calibre3">Let's quickly see how each of these files is structured.</p>
			<h3 class="calibre12">Understanding type enforcement files</h3>
			<p class="calibre3">The type enforcement file, <strong class="source-inline">dhcp.te</strong> in our <a id="_idIndexMarker968" class="pcalibre calibre6 pcalibre1"/>example, has the following structure:</p>
			<p class="source-code">policy_module(dhcp, 1.18.2)</p>
			<p class="source-code">## Declarations</p>
			<p class="source-code"># SELinux booleans</p>
			<p class="source-code"># SELinux types</p>
			<p class="source-code">## Local policy</p>
			<p class="source-code"># Internal SELinux rules</p>
			<p class="source-code"># Core interfaced SELinux rules</p>
			<p class="source-code"># SELinux boolean controlled SELinux rules</p>
			<p class="source-code"># Non-blocking interfaced SELinux rules</p>
			<p class="calibre3">Let's look at each of these areas with an example.</p>
			<h4 class="calibre36">Declaring SELinux objects</h4>
			<p class="calibre3">The <strong class="source-inline">Declarations</strong> section in a <a id="_idIndexMarker969" class="pcalibre calibre6 pcalibre1"/>policy tells us what SELinux types, or other SELinux objects such as SELinux booleans and SELinux roles, are defined within this module.</p>
			<p class="calibre3">The following declarations are common in SELinux policies: </p>
			<ul class="calibre8">
				<li class="calibre9">The first declaration in the <strong class="source-inline">dhcp</strong> SELinux policy declares an SELinux boolean for this module. It is best practice to start the boolean with the SELinux policy module name, although in this case the choice is made to explicitly use <strong class="source-inline">dhcpd</strong> rather than <strong class="source-inline">dhcp</strong> to make it obvious for administrators it is about the DHCP daemon and not possible clients or other use cases:<p class="source-code">## &lt;desc&gt;</p><p class="source-code">##   &lt;p&gt;Determine whether DHCP daemon can use LDAP</p><p class="source-code">##   backends&lt;/p&gt;</p><p class="source-code">## &lt;/desc&gt;</p><p class="source-code">gen_tunable(dhcpd_use_ldap, false)</p><p class="calibre3">The SELinux boolean is accompanied by a specifically structured comment. Comments within the reference policy that use a double hash prefix (<strong class="source-inline">##</strong>) will be parsed by the build code and used to update information outside of the SELinux policy. In this case, the description of the SELinux boolean is created, which will be made visible later on through commands such as <strong class="source-inline">semanage boolean</strong>.</p><p class="calibre3">Once a module is loaded that defines an SELinux policy, other modules can use this boolean as well.</p></li>
				<li class="calibre9">Some domains might also declare a role attribute, which allows easy management of which roles are allowed to use the domain:<p class="source-code">attribute_role dhcpd_roles;</p></li>
				<li class="calibre9">The rest of the declarations in the <strong class="source-inline">dhcp</strong> SELinux policy declare the SELinux types that the policy owns:<p class="source-code">type dhcpd_t;      # The SELinux domain for the daemon</p><p class="source-code">type dhcpd_exec_t; # The executable label for the daemon</p><p class="source-code">init_daemon_domain(dhcpd_t, dhcpd_exec_t)</p><p class="source-code">                   # Linking the executable to the domain</p><p class="calibre3">SELinux policy modules in the reference policy only declare the types and other objects that they own, not those they use. The objects used but defined by other modules should always be hidden away and interacted with through the interface calls.</p></li>
			</ul>
			<p class="calibre3">While other definitions can be <a id="_idIndexMarker970" class="pcalibre calibre6 pcalibre1"/>added to the section as well, these are the most common. Next up are the local policy rules.</p>
			<h4 class="calibre36">Adding the domain's local rules</h4>
			<p class="calibre3">The local policy within<a id="_idIndexMarker971" class="pcalibre calibre6 pcalibre1"/> the type enforcement defines the allowed behavior of the domains owned by the SELinux policy module. For the <strong class="source-inline">dhcp</strong> SELinux policy module, this is only focusing on the <strong class="source-inline">dhcpd_t</strong> SELinux domain. Other SELinux policy modules, especially if they offer a more fine-grained policy structure, will do this for several of its own SELinux domains, or even SELinux user roles.</p>
			<p class="calibre3">Let's go through the SELinux policy rules for the <strong class="source-inline">dhcp.te</strong> example we are looking at:</p>
			<ul class="calibre8">
				<li class="calibre9">The policy starts with the internal SELinux rules, which are interactions between the SELinux types owned by the SELinux policy module itself:<p class="source-code">allow dhcpcd_t self:process { getcap signal_perms };</p><p class="source-code">manage_files_pattern(dhcpd_t, dhcpd_tmp_t, dhcpd_tmp_t)</p><p class="calibre3">The most simple rules are the standard <strong class="source-inline">allow</strong> rules, similar to those that <strong class="source-inline">audit2allow</strong> would recommend. These <strong class="source-inline">allow</strong> rules can refer to support macros (such as <strong class="source-inline">signal_perms</strong>), which we'll discuss in the <em class="italic">Using and understanding the policy macros</em> section. The second line, which is a call to <strong class="source-inline">manage_files_pattern</strong>, is also a support macro.</p></li>
				<li class="calibre9">The second set of local policy definitions are the core interfaced SELinux rules:<p class="source-code">kernel_read_system_state(dhcpd_t)</p><p class="calibre3">These calls use the code that another SELinux policy module has defined in its interface file. In the case of the <strong class="source-inline">kernel_read_system_state</strong> interface, this will grant the <strong class="source-inline">dhcpd_t</strong> SELinux domain the rights to read <strong class="source-inline">proc_t</strong> labeled resources. As <strong class="source-inline">proc_t</strong> is not defined by the <strong class="source-inline">dhcp</strong> SELinux policy module, an interface call has to be used.</p><p class="calibre3">Core interfaced <a id="_idIndexMarker972" class="pcalibre calibre6 pcalibre1"/>SELinux rules are rules that should at all times be available to the system. Unlike application related SELinux policy modules, which can be disabled or unloaded, these core rules are associated with type definitions that cannot be removed from the system or disabled at will.</p></li>
				<li class="calibre9">The third set of local policy definitions are the SELinux boolean controlled calls:<p class="source-code">tunable_policy(`dhcpd_use_ldap', `</p><p class="source-code">  # If boolean is true</p><p class="source-code">  sysnet_use_ldap(dhcpd_t)</p><p class="source-code">', `</p><p class="source-code">  # If boolean is false</p><p class="source-code">')</p><p class="calibre3">Here, the SELinux interface calls (which can also be standard rules such as <strong class="source-inline">allow</strong> rules) are surrounded by a <strong class="source-inline">tunable_policy()</strong> call, which identifies the SELinux boolean (in our case <strong class="source-inline">dhcpd_use_ldap</strong>) that will influence the SELinux policy rules. Most policy modules will only have a single block (for the rules that are activated if the SELinux boolean is true) but it is possible to have two blocks, where the second one defines the rules in case the SELinux boolean is false.</p></li>
				<li class="calibre9">The final set of local policy definitions are the non-blocking interfaced SELinux rules:<p class="source-code">optional_policy(`</p><p class="source-code">  bind_read_dnssec_keys(dhcpd_t)</p><p class="source-code">')</p><p class="calibre3">These are the calls that use definitions provided by other SELinux policy modules, but where these SELinux policy modules might not be loaded on the system.</p><p class="calibre3">In our example, the <strong class="source-inline">bind_read_dnssec_keys()</strong> call allows the <strong class="source-inline">dhcpd_t</strong> SELinux domain to read <strong class="source-inline">dnssec_t</strong> labeled resources, as defined by the bind SELinux policy<a id="_idIndexMarker973" class="pcalibre calibre6 pcalibre1"/> module. However, BIND might not be installed on the system, and the Linux distribution might thus not have its policy loaded. So this call is optional and only active if the bind SELinux policy module is loaded.</p></li>
			</ul>
			<p class="calibre3">The type enforcement file is the file that will change most often. The file context definition file, which we discuss next, is a close second.</p>
			<h3 class="calibre12">Declaring file contexts</h3>
			<p class="calibre3">The file <a id="_idIndexMarker974" class="pcalibre calibre6 pcalibre1"/>context definition file, with the <strong class="source-inline">.fc</strong> suffix, tells the SELinux subsystem what SELinux types have to be associated with the file resources on the system. This information is used by tools such as <strong class="source-inline">restorecon</strong> to reset the context appropriately.</p>
			<p class="calibre3">The rules inside the file are generally grouped based on the directory for which the rules apply. Each rule is structured like so:</p>
			<p class="source-code">&lt;path expression&gt;    [&lt;type/class&gt;]    &lt;context&gt;</p>
			<p class="calibre3">Let's see what these entries imply:</p>
			<ul class="calibre8">
				<li class="calibre9">The <em class="italic">path expressions</em> are the same ones we saw in <a href="B16276_04_Final_VK.xhtml#_idTextAnchor095" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 4</em></a>, <em class="italic">Using File Contexts and Process Domains</em>. Keep in mind that characters such as dot (<strong class="source-inline">.</strong>) have a specific meaning (in this case, it reflects any possible character) so that paths that really require a dot inside must escape the dot.</li>
				<li class="calibre9">The <em class="italic">type/class</em> is an optional setting. If omitted, then it means any possible class is used. The most common values to use are regular files (<strong class="source-inline">--</strong>), directories (<strong class="source-inline">-d</strong>), sockets (<strong class="source-inline">-s</strong>), and symbolic links (<strong class="source-inline">-l</strong>).</li>
				<li class="calibre9">The <em class="italic">context</em> is a reference to the target SELinux type for this resource. In the reference policy, these context references always need to be encased by the <strong class="source-inline">gen_context()</strong> macro, which will add or remove the sensitivity depending on the MLS or MCS support built inside the policy.</li>
			</ul>
			<p class="calibre3">Let's look at a simple example from the <strong class="source-inline">dhcp</strong> SELinux policy module:</p>
			<p class="source-code">/var/named/data(/.*)?  gen_context(system_u:object_r:named_cache_t,s0)</p>
			<p class="calibre3">In this<a id="_idIndexMarker975" class="pcalibre calibre6 pcalibre1"/> example, the <strong class="source-inline">/var/named/data</strong> directory, and any resource below it, will be labeled with the <strong class="source-inline">named_cache_t</strong> SELinux type.</p>
			<p class="calibre3">The last file that is associated with an SELinux policy module is the interface definition file.</p>
			<h3 class="calibre12">Exposing SELinux rules through interfaces</h3>
			<p class="calibre3">Interfaces within <a id="_idIndexMarker976" class="pcalibre calibre6 pcalibre1"/>an SELinux policy module are meant to support a <a id="_idIndexMarker977" class="pcalibre calibre6 pcalibre1"/>more flexible, modular development of SELinux policies across different modules. Whenever a domain or SELinux role needs to interact with resources that are defined in a different SELinux policy module, that module should create a properly named interface for the interaction.</p>
			<p class="calibre3">Interfaces should be accompanied by a minimal amount of documentation, although this documentation is only used when building the documentation of the entire policy. When this is done, the resulting documentation is made available on the system, for instance in <strong class="source-inline">/usr/share/doc/selinux-policy/html</strong>.</p>
			<p class="calibre3">Let's look at the definition for the <strong class="source-inline">dhcpd_domtrans()</strong> interface:</p>
			<p class="source-code">########################################</p>
			<p class="source-code">## &lt;summary&gt;</p>
			<p class="source-code">##	Execute a domain transition to run dhcpd.</p>
			<p class="source-code">## &lt;/summary&gt;</p>
			<p class="source-code">## &lt;param name="domain"&gt;</p>
			<p class="source-code">##	&lt;summary&gt;</p>
			<p class="source-code">##	Domain allowed to transition.</p>
			<p class="source-code">##	&lt;/summary&gt;</p>
			<p class="source-code">## &lt;/param&gt;</p>
			<p class="source-code">#</p>
			<p class="source-code">interface(`dhcpd_domtrans',`</p>
			<p class="source-code">  gen_require(`</p>
			<p class="source-code">    type dhcpd_t, dhcpd_exec_t;</p>
			<p class="source-code">  ')</p>
			<p class="source-code">  corecmd_search_bin($1)</p>
			<p class="source-code">  domtrans_pattern($1, dhcpd_exec_t, dhcpd_t)</p>
			<p class="source-code">')</p>
			<p class="calibre3">As is best practice, the <a id="_idIndexMarker978" class="pcalibre calibre6 pcalibre1"/>interface name starts with the SELinux policy <a id="_idIndexMarker979" class="pcalibre calibre6 pcalibre1"/>name and is followed by the action that is allowed. Sometimes, this action is suffixed with the target resource. The interface itself can reference the arguments passed along to the interface using <strong class="source-inline">$1</strong> (first argument), <strong class="source-inline">$2</strong> (second argument), and so on. So a call such as <strong class="source-inline">dhcpd_domtrans(init_t)</strong> will have the interface called, where <strong class="source-inline">$1</strong> is substituted with <strong class="source-inline">init_t</strong>.</p>
			<p class="calibre3">Let's look at a few examples with common actions:</p>
			<ul class="calibre8">
				<li class="calibre9"><strong class="bold">Domain transitions</strong> allow a<a id="_idIndexMarker980" class="pcalibre calibre6 pcalibre1"/> domain to transition to another domain. If the SELinux policy module only manages a single domain, then there is no target resource defined (as with <strong class="source-inline">dhcpd_domtrans()</strong>). If there are multiple domains, then the target resource will define which domain (as with <strong class="source-inline">bind_domtrans_ndc()</strong>) to allow a domain transition to the <strong class="source-inline">ndc_t</strong> SELinux domain.</li>
				<li class="calibre9"><strong class="bold">Permission interactions</strong> generally <a id="_idIndexMarker981" class="pcalibre calibre6 pcalibre1"/>refer to the permission at hand and, if it is possible to misinterpret to which resource the permission refers, the target resource is listed. So <strong class="source-inline">dhcpd_setattr_state_files()</strong> allows the domain to set the attributes of the <strong class="source-inline">dhcpd_state_t</strong> labeled resources, whereas <strong class="source-inline">bind_signal()</strong> allows the domain to send signals to the <strong class="source-inline">named_t</strong> labeled processes. Most of the interface definitions will be permission interactions.</li>
				<li class="calibre9"><strong class="bold">Role-oriented interfaces</strong> will<a id="_idIndexMarker982" class="pcalibre calibre6 pcalibre1"/> grant the associated SELinux role and SELinux domain all the privileges needed to perform a functional role for the SELinux domain. For instance, the <strong class="source-inline">dhcpd_admin()</strong> role will allow managing the <strong class="source-inline">dhcpd</strong> related resources, starting and stopping the <strong class="source-inline">dhcpd</strong> service, and so on.<p class="calibre3">Suppose you want to grant this to the web administration role, then the call within the web administration SELinux policy module could look like so:</p><p class="source-code">optional_policy(`</p><p class="source-code">  dhcpd_admin(webadm_r, webadm_t)</p><p class="source-code">')</p></li>
			</ul>
			<p class="calibre3">While developing SELinux policies, it is recommended to look into the interface definitions of the SELinux policy modules to see which ones exist and what they provide. Policy developers will put often requested permissions in such interfaces, so the available interfaces give a good view of what you will most likely need for your own SELinux policy module.</p>
			<p class="calibre3">The interface definitions are also made available on the system at <strong class="source-inline">/usr/share/selinux/devel/include</strong> so that you can create and modify SELinux policy modules<a id="_idIndexMarker983" class="pcalibre calibre6 pcalibre1"/> even without checking out the main source repository. Whenever we build a reference policy style module, we use a command like the following:</p>
			<p class="source-code">$ make -f /usr/share/selinux/devel/Makefile &lt;name&gt;.pp</p>
			<p class="calibre3">This will cause the build process to look for the interfaces inside the <strong class="source-inline">/usr/share/selinux/devel/include</strong> location, as well as inside the current working directory.</p>
			<h1 id="_idParaDest-374" class="calibre5"><a id="_idTextAnchor378" class="pcalibre calibre6 pcalibre1"/>Using and understanding the policy macros</h1>
			<p class="calibre3">Across the various SELinux <a id="_idIndexMarker984" class="pcalibre calibre6 pcalibre1"/>policy definitions, we have come across macros that are not tied to a specific SELinux policy module. These are support macros, available inside the <strong class="source-inline">policy/support/*.spt</strong> files.</p>
			<p class="calibre3">The most common macros are those declared inside the <strong class="source-inline">obj_perm_sets.spt</strong> file (which group common permissions for the same class in a single definition) and the <strong class="source-inline">*_patterns.spt</strong> files (which group permissions across different classes in a single definition).</p>
			<h2 id="_idParaDest-375" class="calibre10"><a id="_idTextAnchor379" class="pcalibre calibre6 pcalibre1"/>Making use of single-class permission groups</h2>
			<p class="calibre3"><strong class="bold">Single-class permission groups</strong> allow<a id="_idIndexMarker985" class="pcalibre calibre6 pcalibre1"/> developers to ignore possible extensions of the SELinux supported permissions as time goes by. For instance, if you want to allow a domain to execute a certain resource, it is most often not enough to allow the <strong class="source-inline">execute</strong> permission. You also need the <strong class="source-inline">open</strong> and <strong class="source-inline">read</strong> permissions (as otherwise, the domain cannot read the executable) and the <strong class="source-inline">map</strong> permission (to allow mapping the file in memory).</p>
			<p class="calibre3">If you were to put all these permissions in your own SELinux policy module, then the rule could look like so:</p>
			<p class="source-code">allow dhcpd_t dhcpd_exec_t:file { getattr open map read execute ioctl execute_no_trans };</p>
			<p class="calibre3">If, later on, the SELinux policy is extended with an additional permission that is associated with executing resources, then you will need to look for and update these permissions all over the different SELinux policy modules.</p>
			<p class="calibre3">So the reference policy<a id="_idIndexMarker986" class="pcalibre calibre6 pcalibre1"/> moves all these permissions in a macro called <strong class="source-inline">exec_file_perms</strong>, defined as follows:</p>
			<p class="source-code">define(`exec_file_perms',`{ getattr open map read execute ioctl execute_no_trans }')</p>
			<p class="calibre3">With this macro defined, our policy line can be simplified as follows:</p>
			<p class="source-code">allow dhcpd_t dhcpd_exec_t:file { exec_file_perms };</p>
			<p class="calibre3">If at any point the permissions need to be extended, all that has to happen is to extend the macro definition itself, and the SELinux policy modules can be left untouched.</p>
			<h2 id="_idParaDest-376" class="calibre10"><a id="_idTextAnchor380" class="pcalibre calibre6 pcalibre1"/>Calling permission groups</h2>
			<p class="calibre3">While single-class permission <a id="_idIndexMarker987" class="pcalibre calibre6 pcalibre1"/>groups are a good use for simplifying policy development, <strong class="bold">permission groups</strong> that cover multiple classes are even more common.</p>
			<p class="calibre3">For instance, if a domain needs full management privileges (implying <strong class="source-inline">read</strong>, <strong class="source-inline">write</strong>, as well as creating and removing resources) on resources inside <strong class="source-inline">/var/lib/dhcpd</strong>, then not only are these privileges needed on the files inside that directory (which are labeled with the <strong class="source-inline">dhcpd_state_t</strong> SELinux type), but you also need read/write permissions on the directory itself.</p>
			<p class="calibre3">Such a privilege definition would result in something like so:</p>
			<p class="source-code">allow $1 dhcpd_state_t:dir { rw_dir_perms };</p>
			<p class="source-code">allow $1 dhcpd_state_t:file { manage_file_perms };</p>
			<p class="calibre3">Rather than declaring these as separate calls, they can be put into a single one that groups the two:</p>
			<p class="source-code">manage_files_pattern($1, dhcpd_state_t, dhcpd_state_t)</p>
			<p class="calibre3">SELinux policy <a id="_idIndexMarker988" class="pcalibre calibre6 pcalibre1"/>developers best get acquainted with the various macros available to allow for rapid and efficient SELinux policy development.</p>
			<h1 id="_idParaDest-377" class="calibre5"><a id="_idTextAnchor381" class="pcalibre calibre6 pcalibre1"/>Creating application-level policies</h1>
			<p class="calibre3">Application-level policies<a id="_idIndexMarker989" class="pcalibre calibre6 pcalibre1"/> provide confinement for applications or services. There are a number of different types of application-level policies around:</p>
			<ul class="calibre8">
				<li class="calibre9">End user application policies, which focus on accessing end user data, and will often call various <strong class="source-inline">userdom_*</strong> interfaces (which are provided through the <strong class="source-inline">system/userdomain.if</strong> file). Most of these applications are inside the <strong class="source-inline">apps/</strong> directory).</li>
				<li class="calibre9">Administration applications, which are still user-facing, are more likely to enable interacting with system services and resources.</li>
				<li class="calibre9">Services, which are generally daemonized applications, often interact mostly with their own resources and have a simpler structure.</li>
			</ul>
			<p class="calibre3">When we covered the <strong class="source-inline">sepolicy generate</strong> command in <a href="B16276_14_Final_VK.xhtml#_idTextAnchor354" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 14</em></a>, <em class="italic">Dealing with New Applications</em>, we could select these types (and more) to generate a simple skeleton for those applications.</p>
			<p class="calibre3">Let's look into some example policies and identify useful calls that you might need when developing your own policies.</p>
			<h2 id="_idParaDest-378" class="calibre10"><a id="_idTextAnchor382" class="pcalibre calibre6 pcalibre1"/>Constructing network-facing service policies</h2>
			<p class="calibre3">Services that are <a id="_idIndexMarker990" class="pcalibre calibre6 pcalibre1"/>network-facing (meaning they can be interacted with from outside the system itself) are the first set of services that need to be confined. Hence, building SELinux policy modules for network-facing services should be a primary focus of any Linux administrator that needs to ensure the confinement of applications that do not have a working policy yet.</p>
			<p class="calibre3">If we look at the OpenVPN service, then we find that there is an SELinux policy under <strong class="source-inline">services/openvpn.te</strong> that we can look into.</p>
			<h3 class="calibre12">Identifying the resources that the service interacts with</h3>
			<p class="calibre3">As a policy starts with <a id="_idIndexMarker991" class="pcalibre calibre6 pcalibre1"/>identifying the types and other SELinux objects, we need to consider the resources on the system that the service interacts with. When comparing service policies with each other, you'll notice that the definitions are often very similar:</p>
			<ul class="calibre8">
				<li class="calibre9">The main domain type and its entry point executable are declared first. Depending on the type of service, it contains a call as to how it would be started: as a system service (using <strong class="source-inline">init_daemon_domain()</strong>) or through the D-Bus system bus (using <strong class="source-inline">dbus_system_domain()</strong>).</li>
				<li class="calibre9">The configuration files for the service (such as <strong class="source-inline">openvpn_etc_t</strong>), which could also differentiate between read-only files and read-write (such as <strong class="source-inline">openvpn_etc_rw_t</strong>).</li>
				<li class="calibre9">Runtime files (which are generally stored in <strong class="source-inline">/var/run</strong>) such as <strong class="source-inline">openvpn_runtime_t</strong>.</li>
				<li class="calibre9">Temporary files (which are generally stored in <strong class="source-inline">/tmp</strong> or <strong class="source-inline">/var/tmp</strong>) such as <strong class="source-inline">openvpn_tmp_t</strong>.</li>
				<li class="calibre9">Log files (which are generally stored in <strong class="source-inline">/var/log</strong>) such as <strong class="source-inline">openvpn_var_log_t</strong>.</li>
			</ul>
			<p class="calibre3">Each of the type declarations is followed by a call that marks the type appropriately. For instance, the <strong class="source-inline">logging_log_file()</strong> call will associate the type with the logfile SELinux attribute. This allows general logfile management domains to deal with the newly created resource through this attribute.</p>
			<h3 class="calibre12">Handling the internal SELinux rules</h3>
			<p class="calibre3">With the resources declared, we <a id="_idIndexMarker992" class="pcalibre calibre6 pcalibre1"/>have to define the internal SELinux rules within the SELinux policy. These rules tell SELinux what the domain can do with its own resources, and how SELinux should behave when the resources are interacted with.</p>
			<p class="calibre3">We will generally have two sets of internal rules declared. One is the fine-grained permissions of the domain itself, such as if the domain is allowed to have any capabilities, creating sockets, and so on. The development of these rules is trial-and-error based: start with close to no permissions, see what AVC denials come up, extend the policy, and repeat.</p>
			<p class="calibre3">The other set of internal rules focuses on the interaction with the types declared earlier on. This not only includes which permissions the domain has (such as through the <strong class="source-inline">manage_files_pattern()</strong> calls) but also whether transitions have to occur.</p>
			<p class="calibre3">Setting the right set of transitions is one of the more important first steps to take while developing application policies because <strong class="source-inline">audit2allow</strong> and AVC denials generally do not consider the fact that a target resource has the wrong type assigned. So when we have a service that creates files in <strong class="source-inline">/tmp</strong> (which is labeled as <strong class="source-inline">tmp_t</strong>), we really want the target files to be labeled correctly (such as <strong class="source-inline">openvpn_tmp_t</strong>) and not inherit the <strong class="source-inline">tmp_t</strong> label from the directory:</p>
			<p class="source-code">allow openvpn_t openvpn_tmp_t:file manage_file_perms;</p>
			<p class="source-code">files_tmp_filetrans(openvpn_t, openvpn_tmp_t, file)</p>
			<p class="calibre3">File transitions should be declared for all the resources involved. If a transition has to occur for both files and directories, you can mix the classes in a single call like so:</p>
			<p class="source-code">files_tmp_filetrans(openvpn_t, openvpn_tmp_t, { file dir })</p>
			<p class="calibre3">We can also tell SELinux that a transition should only occur if a specific filename is used:</p>
			<p class="source-code">logging_log_filetrans(openvpn_t, openvpn_status_t, file, "openvpn-status.log")</p>
			<p class="calibre3">It is really recommended to first consider the file transitions (and other resource transitions) before expanding the actual permissions for the domain to make sure that we are not tempted to allow the domain privileges to general types when that is not necessary.</p>
			<h3 class="calibre12">Adding network related permissions</h3>
			<p class="calibre3">While developing and <a id="_idIndexMarker993" class="pcalibre calibre6 pcalibre1"/>expanding the policy, several core functions will be added, such as the <strong class="source-inline">kernel_*</strong> calls to allow processes to interact with the <strong class="source-inline">proc_t</strong> resources, system control settings, and more. Tools such as <strong class="source-inline">audit2allow</strong> will reasonably be able to deduce the right interfaces to call, although it does not hurt to review the interfaces to make sure not too many privileges are assigned.</p>
			<p class="calibre3">Network related permissions on the other hand might require some more attention. As we saw in <a href="B16276_05_Final_VK.xhtml#_idTextAnchor138" class="pcalibre calibre6 pcalibre1"><em class="italic">Chapter 5</em></a>, <em class="italic">Controlling Network Communications</em>, SELinux can dynamically address certain network flows based on the system configuration.</p>
			<p class="calibre3">It is likely that systems who do not have specific controls in place, such as labelled networking or SECMARK, will find that three interface calls could allow the application to work as intended:</p>
			<p class="source-code">corenet_tcp_bind_generic_node(openvpn_t)</p>
			<p class="source-code">corenet_tcp_bind_openvpn_port(openvpn_t)</p>
			<p class="source-code">corenet_tcp_connect_http_port(openvpn_t)</p>
			<p class="calibre3">These three interface calls allow the domain to be network-oriented (<strong class="source-inline">corenet_tcp_bind_generic_node</strong>), listen to the OpenVPN port (<strong class="source-inline">corenet_tcp_bind_openvpn_port</strong>), as well as connecting, as a client, to HTTP ports (<strong class="source-inline">corenet_tcp_connect_http_port</strong>).</p>
			<p class="calibre3">But other calls exist that you might need to add, even though they are currently not detected. They might become necessary when the system is tuned further, such as adding support for labeled networking or introducing SECMARK filtering.</p>
			<p class="calibre3">The first set is to allow sending and receiving packets on generic nodes (hosts) and interfaces:</p>
			<p class="source-code">corenet_tcp_sendrecv_generic_node(openvpn_t)</p>
			<p class="source-code">corenet_tcp_sendrecv_generic_if(openvpn_t)</p>
			<p class="calibre3">For NetLabel support, you might need to add support to receive labeled network packets:</p>
			<p class="source-code">corenet_all_recvfrom_netlabel(openvpn_t)</p>
			<p class="calibre3">For SECMARK support, you need to add support for sending and receiving SECMARK labeled packets:</p>
			<p class="source-code">corenet_sendrecv_openvpn_server_packets(openvpn_t)</p>
			<p class="source-code">corenet_sendrecv_http_client_packets(openvpn_t)</p>
			<p class="calibre3">These calls might not <a id="_idIndexMarker994" class="pcalibre calibre6 pcalibre1"/>show up in early tests, but could be needed later on, and it is recommended to consider the impact of labeled networking and SECMARK on your policy from the beginning.</p>
			<h3 class="calibre12">Building the service interface methods</h3>
			<p class="calibre3">We next focus our efforts <a id="_idIndexMarker995" class="pcalibre calibre6 pcalibre1"/>on the interface methods. These are used to facilitate other SELinux policy modules to interact with the domain we're developing, although they can also be used to simplify policy development for your own policy.</p>
			<p class="calibre3">The three most common interfaces to define, and which other policy developers will assume exist, are the following:</p>
			<ul class="calibre8">
				<li class="calibre9">A <strong class="bold">domain transition interface</strong>, such as <strong class="source-inline">openvpn_domtrans</strong>, allowing the given SELinux domain to <a id="_idIndexMarker996" class="pcalibre calibre6 pcalibre1"/>execute the appropriate binaries or scripts and have the executed commands or applications run in our domain (and as such transition from the source domain to ours).</li>
				<li class="calibre9">A <strong class="bold">run interface</strong>, such as <strong class="source-inline">openvpn_run</strong>, which is like the domain transition interface (and in fact will call it) but also allows our domain for the role. Without this interface, some<a id="_idIndexMarker997" class="pcalibre calibre6 pcalibre1"/> roles might not be able to transition even if they call the domain transition interface.</li>
				<li class="calibre9">An <strong class="bold">administration interface</strong>, such as <strong class="source-inline">openvpn_admin</strong>, which will be assigned to user <a id="_idIndexMarker998" class="pcalibre calibre6 pcalibre1"/>roles/domains to allow them to administer our service. This will allow the user to interact with the processes of our domain (including killing the processes, tracing their actions, and so on) as well as to administer the files and resources used.</li>
			</ul>
			<p class="calibre3">Within the interfaces, we need to declare the SELinux objects that we are going to explicitly reference. This allows the SELinux subsystem to validate whether the code is applicable or not: if the objects are not present in the current policy, then this interface is not valid and will not be used. Declaring objects is done with the <strong class="source-inline">gen_require()</strong> macro:</p>
			<p class="source-code">interface(`openvpn_run',`</p>
			<p class="source-code">  gen_require(`</p>
			<p class="source-code">    attribute_role openvpn_roles;</p>
			<p class="source-code">  ')</p>
			<p class="source-code">  openvpn_domtrans($1)</p>
			<p class="source-code">  roleattribute $2 openvpn_roles;</p>
			<p class="source-code">')</p>
			<p class="calibre3">Other interfaces can be added as <a id="_idIndexMarker999" class="pcalibre calibre6 pcalibre1"/>needed. While you can add interfaces already just in case, be aware that once you define an interface it can be used by other policies, and you might not be made aware of this if you are not developing all policies yourself. If you, later on, want to change the behavior of interfaces or remove them, you might break other policies.</p>
			<h2 id="_idParaDest-379" class="calibre10"><a id="_idTextAnchor383" class="pcalibre calibre6 pcalibre1"/>Addressing user applications</h2>
			<p class="calibre3">If we develop end <a id="_idIndexMarker1000" class="pcalibre calibre6 pcalibre1"/>user applications, their structure will be very similar to those for more service-oriented applications. Content-wise, however, there are a few areas of attention to consider. Let's use the <strong class="source-inline">apps/thunderbird.te</strong> policy as an example:</p>
			<ul class="calibre8">
				<li class="calibre9">The first thing we notice is that many resource defining interfaces are prefixed with <strong class="source-inline">userdom_</strong>. For instance, a temporary file is not <strong class="source-inline">files_tmp_file()</strong> but <strong class="source-inline">userdom_user_tmp_file()</strong>. This will ensure that the resources are known as <strong class="bold">user-managed</strong> temporary files<a id="_idIndexMarker1001" class="pcalibre calibre6 pcalibre1"/> and not regular system temporary files.</li>
				<li class="calibre9">Another important addition is the support for <a id="_idIndexMarker1002" class="pcalibre calibre6 pcalibre1"/>the <strong class="bold">X Desktop Group</strong> (<strong class="bold">XDG</strong>) locations. The XDG locations, defined in the XDG Base Directory specification at <a href="https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html" class="pcalibre calibre6 pcalibre1">https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html</a>, standardize which end user locations are used for what purpose. For instance, inside <strong class="source-inline">~/.cache</strong>, application cache data is stored, whereas configuration data is in <strong class="source-inline">~/.config</strong>.<p class="calibre3">The use of the XDG locations is supported through the <strong class="source-inline">xdg</strong> SELinux policy module, which enables support for types of user content as well: regular documents, downloads, music, pictures, and videos. This distinction allows developing SELinux policies that are only able to interact with that specific end user content and not all the user's data.</p><p class="calibre3">For instance, the<a id="_idIndexMarker1003" class="pcalibre calibre6 pcalibre1"/> thunderbird application is able to manage download data (which by default is located in <strong class="source-inline">~/Downloads</strong>) through the following:</p><p class="source-code">xdg_manage_downloads(thunderbird_t)</p></li>
				<li class="calibre9">To easily establish user content access, user applications should also call the <strong class="source-inline">userdom_user_content_access_template()</strong> template. This will automatically create booleans as well, which administrators can toggle. For instance, for the thunderbird SELinux policy, this will create <strong class="source-inline">thunderbird_manage_generic_user_content</strong>. If set, then thunderbird can not only access the downloads-related resources but all user resources.</li>
				<li class="calibre9">Another template that user application policies will need if they are graphical in nature, is <strong class="source-inline">xserver_user_x_domain_template()</strong>. This template will generate X server related SELinux objects for the application, and allow the application to use the graphical environment on the server.<p class="callout-heading">Important note</p><p class="callout">The reference policy makes a distinction between regular interfaces and templates. Interfaces grant privileges to the domains and roles that are passed to it. Templates on the other hand will generate new objects, such as SELinux booleans, types, attributes, and more. Code-wise, templates cannot be part of boolean-triggered statements (as they do not just add type enforcement rules).</p></li>
			</ul>
			<p class="calibre3">When the baseline of a user application policy is drafted, including the preceding templates, then expanding the policy through trial and error should suffice. Do make sure, however, that all resources on the user location for which you are testing the application are correctly labeled, as otherwise, the denials might trick you into granting more privileges to the domain than necessary.</p>
			<h1 id="_idParaDest-380" class="calibre5"><a id="_idTextAnchor384" class="pcalibre calibre6 pcalibre1"/>Adding user-level policies</h1>
			<p class="calibre3">If we want to create custom<a id="_idIndexMarker1004" class="pcalibre calibre6 pcalibre1"/> user and role policies, then the most confusing choice is the choice of user template to pick. This template creates a role and user domain with a specific purpose in mind, and grants a number of permissions by default:</p>
			<div class="calibre13">
				<div id="_idContainer044" class="img---figure">
					<img src="Images/B16276_15_001.jpg" alt="Figure 15.1 – Relationship between user domain templates " class="calibre37"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.1 – Relationship between user domain templates</p>
			<p class="calibre3">The most common templates to pick for user/role policies are the following:</p>
			<ul class="calibre8">
				<li class="calibre9"><strong class="source-inline">userdom_restricted_user_template()</strong> for (by default) unprivileged end user roles. </li>
				<li class="calibre9"><strong class="source-inline">userdom_admin_user_template()</strong> for (by default) highly privileged end user roles.</li>
			</ul>
			<p class="calibre3">The other templates can be<a id="_idIndexMarker1005" class="pcalibre calibre6 pcalibre1"/> used as well, especially if more fine-grained controls over the roles and user domains are needed. Note, however, that the privileges assigned by the templates are mentioned as <em class="italic">by default</em>. If we want to create a role and user domain for administrating a specific service, then we do not want to use <strong class="source-inline">userdom_admin_user_template()</strong>, as this will grant many more privileges than needed.</p>
			<p class="calibre3">As an example, consider the <strong class="source-inline">roles/dbadm.te</strong> SELinux policy for the database administration role. This role is based upon the <strong class="source-inline">userdom_base_user_template()</strong> interface to ensure minimal permissions are granted. The role is not meant to be used in a direct fashion (login), but rather transitioned toward (for instance, through the <strong class="source-inline">newrole</strong> command, or through well-defined role transitions within the policy).</p>
			<h1 id="_idParaDest-381" class="calibre5"><a id="_idTextAnchor385" class="pcalibre calibre6 pcalibre1"/>Getting help with supporting tools</h1>
			<p class="calibre3">There are tools out there that help in developing SELinux policies, and if needed we can build our own support tools as well. Let's see what support environments we can use.</p>
			<h2 id="_idParaDest-382" class="calibre10"><a id="_idTextAnchor386" class="pcalibre calibre6 pcalibre1"/>Verifying code with selint</h2>
			<p class="calibre3">While<a id="_idIndexMarker1006" class="pcalibre calibre6 pcalibre1"/> SELinux policies <a id="_idIndexMarker1007" class="pcalibre calibre6 pcalibre1"/>can be functionally working, validating whether the code itself is proper and follows best practices is important to ensure that the code is maintainable in the lon<a id="_idTextAnchor387" class="pcalibre calibre6 pcalibre1"/>g run.</p>
			<p class="calibre3">One of the tools that support validating<a id="_idIndexMarker1008" class="pcalibre calibre6 pcalibre1"/> SELinux policy code is <strong class="source-inline">selint</strong>, as offered from <a href="https://github.com/TresysTechnology/selint" class="pcalibre calibre6 pcalibre1">https://github.com/TresysTechnology/selint</a>. Once built and installed, <strong class="source-inline">selint</strong> offers insights into four main areas:</p>
			<ul class="calibre8">
				<li class="calibre9">Convention checks validate whether the SELinux policy follows the reference policy convention on how code should be structured and documented.</li>
				<li class="calibre9">Style checks give hints for code style that might be wrong, and where the developer might have intended a different behavior.</li>
				<li class="calibre9">Warnings are triggered when the code has bad calls that might trigger runtime issues or security issues.</li>
				<li class="calibre9">Errors catch construction faults that will result in compile issues or runtime issues.</li>
			</ul>
			<p class="calibre3">This allows<a id="_idIndexMarker1009" class="pcalibre calibre6 pcalibre1"/> the use of <strong class="source-inline">selint</strong> in automated build processes, as well as facilitating the<a id="_idIndexMarker1010" class="pcalibre calibre6 pcalibre1"/> development of policies.</p>
			<p class="calibre3">Calling <strong class="source-inline">selint</strong> is simple:</p>
			<p class="source-code">$ selint minecraft.te</p>
			<p class="source-code">minecraft.te:  31: (C): Permissions in av rule not ordered</p>
			<p class="source-code">                        (signull before execmem) (C-005)</p>
			<p class="source-code">minecraft.te: 118: (C): Require block used in te file (use an </p>
			<p class="source-code">                        interface call instead) (S-001)</p>
			<p class="calibre3">In this case, two convention malpractices were detected. One is in the ordering of permissions, while another has an explicit require block mentioned for a domain that is not part of that policy module.</p>
			<h2 id="_idParaDest-383" class="calibre10"><a id="_idTextAnchor388" class="pcalibre calibre6 pcalibre1"/>Querying the interfaces and macros locally</h2>
			<p class="calibre3">To help in finding the<a id="_idIndexMarker1011" class="pcalibre calibre6 pcalibre1"/> right interface or macro, we also want to quickly be able to show interface <a id="_idIndexMarker1012" class="pcalibre calibre6 pcalibre1"/>and macro information. With some shell scripting, we can create a few functions that help us along.</p>
			<p class="calibre3">The functions are provided as code together with this book. You might want to change the path that the <strong class="source-inline">POLICY_LOCATION</strong> variable points to at the beginning of the script. By default, it points to the system-installed interface and macros, but you can point it to repository checkouts as well:</p>
			<p class="source-code">POLICY_LOCATION="/usr/share/selinux/devel"</p>
			<p class="calibre3">Source the file to have access to the helper functions:</p>
			<p class="source-code">$ source ./localfuncs</p>
			<p class="calibre3">The helper functions you can use are the following:</p>
			<ul class="calibre8">
				<li class="calibre9">With <strong class="source-inline">sefindif</strong> you can search for an SELinux interface that has a specific SELinux rule inside. You can use regular expressions to find the appropriate one.<p class="calibre3">For instance, to find the interface that grants a domain the privileges to manage certificate files (for readability, we only show the interface code; it will be prefixed with the location where it found it):</p><p class="source-code"><strong class="bold">$ sefindif "manage.* cert_t"</strong></p><p class="source-code"><strong class="bold">interface(`miscfiles_manage_all_certs',`</strong></p><p class="source-code"><strong class="bold">  manage_files_pattern($1, cert_type, cert_type)</strong></p><p class="source-code"><strong class="bold">  manage_lnk_files_pattern($1, cert_type, cert_type)</strong></p><p class="source-code"><strong class="bold">interface(`miscfiles_manage_generic_cert_dirs',`</strong></p><p class="source-code"><strong class="bold">  manage_dirs_pattern($1, cert_t, cert_t)</strong></p><p class="source-code"><strong class="bold">interface(`miscfiles_manage_generic_cert_files',`</strong></p><p class="source-code"><strong class="bold">  manage_files_pattern($1, cert_t, cert_t)</strong></p><p class="source-code"><strong class="bold">  manage_lnk_files_pattern($1, cert_t, cert_t)</strong></p></li>
				<li class="calibre9">With <strong class="source-inline">seshowif</strong> the interface in its entirety (excluding the comment) is displayed.<p class="calibre3">For <a id="_idIndexMarker1013" class="pcalibre calibre6 pcalibre1"/>instance, to show the <strong class="source-inline">miscfiles_manage_all_certs()</strong> interface, use the following code:</p><p class="source-code"><strong class="bold">$ seshowif miscfiles_manage_all_certs</strong></p><p class="source-code"><strong class="bold">interface(`miscfiles_manage_all_certs',`</strong></p><p class="source-code"><strong class="bold">  gen_require(`</strong></p><p class="source-code"><strong class="bold">    attribute cert_type;</strong></p><p class="source-code"><strong class="bold">  ')</strong></p><p class="source-code"><strong class="bold">  allow $1 cert_type:dir list_dir_perms;</strong></p><p class="source-code"><strong class="bold">  manage_files_pattern($1, cert_type, cert_type)</strong></p><p class="source-code"><strong class="bold">  manage_lnk_files_pattern($1, cert_type, cert_type)</strong></p><p class="source-code"><strong class="bold">')</strong></p></li>
				<li class="calibre9">With <strong class="source-inline">sefinddef</strong> and <strong class="source-inline">seshowdef</strong>, the same is possible but for the supporting macros.<p class="calibre3">For instance, to see the <a id="_idIndexMarker1014" class="pcalibre calibre6 pcalibre1"/>content of the <strong class="source-inline">admin_pattern()</strong> helper macro, use the following code:</p><p class="source-code"><strong class="bold">$ seshowdef admin_pattern</strong></p><p class="source-code"><strong class="bold">define(`admin_pattern',`</strong></p><p class="source-code"><strong class="bold">  manage_dirs_pattern($1,$2,$2)</strong></p><p class="source-code"><strong class="bold">  manage_files_pattern($1,$2,$2)</strong></p><p class="source-code"><strong class="bold">  manage_lnk_files_pattern($1,$2,$2)</strong></p><p class="source-code"><strong class="bold">  manage_fifo_files_pattern($1,$2,$2)</strong></p><p class="source-code"><strong class="bold">  manage_sock_files_pattern($1,$2,$2)</strong></p><p class="source-code"><strong class="bold">  relabel_dirs_pattern($1,$2,$2)</strong></p><p class="source-code"><strong class="bold">  relabel_files_pattern($1,$2,$2)</strong></p><p class="source-code"><strong class="bold">  relabel_lnk_files_pattern($1,$2,$2)</strong></p><p class="source-code"><strong class="bold">  relabel_fifo_files_pattern($1,$2,$2)</strong></p><p class="source-code"><strong class="bold">  relabel_sock_files_pattern($1,$2,$2)</strong></p><p class="source-code"><strong class="bold">')</strong></p></li>
			</ul>
			<p class="calibre3">While such functions do not offer the same versatility as a full-fledged policy editor suite would, they can help in quickly finding the right interface or macro.</p>
			<h1 id="_idParaDest-384" class="calibre5"><a id="_idTextAnchor389" class="pcalibre calibre6 pcalibre1"/>Summary</h1>
			<p class="calibre3">The reference policy is the most common source for SELinux policy development, and with years of development effort and maintenance, it has grown to be a full policy set with a vivid development community, and active support by various tools (including <strong class="source-inline">audit2allow</strong>, as well as the <strong class="source-inline">selint</strong> application).</p>
			<p class="calibre3">We've learned how policies are generally structured, and how to start building SELinux policy modules for the most common use cases: application services, end user applications, and user roles. To help us in developing these policies, we've seen that <strong class="source-inline">selint</strong> can do code-style analysis, whereas some shell scripts can help us parse the interface files for quick help.</p>
			<p class="calibre3">In our final chapter, we will look into CIL style SELinux development.</p>
			<h1 id="_idParaDest-385" class="calibre5"><a id="_idTextAnchor390" class="pcalibre calibre6 pcalibre1"/>Questions</h1>
			<ol class="calibre18">
				<li class="calibre9">Why don't Linux distributions use the reference policy natively?</li>
				<li class="calibre9">What are the three main policy files needed for an SELinux module, and what is their purpose?</li>
				<li class="calibre9">Why is a permission set such as <strong class="source-inline">exec_file_perms</strong> preferred over explicitly listing the permissions?</li>
				<li class="calibre9">What is the difference between interfaces and templates?</li>
				<li class="calibre9">Why is the database administration role defined in <strong class="source-inline">dbadm.te</strong> not using <strong class="source-inline">userdom_admin_user_template</strong>?</li>
			</ol>
		</div>
	</div></body></html>