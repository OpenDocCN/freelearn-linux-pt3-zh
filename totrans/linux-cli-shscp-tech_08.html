<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer227">
			<h1 id="_idParaDest-173"><em class="italic"><a id="_idTextAnchor178"/>Chapter 8</em>: Using the Command Line to Find, Extract, and Manipulate Text Content</h1>
			<p>Manipulating text is an everyday job for a full-time system administrator. It can happen for a variety of reasons – for example, you could just be trying to find a service option that you saw somewhere in some configuration file, without remembering what the name of the configuration file is. You know, those moments on Monday morning when you haven't had two cups of your favorite pick-me-up drink and your CPU hasn't booted properly yet? Or, maybe, when you're working with a text file that has a lot of content, but needs specific changes to be made, such as changing some configuration options from off to on, true to false, 0 to 1, and so on. This chapter is going to act as a prequel to one of the later chapters discussing shell scripting examples. </p>
			<p>In this chapter, we are going to learn about the following:</p>
			<ul>
				<li>Using text commands to merge file content</li>
				<li>Converting DOS text to Linux text and vice versa</li>
				<li>Using <strong class="source-inline">cut</strong></li>
				<li>Using <strong class="source-inline">egrep</strong></li>
				<li>Using <strong class="source-inline">sed</strong></li>
			</ul>
			<h1 id="_idParaDest-174"><a id="_idTextAnchor179"/>Technical requirements </h1>
			<p>For these recipes, we're going to use one Linux machine – we can use <strong class="source-inline">client1</strong> from our previous recipes. It doesn't really matter which virtual machine gets used as all the commands that we are going to discuss in these recipes work the same way on all Linux distributions.</p>
			<h1 id="_idParaDest-175"><a id="_idTextAnchor180"/>Using text commands to merge file content</h1>
			<p>Let's start with something<a id="_idIndexMarker592"/> simple – which is merging file content. Of course, we<a id="_idIndexMarker593"/> are only discussing text content here as merging binary files would be pointless. Our goal is to learn how to use two commands – <strong class="source-inline">paste</strong> and <strong class="source-inline">cat</strong> – to do simple things, such as concatenation and merging line by line. Let's start!</p>
			<h2 id="_idParaDest-176"><a id="_idTextAnchor181"/>Getting ready</h2>
			<p>We just need one Ubuntu and one CentOS machine for this recipe. Here, we are going to use <strong class="source-inline">cli1</strong> and <strong class="source-inline">cli2</strong> to master these commands.</p>
			<h2 id="_idParaDest-177"><a id="_idTextAnchor182"/>How to do it…</h2>
			<p>Starting with the simplest command for this chapter – <strong class="source-inline">cat</strong> – let's see some examples of what it does. If we type in a command such as <strong class="source-inline">cat filename.txt</strong> – if a file named <strong class="source-inline">filename.txt</strong> exists – we are going to get the content of that file on display. Let's check an example of this:</p>
			<div>
				<div id="_idContainer199" class="IMG---Figure">
					<img src="Images/Figure_8.1_B16269.jpg" alt="Figure 8.1 – Using the cat command on a text file&#13;&#10;" width="1260" height="533"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.1 – Using the cat command on a text file</p>
			<p>So, we used the <strong class="source-inline">cat</strong> command<a id="_idIndexMarker594"/> to show the content<a id="_idIndexMarker595"/> of an <strong class="source-inline">auth.log</strong> file located in the <strong class="source-inline">/var/log</strong> directory. If we have been using this machine for a while, there will be other files with <strong class="source-inline">auth.log</strong> as a prefix, then a number, and the <strong class="source-inline">gz</strong> extension. Let's check:</p>
			<div>
				<div id="_idContainer200" class="IMG---Figure">
					<img src="Images/Figure_8.2_B16269.jpg" alt="Figure 8.2 – Finding content that we are going to use&#13;&#10;" width="830" height="188"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.2 – Finding content that we are going to use</p>
			<p>So, for the purpose of this recipe, let's use the <strong class="source-inline">auth.log</strong> and <strong class="source-inline">auth.log.1</strong> files. What happens if we want to have one file that contains both <strong class="source-inline">auth.log</strong> and <strong class="source-inline">auth.log.1</strong> content? We'd either open a text editor and do a bit of copy-pasting, or we can use <strong class="source-inline">cat</strong> to do that for us. The <strong class="source-inline">cat</strong> command can be used with multiple files at the same time, such as <strong class="source-inline">cat auth.log auth.log.1</strong>, which would show us the content of the first file followed by the content of the second file. The only thing that we need to do is to redirect the text output from that command to a new file, which we can easily do by using the <strong class="source-inline">&gt;</strong> sign. Let's say that we want to save the output of this command to a file in the <strong class="source-inline">/root</strong> directory called <strong class="source-inline">auth-full.log</strong>. Here's how we'd do that:</p>
			<div>
				<div id="_idContainer201" class="IMG---Figure">
					<img src="Images/Figure_8.3_B16269.jpg" alt="Figure 8.3 – Using the cat command to concatenate files&#13;&#10;" width="966" height="238"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.3 – Using the cat command to concatenate files</p>
			<p><strong class="source-inline">cat</strong> actually displays text files line by line, which is a property that we will heavily use in our chapters relating to shell script examples.</p>
			<p>If for some reason<a id="_idIndexMarker596"/> we wanted to merge files<a id="_idIndexMarker597"/> line by line, we could've used the <strong class="source-inline">paste</strong> command. Let's see how that would work. Seeing that these files are just way too big, we are going to create two files. Let's say that the first file (named <strong class="source-inline">first.txt</strong>) will have the following content:</p>
			<p class="source-code">1 today</p>
			<p class="source-code">2 tomorrow</p>
			<p class="source-code">3 someday</p>
			<p>The second file (named <strong class="source-inline">second.txt</strong>) will have this content:</p>
			<p class="source-code">may be good</p>
			<p class="source-code">may be even better</p>
			<p class="source-code">will be excellent</p>
			<p>Now, let's use the <strong class="source-inline">paste</strong> command and check the result:</p>
			<div>
				<div id="_idContainer202" class="IMG---Figure">
					<img src="Images/Figure_8.4_B16269.jpg" alt="Figure 8.4 – Using the paste command to combine text files line by line&#13;&#10;" width="655" height="311"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.4 – Using the paste command to combine text files line by line</p>
			<p>As we can see, the <strong class="source-inline">paste</strong> command combines two files line by line, by putting them one next to the other. </p>
			<h2 id="_idParaDest-178"><a id="_idTextAnchor183"/>How it works…</h2>
			<p>These two commands<a id="_idIndexMarker598"/> are rather simple<a id="_idIndexMarker599"/> in operation:</p>
			<ul>
				<li>By default, <strong class="source-inline">cat</strong> displays the complete content of a file or set of files, line by line.</li>
				<li>By default, <strong class="source-inline">paste</strong> combines files line by line, side by side.</li>
			</ul>
			<p>These are two very different approaches to text manipulation, both with real-life use cases.</p>
			<p>Our next recipe is a simple one as well – how to deal with a situation when we transfer text files from Microsoft OSs to Linux in terms of making them usable in Linux. As we are going to see, there are some fundamental differences with <strong class="source-inline">.txt</strong> formats between Microsoft OSs and Linux, which makes the next recipe a necessity. Stay tuned for it!</p>
			<h2 id="_idParaDest-179"><a id="_idTextAnchor184"/>There's more…</h2>
			<p>If you need more information about using <strong class="source-inline">cat</strong> or <strong class="source-inline">paste</strong>, make sure that you check out the following:</p>
			<ul>
				<li>Basic <strong class="source-inline">cat</strong> command<a id="_idIndexMarker600"/> examples in Linux: <a href="https://www.tecmint.com/13-basic-cat-command-examples-in-linux/%0D">https://www.tecmint.com/13-basic-cat-command-examples-in-linux/</a></li>
				<li>The <strong class="source-inline">paste</strong> command<a id="_idIndexMarker601"/> in Linux (merge lines): <a href="https://linuxize.com/post/paste-command-in-linux/%0D">https://linuxize.com/post/paste-command-in-linux/</a></li>
			</ul>
			<h1 id="_idParaDest-180"><a id="_idTextAnchor185"/>Converting DOS text to Linux text and vice versa</h1>
			<p>This is a strange idea – you might have thought a <strong class="source-inline">.txt</strong> file is a <strong class="source-inline">.txt</strong> file, right? Wrong.</p>
			<p>There are subtle differences<a id="_idIndexMarker602"/> between <strong class="source-inline">.txt</strong> file formats in DOS/Windows<a id="_idIndexMarker603"/> and Linux. Sometimes, those differences can make you mad in a matter of seconds. We've had our fair share of experiences of that – scripts not working as input files were prepared on Windows, not on Linux; different treatment of CSV files in Excel <em class="italic">by design</em>... sometimes it's just too funny when, after hours of deliberation, you realize that something as simple as a <strong class="source-inline">.txt</strong> file created on another OS can make such a mess. Let's explain what the problem is and work through it.</p>
			<h2 id="_idParaDest-181"><a id="_idTextAnchor186"/>Getting ready</h2>
			<p>We just need one Ubuntu machine<a id="_idIndexMarker604"/> for this recipe. Let's say we are going to continue<a id="_idIndexMarker605"/> using <strong class="source-inline">cli1</strong> to master these commands. Furthermore, we need to install one package, called <strong class="source-inline">dos2unix</strong>. So, if we are using <strong class="source-inline">cli1</strong> (Ubuntu), we need to type in the following command:</p>
			<p class="source-code">apt-get -y install dos2unix</p>
			<p>After this package is installed, we are ready to do our recipe. </p>
			<h2 id="_idParaDest-182"><a id="_idTextAnchor187"/>How to do it…</h2>
			<p>Let's say that we created a <strong class="source-inline">.txt</strong> file called <strong class="source-inline">txtsample.txt</strong> in Notepad on Windows, which has the following content:</p>
			<p class="source-code">My first line in a file</p>
			<p class="source-code">My second line in a file</p>
			<p class="source-code">My third line in a file</p>
			<p class="source-code">My fourth line in a file</p>
			<p>Then, we upload this file to our <strong class="source-inline">cli1</strong> machine and open it in vi or vim to check its content. This is what it looks like:</p>
			<div>
				<div id="_idContainer203" class="IMG---Figure">
					<img src="Images/Figure_8.5_B16269.jpg" alt="Figure 8.5 – What our file seems to look like&#13;&#10;" width="573" height="188"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.5 – What our file seems to look like</p>
			<p>Everything seems fine, right? Now, let's do the same thing all over again, but this time, start vi or vim with the <strong class="source-inline">-b</strong> option. For example, use the <strong class="source-inline">vi</strong> <strong class="source-inline">-b txtsample.txt</strong> command and check the file content now. It should look like this:</p>
			<div>
				<div id="_idContainer204" class="IMG---Figure">
					<img src="Images/Figure_8.6_B16269.jpg" alt="Figure 8.6 – What our file actually looks like&#13;&#10;" width="602" height="188"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.6 – What our file actually looks like</p>
			<p>We can see <strong class="bold">carriage returns</strong> (<strong class="bold">CRs</strong>, those <strong class="source-inline">^M</strong> characters) in the vi/vim<a id="_idIndexMarker606"/> editor now. This is one of those subtle differences between the way Notepad and Linux text editors treat <strong class="source-inline">.txt</strong> files. Linux shell commands<a id="_idIndexMarker607"/> aren't necessarily going to treat this type<a id="_idIndexMarker608"/> of text in a friendly manner, and sometimes scripts will not work properly because of these <em class="italic">extra</em> characters that Linux commands don't need.</p>
			<p>The solution to this problem is a simple package and command called <strong class="source-inline">dos2unix</strong> that we installed in the <em class="italic">Getting ready</em> step of this recipe. After that, it's a simple procedure of typing in the following command:</p>
			<p class="source-code">dos2unix txtsample.txt</p>
			<p>Let's open this file in vi with the same <strong class="source-inline">-b</strong> option now and check the file content:</p>
			<div>
				<div id="_idContainer205" class="IMG---Figure">
					<img src="Images/Figure_8.7_B16269.jpg" alt="Figure 8.7 – End result – a file that's stripped of CRs&#13;&#10;" width="554" height="188"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.7 – End result – a file that's stripped of CRs</p>
			<p>Now that's much better. </p>
			<p>There are other examples of this approach – end-of-file characters, <em class="italic">invisible</em> characters that sometimes appear out of nowhere in Excel-exported CSV files. So, we have to make sure that we are aware of this problem and its simple solution.</p>
			<p>We could also use tools such as <strong class="source-inline">tr</strong>, <strong class="source-inline">awk</strong>, and <strong class="source-inline">perl</strong> to do the same thing. Let's use <strong class="source-inline">tr</strong> as an example:</p>
			<p class="source-code">tr -d '\15\32' &lt; input_dos_file.txt &gt; output_linux_file.txt</p>
			<p>Let's now explain how this works and why it's such a problem. </p>
			<h2 id="_idParaDest-183"><a id="_idTextAnchor188"/>How it works…</h2>
			<p>A CR is a character that has been used through the years as a control<a id="_idIndexMarker609"/> mechanism to set the end<a id="_idIndexMarker610"/> of a line, and, as a result, start a new line of text. For those of us old enough to remember the old typewriter machines, the CR on a mechanical typewriter machine would be that funny lever that we had to pull to get to a new line. By extension, this is a part of ASCII code that helps with cursor positioning (beginning of the next line).</p>
			<p>If we don't clear our <strong class="source-inline">.txt</strong> files of these characters (and others), we might have problems with scripting. In our last two chapters of this book with shell script examples, we're going to have multiple example scripts that use the <strong class="source-inline">cat</strong> command to input something from a <strong class="source-inline">.txt</strong> file into a loop. These characters might mess that procedure up, and we don't want that. </p>
			<p><strong class="source-inline">dos2unix</strong> and the mentioned <strong class="source-inline">tr</strong> command strip the input file of CRs. We might debate which method is better, but at the end of the day, it's about results, and both methods work. We prefer the <strong class="source-inline">dos2unix</strong> method; but, of course, you might prefer the <strong class="source-inline">tr</strong> way.</p>
			<h2 id="_idParaDest-184"><a id="_idTextAnchor189"/>There's more…</h2>
			<p>If you need more information about converting DOS <strong class="source-inline">.txt</strong> files to Linux, refer to the following links:</p>
			<ul>
				<li><strong class="source-inline">dos2unix</strong> man<a id="_idIndexMarker611"/> page: <a href="https://linux.die.net/man/1/dos2unix%0D">https://linux.die.net/man/1/dos2unix</a></li>
				<li><strong class="source-inline">yr</strong> man<a id="_idIndexMarker612"/> page: <a href="https://linux.die.net/man/1/tr%0D">https://linux.die.net/man/1/tr</a></li>
			</ul>
			<h1 id="_idParaDest-185"><a id="_idTextAnchor190"/>Using cut</h1>
			<p>There are tools in IT that get elevated<a id="_idIndexMarker613"/> to greatness by the simple fact that they are great tools. The next three tools that we are going to use are tools that fit the description of some of the greatest CLI tools ever invented. For us, <strong class="source-inline">cut</strong> is the second greatest CLI command of all time; if you want to find out which command takes the coveted <em class="italic">#1</em> spot, stay tuned for the next recipes.</p>
			<p><strong class="source-inline">cut</strong> is a tool that can make our lives a lot easier if we're working with preformatted input. For example, it will easily work with CSV, as that's a formatted type of content that can be easily digested by <strong class="source-inline">cut</strong>. Let's learn about <strong class="source-inline">cut</strong> by doing some examples next.</p>
			<h2 id="_idParaDest-186"><a id="_idTextAnchor191"/>Getting ready</h2>
			<p>We just need one Ubuntu<a id="_idIndexMarker614"/> machine for this recipe, so let's keep using <strong class="source-inline">cli1</strong>. The <strong class="source-inline">cut</strong> command is a standard part of any Linux distribution and that's how it should be, as it's more important than other commands, such as <strong class="source-inline">ls</strong>, <strong class="source-inline">mkdir</strong>, and <strong class="source-inline">ps</strong>.</p>
			<h2 id="_idParaDest-187"><a id="_idTextAnchor192"/>How to do it…</h2>
			<p>Let's first create a sample CSV file. For example, we are going to create a CSV file with user data, and use <strong class="source-inline">cut</strong> on top of that file. Here's what we used for this recipe (CSV file content):</p>
			<div>
				<div id="_idContainer206" class="IMG---Figure">
					<img src="Images/Figure_8.8_B16269.jpg" alt="Figure 8.8 – Sample input CSV file&#13;&#10;" width="596" height="114"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.8 – Sample input CSV file</p>
			<p>We are now going to check what we can do with this file and the <strong class="source-inline">cut</strong> command. Let's start with some simple things. For example, first we are going to extract just names from this file, which translates to the first field (before the first comma sign):</p>
			<div>
				<div id="_idContainer207" class="IMG---Figure">
					<img src="Images/Figure_8.9_B16269.jpg" alt="Figure 8.9 – Extracting the first field from a standard-format file&#13;&#10;" width="427" height="137"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.9 – Extracting the first field from a standard-format file</p>
			<p>By using the <strong class="source-inline">cut</strong> command and two switches, we were able to easily extract names from the CSV file. Now, let's add a bit more to the process. Let's extract the name and login (first and third fields):</p>
			<div>
				<div id="_idContainer208" class="IMG---Figure">
					<img src="Images/Figure_8.10_B16269.jpg" alt="Figure 8.10 – Extracting the first and third fields from our sample file&#13;&#10;" width="440" height="138"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.10 – Extracting the first and third fields from our sample file</p>
			<p>Furthermore, let's now extract<a id="_idIndexMarker615"/> the first three fields – name, surname, and login:</p>
			<div>
				<div id="_idContainer209" class="IMG---Figure">
					<img src="Images/Figure_8.11_B16269.jpg" alt="Figure 8.11 – Extracting a range of fields from our sample file&#13;&#10;" width="445" height="137"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.11 – Extracting a range of fields from our sample file</p>
			<p>We could also choose to sort that output alphabetically:</p>
			<div>
				<div id="_idContainer210" class="IMG---Figure">
					<img src="Images/Figure_8.12_B16269.jpg" alt="Figure 8.12 – Sorting output from a cut file&#13;&#10;" width="535" height="160"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.12 – Sorting output from a cut file</p>
			<p>One other classic example is using <strong class="source-inline">cut</strong> to output fields from one specific field onward – for example, from the second field to the last field:</p>
			<div>
				<div id="_idContainer211" class="IMG---Figure">
					<img src="Images/Figure_8.13_B16269.jpg" alt="Figure 8.13 – Extracting fields from the second field onward&#13;&#10;" width="511" height="138"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.13 – Extracting fields from the second field onward</p>
			<p>If you're heavily into Microsoft PowerShell, this will kind of remind you of the <strong class="source-inline">Import-Csv</strong> PowerShell cmdlet, although the similarities<a id="_idIndexMarker616"/> end there, seeing as PowerShell is an object-based shell language.</p>
			<p>As you can see from these examples, the <strong class="source-inline">cut</strong> command is very useful for situations where we have an input file that's in some sort of standard format that uses some character as a delimiter between fields. We can easily use it to extract content from our text files and to prepare text-based input for other actions that might follow using <strong class="source-inline">cut</strong> in a shell script.</p>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor193"/>How it works…</h2>
			<p><strong class="source-inline">cut</strong> is a straightforward command that has only one prerequisite – we need to have an input file that's formatted in some sort of standard format. That translates to having a file with fields delimited by the same character. If that criterion is met, we can easily use <strong class="source-inline">cut</strong> to do wonders in one-liner commands and shell scripts.</p>
			<p>Most commonly, we use two parameters with the <strong class="source-inline">cut</strong> command:</p>
			<ul>
				<li>The <strong class="source-inline">-f</strong> parameter is used to select which field(s) or field range we are going to use to be extracted by using the <strong class="source-inline">cut</strong> command.</li>
				<li>The <strong class="source-inline">-d</strong> parameter is used to select a delimiter, a character that separates our text strings. </li>
			</ul>
			<p>We can also use it in conjunction with other commands, such as <strong class="source-inline">sort</strong>, <strong class="source-inline">tr</strong>, and <strong class="source-inline">uniq</strong>, to do further manipulation of the output extracted by using the <strong class="source-inline">cut</strong> command. We can even use its parameter called <strong class="source-inline">--output-delimiter</strong> to change the input delimiter to some other output delimiter. </p>
			<p>This was a warmup exercise before the big star of the show – the <strong class="source-inline">egrep</strong> command – as its significance can't be overstated. Let's talk about <strong class="source-inline">egrep</strong> next.</p>
			<h2 id="_idParaDest-189"><a id="_idTextAnchor194"/>There's more…</h2>
			<p>If you need more information about networking in CentOS and Ubuntu, make sure that you check out the following:</p>
			<ul>
				<li>The <strong class="source-inline">cut</strong> man<a id="_idIndexMarker617"/> page: <a href="https://man7.org/linux/man-pages/man1/cut.1.html%0D">https://man7.org/linux/man-pages/man1/cut.1.html</a></li>
				<li>Bash <strong class="source-inline">cut</strong> command<a id="_idIndexMarker618"/> examples: <a href="https://linuxhint.com/bash-cut-command-examples/%0D">https://linuxhint.com/bash-cut-command-examples/</a></li>
			</ul>
			<h1 id="_idParaDest-190"><a id="_idTextAnchor195"/>Using egrep</h1>
			<p>Using <strong class="source-inline">egrep</strong>, and regular expressions<a id="_idIndexMarker619"/> in general, is something like page one, chapter one stuff from the never-written <em class="italic">How to be both cool and incredibly useful</em> IT manual. It is, without a shadow of a doubt, the most useful command that was ever invented in the UNIX/Linux world for system administration. It doesn't really matter whether we're looking for a specific string in a file or set of directories, whether we're trying to find a line in a big text file where a specific string is located, or whether we're trying to find where a specific string isn't, <strong class="source-inline">egrep</strong> can do all of that for us. We are focusing on <strong class="source-inline">egrep</strong> specifically, as it supports both concepts that are behind this command – regular expressions and extended regular expressions. That's where we are going to start – first, by explaining the merits of using regular expressions, and then moving on from that to explain why <strong class="source-inline">egrep</strong> is such an important command. So, buckle up and get ready to go!</p>
			<h2 id="_idParaDest-191"><a id="_idTextAnchor196"/>Getting ready</h2>
			<p>We are going to use two virtual machines for this recipe – the Ubuntu-based <strong class="source-inline">cli1</strong> and CentOS-based <strong class="source-inline">cli2</strong>. That's going to enable us to have more examples as logging configuration on Ubuntu is a bit different from CentOS, and CentOS's logging configuration makes it easier to drive some points home. So, start both of these virtual machines and let's get going.</p>
			<h2 id="_idParaDest-192"><a id="_idTextAnchor197"/>How to do it…</h2>
			<p>Using regular expressions comes naturally to everyone if we take some time to get to know how to use them. By extension, our first <em class="italic">frontend</em> to regular expressions is using the <strong class="source-inline">grep</strong> or <strong class="source-inline">egrep</strong> command. These commands enable us to find a text string inside a text file or text input.</p>
			<p>Let's use a simple example. In <a href="B16269_04_Final_PD_ePub.xhtml#_idTextAnchor077"><em class="italic">Chapter 4</em></a>, <em class="italic">Using Shell to Configure and Troubleshoot Network</em>, we used the <strong class="source-inline">ps</strong> command to display running processes. Let's say that we want to do this now, but by using regular expressions. For example, we need to list all the processes<a id="_idIndexMarker620"/> on our Linux server that were started by user <strong class="source-inline">student</strong>.</p>
			<p>If we start with the <strong class="source-inline">ps</strong> command first – for example, if we use the <strong class="source-inline">ps auwwx</strong> command – we are going to get an output like this:</p>
			<div>
				<div id="_idContainer212" class="IMG---Figure">
					<img src="Images/Figure_8.14_B16269.jpg" alt="Figure 8.14 – ps auwwx input, cut short for formatting reasons&#13;&#10;" width="1260" height="538"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.14 – ps auwwx input, cut short for formatting reasons</p>
			<p>Now, let's discuss the fact that this is a text output for just a second – it has a lot of letters and numbers. Also, let's focus on the fact that all processes running on our system are represented by a line in the <strong class="source-inline">ps</strong> command output – a line that, as seen in the figure, starts with the <strong class="source-inline">root, www-data</strong> string, or some other string that represents the user that owns the process. How about if we figure out a way of using that as a property to filter the <strong class="source-inline">ps</strong> command output as text, by using the idea of <em class="italic">line starts with</em> <strong class="source-inline">student</strong> for it?</p>
			<p>If we wanted to do that, we would use a simple command: <strong class="source-inline">ps auwwx | grep ^student</strong>. As we discussed previously, the <strong class="source-inline">|</strong> sign means <em class="italic">we want to send the output of the first command to the second command</em>. Furthermore, <strong class="source-inline">grep</strong> means <em class="italic">we want to filter something out</em>. And this <strong class="source-inline">^student</strong> thing? That's what we call a regular expression pattern, with the <strong class="source-inline">^</strong> character being a regular expression symbol. Specifically, it's an anchor, which when used with <strong class="source-inline">grep</strong> or some other regular expression-aware command means <em class="italic">line starts with</em> the character, or a set of characters that follow. Let's put that theory into practice:</p>
			<div>
				<div id="_idContainer213" class="IMG---Figure">
					<img src="Images/Figure_8.15_B16269.jpg" alt="Figure 8.15 – Using our first regular expression&#13;&#10;" width="1189" height="110"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.15 – Using our first regular expression</p>
			<p>So, here we go, we filtered<a id="_idIndexMarker621"/> our output by using the <strong class="source-inline">student</strong> string as a filter. We can also see that each appearance of that string is marked in red. This comes from the fact that <strong class="source-inline">grep</strong> commands use the <strong class="source-inline">--color</strong> option by default – an option that highlights the string that we were using as a condition for filtering.</p>
			<p>Let's say that now we want to find all lines in our <strong class="source-inline">ps auwwx</strong> output that end with the <strong class="source-inline">bash</strong> string. We can easily use regular expressions for that. Here's how we'd do that:</p>
			<div>
				<div id="_idContainer214" class="IMG---Figure">
					<img src="Images/Figure_8.16_B16269.jpg" alt="Figure 8.16 – Using a regular expression to find a string at the end of a line&#13;&#10;" width="920" height="85"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.16 – Using a regular expression to find a string at the end of a line</p>
			<p>So far, we've used the <strong class="source-inline">ps</strong> command as it's convenient and familiar. Let's now move on to other examples that are going to use text files as a basis. The first one that comes to mind is <strong class="source-inline">/usr/share/dict/words</strong>, a dictionary text file that contains more than 100,000 words. The format of that file is <em class="italic">one word per line</em>, so more than 100,000 words equals more than 100,000 lines. Let's try to find all the lines that have the <strong class="source-inline">parrot</strong> string in them. Here's the command and result:</p>
			<div>
				<div id="_idContainer215" class="IMG---Figure">
					<img src="Images/Figure_8.17_B16269.jpg" alt="Figure 8.17 – Using grep directly on a text file&#13;&#10;" width="769" height="158"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.17 – Using grep directly on a text file</p>
			<p>So, the <strong class="source-inline">grep</strong> command can also be directly used on a text file, which is very useful when dealing with scripts, input files into scripts, and so on.</p>
			<p>So far, so good. Let's make things a bit more complicated. Let's say that we need<a id="_idIndexMarker622"/> to find all lines in the same file (<strong class="source-inline">/usr/share/dict/words</strong>) that contain a string conforming to these rules:</p>
			<ul>
				<li>The line needs to start with <strong class="source-inline">p</strong>.</li>
				<li>The letter <strong class="source-inline">p</strong> needs to be <em class="italic">followed by a vowel</em>.</li>
				<li>A vowel needs to be followed by the <strong class="source-inline">ta</strong> string.</li>
			</ul>
			<p>All of a sudden, things get much more complicated. Imagine having to find these words using a regular text editor. Writing down all these combinations would lead us to the following words that we're looking for:</p>
			<ul>
				<li><strong class="source-inline">pata</strong>, followed by anything</li>
				<li><strong class="source-inline">peta</strong>, followed by anything</li>
				<li><strong class="source-inline">pita</strong>, followed by anything</li>
				<li><strong class="source-inline">pota</strong>, followed by anything</li>
				<li><strong class="source-inline">puta</strong>, followed by anything</li>
			</ul>
			<p>In a regular text editor, it would take us five different sequential finds to find all the words, and even then, we'd have to press <em class="italic">next-next-next</em> for all the next appearances in case one of these string samples can be matched multiple times.</p>
			<p>This is where regular expressions can be of great help. We could do this:</p>
			<div>
				<div id="_idContainer216" class="IMG---Figure">
					<img src="Images/Figure_8.18_B16269.jpg" alt="Figure 8.18 – Finding a more complex string sample&#13;&#10;" width="831" height="510"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.18 – Finding a more complex string sample</p>
			<p>By using the <strong class="source-inline">^p[aeiou]ta</strong> regular expression, we were able to find all of the words matching that criterion easily. When using<a id="_idIndexMarker623"/> these square brackets to input a regular expression sample, we are basically saying to the regular expression-aware command to search for <em class="italic">either a, or e, or i, or o, or u</em> as a character inside the regular expression string. </p>
			<p>As we can see, getting to know regular expressions<a id="_idIndexMarker624"/> can be quite useful. Let's add some more of them with a short explanation:</p>
			<div>
				<div id="_idContainer217" class="IMG---Figure">
					<img src="Images/B16269_08_Table_1.jpg" alt="Table 8.1 – Commonly used regular expression symbols and their meaning&#13;&#10;" width="1412" height="1184"/>
				</div>
			</div>
			<p class="figure-caption">Table 8.1 <a id="_idTextAnchor198"/>– Commonly used regular expression symbols and their meaning</p>
			<p>There are many more regular expression<a id="_idIndexMarker625"/>s that we can use, but let's just start with these and then move on to more complex examples – for example, extended regular expressions. </p>
			<p>How about matching numbers? Matching numbers with regular expressions is, let's say, <em class="italic">fun</em>. Especially if we need to find a number range – things get really complicated real soon if that's the case. Let's discuss<a id="_idIndexMarker626"/> this by using three examples – one for a single-digit number range, one for a simple double-digit number range, and one for a more complex double-digit number range. We can extrapolate how this logic would work on larger numbers. Let's start with a simpler example – for example, a number range from 0 to 5 – and just work with regular expressions, forgetting the <strong class="source-inline">grep</strong> command for a second. In regular expression terms, that would be <strong class="source-inline">[0-5]</strong>.</p>
			<p>For our next example, let's use a simple double-digit number range – let's say, 14-19. In regular expression terms, we'd write that as <strong class="source-inline">1[4-9]</strong>.</p>
			<p>This means 1 as a leading number (tens), and then the number range from 4 to 9, which equals 14-19. </p>
			<p>So far, we specifically chose to use the <strong class="source-inline">grep</strong> command to do these first examples as it works with basic regular expressions. We need to add a <strong class="source-inline">-E</strong> switch to the <strong class="source-inline">grep</strong> command or start using the <strong class="source-inline">egrep</strong> command if we want to move on to extended regular expressions. So far, we've covered some basics, so it's time to make things a bit more complicated. Everything<a id="_idIndexMarker627"/> that we've discussed so far is what we call <strong class="bold">Basic Regular Expressions</strong> (<strong class="bold">BREs</strong>). When talking about <strong class="bold">Extended Regular Expressions</strong> (<strong class="bold">ERE</strong>), we need to keep in mind<a id="_idIndexMarker628"/> that, by using them, we are trying to match a specific set of strings, not just one specific string. Also, there are some differences in syntax, as they make a couple of things easier – we don't have to escape some characters. For example, BRE constructs such as <strong class="source-inline">\?</strong> and <strong class="source-inline">\|</strong> get replaced in EREs with <strong class="source-inline">?</strong> and <strong class="source-inline">|</strong>. That makes the syntax cleaner and easier on the eye, so to speak. Let's work on some examples, first by continuing our <em class="italic">using regular expressions to match numbers</em> discussion.</p>
			<p>What happens if we need to find a number range, for example, 37-94? Regular expressions can't work with multiple-digit numbers in ranges – we need to slice that into ones, tens, hundreds, and so on. And then, we need to use a very well-known concept called<a id="_idIndexMarker629"/> the union of a set (of ranges) to combine all of the ranges into one range that fits the regular expression that we wanted to find. Keeping in mind that we are going to need a set – a set of numbers, in this example – we are going to do this by using EREs. Let's see how that works with minimization in mind – we want to have a regular expression that's as short as possible. Knowing the fact that we need to use the union of a set, the simplest way to do this number range would be as follows:</p>
			<ul>
				<li>37-39</li>
				<li>40-89</li>
				<li>90-94</li>
			</ul>
			<p>In regular expression terms, those sets would be as follows:</p>
			<ul>
				<li><strong class="source-inline">3[7-9]</strong> for 37-39</li>
				<li><strong class="source-inline">[4-8][0-9]</strong> for 40-89</li>
				<li><strong class="source-inline">9[0-4]</strong> for 90-94</li>
			</ul>
			<p>As a regular expression, we'd write it like this:</p>
			<p><strong class="source-inline">3[7-9]|[4-8][0-9]|9[0-4]</strong> </p>
			<p>Here, the <strong class="source-inline">|</strong> sign basically<a id="_idIndexMarker630"/> stands for <em class="italic">or</em>. This is a way of implementing a union set when using regular expressions.</p>
			<p>Keeping in mind that Ubuntu's version of the <strong class="source-inline">/usr/share/dict/words</strong> file doesn't have a single number in it, we added a couple of numbers to the top of this file just so that we have something to test with. For example, we added the following to the top of this file:</p>
			<ul>
				<li><strong class="source-inline">41</strong></li>
				<li><strong class="source-inline">58</strong></li>
				<li><strong class="source-inline">36</strong></li>
				<li><strong class="source-inline">95</strong></li>
				<li><strong class="source-inline">94</strong></li>
			</ul>
			<p>We deliberately chose these numbers as they contain both numbers that are conformant to the regular expression that we made (41, 58, and 94 will be a match) and numbers that aren't (36 and 95). If we use <strong class="source-inline">grep</strong> with our regular expression on this file with added numbers, we will get the following output:</p>
			<div>
				<div id="_idContainer218" class="IMG---Figure">
					<img src="Images/Figure_8.19_B16269.jpg" alt="Figure 8.19 – Using a union set works and we found our matches&#13;&#10;" width="1030" height="110"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.19 – Using a union set works and we found our matches</p>
			<p>As we grow the number of digits that we're looking for, regular expressions get more and more complex. We should always<a id="_idIndexMarker631"/> minimize as much as we can, but there will be situations where we must make a lot of union sets to find something that we are looking for. That's just the name of the game, nothing to be scoffed at.</p>
			<p>Our next example is going to find words (non-numbered only) that are 19 to 20 characters long, made of letters only. We're still using the same file as before, so let's see how we do that:</p>
			<div>
				<div id="_idContainer219" class="IMG---Figure">
					<img src="Images/Figure_8.20_B16269.jpg" alt="Figure 8.20 – Finding words of specific length&#13;&#10;" width="937" height="287"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.20 – Finding words of specific length</p>
			<p>Easy, right? We matched all the lowercase and uppercase characters and then said <em class="italic">words need to have 19 to 20 of those</em>.</p>
			<p>Things tend to get even more complicated when you're trying to create a regular expression for some words that are common, yet different, especially if word length is variable, and even more so if number ranges are involved. But all of that doesn't bring us closer to explaining what the practical point, the real value of regular expressions, is. Everything that we did so far seems like general hocus pocus, <em class="italic">trying to find some text – why should we care about that?</em> Generally speaking, we were only describing the principle, as using generic examples helps. Realistically, there's absolutely no way to learn regular expressions by reading 10-15 pages of text. But we are now going to make an educated effort to move this story along to real-life, practical uses of regular expressions.</p>
			<p>There are some common services that use <strong class="source-inline">grep</strong> and/or regular expressions constantly. We have to keep in mind<a id="_idIndexMarker632"/> that this recipe is about <strong class="source-inline">grep</strong> as a command, not about regular expressions only. </p>
			<p>For example, regular expressions are heavily used for mail filtering. Checking the body of an email – basically text content – is easy if you have a regular expression-enabled mail filter. From an everyday system administrator standpoint, regular expressions are constantly used for parsing through log files and finding valuable information in them. Let's make that point now by using regular expressions on log files, as that's one of the most commonly used practices that's been happening for decades now.</p>
			<p>Let's now switch to <strong class="source-inline">cli2</strong>, our CentOS-based system, and use <strong class="source-inline">/var/log/messages</strong> for the next examples. This file contains the main system log on CentOS, so it's perfectly suitable to use regular expressions to find something in it. Let's start with the simple stuff. For example, let's say that we need to find all log entries in <strong class="source-inline">/var/log/messages</strong> that were made on October 6, and even more specifically, at the ninth hour, by a service called <strong class="source-inline">PackageKit</strong>. Let's first check the structure of this log file – it looks like this:</p>
			<div>
				<div id="_idContainer220" class="IMG---Figure">
					<img src="Images/Figure_8.21_B16269.jpg" alt="Figure 8.21 – Format of a file that we're going to use grep on&#13;&#10;" width="1452" height="846"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.21 – Format of a file that we're going to use grep on</p>
			<p>As we were discussing in our previous recipe about the <strong class="source-inline">cut</strong> command, we can see that this file <em class="italic">kind of</em> has a standard format. There's a timestamp at the beginning, the hostname after that, the service and PID after that, and then some kind of text message. Also, notice the fact that the timestamp<a id="_idIndexMarker633"/> part has a very cool addition – its format is not <strong class="source-inline">Oct 6</strong> with a single space between; it has two spaces. This is very important as it keeps the date format a fixed length when we get to double-digit dates, such as <strong class="source-inline">Oct</strong> <strong class="source-inline">15</strong>. It just makes everything formatted nicely, which is cool.</p>
			<p>So, the simple fact is that we can easily output this by using <strong class="source-inline">grep</strong>. Let's do it:</p>
			<div>
				<div id="_idContainer221" class="IMG---Figure">
					<img src="Images/Figure_8.22_B16269.jpg" alt="Figure 8.22 – Filtering out data that we wanted to filter out&#13;&#10;" width="1443" height="625"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.22 – Filtering out data that we wanted to filter out</p>
			<p>The first part of the command greps out all messages<a id="_idIndexMarker634"/> from <strong class="source-inline">Oct 6</strong> that starts with <strong class="source-inline">09</strong> in the hour part of the timestamp; then, we piped that out to another <strong class="source-inline">grep</strong> command that searches for the <strong class="source-inline">PackageKit</strong> string.</p>
			<p>The next example – and this one becomes more common as we get older – is, let's say that we can't remember the name of a file where the <strong class="source-inline">firewall</strong> string is used. We remember that it was somewhere in the <strong class="source-inline">/etc/sysconfig</strong> folder, but we can't seem to remember what the filename was – one of those <em class="italic">it's early Monday morning, I haven't had time to wake up</em> moments. This is what we could do by using <strong class="source-inline">grep</strong>:</p>
			<div>
				<div id="_idContainer222" class="IMG---Figure">
					<img src="Images/Figure_8.23_B16269.jpg" alt="Figure 8.23 – Using grep on a stack of files all at once&#13;&#10;" width="1448" height="776"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.23 – Using grep on a stack of files all at once</p>
			<p>The <strong class="source-inline">grep</strong> option <strong class="source-inline">-r</strong> means <em class="italic">recursive</em> and the <strong class="source-inline">-i</strong> option means <em class="italic">case insensitive</em>. Also, the <strong class="source-inline">-r</strong> option ignores<a id="_idIndexMarker635"/> any symbolic links as it recursively moves through subdirectories. If we want that behavior to change, we can use the <strong class="source-inline">-r</strong> option, which will take symbolic links into account. As we have the capability to use recursive search through file contents, that means <strong class="source-inline">grep</strong> is going to dive into subdirectories and go through all files. That means we must add one caveat to our discussion – we really, <em class="italic">really shouldn't</em> use this on binary files, for obvious reasons. It would make a big mess on our terminal output, if nothing else.</p>
			<p>Let's end this recipe by using <strong class="source-inline">egrep</strong> for a much more complex scenario involving EREs and different text patterns on text input, the caveat being that we want to see a bit of  <em class="italic">context</em> around our text pattern matches. Let's say that we're trying to go through our <strong class="source-inline">dmesg</strong> boot log, and we are searching for all the hard disks – all the <strong class="source-inline">/dev/hd*</strong> and <strong class="source-inline">/dev/sd</strong> devices. We could use the following command for that purpose:</p>
			<p class="source-code">dmesg | egrep -C2 '(h|s)d[a-z]'</p>
			<p>Let's check what the output would look like:</p>
			<p class="source-code">[root@cli2 sysconfig]# dmesg | egrep '(s|h)d[a-z]' -C2</p>
			<p class="source-code">[    0.000000] Linux version 4.18.0-305.17.1.el8_4.x86_64 (mockbuild@kbuilder.bsys.centos.org) (gcc version 8.4.1 20200928 (Red Hat 8.4.1-1) (GCC)) #1 SMP Wed Sep 8 14:00:07 UTC 2021</p>
			<p class="source-code">[    0.000000] Command line: BOOT_IMAGE=(hd0,msdos1)/vmlinuz-4.18.0-305.17.1.el8_4.x86_64 root=/dev/mapper/cl-root ro resume=/dev/mapper/cl-swap rd.lvm.lv=cl/root rd.lvm.lv=cl/swap rhgb quiet</p>
			<p class="source-code">[    0.000000] Disabled fast string operations</p>
			<p class="source-code">[    0.000000] x86/fpu: Supporting XSAVE feature 0x001: 'x87 floating point registers'</p>
			<p class="source-code">--</p>
			<p class="source-code">[    0.000000] Built 1 zonelists, mobility grouping on.  Total pages: 1032024</p>
			<p class="source-code">[    0.000000] Policy zone: Normal</p>
			<p class="source-code">[    0.000000] Kernel command line: BOOT_IMAGE=(hd0,msdos1)/vmlinuz-4.18.0-305.17.1.el8_4.x86_64 root=/dev/mapper/cl-root ro resume=/dev/mapper/cl-swap rd.lvm.lv=cl/root rd.lvm.lv=cl/swap rhgb quiet</p>
			<p class="source-code">[    0.000000] Specific versions of hardware are certified with Red Hat Enterprise Linux 8. Please see the list of hardware certified with Red Hat Enterprise Linux 8 at https://catalog.redhat.com.</p>
			<p class="source-code">[    0.000000] Memory: 3113700K/4193716K available (12293K kernel code, 2225K rwdata, 7712K rodata, 2476K init, 14048K bss, 256384K reserved, 0K cma-reserved)</p>
			<p class="source-code">--</p>
			<p class="source-code">[    0.023000] ... event mask:             000000000000000f</p>
			<p class="source-code">[    0.023000] rcu: Hierarchical SRCU implementation.</p>
			<p class="source-code">[    0.023375] NMI watchdog: Perf NMI watchdog permanently disabled</p>
			<p class="source-code">[    0.037028] smp: Bringing up secondary CPUs ...</p>
			<p class="source-code">[    0.037823] x86: Booting SMP configuration:</p>
			<p class="source-code">--</p>
			<p class="source-code">[    2.384538] scsi 2:0:0:0: Attached scsi generic sg0 type 0</p>
			<p class="source-code">[    2.384599] scsi 1:0:0:0: Attached scsi generic sg1 type 5</p>
			<p class="source-code">[    2.391073] sd 2:0:0:0: [sda] 41943040 512-byte logical blocks: (21.5 GB/20.0 GiB)</p>
			<p class="source-code">[    2.391149] sd 2:0:0:0: [sda] Write Protect is off</p>
			<p class="source-code">[    2.391150] sd 2:0:0:0: [sda] Mode Sense: 61 00 00 00</p>
			<p class="source-code">[    2.391304] sd 2:0:0:0: [sda] Cache data unavailable</p>
			<p class="source-code">[    2.391305] sd 2:0:0:0: [sda] Assuming drive cache: write through</p>
			<p class="source-code">[    2.401493]  sda: sda1 sda2</p>
			<p class="source-code">[    2.404998] sr 1:0:0:0: [sr0] scsi3-mmc drive: 1x/1x writer dvd-ram cd/rw xa/form2 cdda tray</p>
			<p class="source-code">[    2.405000] cdrom: Uniform CD-ROM driver Revision: 3.20</p>
			<p class="source-code">[    2.406103] sd 2:0:0:0: [sda] Attached SCSI disk</p>
			<p class="source-code">[    2.413125] usb 2-2.1: new full-speed USB device number 4 using uhci_hcd</p>
			<p class="source-code">[    2.417859] sr 1:0:0:0: Attached scsi CD-ROM sr0</p>
			<p class="source-code">--</p>
			<p class="source-code">[    4.345611] usbcore: registered new interface driver btusb</p>
			<p class="source-code">[    4.396658] intel_pmc_core intel_pmc_core.0:  initialized</p>
			<p class="source-code">[    4.421252] XFS (sda1): Mounting V5 Filesystem</p>
			<p class="source-code">[    4.596411] XFS (sda1): Ending clean mount</p>
			<p class="source-code">[    4.706702] RPC: Registered named UNIX socket transport module.</p>
			<p class="source-code">[    4.706703] RPC: Registered udp transport module.</p>
			<p>If we take a look at the end<a id="_idIndexMarker636"/> of this output, we can see that the last two lines don't match our regular expression used to filter data. That's because we used the <strong class="source-inline">-C2</strong> parameter with <strong class="source-inline">egrep</strong>, and that option enables <strong class="source-inline">egrep</strong> to show two lines preceding and two lines following our pattern match. We can divide that option into options <strong class="source-inline">-A</strong> and <strong class="source-inline">-B</strong> (after and before the match, respectively) if we want to specify a custom number of lines to appear after and before our pattern match. There are many more <strong class="source-inline">grep</strong> options available, but these are enough to get us started. We will add some more examples of using regular expressions and some topics we didn't cover here in the next recipe, about the <strong class="source-inline">sed</strong> command.</p>
			<h2 id="_idParaDest-193"><a id="_idTextAnchor199"/>How it works…</h2>
			<p><strong class="source-inline">grep</strong> is a pattern-matching command that can work in a variety of different ways – either as a standalone command that takes text files as input or as something that we pipe input to in a command set. Its purpose is clear – find specific text patterns in a large set of text. A couple of years ago, its default output changed a little bit as it used to show the lines matching our search pattern, while now it does that and it does it in color, by marking the found search pattern in red.</p>
			<p><strong class="source-inline">grep</strong> works by implementing the idea of text pattern search into a programmable command that's a regular part of shell scripts, as we'll explain in the last two chapters with practical examples of scripting. As such, it's an irreplaceable part of a system administrator's toolkit as it enables us to find important text data from one or many files, therefore bringing a sort of chaos into order. </p>
			<p>The most commonly used options are as follows:</p>
			<ul>
				<li><strong class="source-inline">-E</strong> (or <strong class="source-inline">egrep</strong>): By default, <strong class="source-inline">grep</strong> recognizes BREs only. If we use the <strong class="source-inline">-E</strong> parameter, it works with EREs.</li>
				<li><strong class="source-inline">-i</strong>: Case-insensitive search.</li>
				<li><strong class="source-inline">-v</strong>: Invert match, find the opposite of our search pattern: <strong class="source-inline">A</strong>, <strong class="source-inline">-B</strong>, <strong class="source-inline">-C</strong> – options providing <em class="italic">context</em> to our output, by showing A number of lines after, B number of lines before, or C number of lines before and after our pattern match.</li>
				<li><strong class="source-inline">-n</strong>: Show the line number where the pattern match appears.</li>
			</ul>
			<p>Let's continue our quest to use CLI-based utilities<a id="_idIndexMarker637"/> that can do important things on text content by moving on to look at the <strong class="source-inline">sed</strong> command in our next recipe. That will also give us some more scope to further our knowledge about regular expressions, as <strong class="source-inline">sed</strong> can use them to be even more useful than its usual, vanilla self.</p>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor200"/>There's more…</h2>
			<p>If you need more information about <strong class="source-inline">grep</strong> in Linux, you can check out the following links:</p>
			<ul>
				<li><strong class="source-inline">grep</strong> man<a id="_idIndexMarker638"/> page: <a href="https://man7.org/linux/man-pages/man1/grep.1p.html%0D">https://man7.org/linux/man-pages/man1/grep.1p.html</a></li>
				<li>20 useful <strong class="source-inline">grep</strong> command examples<a id="_idIndexMarker639"/> in Linux: <a href="https://www.linuxbuzz.com/grep-command-examples-linux/%0D">https://www.linuxbuzz.com/grep-command-examples-linux/</a></li>
				<li>Regular<a id="_idIndexMarker640"/> expressions in <strong class="source-inline">grep</strong>: <a href="https://linuxize.com/post/regular-expressions-in-grep/%0D">https://linuxize.com/post/regular-expressions-in-grep/</a></li>
				<li>Stanford's regular expression<a id="_idIndexMarker641"/> cheat sheet: <a href="http://stanford.edu/~wpmarble/webscraping_tutorial/regex_cheatsheet.pdf%0D">http://stanford.edu/~wpmarble/webscraping_tutorial/regex_cheatsheet.pdf</a></li>
			</ul>
			<h1 id="_idParaDest-195"><a id="_idTextAnchor201"/>Using sed</h1>
			<p>In addition to our discussion<a id="_idIndexMarker642"/> about manipulating text, we absolutely must discuss <strong class="source-inline">sed</strong>. It's a go-to tool to solve so many problems where quick solutions are needed and a lot of text is involved. I can list more than a few examples just from the past couple of years where it saved my skin. For example, I had a couple of projects that required migrating WordPress<a id="_idIndexMarker643"/> sites from one domain to another. As it was something that needed to be done in a flash, testing migration modules wasn't an option. The simpler way was to just export the MySQL database, change <em class="italic">domain1</em> to <em class="italic">domain2</em>, and check whether it worked. Later, I had a couple more projects like that where it wasn't just a domain name change; subdomain name changes were needed too, and so on. Keeping in mind that it would take me weeks to do this manually on a database that was gigabytes in size – yes, <strong class="source-inline">sed</strong> really helped me out in those jams. Let's discuss the merits of using <strong class="source-inline">sed</strong> and learn by working on a couple of examples. In the last two chapters of this book, we're also going to go through some of these WordPress-based examples so that we can see how that's done in a jiffy.</p>
			<h2 id="_idParaDest-196"><a id="_idTextAnchor202"/>Getting ready</h2>
			<p>Let's continue using the <strong class="source-inline">cli2</strong> machine from the previous recipe. If it's shut down, turn it back on so that we can learn about using <strong class="source-inline">sed</strong>. </p>
			<h2 id="_idParaDest-197"><a id="_idTextAnchor203"/>How to do it…</h2>
			<p>When we're using <strong class="source-inline">cut</strong>, we are working with standard-formatted input that needs to be transformed in some way. When we're using <strong class="source-inline">grep</strong>, we are looking to find a text sample just for the purpose of finding that text sample. What happens if we need to find some text sample and change it to something else?</p>
			<p>For most users, the answer is, <em class="italic">I'm going to open my favorite editor and do a search and replace</em>.</p>
			<p>Precisely. And that's what <strong class="source-inline">sed</strong> is mostly about, especially if we have a file that's really big, gigabytes and more in size. It's about having the capability to do a search and replace, based on text patterns and regular expressions, without having to open an editor.</p>
			<p>Have you ever tried to open a 1 GB text file in Notepad or Wordpad to do search and replace, and if so, how did that work out for you? Let alone having to read multiple large files on multiple systems, especially non-Windows systems?</p>
			<p>Let's do some simple, a bit complicated, and more complicated scenarios with <strong class="source-inline">sed</strong>. The first scenario is going to be related to inserting and appending a bit of text:</p>
			<p class="source-code">echo "This should be first line" | sed 'i\THIS will be the first line '</p>
			<p>Let's check the result of this command:</p>
			<div>
				<div id="_idContainer223" class="IMG---Figure">
					<img src="Images/Figure_8.24_B16269.jpg" alt="Figure 8.24 – First example of using the sed command&#13;&#10;" width="1444" height="190"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.24 – First example of using the sed command</p>
			<p>The <strong class="source-inline">-i</strong> switch in this command<a id="_idIndexMarker644"/> does inline replacement. Keeping in mind that we used <strong class="source-inline">sed</strong> without any additional options, it didn't replace anything with anything, just inserted the line before the <strong class="source-inline">echo</strong> command, although logic suggests that the <strong class="source-inline">echo</strong> command's output should've been first.</p>
			<p>Generally speaking, <strong class="source-inline">sed</strong> has the following syntax:</p>
			<p class="source-code">sed -parameter 'option/sourcetext/destinationtext/anotheroption' sourcetextfile</p>
			<p>As we can see, in our previous example, we didn't use any options at the beginning or end of the <strong class="source-inline">sed</strong> quotes; we only used source text. <strong class="source-inline">sed</strong> can also be used to extract specific lines from a file. For example, let's say that we want to extract lines 5-10 from the <strong class="source-inline">/var/log/messages</strong> file in our <strong class="source-inline">cli2</strong> CentOS machine:</p>
			<div>
				<div id="_idContainer224" class="IMG---Figure">
					<img src="Images/Figure_8.25_B16269.jpg" alt="Figure 8.25 – Using sed to extract a specific part of a text file&#13;&#10;" width="1450" height="594"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.25 – Using sed to extract a specific part of a text file</p>
			<p>The default way<a id="_idIndexMarker645"/> of operation for <strong class="source-inline">sed</strong> is to print every line, and if there is a substitution being made by our source/destination text configuration, it will print the substituted text instead of printing the original one. That's why we have <strong class="source-inline">-n</strong>, as we don't want to print any new lines as we're not doing any kind of substitution. <strong class="source-inline">'5,10p'</strong> means print from lines 5 to 10.</p>
			<p>We can also do the opposite of that – let's say, we want to print all lines from a file, and delete lines 5 to 10. We can use the following command to do that:</p>
			<p class="source-code"># sed '5,10d' somefile.txt</p>
			<p>We can also use <strong class="source-inline">sed</strong> to display some lines that are not successive in a text file, for example, display lines 20-25 and 40-100 in <strong class="source-inline">somefile.txt</strong> (<strong class="source-inline">-e</strong> used per expression):</p>
			<p class="source-code">sed -n -e '20,25p' -e '40,100p' somefile.txt</p>
			<p>But that's all just using <strong class="source-inline">sed</strong> for some very pedestrian stuff. Let's now start using it for what we'd mostly use it for, which is string replacement.</p>
			<p>Let's say that we have a text file called <strong class="source-inline">sample.txt</strong> with the following content:</p>
			<p><em class="italic">This camera produces some weird sounds. Sometimes it buzzes, sometimes it squeals, and always manages to somehow produce un-camera-like high-pitched squeal that should only be audible to dolphins and whales. As a camera, it's good. As a camera with ability to record sound, it's useless. So, we need a camera.</em></p>
			<p>Our first <strong class="source-inline">sed</strong>-based task<a id="_idIndexMarker646"/> is going to be to replace all instances of <strong class="source-inline">camera</strong> with <strong class="source-inline">microphone</strong>. For that, we need to use the following command:</p>
			<p class="source-code">sed 's/camera/microphone/g' sample.txt</p>
			<p>As expected, the word <strong class="source-inline">camera</strong> gets replaced with the word <strong class="source-inline">microphone</strong> in the console, and the end result looks like this:</p>
			<div>
				<div id="_idContainer225" class="IMG---Figure">
					<img src="Images/Figure_8.26_B16269.jpg" alt="Figure 8.26 – Using sed to replace words without saving these changes to our original file&#13;&#10;" width="1442" height="226"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.26 – Using sed to replace words without saving these changes to our original file</p>
			<p>If we want to replace <strong class="source-inline">camera</strong> with <strong class="source-inline">microphone</strong> and for these changes to be saved to the original file, we need to use the following command:</p>
			<p class="source-code">sed -i 's/camera/microphone/g' sample.txt</p>
			<p>As expected, this is the end result:</p>
			<div>
				<div id="_idContainer226" class="IMG---Figure">
					<img src="Images/Figure_8.27_B16269.jpg" alt="Figure 8.27 – Using sed to replace words and saving those changes to the original file&#13;&#10;" width="1444" height="257"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.27 – Using sed to replace words and saving those changes to the original file</p>
			<p>The <strong class="source-inline">sed</strong> options <strong class="source-inline">s</strong> and <strong class="source-inline">g</strong> are for searching for a word or regular expression and then replacing it globally. By using the <strong class="source-inline">-i</strong> switch, we made that replacement operation in place, which means saving replacement changes to the original file.</p>
			<p>Some more examples are as follows:</p>
			<p>a) Insert blank lines for each non-empty line in the original file:</p>
			<p class="source-code">sed G somefile.txt</p>
			<p>b) Keep the original file content<a id="_idIndexMarker647"/> by creating a backup file and do an inline replacement in the original file:</p>
			<p class="source-code">sed -i'.backup' 's/somethingtochange/somethingtobechangedto/g' somefile.txt</p>
			<p>c) Replace the word <strong class="source-inline">somethingtochange</strong> with <strong class="source-inline">somethingtobechangedto</strong> when the <strong class="source-inline">practice</strong> string appears in the line:</p>
			<p class="source-code"> sed '/practice/s/somethingtochange/somethingtochangeto/g' somefile.txt</p>
			<p>d) Negation of the previous statement: Replace <strong class="source-inline">somethingtochange</strong> with <strong class="source-inline">somethingtochangeto</strong> and only replace it if the <strong class="source-inline">practice</strong> string does not appear in the line:</p>
			<p class="source-code"> sed '/practice/!s/somethingtochange/somethingtochangeto/g' somefile.txt</p>
			<p>e) We can delete the line that matches some pattern:</p>
			<p class="source-code"> sed '/somepattern/d'</p>
			<p>f) Let's search for a number inline and append a currency symbol before the number (regular expression for finding numbers used, as well as a backslash for proper quoting):</p>
			<p class="source-code">sed 's/\([0-9]\)/EUR\1/g' somefile.txt</p>
			<p>g) Let's replace <strong class="source-inline">/bin/bash</strong> with <strong class="source-inline">/bin/tcsh</strong> in <strong class="source-inline">/etc/password</strong> (a regular expression isn't needed here, but we have to use the <strong class="source-inline">\</strong> character for correct interpretation of the <strong class="source-inline">/</strong> character as the <strong class="source-inline">/</strong> character is a special character):</p>
			<p class="source-code">sed 's/\/bin\/bash/\/bin\/tcsh/' /etc/passwd</p>
			<p>As we can see, <strong class="source-inline">sed</strong> is a very powerful tool that can be used to do a lot of changes <em class="italic">on the fly</em>. We are going to show some more examples of using <strong class="source-inline">sed</strong> in scripts later in this book, specifically in the last two chapters with shell script examples. That will give us further insight into <strong class="source-inline">sed</strong> and its usefulness in everyday work.</p>
			<h2 id="_idParaDest-198"><a id="_idTextAnchor204"/>How it works…</h2>
			<p>As a command-line text replacement<a id="_idIndexMarker648"/> utility, <strong class="source-inline">sed</strong> requires us to <em class="italic">explain</em> what we want to do to it. That's the reason why the structure of <strong class="source-inline">sed</strong> commands seems a bit <em class="italic">descriptive</em> – that's just because it is. It also has a lot of options and switches, which add to the overall usability and possible usage scenarios.</p>
			<p>The basic command structure is usually something like this:</p>
			<p class="source-code">sed (-i) 's/something/tosomething/g' filename.txt</p>
			<p>Or, it might be like this:</p>
			<p class="source-code">sed -someoption filename.txt</p>
			<p>Of course, <strong class="source-inline">sed</strong> is often used in scripts, either standalone or as a part of a serial pipeline, something like this:</p>
			<p class="source-code">command1 |( command2 |) sed …..</p>
			<p>Whichever way we use <strong class="source-inline">sed</strong>, it's essential to learn at least some of its switches and settings, starting with the most commonly used ones – <strong class="source-inline">s</strong> and <strong class="source-inline">g</strong> inside <strong class="source-inline">sed</strong> expressions and <strong class="source-inline">-i</strong> as a command-line parameter.</p>
			<p>Say we have a command such as the following:</p>
			<p class="source-code">sed (-i) 's/something/tosomething/g' filename.txt</p>
			<p>Obviously, this has multiple important options. The <strong class="source-inline">-i</strong> option, as we mentioned, is all about interactive change that's going to implement our search-and-replace criteria in the original file. Without it, we are going to get results from our <strong class="source-inline">sed</strong> command to the screen, basically results written to the console. Options inside the quotes – <strong class="source-inline">s</strong> and <strong class="source-inline">g</strong> – are the most-used <strong class="source-inline">sed</strong> options, and they mean search and globally replace, that is, in the whole file.</p>
			<p>We could do the same thing without the <strong class="source-inline">-i</strong> option, by doing this:</p>
			<p class="source-code">sed 's/something/tosomething/g' inputfile.txt &gt; outputfile.txt</p>
			<p>But, as you might imagine, this requires more typing and is generally more complicated.</p>
			<p>The <strong class="source-inline">sed</strong> command-line option <strong class="source-inline">-n</strong> can be used to suppress output to the terminal, and that's the reason why it's used often. If we have a large text file that we're modifying and we aren't using the <strong class="source-inline">-i</strong> option, this might be the go-to option to use if we don't want our console filled with text data.</p>
			<p>One more very useful<a id="_idIndexMarker649"/> option is the <strong class="source-inline">-f</strong> option, as it allows us to use an input <strong class="source-inline">sed</strong> file with replacement definitions. Say we run the following command:</p>
			<p class="source-code">sed -f seddefinitionfile.sed inputfile.txt &gt; outputfile.txt</p>
			<p>We create a <strong class="source-inline">seddefinitionfile.sed</strong> file that contains this:</p>
			<p class="source-code">#!/usr/bin/sed -f</p>
			<p class="source-code">s/something/tosomething/g</p>
			<p class="source-code">s/somethingelse/tosomethingelse/g</p>
			<p>We can use these options to do multiple <strong class="source-inline">sed</strong> transformations in one command. We just need to create <strong class="source-inline">sed</strong> definitions in the file and use it.</p>
			<p>The next chapter in this book is going to introduce us to the world of shell scripting – and the whole second half of the book is about shell scripting. We will get to use all the tools that we discussed up to now there, and combine them to create shell scripts, some of the most used programming-based administration tools ever. Take a short break and get ready to shell script!</p>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor205"/>There's more…</h2>
			<p>If you need more information about networking in CentOS and Ubuntu, make sure that you check out the following:</p>
			<ul>
				<li><strong class="source-inline">sed</strong> manual<a id="_idIndexMarker650"/> page: <a href="https://man7.org/linux/man-pages/man1/sed.1p.html%0D">https://man7.org/linux/man-pages/man1/sed.1p.html</a></li>
				<li>50 <strong class="source-inline">sed</strong> command<a id="_idIndexMarker651"/> examples: <a href="https://linuxhint.com/50_sed_command_examples/%0D">https://linuxhint.com/50_sed_command_examples/</a></li>
				<li><strong class="source-inline">sed</strong> quick<a id="_idIndexMarker652"/> reference guide: https://kwiki.kryptsec.com/books/sed-editor/page/sed-quick-reference-guide</li>
			</ul>
		</div>
	</div></body></html>