- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Filesystem Mount and Manipulation Commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Linux filesystem mount and manipulation commands are a set of essential
    tools that allow Linux system administrators to manage and manipulate filesystems
    and storage devices. These commands provide a flexible and efficient way to mount
    and unmount filesystems, manage disk partitions, and perform various file manipulation
    tasks. They are widely used in Linux environments due to their versatility, reliability,
    and ease of use. One of the key reasons why such commands are highly valued by
    system administrators is their ability to manage filesystems and storage devices.
    These commands enable administrators to mount different types of filesystems,
    such as `ext4`, `NTFS`, or `NFS`, making data accessible and usable within the
    Linux system. They also provide options for managing network filesystems, allowing
    administrators to connect and access remote filesystems over a network. Another
    important aspect of these tools is their role in disk partition management. With
    them, administrators can create, resize, and delete disk partitions, ensuring
    efficient allocation of disk space and organizing data according to specific requirements.
    The ability to manipulate partitions is crucial for tasks such as setting up multi-boot
    systems, creating dedicated storage areas, or managing disk space for virtual
    machines.
  prefs: []
  type: TYPE_NORMAL
- en: These commands offer an added range of file manipulation capabilities, such
    as navigating and exploring the filesystem, searching for files, manipulating
    file permissions and ownership, as well as performing tasks such as copying, moving,
    and deleting files. This flexibility allows for efficient file management and
    maintenance operations, ensuring data organization, integrity, and security within
    the Linux system.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore some of the most important commands in this
    category. These commands play a vital role in managing filesystems, allowing for
    the mounting and unmounting of devices, and enabling efficient data access and
    storage. System administrators heavily rely on these commands to establish connections
    between devices and the filesystem, exercise control over mounted resources, and
    carry out various file operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Linux mount commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The mount command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The umount command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fuser command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File manipulation using cat, grep, and more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux mount commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mounting in Linux refers to the process of connecting a filesystem to a specific
    directory in the directory tree hierarchy, allowing the operating system and its
    users to access the contents of that filesystem. The `mount` command plays a crucial
    role in this process by associating a device or a remote network share with a
    mount point, which is a directory where the filesystem becomes accessible. By
    using the `mount` command, Linux system administrators can dynamically attach
    various types of filesystems, including local disks, network shares, virtual filesystems,
    and removable storage devices, to specific mount points in the filesystem hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: The Linux `mount` commands are vital tools in Linux for connecting filesystems
    to specific mount points, allowing administrators to effectively utilize storage
    resources and provide seamless access to data. Through the `mount` command, Linux
    system administrators can configure and manage various filesystem types, set mounting
    options, and integrate additional storage devices. Mounting is essential for organizing
    data, facilitating system boot processes, and expanding storage capacity, making
    it a fundamental aspect of Linux filesystem management.
  prefs: []
  type: TYPE_NORMAL
- en: The mount command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `mount` command in Linux is a powerful tool that’s used to connect and integrate
    filesystems into the directory tree structure of the operating system. By using
    the `mount` command, administrators can effectively extend the available storage
    capacity, manage data across different devices, and ensure seamless data access
    for users. One of the key reasons for the importance of the `mount` command is
    its ability to provide flexibility and scalability in storage management. With
    the `mount` command, administrators can easily add new storage devices or network
    shares to the system, making them accessible to users without disrupting the existing
    filesystem. This allows for efficient allocation and utilization of storage resources,
    ensuring that data is stored in an organized and accessible manner.
  prefs: []
  type: TYPE_NORMAL
- en: The `mount` command also plays a crucial role in system boot processes. During
    boot, the root filesystem, which contains the essential operating system files,
    is mounted using the `mount` command. This operation requires superuser (`sudo`)
    privileges. Mounting the root filesystem ensures that the system can access and
    load the necessary files to successfully start up. Without the `mount` command,
    the operating system would not be able to locate and access the root filesystem,
    leading to boot failures and an unusable system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see a scenario where the `mount` command is utilized:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mounting NFS shares**: The following screenshot shows the code for mounting
    NFS shares:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Mounting NFS shares](img/B18212_06_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – Mounting NFS shares
  prefs: []
  type: TYPE_NORMAL
- en: 'We will break down the command for more clarity:'
  prefs: []
  type: TYPE_NORMAL
- en: '`10.10.XXX.XX`. This IP address indicates the network location of the NFS server
    that hosts the shared directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/var` is specified as the exported share name. This refers to the specific
    directory or filesystem on the NFS server that is being made available for sharing
    over the network.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/mnt/Keno`. This directory serves as the access point on the local system
    where the NFS share will be integrated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, the `ls -la /mnt/Keno` command is used to list the contents of the `/mnt/Keno`
    directory in a detailed and comprehensive format.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By executing `ls -la /mnt/Keno`, you will see a detailed listing of all the
    files and directories present in the `/mnt/Keno` directory, including hidden files.
    The output will include information such as the file/directory permissions, ownership,
    size, modification date, and name.
  prefs: []
  type: TYPE_NORMAL
- en: '**Mounting second storage device and partition**: The following screenshot
    shows the code for mounting the second storage device and partition:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Mounting the second storage device and partition 1](img/B18212_06_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – Mounting the second storage device and partition 1
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s break down the command for more clarity:'
  prefs: []
  type: TYPE_NORMAL
- en: 'This first command creates two directories, `/mnt/sdb` and `/mnt/sdb1`, using
    the `mkdir` command. The `mkdir` command is used to make directories in the specified
    locations. In this case, it creates two directories under the `/mnt` directory:
    `/mnt/sdb` and `/mnt/sdb1`. These directories will serve as mount points for the
    corresponding devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second command attempts to mount the `/dev/sdb` device to the mount point,
    `/mnt/sdb`, using the `mount` command. The `mount` command is used to attach a
    filesystem to the directory hierarchy. In this case, it is trying to mount the
    `/dev/sdb` device (which represents the entire disk) to the mount point, `/mnt/sdb`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third command mounts the `/dev/sdb1` device (which represents a specific
    partition on the disk) to the mount point, `/mnt/sdb1`, using the `mount` command.
    This command successfully mounts the specified partition to the corresponding
    mount point.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the fourth command lists information about all available block devices
    in a tree-like format. It provides an overview of the block devices present in
    the system, including their names, sizes, and partition information. Running this
    command after the previous steps allows you to see the details of the mounted
    devices (`sdb` and its partition, `sdb1`, in this case) and any other connected
    storage devices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `mount` command without any arguments displays all currently mounted filesystems.
    To check whether`sdb1` is mounted, you can search for its entry in the output.
    You can do this by using the *Ctrl* + *F* shortcut, which opens a search pop-up
    window on your terminal. Type `sdb1` in the search field to quickly locate the
    relevant information. This allows you to easily find out whether `sdb1` is mounted
    and retrieve its associated details. If `sdb1` is mounted, you will see its mount
    point and other relevant information listed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – Mounting the second storage device and partition 2](img/B18212_06_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – Mounting the second storage device and partition 2
  prefs: []
  type: TYPE_NORMAL
- en: '`/``etc/mtab` `/etc/mtab` file, which contains a list of currently mounted
    filesystems. Look for a line in the output that corresponds to `sdb1`. The line
    will include the device path (`/dev/sdb1`), the mount point, and other information:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 6.4 – Checking the /etc/mtab file](img/B18212_06_04_(Merged).jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – Checking the /etc/mtab file
  prefs: []
  type: TYPE_NORMAL
- en: By checking either the `mount` command output or the `/etc/mtab` file, you can
    determine whether `sdb1` is currently mounted and find its associated mount point.
  prefs: []
  type: TYPE_NORMAL
- en: The umount command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `umount` command in Linux is used to unmount or detach a mounted filesystem
    from the directory tree. It allows system administrators to safely remove mounted
    devices or network shares, ensuring that all pending read and write operations
    are completed and any cached data is properly flushed before the filesystem is
    unmounted. This command is essential for maintaining the integrity of the filesystem
    and preventing data corruption. One of the primary reasons for using the `umount`
    command is to safely disconnect storage devices or network shares from the system.
    When a filesystem is mounted, it establishes a connection between the device or
    network share and a directory in the filesystem hierarchy. Unmounting the filesystem
    ensures that any ongoing read or write operations are completed, preventing data
    loss or corruption. It also releases system resources associated with the mounted
    filesystem, freeing up memory and improving system performance.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that directories mounted with this command are not permanent.
    They will be unmounted automatically after a system reboot. If you want to make
    the mount points permanent and have the filesystems mounted automatically at boot,
    you need to update the `/etc/fstab` (filesystems table) configuration file with
    the appropriate entries. This ensures that the mount points are reliable and persist
    across reboots.
  prefs: []
  type: TYPE_NORMAL
- en: The `umount` command in Linux is crucial for managing removable media, such
    as USB drives or external hard disks. Before physically disconnecting the device
    from the system, it is necessary to unmount it using the `umount` command. This
    ensures that all data is written to the device, preventing data loss or filesystem
    inconsistencies. Additionally, the `umount` command is used to detach network
    shares, such as NFS or Samba mounts, allowing users to disconnect from remote
    filesystems securely.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that `umount` typically requires superuser privileges,
    so you may need to use `sudo` to execute it. Executing the `umount` command is
    of utmost importance for safely detaching mounted filesystems in Linux. It ensures
    data integrity, releases system resources, and facilitates the proper removal
    of storage devices or network shares. By using the `umount` command, system administrators
    can effectively manage filesystem connections and maintain the stability and reliability
    of the overall system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at some scenarios where the `umount` command was utilized:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unmounting** **a partition**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unmounting a partition ensures that any pending read or write operations are
    completed, and it allows you to safely disconnect or perform maintenance on the
    storage device without the risk of data corruption:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.5 – Unmounting a partition](img/B18212_06_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5 – Unmounting a partition
  prefs: []
  type: TYPE_NORMAL
- en: After executing these commands, the system will unmount the specified partition
    from their respective mount points. You can verify the unmounting by using the
    `mount` command or checking the output of the `df` command to confirm that the
    devices are no longer listed as being mounted at the specified locations.
  prefs: []
  type: TYPE_NORMAL
- en: '**Unmounting** **multiple filesystems**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 6.6 – Unmounting multiple filesystems](img/B18212_06_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.6 – Unmounting multiple filesystems
  prefs: []
  type: TYPE_NORMAL
- en: This command unmounts multiple filesystems simultaneously. In this example,
    it unmounts the USB drives mounted at `/mnt/usb1` and `/mnt/usb2`, as well as
    the NFS share mounted at `/mnt/nfs`.
  prefs: []
  type: TYPE_NORMAL
- en: The fuser command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `fuser` command in Linux is a powerful tool that’s used to identify processes
    that are currently accessing or using specified files, directories, or sockets.
    It provides information about which processes have active file handles or network
    connections to a given file or directory. The command is primarily used to investigate
    and troubleshoot issues related to resource utilization, file locking, and unresponsive
    processes.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the `fuser` command typically requires superuser privileges,
    so you may need to use `sudo` to execute it. The importance of the `fuser` command
    lies in its ability to help system administrators identify and resolve conflicts
    related to file access. By running the command with appropriate options and specifying
    the target file or directory, administrators can obtain a list of **process IDs**
    (**PIDs**) that have a file or directory open.
  prefs: []
  type: TYPE_NORMAL
- en: This information can be valuable in scenarios where a file is locked, preventing
    other processes from accessing or modifying it. By identifying the process responsible
    for the lock, administrators can take appropriate actions, such as terminating
    or restarting the process, to release the file lock and restore normal operations.
  prefs: []
  type: TYPE_NORMAL
- en: The significance of the `fuser` command lies in its role in maintaining the
    integrity of the filesystem. It ensures that resources tied to a device are properly
    released before undertaking any maintenance tasks. This is crucial because attempting
    to unmount or detach a device that is still in use can lead to unexpected errors
    and data inconsistencies. By identifying which processes are using specific files,
    directories, or sockets, administrators can address resource contention issues,
    troubleshoot file access conflicts, and ensure the smooth operation of the system.
    Furthermore, the `fuser` command aids in releasing file locks and facilitating
    safe resource management. It allows administrators to proactively address any
    potential conflicts or dependencies before making changes to the filesystem. By
    preventing processes from holding exclusive access to files or directories, the
    `fuser` command ensures that other operations can be performed seamlessly. Ultimately,
    the `fuser` command enhances system stability, minimizes the risk of data loss,
    and contributes to the overall efficiency of managing filesystems and storage
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore some scenario-based examples demonstrating the usage of the `fuser`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Checking for any processes that are currently accessing files** **or directories**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 6.7 – Checking for any processes that are currently accessing files
    or directories](img/B18212_06_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.7 – Checking for any processes that are currently accessing files or
    directories
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what each part of the command does:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fuser` is the actual command that is being executed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-v` is an option that stands for **verbose** and provides more detailed information
    about the processes accessing the directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/home/instructor` is the path to the directory that is being checked'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you run this command, it will display a list of processes, along with their
    PIDs that are currently using files or directories within the specified directory.
    The verbose output will include additional details such as the user, the type
    of access (read, write, or both), and the access time.
  prefs: []
  type: TYPE_NORMAL
- en: '**Checking for processes using a specific file in your** **current directory**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 6.8 – Checking for processes using a specific file in your current
    directory](img/B18212_06_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.8 – Checking for processes using a specific file in your current directory
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what each part of the command does:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fuser` is the actual command that is being executed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.` represents the current directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you run this command, it will display a list of processes, along with their
    PIDs that are currently using files or directories within the current directory.
    This includes any subdirectories and files within the current directory.
  prefs: []
  type: TYPE_NORMAL
- en: The output also shows that the process has a PID of `12102`. This means that
    the process can be identified by the operating system using this unique identifier
    and the `c` character in the PID output means that the process has the file open
    for reading and writing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `fuser` command will list the following types of access in the `ACCESS`
    column:'
  prefs: []
  type: TYPE_NORMAL
- en: '`C`: Open for reading and writing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`R`: Open for reading only'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`W`: Open for writing only'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`U`: Open by a process that is no longer running'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`4330`. The `-n` option specifies the network protocol.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 6.9 – Determining processes using a network socket](img/B18212_06_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.9 – Determining processes using a network socket
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a breakdown of the command and its components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fuser` is the command itself, which stands for **file user**. It is used to
    identify processes that are using files or network sockets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-n tcp` is an option that specifies the type of network protocol to search
    for. In this case, it is set to `tcp`, indicating that we are interested in TCP
    connections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`4330` is the specific TCP port number that we want to check for.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you run this command, it will provide information about the processes that
    are currently using TCP port `4330`. It will display the PIDs of the processes,
    along with additional details, such as the user who owns the process and the command
    associated with it.
  prefs: []
  type: TYPE_NORMAL
- en: File manipulation using cat, grep, and more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using commands such as `cat` and `grep` is a fundamental aspect of working with
    files in Linux and other Unix-like systems. These commands provide powerful and
    versatile tools for managing and extracting information from files. They are essential
    for system administrators, developers, and anyone who works with text files regularly.
    One of the main reasons for the importance of file manipulation commands is their
    ability to efficiently process and manipulate large amounts of data. Commands
    such as `cat`, which stands for `grep`, which is used for searching and pattern
    matching within files. `grep` enables users to search for specific text patterns,
    extract relevant information, and filter out unnecessary data. This is invaluable
    for analyzing log files, extracting specific lines of code from source files,
    or searching for specific error messages within a file. Its versatility and efficiency
    make it an indispensable tool for various tasks, such as data analysis, system
    troubleshooting, and log file parsing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to `cat` and `grep`, there are numerous other file manipulation
    commands available in Linux, each serving a specific purpose. For example, commands
    such as `sed` and `awk` provide advanced text processing capabilities, allowing
    users to perform complex operations such as search and replace, pattern-based
    editing, and field extraction. These commands empower users to automate repetitive
    tasks, transform data, and manipulate files in a precise and controlled manner.
    The ability to efficiently manipulate files using these commands enhances productivity,
    enables effective data analysis, and facilitates automation in various system
    administration and development tasks. Let’s explore how system administrators
    can leverage these powerful tools in their day-to-day tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Extracting lines containing a specific pattern using `cat` and `grep`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 6.10 – Extracting lines containing a specific pattern using cat and
    grep](img/B18212_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.10 – Extracting lines containing a specific pattern using cat and grep
  prefs: []
  type: TYPE_NORMAL
- en: The `cat output.txt | grep "pattern"` command is used to display lines from
    the `output.txt` file that match the specified pattern. Here, `cat output.txt`
    is used to display the contents of `output.txt`, and the output is piped (`|`)
    to the `grep` command. The `grep` command searches for lines containing the specified
    pattern and displays only those lines. To use `grep`, you can simply run a command
    such as `grep "search_term" your_file`, where `search_term` is the text or pattern
    you want to search for, and `your_file` is the file in which you want to perform
    the search.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replacing text in a file using `sed`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 6.11 – Replacing text in a file using sed](img/B18212_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.11 – Replacing text in a file using sed
  prefs: []
  type: TYPE_NORMAL
- en: The `sed -i 's/pattern/mad_max/g' output.txt` command is used to replace occurrences
    of the specified pattern with `mad_max` in the `output.txt` file and modify the
    file in place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a breakdown of the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sed`: The command for the stream editor, used for text manipulation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-i`: Specifies the “in-place” editing mode, which means the changes will be
    made directly to the `output.txt` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''s/pattern/mad_max/g''`: This is the substitution command in the form of
    `''s/old_text/new_text/g''`. It tells `sed` to search for occurrences of the pattern
    and replace them with `mad_max`. The `g` flag is used to perform the replacement
    globally on each matching line, not just the first occurrence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, the `cat output.txt | grep "mad_max"` command is used to search for
    lines in the `output.txt` file that contain `mad_max`.
  prefs: []
  type: TYPE_NORMAL
- en: Using `awk` to filter lines based on a condition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This command uses `awk` to filter the lines in the file (`output2.txt`) based
    on the condition that the first column is greater than 10\. Only the lines satisfying
    the condition are displayed:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.12 – awk – filtering lines based on a condition](img/B18212_06_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.12 – awk – filtering lines based on a condition
  prefs: []
  type: TYPE_NORMAL
- en: 'The `awk ''$1 > 10'' output2.txt` command is used to filter and print lines
    from a file where the value in the first column is greater than 10\. Here’s an
    explanation of each part of the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`awk`: The command-line tool for text processing and pattern scanning in Linux.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''$1 > 10''`: The pattern or condition to be matched in the input file. In
    this case, it checks whether the value in the first column (denoted by `$1`) is
    greater than 10.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`output2.txt`: The name of the file from which the command reads the input.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you run this command, `awk` reads the contents of `output2.txt` and evaluates
    the given pattern for each line. If the value in the first column of a line is
    greater than 10, that line is printed to the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s say `file.txt` contains the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.13 – awk example 1](img/B18212_06_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.13 – awk example 1
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the `awk ''$1 > 10'' file.txt` command will output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.14 – awk example 2](img/B18212_06_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.14 – awk example 2
  prefs: []
  type: TYPE_NORMAL
- en: It filters out the lines where the value in the first column is not greater
    than 10 and prints only the lines that satisfy the condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Counting the occurrence of a specific word in a file using `cat`, `grep`, and
    `wc` (**word count**):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 6.15 – Counting the occurrence of a specific word in a file using
    cat, grep, and wc](img/B18212_06_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.15 – Counting the occurrence of a specific word in a file using cat,
    grep, and wc
  prefs: []
  type: TYPE_NORMAL
- en: 'This command counts the number of occurrences of the exact word, `disproperty`,
    in the `output2.txt` file. The output is displayed as a single line count. Here’s
    the breakdown of the command:'
  prefs: []
  type: TYPE_NORMAL
- en: In the first command, `cat output2.txt | grep -w "disproperty" | wc -l`, the
    `output2.txt` file is passed to the `cat` command, which reads and displays the
    content of the file. The output is then piped (`|`) to the `grep` command with
    the `-w` flag, which searches for the exact word, `disproperty`, in the input.
    The result is then piped again to the `wc -l` command, which counts the number
    of lines (`-l`). The output of this command is `1`, indicating that `disproperty`
    appears once in the file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the second command, `cat output2.txt | grep -w "mad_max" | wc -l`, the same
    process is followed. The `output2.txt` file is read by `cat`, and the output is
    piped to `grep -w "mad_max"` to search for the exact word, `mad_max`. The result
    is then piped to `wc -l` to count the number of lines. In this case, the output
    is `2`, indicating that `mad_max` appears twice in the file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These examples showcase the versatility and power of the `cat`, `grep`, `sed`,
    and `awk` commands in performing various file manipulation tasks, such as filtering
    lines, replacing text, extracting fields, and counting occurrences.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, file manipulation commands such as `cat`, `grep`, `sed`, and `awk`
    play a crucial role in managing and extracting information from files in Linux.
    They provide powerful and efficient tools for working with text-based data, allowing
    users to concatenate, search for, filter, and transform files with ease. Their
    importance lies in their ability to handle large amounts of data, facilitate efficient
    data analysis, and automate repetitive tasks. By mastering these commands, users
    gain valuable skills for effectively working with files, enabling them to accomplish
    tasks more efficiently and improve their overall productivity in a Linux environment.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, Linux mount and manipulation commands are vital tools for managing
    filesystems, mounting and unmounting devices, and manipulating files in Linux.
    These commands empower system administrators to establish connections between
    devices and the filesystem, control access to mounted resources, and perform diverse
    file operations. By skillfully utilizing these commands, system administrators
    can optimize data access and storage, enforce robust security measures, and uphold
    the integrity of the filesystem. Overall, Linux mount and manipulation commands
    are indispensable in ensuring efficient system administration, safeguarding data,
    and maintaining a secure and well-organized Linux environment.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter focused on Linux mount and manipulation commands, which are essential
    tools for managing filesystems, mounting and unmounting devices, and manipulating
    files in Linux. This chapter began by highlighting the significance of these commands
    in establishing connections between devices and the filesystem, controlling access
    to mounted resources, and performing various file operations. The `mount` command
    takes center stage as it enables administrators to mount filesystems and devices
    to specific mount points, ensuring efficient data access and storage. The `umount`
    command was introduced as its counterpart, allowing for the safe unmounting of
    filesystems and detaching storage devices. The `fuser` command proves invaluable
    in scenarios where it is necessary to check for active processes accessing files
    or directories before unmounting or detaching devices, safeguarding against potential
    data loss or corruption. Additionally, this chapter explored the usage of the
    `cat`, `grep`, `sed`, and `awk` commands for file manipulation, including searching
    for patterns, replacing text, and extracting specific data. These commands provide
    versatile ways to manipulate and analyze files efficiently. Overall, Linux mount
    and manipulation commands offer administrators the means to manage filesystems,
    control access, troubleshoot conflicts, and ensure the integrity and security
    of the Linux environment.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming chapter, which is dedicated to file content and conversion commands,
    we will delve into a diverse range of potent tools that empower system administrators
    to effectively handle and modify file content within a Linux environment. This
    chapter, which is a part of our comprehensive series on frequently used commands,
    will extensively cover a selection of indispensable commands that are widely employed
    for seamless file content management and proficient file format conversions.
  prefs: []
  type: TYPE_NORMAL
- en: Part 3:Frequently Used Commands – Part 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Part 3*, we concentrate on commonly used Linux commands for file analysis,
    conversion, activation, monitoring, troubleshooting, network management, and so
    on. This section simplifies practical command usage for various tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section contains the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B18212_07.xhtml#_idTextAnchor084), *File Content and Conversion*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B18212_08.xhtml#_idTextAnchor094), *Linux SWAP*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B18212_09.xhtml#_idTextAnchor100), *Monitoring and Debugging*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B18212_10.xhtml#_idTextAnchor118), *Linux IPTABLES and Networking*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B18212_11.xhtml#_idTextAnchor127), *File Transfer, Downloading,
    and Log Management*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
