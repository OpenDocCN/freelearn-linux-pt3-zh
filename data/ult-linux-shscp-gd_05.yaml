- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Customizing the Environment
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义环境
- en: In this chapter, we’ll look at the various configuration files for the `bash`
    shell environment. We’ll look at how to customize these configuration files, and
    how to set certain environmental options from the command-line.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将查看 `bash` shell 环境的各种配置文件。我们将看看如何自定义这些配置文件，以及如何从命令行设置某些环境选项。
- en: 'Topics in this chapter include:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主题包括：
- en: Reviewing the environmental variables
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审查环境变量
- en: Understanding the configuration files
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解配置文件
- en: Setting shell options from the command line
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从命令行设置 shell 选项
- en: I’m sticking with `bash` for now, but in *Chapter 22, Understanding the Z Shell*,
    I’ll explain how `zsh` is set up.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '我现在坚持使用 `bash`，但在*第22章，理解Z Shell*中，我会解释如何设置 `zsh`。 '
- en: If you’re raring and ready, let’s get going.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经迫不及待，我们就开始吧。
- en: Technical Requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you’ll need one Fedora virtual machine and one Debian virtual
    machine. I won’t be providing a Hands-On Lab in this chapter. Instead, I’ll just
    invite you to follow along on your virtual machines as you read through the chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要一台 Fedora 虚拟机和一台 Debian 虚拟机。我不会提供本章的动手实验。相反，我会邀请你在阅读本章时跟随你的虚拟机操作。
- en: Reviewing the Environmental Variables
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审查环境变量
- en: In *Chapter 3, Understanding Variables and Pipelines*, I introduced the concept
    of environmental variables. In this chapter, I’d like to expand on that topic.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第3章，理解变量与管道*中，我介绍了环境变量的概念。在本章中，我将进一步展开这个话题。
- en: 'We’ve already seen that environmental variables can be used to help customize
    and control your shell environment. Here’s a table of some of the more common
    environmental variables:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，环境变量可以帮助自定义和控制你的 shell 环境。以下是一些常见环境变量的表格：
- en: '| **Environmental Variable** | **Purpose** |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| **环境变量** | **用途** |'
- en: '| `USER` | The username of the person who is currently logged into the system.
    |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `USER` | 当前登录系统的用户的用户名。 |'
- en: '| `UID` | The User ID number of the logged-in user. |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `UID` | 当前登录用户的用户 ID。 |'
- en: '| `EUID` | The Effective User ID number of the user who’s running a certain
    process. |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `EUID` | 运行某个进程的用户的有效用户 ID。 |'
- en: '| `MAIL` | This defines the path to the mail spool of the logged in user. |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `MAIL` | 这定义了当前登录用户的邮件队列路径。 |'
- en: '| `SHELL` | The path to the shell that is currently in use. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `SHELL` | 当前使用的 shell 路径。 |'
- en: '| `PWD` | The current working directory. (PWD stands for “Print Working Directory”.)
    |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `PWD` | 当前工作目录。（PWD 代表“打印工作目录”）。 |'
- en: '| `OLDPWD` | The previous working directory. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `OLDPWD` | 上一个工作目录。 |'
- en: '| `HOSTNAME` | The hostname of the computer. |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `HOSTNAME` | 计算机的主机名。 |'
- en: '| `PATH` | A colon-delimited list of directories in which the system looks
    when you type an executable program name. This variable gets built in several
    configuration files, such as `/etc/profile` and the `.bashrc` file that resides
    in the user’s home directory. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `PATH` | 一个以冒号分隔的目录列表，系统在你输入可执行程序名称时会搜索这些目录。这个变量是在多个配置文件中构建的，比如 `/etc/profile`
    和用户主目录中的 `.bashrc` 文件。 |'
- en: '| `HOME` | This holds the path for the current user’s home directory. Some
    programs will use this variable to determine where to find configuration files
    or determine the default location to store files. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `HOME` | 这是当前用户的主目录路径。一些程序会使用这个变量来确定配置文件的位置或决定存储文件的默认位置。 |'
- en: '| `PS1` | The primary shell prompt. |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `PS1` | 主 shell 提示符。 |'
- en: '| `PS2` | The secondary shell prompt. |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `PS2` | 次要 shell 提示符。 |'
- en: '| `TERM` | This specifies the current terminal type. You’ll probably see it
    set as either `xterm` or some form of `xterm` for non-login sessions and login
    sessions from a remote GUI terminal emulator, and just `Linux` for login sessions
    at the local console. (I’ll explain the types of sessions in the next section.)
    The system needs to know which terminal type is in use so that it will know how
    to move the cursor and display text effects in text-mode programs. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `TERM` | 这指定了当前的终端类型。在非登录会话和通过远程图形界面终端模拟器的登录会话中，你可能会看到它被设置为 `xterm` 或某种形式的
    `xterm`，而在本地控制台的登录会话中则通常为 `Linux`。（我将在下一节中解释会话类型。）系统需要知道当前使用的是哪种终端类型，这样它才能知道如何在文本模式程序中移动光标和显示文本效果。
    |'
- en: '| `DISPLAY` | This variable allows you to have multiple displays running from
    the same computer. If you’re only running one display, you’ll see a returned value
    of `:0`. (That means, the first display on the current computer.) |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `DISPLAY` | 该变量允许你在同一台计算机上运行多个显示器。如果你只运行一个显示器，你会看到返回值为 `:0`。（这意味着当前计算机上的第一个显示器。）
    |'
- en: '| `EDITOR` | This sets the default text editor that you want to use for system
    administrative functions such as `systemctl edit` and `crontab -e`. Your best
    choices are generally either `nano` or `vim`. |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `EDITOR` | 该变量设置你希望用于系统管理功能（如 `systemctl edit` 和 `crontab -e`）的默认文本编辑器。通常，最佳选择是
    `nano` 或 `vim`。 |'
- en: 'Table 5.1: The more common environmental variables'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.1：更常见的环境变量
- en: The slightly tricky part about this is that environmental variables aren’t always
    exactly the same across all Linux distros. For example, the `EDITOR` variable
    is defined here on my Fedora workstation, but it’s not used at all on any Debian
    or Ubuntu distros. Instead, Debian and Ubuntu use another mechanism for setting
    the default editor, which we’ll look at in a bit.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这里稍微复杂的地方是，环境变量在不同的 Linux 发行版中并不完全相同。例如，`EDITOR` 变量在我的 Fedora 工作站上有定义，但在任何 Debian
    或 Ubuntu 发行版上都没有使用。相反，Debian 和 Ubuntu 使用另一种机制来设置默认编辑器，我们稍后会讨论。
- en: Now, before I can fully explain the `bash` configuration files, I need to explain
    the different types of shell sessions.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我能完全解释 `bash` 配置文件之前，我需要先解释不同类型的 Shell 会话。
- en: Understanding Shell Sessions
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Shell 会话
- en: 'Any time you initiate interaction with a shell, you’re creating a **shell session**.
    Shell sessions can be classified in the following ways:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你启动与 Shell 的交互时，你都在创建一个 **Shell 会话**。Shell 会话可以按照以下方式分类：
- en: '**Interactive shells**: When you sit down at a computer and enter commands
    on the command-line, you’re working with an interactive shell.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交互式 Shell：** 当你坐在计算机前并在命令行上输入命令时，你正在使用交互式 Shell。'
- en: '**Non-interactive shells**: When a shell session is invoked from within a shell
    script, you’re working with a non-interactive shell.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非交互式 Shell：** 当从 Shell 脚本中调用一个 Shell 会话时，你正在使用非交互式 Shell。'
- en: '**Login shells:** If you log into a Linux machine that’s running in text mode,
    without a graphical interface, you’re working with a login shell. You can also
    work with a login shell on a desktop machine by invoking a *Ctrl-Alt-Function_Key*
    sequence to switch away from the desktop interface to a text mode terminal. (You
    can use function keys F1 through F6 for this.) Or, you can invoke the `bash -l`
    command in the normal terminal emulator to open a child `bash` session in login
    mode. The final way to initiate a login shell session is to log into a machine
    remotely via Secure Shell. Regardless of whether the remote machine is of a text-mode
    or GUI-mode variety, your remote session will be of the login shell type.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**登录 Shell：** 如果你登录到一台运行在文本模式下且没有图形界面的 Linux 机器，你正在使用登录 Shell。你也可以通过调用 *Ctrl-Alt-Function_Key*
    组合键，在桌面机器上将桌面界面切换到文本模式终端，从而使用登录 Shell。（你可以使用 F1 到 F6 的功能键来完成此操作。）或者，你可以在正常的终端模拟器中调用
    `bash -l` 命令来以登录模式打开一个子 `bash` 会话。启动登录 Shell 会话的最终方式是通过安全外壳（SSH）远程登录到一台机器。无论远程机器是文本模式还是图形用户界面（GUI）模式，你的远程会话都将是登录
    Shell 类型的。'
- en: '**Non-login shells**: Any time you open a terminal emulator on a desktop Linux
    machine, you’re working with a non-login shell.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非登录 Shell：** 每次你在桌面 Linux 机器上打开一个终端模拟器时，你正在使用非登录 Shell。'
- en: So, what does all this mean? Well, the difference between interactive and non-interactive
    shells is fairly obvious, so I won’t talk more about that. But, I would like to
    point out two different ways to know whether you’re working with a login shell
    or a non-login shell.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这一切意味着什么呢？嗯，交互式 Shell 和非交互式 Shell 之间的区别比较明显，所以我就不再多说了。但我想指出两种方法，帮助你判断自己是否正在使用登录
    Shell 或非登录 Shell。
- en: 'The first way is to use the `shopt` command, like so:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法是使用 `shopt` 命令，像这样：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `shopt` command can be used to set various configuration options for a
    `bash` session. Here though, I’m using it without any option switches to just
    view the `login_shell` setting. You see here that the `login_shell` setting is
    `off`, which means that I’m in a non-login shell here on my Fedora workstation.
    On my text mode Fedora Server virtual machine, the `shopt` output looks like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`shopt` 命令可以用来为 `bash` 会话设置各种配置选项。在这里，我没有使用任何选项开关，而只是查看 `login_shell` 设置。你可以看到
    `login_shell` 设置为 `off`，这意味着我在 Fedora 工作站上使用的是非登录 Shell。而在我的文本模式 Fedora 服务器虚拟机上，`shopt`
    输出是这样的：'
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you see, the `login_shell` parameter is `on`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`login_shell` 参数是 `on`。
- en: 'The second way to tell if you’re in a login shell is to use the `echo $0` command,
    like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 判断是否处于登录 shell 的第二种方法是使用 `echo $0` 命令，像这样：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `$0` argument is what’s known as a **positional parameter**. I’ll provide
    in-depth coverage of positional parameters in *Chapter 8, Basic Shell Script Construction*,
    so don’t stress out about them just yet. All you need to know for now is that
    the `echo $0` command shows the name of the script or executable that’s currently
    in use.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`$0` 参数被称为 **位置参数**。我将在 *第 8 章，基本 Shell 脚本构建* 中深入讲解位置参数，所以现在不必担心它们。你现在需要知道的仅仅是，`echo
    $0` 命令显示的是当前使用的脚本或可执行文件的名称。'
- en: 'In this case, we’re in a `bash` session, which means that the `bash` executable
    is in use. But, how do we know whether or not we’re using a login shell? Well,
    it’s just that the `bash` output is not preceded by a dash, which means that we’re
    not in a login shell. To show the difference, here’s what you’ll see on the text-mode
    Fedora Server virtual machine:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们处于一个 `bash` 会话中，这意味着正在使用 `bash` 可执行文件。但是，我们怎么知道自己是否使用的是登录 shell 呢？其实，`bash`
    输出前面没有破折号，这意味着我们不在登录 shell 中。为了显示区别，以下是你在文本模式的 Fedora 服务器虚拟机上看到的内容：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `-bash` output indicates that I’m in a login shell.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`-bash` 输出表示我在一个登录 shell 中。'
- en: Even from afar, I can read your mind. (Yes, I know that that’s creepy.) I know
    that you’re wondering why you need to know about these different types of shell
    sessions. Well, it’s just that there are several different `bash` configuration
    files. The type of shell session you’re using determines which configuration files
    the session accesses. So, now that you know about the different types of shell
    sessions, we can look at these configuration files.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 即使从远处，我也能读懂你的心思。（是的，我知道这很吓人。）我知道你在想，为什么你需要了解这些不同类型的 Shell 会话。其实，是因为有几个不同的 `bash`
    配置文件。你使用的 shell 会话类型决定了该会话访问哪些配置文件。所以，现在你已经了解了不同类型的 Shell 会话，我们可以来看看这些配置文件。
- en: Understanding the Configuration Files
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解配置文件
- en: As we’ve already seen, you can set environmental variables from the command-line.
    But, any variables you set in this manner will only last for the duration of the
    command-line session. When you log out of the system or close the terminal emulator
    window, any environmental changes that you’ve made from the command-line will
    be lost.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们已经看到的，你可以通过命令行设置环境变量。但是，任何你以这种方式设置的变量只会在命令行会话期间有效。当你退出系统或关闭终端仿真窗口时，命令行中所做的任何环境更改都会丢失。
- en: What if we want to make these changes permanent? There are several configuration
    files that we can edit to save our changes. Some are global and will affect all
    users, while others will only affect an individual user. The slightly tricky part
    is that the files differ from one Linux distro to the next. Let’s start by looking
    at the `bash` configuration files on Fedora. After that, we’ll move on to Debian.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想让这些更改永久生效怎么办？有几个配置文件可以编辑以保存我们的更改。有些是全局的，会影响所有用户，而另一些则只会影响单个用户。稍微复杂的是，这些文件在不同的
    Linux 发行版之间有所不同。我们先来看 Fedora 上的 `bash` 配置文件。之后，我们再看看 Debian。
- en: bash Global Configuration Files on Fedora
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Fedora 上的 bash 全局配置文件
- en: 'As we’ve already seen, there are global configuration files in the `/etc/`
    directory, and users’ configuration files in each user’s own home directory. For
    the global configuration, we have these two files:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们已经看到的，在 `/etc/` 目录中有全局配置文件，在每个用户的主目录中有用户配置文件。对于全局配置，我们有这两个文件：
- en: '`/etc/profile`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/etc/profile`'
- en: '`/etc/bashrc`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/etc/bashrc`'
- en: 'The `/etc/profile` file sets up the environment for anyone who opens a `bash`
    login shell session, and is executed as soon as a user logs in. Go ahead and open
    it and look through it. What you’ll see is a somewhat complex shell script that
    performs the following functions:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`/etc/profile` 文件为任何打开 `bash` 登录 shell 会话的用户设置环境，并在用户登录后立即执行。打开它并浏览，你会看到一个相当复杂的
    Shell 脚本，执行以下功能：'
- en: It defines the default `PATH` setting for both the root user and every non-root
    user who’s using a login shell.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它为 root 用户和所有使用登录 shell 的非 root 用户定义了默认的 `PATH` 设置。
- en: It defines the various environmental variables that are associated with each
    logged-in user. These include the `UID`, `EUID`, `USER`, `LOGNAME`, and `MAIL`
    variables.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它定义了与每个登录用户相关的各种环境变量。这些变量包括 `UID`、`EUID`、`USER`、`LOGNAME` 和 `MAIL`。
- en: It sets the machine’s `HOSTNAME`.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它设置了机器的 `HOSTNAME`。
- en: It sets the `HISTSIZE` variable, which defines how many past commands will be
    held in each user’s command history.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它设置了`HISTSIZE`变量，该变量定义了每个用户的命令历史中将保留多少条过去的命令。
- en: After having done all of the above, it reads in the various configuration scripts
    in the `/etc/profile.d/` directory. Most of these scripts define system-wide behaviors
    for certain system utilities. There’s also a script that sets the default `EDITOR`
    for system utilities that automatically open a text editor.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成上述操作后，它会读取`/etc/profile.d/`目录中的各种配置脚本。大多数这些脚本定义了某些系统工具的系统范围行为。还有一个脚本用于设置自动打开文本编辑器的系统工具的默认`EDITOR`。
- en: Of course, at this point I don’t expect you to completely understand what’s
    going on in this profile file. However, what you see in this file is the kind
    of stuff that we’ll be covering throughout the remainder of this book. Once you’ve
    gone through all of that, you’ll be able to come back and have a better understanding
    of exactly what this file is doing.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，到目前为止，我不指望你完全理解该配置文件中的内容。然而，你在这个文件中看到的正是我们将在本书后续部分覆盖的内容。一旦你完成了所有的学习，你将能更好地理解这个文件究竟在做什么。
- en: The other global configuration file is the `/etc/bashrc` file, which affects
    non-login shell sessions. It does a few different things for us, but for our present
    purposes just know that this is where the `PS1` variable is defined for interactive
    sessions, and that it defines the `PATH` setting for users who are using a non-login
    shell.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个全局配置文件是`/etc/bashrc`文件，它影响非登录Shell会话。它为我们做了几件不同的事情，但就目前的目的而言，只需要知道这是为交互式会话定义`PS1`变量的地方，并且它为使用非登录Shell的用户定义了`PATH`设置。
- en: 'In addition to these two main files, there are also supplementary configuration
    files in the `/etc/profile.d/` directory, as you see here:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这两个主要文件之外，`/etc/profile.d/`目录中还有一些补充的配置文件，如你所见：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Each of these files contains supplementary configuration information for the
    shell environment. In general, each file does either one of these two things for
    us:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 每个文件包含了针对Shell环境的补充配置信息。通常，每个文件为我们做了以下两件事情中的一件：
- en: Creating aliases for certain other commands. (We’ll cover aliases in just a
    bit.)
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为某些其他命令创建别名。（我们稍后将讨论别名。）
- en: Defining environmental variables that aren’t already defined in the `/etc/profile`
    or `/etc/bashrc` files.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义在`/etc/profile`或`/etc/bashrc`文件中尚未定义的环境变量。
- en: 'For a simple example of the second function, let’s look at the definition for
    the `EDITOR` variable. On the server version of Fedora it will be in the `/etc/profile.d/vim-default-editor.sh`
    file, and on the workstation version of Fedora it will be in the `/etc/profile.d/nano-default-editor.sh`
    file. Here’s what the server version looks like:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第二个功能的简单示例，让我们看一下`EDITOR`变量的定义。在Fedora的服务器版本中，它将位于`/etc/profile.d/vim-default-editor.sh`文件中，而在Fedora的工作站版本中，它将位于`/etc/profile.d/nano-default-editor.sh`文件中。以下是服务器版本的内容：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Again, I don’t expect you to fully understand what’s going on with this just
    yet. So for now, the simple explanation is that if the `EDITOR` environmental
    variable hasn’t yet been set, then it will be set it to `/usr/bin/vim`. (On the
    workstation edition of Fedora, `EDITOR` will be set to `/usr/bin/nano`.)
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 再次说明，我并不期望你现在完全理解这一切。所以目前简单的解释是，如果`EDITOR`环境变量尚未设置，那么它将被设置为`/usr/bin/vim`。（在Fedora的工作站版本中，`EDITOR`将设置为`/usr/bin/nano`。）
- en: 'There may be times when an administrator needs to alter the default environmental
    settings that have been defined in either `/etc/profile` or `/etc/bashrc`. You
    could do that by editing the `/etc/profile` or the `/etc/bashrc` file, but that’s
    not recommended. Instead, just place the new settings in the `/etc/profile.d/sh.local`
    file. Currently, there’s nothing in that file except for an explanatory comment,
    as we see here:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，管理员可能需要更改在`/etc/profile`或`/etc/bashrc`中定义的默认环境设置。你可以通过编辑`/etc/profile`或`/etc/bashrc`文件来实现，但这并不推荐。相反，应该将新的设置放入`/etc/profile.d/sh.local`文件中。目前，除了一个说明性注释外，该文件没有其他内容，如下所示：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Okay, that about does it for the global configuration files on Fedora. Let’s
    now look at the users’ own configuration files.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这就是Fedora的全局配置文件的内容。现在让我们来看看用户的配置文件。
- en: Users’ Configuration Files on Fedora
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Fedora上的用户配置文件
- en: 'Shell configuration files in the users’ home directories are considered as
    hidden files, because their filenames begin with a dot. To see them, you’ll need
    to use the `-a` option with `ls`, like so:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 用户主目录中的Shell配置文件被视为隐藏文件，因为它们的文件名以点号开头。要查看这些文件，你需要使用`ls`命令的`-a`选项，像这样：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Only three of these files are of concern to us, which are:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 只有这三个文件对我们有关系，它们是：
- en: '`.bash_logout`: This file is currently empty, except for an explanatory comment.
    Any commands that you place in this file will be executed either upon logging
    out of an interactive login shell session, or when the `exit` function is invoked
    at the end of a shell script. Among other things, you could use this to automatically
    clean up temporary files or to perform an automatic backup of files in a user’s
    home directory when the user exits the shell session.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.bash_logout`：此文件目前为空，只有一条说明性注释。你放在此文件中的任何命令将会在从交互式登录Shell会话退出时执行，或者当在Shell脚本的末尾调用`exit`函数时执行。除了其他功能外，你可以使用此文件在用户退出Shell会话时自动清理临时文件，或者执行用户主目录中文件的自动备份。'
- en: '`.bash_profile`: This file is only used for login shell sessions. So, if you
    open a terminal emulator on your desktop machine, anything that’s in this file
    will have no effect. If you look at the contents of this file, you’ll see that
    the only thing it does by default is to cause the `.bashrc` file to be read in.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.bash_profile`：此文件仅用于登录Shell会话。因此，如果你在桌面计算机上打开终端模拟器，文件中的任何内容都不会产生影响。如果你查看该文件的内容，你会看到它默认唯一的作用就是读取`.bashrc`文件。'
- en: '`.bashrc`: This is the main bash configuration file for the user level, which
    directly affects non-login shell sessions. Since the `.bash_profile` file causes
    the `.bashrc` file to be read in for login shell sessions, anything you place
    into `.bashrc` affects both login and non-login sessions.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.bashrc`：这是用户级的主要bash配置文件，直接影响非登录Shell会话。由于`.bash_profile`文件会使`.bashrc`文件在登录Shell会话中被读取，因此你放入`.bashrc`中的任何内容都会影响登录会话和非登录会话。'
- en: 'So, how does this work in practice? Well, let’s say that you need to add the
    `/opt/` directory to your working `PATH`. Currently, the `PATH` looks like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这在实际操作中是如何运作的呢？假设你需要将`/opt/`目录添加到你的工作`PATH`中。当前，`PATH`看起来是这样的：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To add the `/opt/` directory, open the `.bashrc` file in your text editor,
    and look for this stanza:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 若要添加`/opt/`目录，请在文本编辑器中打开`.bashrc`文件，找到这一段内容：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Change it so that it looks like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 将其更改为如下所示：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Log out and then log back in. Your `PATH` setting should now look like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 登出并重新登录。你的`PATH`设置现在应该是这样的：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can now place executable scripts or binary executable files in the `/opt/`
    directory, and run them without having to specify the entire path.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以将可执行脚本或二进制可执行文件放入`/opt/`目录，并且无需指定完整路径即可运行它们。
- en: 'To make a permanent change to your command prompt setting so that it will also
    show the current date and time, place this line at the end of the `.bashrc` file:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 若要永久更改你的命令提示符设置，使其也能显示当前的日期和时间，请将以下这一行添加到`.bashrc`文件的末尾：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Log out and log back in. Your command prompt should now look like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 登出并重新登录。你的命令提示符现在应该是这样的：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: So, that’s all pretty cool, right? For even more coolness, let’s move on to
    the Debian configuration files.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这一切看起来都很酷，对吧？为了增加更多的酷炫感，让我们继续讨论Debian的配置文件。
- en: bash Global Configuration Files on Debian
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Debian上的bash全局配置文件
- en: On Debian, things are somewhat different. The `/etc/profile` file is still there,
    but it’s radically different from the one on Fedora. Go ahead and look at it on
    your own virtual machine. You’ll see that all it does is define the `PATH` and
    `PS1` variables and read in any supplementary files that are in the `/etc/profile.d/`
    directory. If the session is an actual `bash` session instead of an `sh` session,
    then it will also read in the `/etc/bash.bashrc` file. Also, you’ll see that Debian
    uses a method for defining `PATH` that’s radically different from the method that’s
    used on Fedora.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在Debian中，情况略有不同。`/etc/profile`文件仍然存在，但与Fedora上的版本有着根本的不同。你可以在你自己的虚拟机上查看它。你会看到，它所做的只是定义`PATH`和`PS1`变量，并读取`/etc/profile.d/`目录中的任何补充文件。如果会话是一个实际的`bash`会话，而不是`sh`会话，它还会读取`/etc/bash.bashrc`文件。此外，你会看到Debian在定义`PATH`时使用了一种与Fedora方法完全不同的方式。
- en: 'Instead of the `/etc/bashrc` file that Fedora uses, Debian uses the `/etc/bash.bashrc`
    file. This file does the following things for us:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 与Fedora使用的`/etc/bashrc`文件不同，Debian使用`/etc/bash.bashrc`文件。该文件为我们做了以下几件事：
- en: It checks the size of the window in which the `bash` session is running, so
    that the correct number of lines and columns can be displayed after the user enters
    a command.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它检查运行 `bash` 会话的窗口大小，以便在用户输入命令后正确显示行数和列数。
- en: It defines the `PS1` variable.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它定义了 `PS1` 变量。
- en: If a user enters a command that `bash` can’t find, it invokes the `command_not_found_handle`
    function if the `command-not-found` software package isn’t installed.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户输入 `bash` 找不到的命令，并且没有安装 `command-not-found` 软件包，它会调用 `command_not_found_handle`
    函数。
- en: At the top of the `bash.bashrc` file, you’ll see that it’s invoked for interactive
    shell sessions, and that it will also get invoked for login shell sessions if
    the `profile` file sources it. We’ve already seen that the `profile` file does
    source it, so we know that `bash.bashrc` does run for both login and non-login
    interactive sessions.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `bash.bashrc` 文件的顶部，你会看到它会在交互式 shell 会话中被调用，并且如果 `profile` 文件引用了它，它也会在登录 shell
    会话中被调用。我们已经看到 `profile` 文件确实引用了它，所以我们知道 `bash.bashrc` 会在登录和非登录的交互式会话中运行。
- en: When a configuration file reads in information from another configuration file,
    we say that the first file is **sourcing** the second file.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个配置文件从另一个配置文件中读取信息时，我们称第一个文件为**源文件**，第二个文件为被源文件引用的文件。
- en: Unlike on Fedora, the `/etc/profile.d/` directory doesn’t do much for us by
    default. The only thing you’ll see there is the `bash_completion.sh` script. As
    you’ll see in a moment, the aliases that are defined in the `/etc/profile.d/`
    directory on Fedora are defined in the users’ configuration files on Debian.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Fedora 不同，`/etc/profile.d/` 目录在 Debian 中默认没有什么作用。你在这里唯一能看到的就是 `bash_completion.sh`
    脚本。正如你稍后会看到的那样，Fedora 上在 `/etc/profile.d/` 目录中定义的别名，在 Debian 中会定义在用户的配置文件里。
- en: Users’ Configuration Files on Debian
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Debian 上的用户配置文件
- en: 'In each user’s home directory on a Debian system, we have these bash configuration
    files:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Debian 系统的每个用户主目录中，我们都有以下这些 bash 配置文件：
- en: '`.bash_logout`: This is the same as the `.bash_logout` file on Fedora, except
    that it contains a command that will clear the screen upon logout from a login
    session.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.bash_logout`：这与 Fedora 上的 `.bash_logout` 文件相同，不同之处在于它包含一个命令，该命令在注销登录会话时会清屏。'
- en: '`.profile`: This replaces the `.bash_profile` that’s on Fedora, and serves
    the same purpose.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.profile`：这个文件替代了 Fedora 上的 `.bash_profile`，并且具有相同的作用。'
- en: '`.bashrc`: It does the same things as the `.bashrc` file on Fedora, and more
    besides. It also defines some of the environmental variables that are defined
    globally on Fedora, and it also defines some of the aliases that are defined in
    the `/etc/profile.d/` directory on Fedora.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.bashrc`：它执行与 Fedora 上的 `.bashrc` 文件相同的操作，且更多。它还定义了一些在 Fedora 上全局定义的环境变量，并且定义了一些在
    Fedora 的 `/etc/profile.d/` 目录中定义的别名。'
- en: As I’ve already told you, I don’t expect you to read through any of these configuration
    files and completely understand what they’re doing. That’s why I’ve only shown
    you a few small snippets of these files instead of trying to explain each one
    in detail. After you’ve completely gone through this book, you’ll have gained
    a better understanding of them.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前所说，我并不指望你阅读这些配置文件并完全理解它们的作用。这就是为什么我只展示了一些小片段，而不是详细解释每个文件。在你完全阅读完这本书后，你将对它们有更深入的理解。
- en: I should also point out that every family of Linux distros has its `bash` configuration
    files set up differently. I can’t cover all of them, but you can probably figure
    out what’s going on with them from what I’ve told you here.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我还应该指出，每个 Linux 发行版家庭的 `bash` 配置文件设置方式都不同。我无法覆盖所有的配置，但你可以根据我在这里讲的内容，大致了解它们的作用。
- en: Setting the Default Editor on Debian
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Debian 上设置默认编辑器
- en: Oh, dear, I almost forgot to show you how to change the default editor for Debian,
    since we can’t do it by setting an environmental variable. So, let’s look at that
    now.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀，我差点忘了向你展示如何更改 Debian 的默认编辑器，因为我们不能通过设置环境变量来做到这一点。那么，接下来让我们来看一下。
- en: 'On a Debian system, the default editor is defined by a pair of symbolic links,
    as you see here:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Debian 系统上，默认编辑器是通过一对符号链接定义的，如你所见：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `editor` symbolic link in the `/usr/bin/` directory points to the `editor`
    symbolic link in the `/etc/alternatives/` directory, which in turn points to the
    `nano` executable that’s in the `/bin/` directory. This tells us that `nano` is
    set as the default editor. To change the default editor on a Debian machine, you’ll
    first need to ensure that the editor that you want to use is installed. Then,
    use the `update-alternatives` utility, like so:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`/usr/bin/` 目录中的 `editor` 符号链接指向 `/etc/alternatives/` 目录中的 `editor` 符号链接，而后者又指向位于
    `/bin/` 目录中的 `nano` 可执行文件。这告诉我们 `nano` 被设置为默认编辑器。要在 Debian 系统上更改默认编辑器，首先需要确保你想使用的编辑器已安装。然后，使用
    `update-alternatives` 工具，如下所示：'
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'I’ve chosen the number `2` option to set `vim` as the default editor. Let’s
    see how that changed the symbolic link in the `/etc/alternatives/` directory:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择了 `2` 选项来将 `vim` 设置为默认编辑器。让我们看看这如何改变 `/etc/alternatives/` 目录中的符号链接：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Very cool. This allows me to use my favorite editor.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 非常酷。这让我可以使用我最喜欢的编辑器。
- en: Okay, now that we’ve seen the configuration files, let’s look at another way
    to customize a shell session.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们已经查看了配置文件，接下来让我们看看另一种自定义 shell 会话的方法。
- en: Setting Shell Options from the Command-line
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从命令行设置 Shell 选项
- en: In addition to using environmental variables to modify your shell session, you
    can also use **shell options**. You would use the `set` command to set shell options
    from either the command-line or from within your shell scripts. You can also use
    it from the command-line to just view the options that are set.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用环境变量来修改 shell 会话外，你还可以使用 **shell 选项**。你可以使用 `set` 命令从命令行或 shell 脚本中设置 shell
    选项。你还可以仅从命令行查看已设置的选项。
- en: You can use either the Fedora or the Debian virtual machine for this section.
    With only one minor exception that concerns a man page, everything will be the
    same on both of them.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 Fedora 或 Debian 虚拟机进行本节操作。除了涉及手册页的小差异外，其他部分在这两者上都是一样的。
- en: 'To begin, let’s invoke the `set` command without any options or arguments,
    like so:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们调用不带任何选项或参数的 `set` 命令，如下所示：
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: What you’ll see is a complete list of environmental variables and **shell functions**
    that are active for this shell session. (I’ll tell you more about shell functions
    in *Chapter 10, Understanding Functions*.)
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到一个完整的环境变量和 **shell 函数** 列表，它们对于当前的 shell 会话是活动的。（我将在 *第 10 章，理解函数* 中详细讲解
    shell 函数。）
- en: 'Use the `set -o` command to just see the list of shell options that are active,
    like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `set -o` 命令仅查看活动的 shell 选项列表，像这样：
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: I won’t go over what each and every one of these options does, but I will tell
    you how to find out what they do. The only catch is that there’s a bit of a trick
    to it. That is, there’s no man page that’s specifically for the `set` command.
    When you do `man set` on your Fedora machine, you’ll actually pull up the `bash`
    man page. On Debian, you’ll have to do `man bash`, because `man set` won’t work
    at all. The reason for this is that the `set` command is built into the `bash`
    executable, and doesn’t have its own executable. Once you have the `bash` man
    page up, you’ll need to search through it to find the explanation of the `set`
    command and all of its options. For now, let’s look at a couple of the more useful
    options and how to set them.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会详细讲解这些选项的作用，但我会告诉你如何找出它们的作用。唯一的诀窍是，有一点小技巧。也就是说，并没有专门为 `set` 命令提供的手册页。当你在
    Fedora 系统上执行 `man set` 时，实际上会打开 `bash` 的手册页。在 Debian 系统上，你需要执行 `man bash`，因为 `man
    set` 根本无法使用。原因在于，`set` 命令是内建在 `bash` 可执行文件中的，并没有单独的可执行文件。一旦打开了 `bash` 的手册页，你需要在其中查找
    `set` 命令及其所有选项的说明。现在，我们来看几个更有用的选项以及如何设置它们。
- en: 'In *Chapter 4, Understanding Input/Output Redirection*, I told you how the
    `noclobber` option can help prevent you from accidentally overwriting an important
    file. By default, `noclobber` is off, as you see here:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 4 章，理解输入/输出重定向* 中，我告诉过你 `noclobber` 选项如何帮助防止你不小心覆盖重要的文件。默认情况下，`noclobber`
    是关闭的，如你所见：
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The way you turn options on and off is completely counterintuitive. You’ll
    use the `set -o` command to turn an option on and the `set +o` command to turn
    an option off, which is the exact opposite of what you’d think it would be. (I
    have no idea why someone decided to do things this way. But, whatever, right?)
    So, let’s say that we want to turn the `noclobber` option on. Here’s what that
    looks like:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 启用和禁用选项的方式完全违反直觉。你将使用 `set -o` 命令来启用选项，使用 `set +o` 命令来禁用选项，这正好与你想的相反。（我不知道为什么有人决定这样做。但不管了，对吧？）假设我们想要启用
    `noclobber` 选项。如下所示：
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, let’s turn it back off:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们把它关闭：
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'For some options, such as `noclobber`, you can use a shorthand notation. So,
    to minimize keystrokes while turning `noclobber` on or off just do this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些选项，例如 `noclobber`，你可以使用简写表示法。因此，为了减少输入，在开启或关闭 `noclobber` 时，只需这样操作：
- en: '[PRE22]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this example, the `-C` replaces `-o noclobber`, and `+C` replaces `+o noclobber`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`-C` 替代了 `-o noclobber`，`+C` 替代了 `+o noclobber`。
- en: 'Another option that you might find useful is the `allexport` option. To see
    how you might use it, let’s set a programming variable from the command-line,
    and then try to use it in a child shell. Here’s what that looks like:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个你可能会发现有用的选项是 `allexport` 选项。为了看看你如何使用它，让我们从命令行设置一个编程变量，然后尝试在子 shell 中使用它。如下所示：
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As you see, once I opened a child shell with the `bash` command, the value
    of `car` is no longer available to me. One way to fix that is to precede the variable
    definition with `export`, like so:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，一旦我通过 `bash` 命令打开子 shell，`car` 的值就不再对我可用了。解决这个问题的一种方法是，在变量定义前加上 `export`，如下所示：
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This time, the value of `car` is available to me in the child shell. The problem
    with this method is that I would have to remember to precede each variable definition
    I create with `export`. It would be easier just to set the `allexport` option
    so that every variable I create will be exported automatically. Here’s how that
    works:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，`car` 的值在子 shell 中对我可用。这个方法的问题是，我必须记得在创建每个变量定义时都要加上 `export`。最简单的方法是设置 `allexport`
    选项，这样我创建的每个变量都会自动导出。下面是实现的方式：
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This time, the `car` variable got exported automatically so that its value
    is available in the child shell. When you’re done with `allexport`, you can turn
    it off, like so:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，`car` 变量自动导出了，因此它的值在子 shell 中可用。当你完成 `allexport` 后，可以像这样关闭它：
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `-a` shorthand notation is also available for `allexport`, which looks
    like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`allexport` 也可以使用 `-a` 简写表示法，格式如下：'
- en: '[PRE27]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: And now, my shell option settings are back to their default values.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我的 shell 选项设置已恢复到默认值。
- en: Keep in mind that any options that you set will return to normal when you exit
    from the shell session.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，您设置的任何选项在退出 shell 会话时都会恢复到默认状态。
- en: Okay, that does it for shell options, at least for now. In *Chapter 21, Debugging
    Shell Scripts*, I’ll show you a couple of more cool tricks that you can do with
    them. With all this out of the way, let’s move on to the final section of this
    chapter.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，关于 shell 选项的内容就到此为止，至少暂时是这样。在 *第 21 章，调试 Shell 脚本* 中，我会展示一些你可以用它们做的更多酷炫技巧。既然这些内容已经讲完，我们来进入本章的最后部分。
- en: Understanding Aliases
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解别名
- en: If you ever watch any crime dramas on television, you might see some criminal
    who uses more than one name. Of course, only one of those names is the criminal’s
    real name. All of the other names are fake names, or aliases, that the criminal
    uses to prevent being found by the police. In the world of operating system shells,
    **aliases** are quite useful and have nothing to do with criminal activity. In
    fact, you’re already using them without realizing it.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看过任何电视犯罪剧，你可能会看到一些犯罪分子使用多个名字。当然，只有一个名字是这个犯罪分子的真实姓名。其他所有名字都是假名，或者叫做别名，犯罪分子用它们来避免被警察找到。在操作系统的
    shell 中，**别名**非常有用，且与犯罪活动毫无关系。事实上，你已经在不知不觉中使用它们了。
- en: Think of an alias as a command that you can use in place of another command.
    For example, let’s say that you’re one of those poor souls who’s stuck using Windows
    most of the time, and who only occasionally gets the chance to work with Linux.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 把别名当作一个可以替代另一个命令的命令。例如，假设你是那些大多数时间都被困在 Windows 系统里的可怜灵魂之一，偶尔才有机会使用 Linux。
- en: 'Now, let’s say that every time you get on a Linux machine, you instinctively
    always type in Windows commands, as you’re doing here:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 假设每次你登录到 Linux 机器时，你本能地总是输入 Windows 命令，就像你在这里做的那样：
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Yeah, that `cls` command that you always use on Windows doesn’t work so well
    on Linux, does it? There’s an easy fix to that, though. Just create an alias that
    points to the `clear` command, like so:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，你在 Windows 上总是使用的 `cls` 命令，在 Linux 上似乎不太好用，对吧？不过，有个简单的解决办法。只需创建一个指向 `clear`
    命令的别名，像这样：
- en: '[PRE29]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Once you do this, you’ll be able to clear the screen with either the `cls`
    command or the `clear` command. Note that in this case, I didn’t have to surround
    the alias definition with quotes because it doesn’t contain any blank spaces or
    special symbols. Creating an alias that has blank spaces or special characters
    in its definition would look something like this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你这么做了，你就能使用 `cls` 命令或 `clear` 命令清屏。请注意，在这种情况下，我不需要将别名定义用引号括起来，因为它不包含空格或特殊符号。如果创建的别名定义包含空格或特殊字符，格式会像这样：
- en: '![B21693_05_03](img/B21693_05_01.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![B21693_05_03](img/B21693_05_01.png)'
- en: 'Figure 5.1: Using my new lla alias on Fedora'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1：在 Fedora 上使用我的新 `lla` 别名
- en: Coolness, it works.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 很酷，效果不错。
- en: 'To see the list of all active aliases, just use the `alias` command without
    any options or arguments, like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看所有激活的别名列表，只需使用不带任何选项或参数的 `alias` 命令，像这样：
- en: '[PRE30]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As you see, they’re listed in alphabetical order. On Fedora, several aliases
    have already been globally-defined in a set of scripts in the `/etc/profile.d/`
    directory. For an example, let’s look in the `/etc/profile.d/colorls.sh` script.
    Most of the script is rather complex, consisting of commands that define the color
    scheme that will be used with the `ls` aliases. At the bottom, you’ll find the
    actual aliases, which look like this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，它们按字母顺序排列。在 Fedora 上，多个别名已经在 `/etc/profile.d/` 目录下的一组脚本中全局定义。举个例子，我们来看看
    `/etc/profile.d/colorls.sh` 脚本。大部分脚本比较复杂，由定义与 `ls` 别名配合使用的颜色方案的命令组成。在脚本的底部，你会找到实际的别名，它们看起来像这样：
- en: '[PRE31]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here, we see that:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到：
- en: The `ll` alias replaces the `ls -l --color=auto` command
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ll` 别名替换了 `ls -l --color=auto` 命令'
- en: The `l.` alias replaces the `ls -d .* --color=auto` command
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`l.` 别名替换了 `ls -d .* --color=auto` 命令'
- en: The `ls` alias replaces the `ls --color=auto` command.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ls` 别名替换了 `ls --color=auto` 命令。'
- en: 'To see how these aliases work, create a few files and directories in the home
    directory of your Fedora virtual machine, like this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看这些别名是如何工作的，可以在 Fedora 虚拟机的主目录中创建一些文件和目录，像这样：
- en: '[PRE32]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'When you do a plain `ls` command, you’ll see that the plain text file shows
    up in either black or white letters, depending upon whether you’re using a black
    or a white background for your terminal. The directory shows up in blue letters,
    the graphic file shows up in magenta letters, and the executable script shows
    up in green letters. The `ll` alias performs the same function as the `ls -l`
    command, again with color coding, as you see here:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行普通的 `ls` 命令时，你会看到普通文本文件以黑色或白色字母显示，具体取决于你终端的背景颜色是黑色还是白色。目录会以蓝色字母显示，图形文件以品红色字母显示，可执行脚本以绿色字母显示。`ll`
    别名执行的功能与 `ls -l` 命令相同，同样带有颜色编码，正如你所看到的：
- en: '![](img/B21693_05_02.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21693_05_02.png)'
- en: 'Figure 5.2: Using the ll alias on Fedora'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2：在 Fedora 上使用 `ll` 别名
- en: 'Finally, the `l.` alias shows you the files and directories whose names begin
    with a dot, again with color coding. It looks something like this:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`l.` 别名展示了以点号开头的文件和目录，同样带有颜色编码。它看起来像这样：
- en: '![B21693_05_02](img/B21693_05_03.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![B21693_05_02](img/B21693_05_03.png)'
- en: 'Figure 5.3: Using the l. alias on Fedora'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3：在 Fedora 上使用 `l.` 别名
- en: The Debian developers have done things differently. Instead of defining aliases
    at the global level, the Debian folk just define them at the user level. You’ll
    find the list of defined aliases in the `.bashrc` file that’s in every user’s
    home directory. Only one is enabled by default, but you can easily enable any
    or all of the others by removing the `#` symbol from in front of them.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Debian 开发者的做法与众不同。与其在全局层面定义别名，Debian 的开发者们选择在用户层面定义它们。你可以在每个用户的主目录下找到定义的别名列表，这些别名保存在
    `.bashrc` 文件中。默认情况下，只有一个别名被启用，但你可以通过去掉前面的 `#` 符号来轻松启用任何或所有其他别名。
- en: 'On the Fedora machine, there’s a `which` alias that replaces the `which` command.
    This alias shows you not only where the executable file for a command is, it also
    shows you if there’s an alias for that command. Here’s what that looks like:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Fedora 机器上，有一个 `which` 别名替换了 `which` 命令。这个别名不仅会告诉你某个命令的可执行文件在哪，它还会告诉你该命令是否有别名。下面是它的效果：
- en: '[PRE33]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'There’s no `which` alias on Debian, so you can’t use `which` to see if there
    are any aliases for other commands. Here’s what the Debian output looks like:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Debian 中没有 `which` 别名，因此你不能使用 `which` 查看是否存在其他命令的别名。以下是 Debian 输出的样子：
- en: '[PRE34]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'It’s important to note that if you have an alias that has the same name as
    the actual underlying command, the alias always takes precedence. There are two
    ways to override that so that you can directly invoke the executable file for
    a command. The first way is to just specify the entire path to that executable,
    like this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，如果你有一个别名与实际底层命令同名，则别名始终优先。你可以通过两种方式来覆盖这个问题，以便直接调用命令的可执行文件。第一种方式是直接指定可执行文件的完整路径，像这样：
- en: '[PRE35]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The second way is to precede the command with a backslash, like this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方式是，在命令前加上反斜杠，像这样：
- en: '[PRE36]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You’ll now see the `ls` output without any color-coding. Let’s try it again
    with `which`, like this:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在会看到没有颜色编码的 `ls` 输出。让我们再试一次，用 `which`，像这样：
- en: '[PRE37]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This time, `which` only shows the location of the executable file, and ignores
    the alias. If you need to disable an alias, use the `unalias` command, like this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，`which` 只显示可执行文件的位置，忽略了别名。如果需要禁用一个别名，可以使用 `unalias` 命令，像这样：
- en: '[PRE38]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this case, the alias is only disabled temporarily, until you close the shell
    session. If you use `unalias` for any aliases that you’ve created from the command-line,
    that alias will be disabled permanently.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，别名只会暂时禁用，直到你关闭 shell 会话。如果你使用 `unalias` 禁用任何从命令行创建的别名，该别名将永久禁用。
- en: The last thing I’ll say about aliases is that any alias you set at the command-line
    will disappear when you exit the shell session. To make them permanent on either
    Debian or Fedora, just place them in the `.bashrc` file that’s in your home directory.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 关于别名的最后一件事是，你在命令行设置的任何别名会在退出 shell 会话时消失。为了在 Debian 或 Fedora 上使别名永久生效，只需将它们放入你家目录下的
    `.bashrc` 文件中。
- en: All right, that pretty much wraps things up for this chapter. Let’s summarize
    and move on.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这几乎是本章的总结了。让我们总结一下，然后继续前进。
- en: Summary
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we’ve completed laying the groundwork for the chapters to come.
    We explained the different types of shell sessions, and then looked at the configuration
    files that affect the shell environment at both the global and user levels. Then,
    we looked at how to set shell options and how to create and use aliases.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经为接下来的章节打下了基础。我们解释了不同类型的 shell 会话，然后查看了影响 shell 环境的全局和用户级配置文件。接着，我们介绍了如何设置
    shell 选项以及如何创建和使用别名。
- en: Now that you know the basics of how a shell operates, you’re ready to tackle
    some meatier issues, like how to use text-stream filters. We’ll start with that
    in the next chapter. I’ll see you there.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了 shell 操作的基本原理，接下来你可以开始处理更复杂的问题，比如如何使用文本流过滤器。我们将在下一章开始讨论。下次见。
- en: Questions
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which two of the following commands turn on the `noclobber` option? (Choose
    two.)
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪两个命令会开启 `noclobber` 选项？（选择两个。）
- en: '`set +o noclobber`'
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`set +o noclobber`'
- en: '`set -o noclobber`'
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`set -o noclobber`'
- en: '`set -C`'
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`set -C`'
- en: '`set +C`'
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`set +C`'
- en: On a Fedora machine, which of the following user-level configuration files will
    only affect a login shell session?
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Fedora 机器上，以下哪一个用户级配置文件只会影响登录 shell 会话？
- en: '`profile`'
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`profile`'
- en: '`.bash_profile`'
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`.bash_profile`'
- en: '`.bash.bashrc`'
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`.bash.bashrc`'
- en: You’ve just opened a terminal emulator on your desktop Linux machine. What type
    of shell session are you using? (Choose two.)
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你刚在桌面 Linux 机器上打开了一个终端模拟器。你正在使用哪种类型的 shell 会话？（选择两个。）
- en: non-interactive
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 非交互式
- en: login
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录
- en: interactive
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 交互式
- en: non-login
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 非登录
- en: Further Reading
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入阅读
- en: 'How to List Environmental Variables on Linux: [https://www.howtogeek.com/842780/linux-list-environment-variables/](https://www.howtogeek.com/842780/linux-list-environment-variables/)'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何列出 Linux 中的环境变量：[https://www.howtogeek.com/842780/linux-list-environment-variables/](https://www.howtogeek.com/842780/linux-list-environment-variables/)
- en: 'Types of Linux Shell Sessions: [https://www.automationdojos.com/types-of-linux-shell-sessions/](https://www.automationdojos.com/types-of-linux-shell-sessions/)'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux Shell 会话的类型：[https://www.automationdojos.com/types-of-linux-shell-sessions/](https://www.automationdojos.com/types-of-linux-shell-sessions/)
- en: 'Linux set Command & How to Use it (9 examples): [https://phoenixnap.com/kb/linux-set](https://phoenixnap.com/kb/linux-set)'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux set 命令及其使用方法（9 个示例）：[https://phoenixnap.com/kb/linux-set](https://phoenixnap.com/kb/linux-set)
- en: Answers
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: b and c
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b 和 c
- en: c
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: c
- en: c and d
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: c 和 d
- en: Join our community on Discord!
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区！
- en: Read this book alongside other users, Linux experts, and the author himself.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 和其他用户、Linux 专家以及作者本人一起阅读本书。
- en: Ask questions, provide solutions to other readers, chat with the author via
    Ask Me Anything sessions, and much more. Scan the QR code or visit the link to
    join the community.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 提出问题，为其他读者提供解决方案，通过“问我任何问题”环节与作者交流，等等。扫描二维码或访问链接加入社区。
- en: '[https://packt.link/SecNet](https://packt.link/SecNet)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/SecNet](https://packt.link/SecNet)'
- en: '![](img/QR_Code10596186092701843.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code10596186092701843.png)'
