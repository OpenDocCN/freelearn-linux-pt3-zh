- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Automating Scripts with here Documents and expect
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 here Documents 和 expect 自动化脚本
- en: So, exactly where is *here*? Well, I suppose that it’s just where I happen to
    be, or from your own perspective, wherever you happen to be. The bigger mystery,
    which nobody seems to have figured out, is why a very useful shell scripting construct
    has such a strange name.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，究竟*here*在哪里呢？嗯，我想它就只是我所在的地方，或者从你的角度来看，任何你所在的地方。更大的谜团是，似乎没有人弄明白，为什么这个非常有用的
    shell 脚本结构会有如此奇怪的名字。
- en: A **here document**, which can also be called a **here script** or a **heredoc**,
    isn’t really a document, and it has nothing to do with anyone’s current location.
    But, as you shall soon see, it’s extremely useful in a number of different ways,
    such as in automating your scripts.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**here document**，也可以称为**here script**或**heredoc**，其实并不是一个文档，也与任何人的当前位置无关。但是，正如你很快会看到的，它在很多不同的方面非常有用，比如自动化脚本。'
- en: The second automation method I’ll show you is **expect**, which is a scripting
    environment with its own scripting language.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我将展示的第二种自动化方法是**expect**，它是一个具有自己脚本语言的脚本环境。
- en: 'Topics in this chapter include:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主题包括：
- en: Using here Documents
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 here Documents
- en: Automating responses with expect
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 expect 自动化响应
- en: All right, let’s get ready to automate!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，准备好进行自动化吧！
- en: Technical Requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can use any Linux virtual machine for this chapter. Also, as always, you
    can grab the script and text files from GitHub by doing:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用任何 Linux 虚拟机来完成本章的内容。此外，像往常一样，你可以通过以下方式从 GitHub 获取脚本和文本文件：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Using here Documents
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 here Documents
- en: A *here document* is a block of code that you place into a script to perform
    a certain task. Yeah, I know, I said the same thing about functions. But, *here
    documents* are completely different. They’ve been around since the early days
    of Unix, and can be used in various different programming languages.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*Here document* 是你放入脚本中的一块代码，用于执行特定任务。是的，我知道，我之前说过函数也是这么说的。但*here documents*完全不同。它们自
    Unix 早期就存在，并且可以在各种不同的编程语言中使用。'
- en: '**Formatting note**: The accepted Unix and Linux convention for writing out
    the term “here document” is to do so in all lower-case letters. That can get a
    bit confusing, though. So, to eliminate the confusion, I’ll just italicize the
    term throughout the rest of this book, like this: *here document*.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**格式说明**：Unix 和 Linux 中公认的写法是将“here document”一词全部用小写字母书写。不过，这可能有点让人困惑。所以，为了消除混淆，我将在本书的其余部分将该术语斜体化，像这样：*here
    document*。'
- en: '*Here documents* work by providing another way to redirect input into a particular
    command. The code that performs this redirection is enclosed by a pair of **limit
    strings**, which look something like this:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*Here documents* 的工作原理是通过提供另一种方式将输入重定向到特定命令。执行此重定向的代码被一对**限界字符串**括起来，通常长这样：'
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `<<` sequence is a special type of redirector. It takes input from whatever
    code or text is between the two limit strings, which in this case are called `_EOF_`.
    It’s traditional to use either `_EOF_` or `EOF` as the limit strings, but you
    can actually use pretty much any text string you want, as long as they’re the
    same at both the beginning and end of the code block, and also as long as they
    don’t conflict with the names of any variables or functions. In fact, it can often
    help make the script more readable if you give descriptive names to your limit
    strings. (Some tutorials that you’ll find use the term **token** instead of **limit
    string**, but it’s still the same thing.)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`<<` 序列是一种特殊类型的重定向符号。它从两个限界字符串之间的代码或文本中获取输入，这些字符串在本例中称为 `_EOF_`。传统上，通常使用 `_EOF_`
    或 `EOF` 作为限界字符串，但实际上你可以使用几乎任何文本字符串，只要它们在代码块的开始和结束位置相同，并且不会与任何变量或函数的名称冲突。事实上，如果你为限界字符串取个描述性的名字，通常有助于提高脚本的可读性。（一些教程中使用**token**而非**limit
    string**，但其实它们是一样的。）'
- en: 'Instead of using `<<` as the redirector, you can also use `<<-`, like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用`<<`作为重定向符号外，你还可以使用`<<-`，像这样：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Adding the dash prevents any leading tab characters from indenting any displayed
    text. (Leading spaces will still indent the text, but tabs won’t. I’ll explain
    more about this in just a bit.) This makes it so that you can indent the code
    in the script to make it more readable, without causing the output to be indented.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 添加破折号可以防止任何前导制表符字符缩进任何显示的文本。（前导空格仍然会缩进文本，但制表符则不会。我稍后会对此进行更详细的解释。）这样，你就可以缩进脚本中的代码，使其更具可读性，而不会导致输出内容被缩进。
- en: 'Here are some of the things that you can do with *here documents*:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你可以使用*here documents*做的一些事情：
- en: Display multi-line comments from a shell script.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 shell 脚本中显示多行注释。
- en: Create a simple look-up directory.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个简单的查找目录。
- en: Automate the creation of documents, such as web content files or reports.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化文档的创建，比如网页内容文件或报告。
- en: Your *here documents* can work with either static or dynamic data. Let’s start
    with the static ones, since they’re the simplest.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你的*here 文档*可以处理静态数据或动态数据。让我们从静态数据开始，因为它们是最简单的。
- en: Creating here Documents with Static Data
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用静态数据创建 Here 文档
- en: 'There may be times when you’ll want your scripts to display some sort of a
    multi-line message when users invoke them. This message could be a help message,
    a copyright message, or a licensing message. You could do that with a series of
    `echo` commands, which would look something like this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能希望当用户调用脚本时，脚本显示一种多行消息。这条消息可以是帮助信息、版权信息或许可信息。你可以通过一系列`echo`命令来实现，这看起来像这样：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This works, but if you need to display a long message, typing in many individual
    echo commands can get a bit tedious. Using a *here document* to display the message
    can make things much easier. Here’s how that looks in the `here-doc1.sh` script:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这样有效，但如果你需要显示长消息，输入许多单独的 echo 命令会变得有些繁琐。使用*here 文档*来显示消息会让事情变得更加简单。以下是`here-doc1.sh`脚本中显示这种效果的方式：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this case, I’m using `licensing` as the limit strings, instead of the more
    traditional `_EOF_`. This way, I can tell at a glance what the *here document*
    is doing for me. Here’s what happens when I run the script:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我使用`licensing`作为限制字符串，而不是传统的`_EOF_`。这样，我可以一眼看出*here 文档*在做什么。以下是我运行脚本时发生的情况：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you see, the text that’s between the two `licensing` strings gets redirected
    into the `cat` command, which then displays the text on screen.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，位于两个`licensing`字符串之间的文本会被重定向到`cat`命令，后者会将文本显示在屏幕上。
- en: 'There may be times when you’ll need to choose a license for any free-as-in-freedom
    software or shell scripts that you need to create. There are many free software
    licenses from which to choose, and you’ll need to choose the one that best fits
    your needs. Basically though, you can classify the various licenses as either
    permissive or non-permissive. Permissive licenses, such as the MIT and BSD licenses,
    allow licensed code to be embedded into proprietary software, and don’t require
    that the source code for the finished product be provided to the customer. (This
    is why Apple can include FreeBSD code in its proprietary OS X and macOS operating
    systems.) Non-permissive licenses, such as the various GNU Public Licenses, prohibit
    the use of licensed code in proprietary software, and require that software vendors
    make the source code of the finished product available to customers. Anyway, you
    can read all about the various free software licenses here: [https://opensource.org/licenses/](https://opensource.org/licenses/)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你需要为任何自由软件或 shell 脚本选择许可证。自由软件许可有很多种，你需要选择最适合你需求的一个。基本上，你可以将各种许可证分为宽松许可和非宽松许可。宽松许可，如
    MIT 和 BSD 许可证，允许将被许可的代码嵌入到专有软件中，并且不要求将最终产品的源代码提供给客户。（这就是为什么苹果可以将 FreeBSD 代码包含在其专有的
    OS X 和 macOS 操作系统中的原因。）非宽松许可，如各种 GNU 通用公共许可证，禁止将被许可的代码用于专有软件，并且要求软件供应商将最终产品的源代码提供给客户。总之，你可以在这里阅读有关各种自由软件许可的详细信息：[https://opensource.org/licenses/](https://opensource.org/licenses/)
- en: By the way, MIT stands for Massachusetts Institute of Technology, BSD stands
    for Berkeley Software Distribution, and GNU is a recursive acronym that stands
    for GNU is not Unix.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，MIT 代表麻省理工学院，BSD 代表伯克利软件分发，GNU 是一个递归首字母缩略词，代表“GNU 不是 Unix”。
- en: 'There may be times when you’ll want to indent the code in your *here documents*
    to make the script more readable. That’s not the case with this `here-doc1.sh`
    script, but let’s pretend that it is. Let’s create the `here-doc1-tabs.sh` script,
    and make it look like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能希望将代码缩进到你的*here 文档*中，以使脚本更具可读性。`here-doc1.sh`脚本并不是这样做的，但我们假设它是这样。我们来创建`here-doc1-tabs.sh`脚本，看看它是怎么做的：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This is the same as `here-doc1.sh`, except that I placed two tabs in front
    of the “This software. . .” line, one tab in front of the “Anyone who. . .” and
    “. . .of this license” lines, and three blank spaces in front of the “GNU GPL
    3\. . .” line. Watch what happens when I run this new script:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`here-doc1.sh`相同，只不过我在“这款软件...”行前面放了两个制表符，在“任何人...”和“...此许可证...”行前面放了一个制表符，在“GNU
    GPL 3...”行前面放了三个空格。看看当我运行这个新脚本时会发生什么：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, let’s say that we want to leave the tabs and the blank space in the script,
    but we don’t want the tabs to show up in the output. All we have need to do is
    to change the `<<` to `<<-`, as you see here in the `here-doc1-tabs-dash.sh` script:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想保留脚本中的制表符和空格，但又不希望制表符出现在输出中。我们需要做的就是将`<<`改为`<<-`，正如你在`here-doc1-tabs-dash.sh`脚本中看到的那样：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, watch what happens when I run it:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看看我运行它时发生了什么：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This time, all of the lines that begin with tabs in the script now output text
    that is flush with the left margin. However, the line that begins with three blank
    spaces outputs text with three blank spaces.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，脚本中所有以制表符开头的行现在都会输出与左边缘对齐的文本。然而，以三个空格开头的那一行则输出带有三个空格的文本。
- en: As I mentioned in the opening paragraph of this section, using `<<-` instead
    of `<<` prevents any leading tabs in your *here document* from showing up in the
    script’s output. But, it allows any leading blank spaces to show up.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在本节开头段落中提到的，使用`<<-`代替`<<`可以防止*here文档*中的前导制表符出现在脚本的输出中。但它允许任何前导空格显示出来。
- en: 'It’s important to remember that you can’t have any blank spaces in front of
    the closing limit string. If I were to insert a blank space in front of the closing
    `licensing` string in the `here-doc1.sh` script, I would get an error message
    that looks something like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，在结束限制字符串前不能有任何空格。如果我在`here-doc1.sh`脚本中的结束`licensing`字符串前插入空格，我会得到类似如下的错误信息：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Of course, this isn’t what you want.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这不是你想要的。
- en: This `here-doc1.sh` script isn’t very useful as-is, because the only thing it
    does is display a message. So normally, you’d place the rest of your code after
    the *here document*. One cool trick you can do is to place a `sleep` command and
    a `clear` command immediately after the *here document*, so that the opening message
    will display for a specified number of seconds before the main part of the script
    begins to execute.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`here-doc1.sh`脚本本身不是很有用，因为它唯一的作用就是显示一条信息。所以通常，你会将其余的代码放在*here文档*之后。你可以做一个很酷的技巧，就是在*here文档*后面立即放置一个`sleep`命令和一个`clear`命令，这样开头的消息将在主脚本开始执行之前显示指定的秒数。
- en: Also, you’re not limited to using this type of *here document* at the beginning
    of the script. You can place one anywhere in the script where you might need to
    impart some sort of information to a user.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你并不局限于在脚本开头使用这种*here文档*。你可以将它放在脚本的任何地方，只要你需要向用户传达某些信息。
- en: 'Next, let’s create a simple look-up directory with a list of phone numbers.
    Here’s the `here-doc2.sh` script that does that:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个简单的查找目录，列出一些电话号码。这里是实现这一功能的`here-doc2.sh`脚本：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In this script, I’m passing a name as a positional parameter to the `grep`
    command. The phone directory entries are between the two `directory` limit strings.
    Note that in this script, I didn’t place a blank space between the `<<` and the
    first limit string, as I did in the previous example. This just shows you that
    the blank space is optional, and that either way works. Anyway, here’s what happens
    when I look up Lionel’s phone number:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中，我将一个名称作为位置参数传递给`grep`命令。电话目录条目位于两个`directory`限制字符串之间。请注意，在这个脚本中，我没有像上一个例子那样在`<<`和第一个限制字符串之间放置空格。这只是告诉你，空格是可选的，哪种方式都可以。无论如何，以下是我查找莱昂内尔电话号码时发生的情况：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If your *here document* includes any metacharacters that cause the shell to
    take some sort of action, you’ll need to escape them with a backslash, as you
    see here in the `here-doc3.sh` script:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的*here文档*中包含任何元字符，这些字符会导致Shell采取某种动作，你需要用反斜杠将它们转义，正如你在`here-doc3.sh`脚本中看到的那样：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Surrounding strings that contain special characters with quotes won’t work,
    because *here documents* treat all quote symbols as literal characters.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 用引号包围包含特殊字符的字符串是行不通的，因为*here文档*会将所有引号符号视为字面字符。
- en: 'This method of dealing with special characters works, but there’s an easier
    way. Just place a backslash in front of the limit string, like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这种处理特殊字符的方法是可行的，但有更简单的方法。只需在限制字符串前加一个反斜杠，像这样：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can also surround the limit string with a pair of single quotes, like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以用一对单引号将限制字符串包围起来，像这样：
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Although these latter two methods work well and are easier than having to escape
    every special character individually, they can mess you up if you need to use
    a `$` to obtain the value of a variable. That’s because everything will get treated
    as a literal string, even if you don’t want that. To see how that works, let’s
    look at the `here-doc3-wrong.sh` script:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这两种方法都很好用，而且比需要逐个转义每个特殊字符要容易，但如果你需要使用`$`来获取变量的值，它们可能会弄乱你的代码。这是因为即使你不希望这样，所有内容都会被当作字面字符串处理。为了看看这是如何工作的，让我们看一下`here-doc3-wrong.sh`脚本：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You see that I’ve placed a backslash in front of the opening `donations` limit
    string in order to escape all of the `$` metacharacters. I’ve also placed a `$1`
    on a line by itself, just before the closing `donations` limit string. What I
    want to happen is for the value of the `$1` positional parameter to print out
    at the end of the output. But, watch what happens when I run this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到我在开头的`donations`限制字符串前面放了一个反斜杠，用来转义所有的`$`元字符。我还将`$1`单独放在一行，在关闭的`donations`限制字符串之前。我想要的效果是将`$1`位置参数的值打印到输出的末尾。但是，当我运行它时，看看会发生什么：
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, let’s remove the backslash from in front of the opening limit string,
    and escape all of the `$` metacharacters individually, except for the one that’s
    in the positional parameter. This script should now look like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们去掉开头限制字符串前面的反斜杠，并且分别转义所有的`$`元字符，除了位置参数中的那个。这段脚本现在应该如下所示：
- en: '[PRE18]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When I run the script now, the value of the `$1` at the bottom should print
    out, like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当我现在运行脚本时，底部的`$1`的值应该会打印出来，像这样：
- en: '[PRE19]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The lesson here is that even though some of our programming shortcuts can be
    very handy, it might not always be appropriate to use them.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的教训是，尽管我们的某些编程快捷方式非常有用，但它们并不总是适合使用。
- en: That pretty much covers the static angle. Now, let’s get dynamic.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本涵盖了静态部分。现在，让我们来看动态部分。
- en: Creating here documents with Dynamic Data
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用动态数据创建here文档
- en: 'In addition to including normal data in *here documents*, you can also include
    the programming constructs and commands that you’d use normally. Then, just redirect
    the output into a dynamically-generated document. Here’s the `here-doc4.sh` script,
    which shows a simple example of redirecting output into a `.html` file:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在*here文档*中包含正常数据外，你还可以包括你通常会使用的编程结构和命令。然后，只需将输出重定向到动态生成的文档中。以下是`here-doc4.sh`脚本，它展示了将输出重定向到`.html`文件的一个简单示例：
- en: '[PRE20]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To prove that it works, just open the resultant file in a web browser. The
    web page should look something like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明它有效，只需在网页浏览器中打开结果文件。网页应该看起来像这样：
- en: '![B21693_12_1](img/B21693_12_01.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![B21693_12_1](img/B21693_12_01.png)'
- en: 'Figure 12.1: The web page that was generated by the here-doc4.sh script'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1：由`here-doc4.sh`脚本生成的网页
- en: Of course, I’m keeping things simple here by creating a very simple document
    with only a few simple HTML tags to format it. But, if you’re clever with HTML
    coding, you can make the document as fancy as you want.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我在这里保持简单，创建了一个非常简单的文档，只有一些简单的HTML标签来格式化它。但是，如果你擅长HTML编码，你可以将文档做得非常精美。
- en: In case you’re wondering, HTML stands for **Hypertext Markup Language**. Long
    ago, when the public Internet was brand new and I still had a full head of hair,
    the only way to create websites was to hand-code them in HTML. (Ah, yes. Those
    were the days.)
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在想，HTML代表**超文本标记语言**。很久以前，当公共互联网刚刚问世，我还留着满头的头发时，创建网站的唯一方法就是用HTML手工编写代码。（啊，是的，那是个美好的时代。）
- en: 'You can also create documents in other formats. For example, if you want to
    create a `.pdf` document, there are a couple of ways to do that. The simplest
    way is to install the appropriate `pandoc` packages from either your Linux or
    FreeBSD distro’s repository. (It’s also available for macOS, but you’ll need to
    download the installer package from the Pandoc website.) The slight catch with
    this is that you’ll also need to install a **PDF engine**, and some PDF engines
    aren’t available for all distros. Your best bet is to stick with the **pdflatex
    engine**, because it’s available for pretty much all Linux distros, as well as
    for FreeBSD and macOS. (Sadly, there are no `pandoc` or PDF engine packages available
    for OpenIndiana.) On your Fedora virtual machine, install `pandoc` and the pdflatex
    engine with this simple command:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以创建其他格式的文档。例如，如果你想创建一个`.pdf`文档，有几种方法可以做到。最简单的方法是从你的Linux或FreeBSD发行版的仓库中安装适当的`pandoc`包。（它也可用于macOS，但你需要从Pandoc网站下载安装程序包。）这里的一个小问题是，你还需要安装一个**PDF引擎**，而且并非所有发行版都有PDF引擎可用。你最好的选择是坚持使用**pdflatex引擎**，因为它几乎可以在所有Linux发行版上使用，同时也支持FreeBSD和macOS。（遗憾的是，没有适用于OpenIndiana的`pandoc`或PDF引擎包。）在你的Fedora虚拟机上，可以使用这个简单的命令来安装`pandoc`和pdflatex引擎：
- en: '[PRE21]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This same command will also install `pandoc` on Red Hat Enterprise Linux-type
    distros, but you’ll first need to install the EPEL repository. On AlmaLinux and
    Rocky Linux, install EPEL like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令也可以在Red Hat Enterprise Linux类发行版上安装`pandoc`，但你首先需要安装EPEL仓库。在AlmaLinux和Rocky
    Linux上，像这样安装EPEL：
- en: '[PRE22]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'On Debian or Ubuntu-type distros, just do:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在Debian或Ubuntu类的发行版上，只需执行：
- en: '[PRE23]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'On FreeBSD do:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在FreeBSD上执行：
- en: '[PRE24]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Note that for FreeBSD, I’m assuming that you’ve already installed the `sudo`
    package, added yourself to the `wheel` group, and have configured `visudo`. If
    you haven’t, you can just log in as the root user for now, in order to perform
    the installation. Also, if you haven’t done so already, be sure to install the
    `bash` package, and create a symbolic link to `bash` in the `/bin/` directory,
    like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于FreeBSD，我假设你已经安装了`sudo`包，将自己添加到`wheel`组，并配置了`visudo`。如果没有，你可以现在以root用户登录，以便进行安装。此外，如果你还没有这样做，务必安装`bash`包，并在`/bin/`目录下创建一个指向`bash`的符号链接，方法如下：
- en: '[PRE25]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `here-doc` scripts that I’ve shown you so far will work on the `/bin/sh`
    shell that FreeBSD uses by default, but I’ll soon be showing you a script that
    will require actual `bash`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我向你展示的`here-doc`脚本将在FreeBSD默认使用的`/bin/sh` shell上工作，但我很快会向你展示一个需要实际`bash`的脚本。
- en: For macOS, you’ll need to download the Pandoc and MacTeX installers from their
    respective websites.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对于macOS，你需要从各自的网站下载Pandoc和MacTeX安装程序。
- en: If you’re running OpenIndiana, you’re out of luck, because there are no `pandoc`
    or pdf engine packages available for it. That’s okay though, because as you’ll
    see in a few moments, I’ve made the upcoming demo script so that it will still
    run on it.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在使用OpenIndiana，很遗憾，你会失望的，因为没有可用于该系统的`pandoc`或pdf引擎包。不过没关系，正如你将在稍后看到的，我已经制作了即将展示的演示脚本，使它依然可以在OpenIndiana上运行。
- en: In any case, the installation of `pandoc` and the pdf engine packages takes
    a while, because a lot of dependencies also need to be installed. So, you might
    as well go grab your favorite beverage while you’re waiting.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，安装`pandoc`和pdf引擎包需要一些时间，因为许多依赖项也需要安装。因此，在等待的时候，你不妨去拿一杯你最喜欢的饮品。
- en: 'Once you have `pandoc` installed, on everything except for OpenIndiana, add
    the following lines to the end of your `here-doc4.sh` script:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了`pandoc`，在除了OpenIndiana之外的所有系统上，将以下几行添加到你的`here-doc4.sh`脚本的末尾：
- en: '[PRE26]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now when you run the `here-doc4.sh` script, you’ll end up with the `sysinfo.pdf`
    file as the result. You can either open the file in your favorite document viewer,
    or add a line of code to have the file automatically print out. Assuming that
    you’ve installed the appropriate printer drivers and have set a default printer,
    the command that you would add to the end of the script to do this would be:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你运行`here-doc4.sh`脚本时，最终会生成`sysinfo.pdf`文件作为结果。你可以在你喜欢的文档查看器中打开该文件，或者添加一行代码让文件自动打印出来。假设你已经安装了适当的打印机驱动程序并设置了默认打印机，你可以在脚本末尾添加以下命令来实现这一功能：
- en: '[PRE27]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Tip
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: I showed you how to set up a default printer and use `lpr` in *Chapter 7, Text
    Stream Filters - Part 2*.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经在*第7章，文本流过滤器 - 第2部分*中向你展示了如何设置默认打印机并使用`lpr`。
- en: The reason I’m using HTML in this *here document* example is simply because
    HTML is so easy. If you’re clever with any other document markup language, such
    as Postscript, Markdown, Troff or LaTeX, feel free to use one of them in place
    of HTML. In all cases, you can convert the resultant file to a `.pdf` file, if
    that’s what you need. On the other hand, if you don’t need anything this fancy,
    you could omit all markup language tags, and just save your output to a plain-text
    file. Then, use the appropriate text stream filters, such as `fmt` and `pr`, to
    prepare the file for print out. The possibilities are only limited by your own
    imagination.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我之所以在这个*这里文档*示例中使用HTML，仅仅是因为HTML非常简单。如果你对其他文档标记语言如Postscript、Markdown、Troff或LaTeX非常熟悉，可以随意用它们替代HTML。在所有情况下，如果你需要，你都可以将生成的文件转换为`.pdf`文件。另一方面，如果你不需要那么复杂的格式，可以省略所有标记语言标签，直接将输出保存为纯文本文件。然后，使用适当的文本流过滤器，如`fmt`和`pr`，将文件准备好用于打印。可能性仅受你自己想象力的限制。
- en: Now that we’ve covered the basics, let’s look at something that’s a bit more
    complex.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了基础内容，让我们来看一些稍微复杂一点的内容。
- en: Using Functions in here Documents
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在此文档中使用函数
- en: For this section, I created the `sysinfo.lib` file, which you can download from
    Github. Then, copy it to your `/usr/local/lib/` directory. Finally, download the
    `system-info.sh` script from Github. I can’t show you either the library file
    or the shell script in their entirety here, but I can show you some snippets and
    provide some explanation.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这一部分，我创建了`sysinfo.lib`文件，你可以从Github下载。然后，将它复制到你的`/usr/local/lib/`目录中。最后，从Github下载`system-info.sh`脚本。我不能在这里展示库文件或shell脚本的完整内容，但我可以给你展示一些代码片段并提供一些解释。
- en: In this demo, you’ll see what I had to do to make this script work on Linux,
    FreeBSD, macOS, and OpenIndiana.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个演示中，你将看到我为使这个脚本能够在Linux、FreeBSD、macOS和OpenIndiana上工作所做的事情。
- en: 'The first two functions in the library, the `show_uptime()` and `drive_space()`
    functions, are quite easy. Each of them executes just one simple system information
    command and then adds some HTML tags, as you see here:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 库中的前两个函数，`show_uptime()`和`drive_space()`，非常简单。每个函数仅执行一个简单的系统信息命令，然后添加一些HTML标签，正如你在这里看到的：
- en: '[PRE28]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: I used `df -P` in the `drive_space()` function so that the output would format
    properly on macOS. (The `-P` isn’t needed for Linux, FreeBSD, or OpenIndiana,
    but it doesn’t hurt anything to have it.)
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我在`drive_space()`函数中使用了`df -P`，以便在macOS上正确格式化输出。（`-P`在Linux、FreeBSD或OpenIndiana上并不需要，但加上它也没有坏处。）
- en: 'Now, take a look at the `home_space()` function:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看看`home_space()`函数：
- en: '[PRE29]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This function uses the `du` utility to report the amount of drive space that
    each user’s home directory is using. The slight problem is that OpenIndiana and
    macOS don’t have users’ home directories in the `/home/` directory, as Linux and
    FreeBSD do. So, I included code that would determine where `du` is to look, as
    determined by the operating system.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数使用`du`工具报告每个用户的主目录占用的磁盘空间。一个小问题是，OpenIndiana和macOS不像Linux和FreeBSD那样将用户的主目录放在`/home/`目录下。所以，我加入了代码来确定`du`应该查看的位置，这取决于操作系统。
- en: 'Next are the `open_files()` and `open_files_root()` functions, which report
    the number of files that the apache and root users have open. Both functions are
    the same except for the specified user, so I’ll just show you one of them here:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`open_files()`和`open_files_root()`函数，它们报告了apache和root用户打开的文件数量。两个函数除了指定的用户不同外是相同的，因此我这里只展示其中一个：
- en: '[PRE30]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You see that it’s very simple, and just pipes the `lsof -u` output into `wc
    -l` to count the number of open files for the specified user.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现它非常简单，只是将`lsof -u`的输出传递给`wc -l`来统计指定用户打开的文件数量。
- en: 'The next function is `open_files_users()`, which is a bit more complex. I once
    again need to take the difference in home directory locations into account, which
    you see here in the first half of the function:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个函数是`open_files_users()`，稍微复杂一些。我再次需要考虑主目录位置的差异，正如你在函数前半部分看到的：
- en: '[PRE31]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The second half of the function is a *for* loop that reads the names of the
    users’ home directories, and then uses those names in the `lsof` commands. But,
    there’s another wrinkle here that we need to iron out. It’s that if your Linux
    machine has the `/home/` directory mounted on its own partition, and the partition
    is formatted with either the `ext3` or `ext4` filesystem, there will be a `lost+found`
    directory that’s not a user’s home directory. On macOS, you’ll see a `Shared`
    directory that’s also not a user’s home directory. If you try to use either of
    these two directory names as an argument for `lsof`, you’ll receive an error.
    So, I had to add some code to exclude those two directory names from being used,
    as you see here:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的第二部分是一个*for*循环，它读取用户主目录的名称，然后在`lsof`命令中使用这些名称。但这里还有一个问题需要解决。如果你的Linux机器将`/home/`目录挂载到自己的分区上，并且该分区使用`ext3`或`ext4`文件系统格式化，那么会有一个`lost+found`目录，它不是用户的主目录。在macOS上，你会看到一个`Shared`目录，它也不是用户的主目录。如果你尝试将这两个目录名称之一作为`lsof`的参数，你会收到错误。因此，我必须添加一些代码来排除这两个目录名称不被使用，如下所示：
- en: '[PRE32]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You see that I’m using the `&&` sequence as an `and` operator so that I can
    place both test conditions into just one `if..then` construct. One reference that
    I found states that the `and` (`&&`) and `or` (`||`) operators work better with
    the `[[..]]` test construct than they do with the `[..]` test construct. However,
    I just tested the function both ways, and both work for me here. I’ve also shown
    you something that I don’t remember having shown you before. That is, you can
    nest one command substitution construct within another command substitution construct,
    as you see in the first `echo` line.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，我使用了`&&`序列作为`and`操作符，这样我就能把两个测试条件放入一个`if..then`结构中。我找到的一个参考文献指出，`and`（`&&`）和`or`（`||`）操作符在与`[[..]]`测试结构一起使用时，比与`[..]`测试结构一起使用时效果更好。不过，我测试了这两种方式，对我来说都可以正常工作。我还向你展示了一些我不记得以前展示过的内容。也就是说，你可以将一个命令替换结构嵌套在另一个命令替换结构中，正如你在第一个`echo`命令中看到的那样。
- en: 'Finally, there’s the `system_info()` function, which again will work differently
    on different operating systems. That’s because system information is in the `/etc/os-release`
    file on Linux and FreeBSD and in the `/etc/release` file on OpenIndiana. On macOS,
    there’s no kind of release file at all, so I had to use another method. Anyway,
    here’s the top portion of the function, which is for Linux and FreeBSD:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后是`system_info()`函数，它在不同操作系统上会有所不同。这是因为在Linux和FreeBSD中，系统信息保存在`/etc/os-release`文件中，而在OpenIndiana中，系统信息保存在`/etc/release`文件中。在macOS上根本没有任何类型的发行版文件，因此我不得不使用其他方法。无论如何，下面是这个函数的前部分，适用于Linux和FreeBSD：
- en: '[PRE33]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If the `/etc/os-release` file is present, the value of the `os` variable will
    be the `PRETTY_NAME` line from that file. The `echo "${os:12}"` line strips off
    the `PRETTY_NAME` part, so that only the actual version name of the Linux or FreeBSD
    distro is left. I then used the `uname -orp` command to show the system information
    that I want everyone to see. (I’ll let you look in the `uname` man page to see
    what all of the option switches are doing.)
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在`/etc/os-release`文件，则`os`变量的值将是该文件中的`PRETTY_NAME`行。`echo "${os:12}"`命令将去掉`PRETTY_NAME`部分，这样只留下Linux或FreeBSD发行版的实际版本名称。然后我使用`uname
    -orp`命令显示我希望每个人看到的系统信息。（我会让你查看`uname`的手册页，了解所有选项的作用。）
- en: 'The next part of the function is for OpenIndiana, as you see here:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的下一部分是适用于OpenIndiana的，如下所示：
- en: '[PRE34]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `/etc/release` file on OpenIndiana isn’t the same as the `/etc/os-release`
    file on Linux and FreeBSD. So, I used the `head -1` command to read the first
    line of the file, which contains the version name of the distro.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: OpenIndiana中的`/etc/release`文件与Linux和FreeBSD中的`/etc/os-release`文件不同。因此，我使用`head
    -1`命令读取文件的第一行，该行包含了发行版的版本名称。
- en: 'The final portion of this function is for OS X/macOS, as you see here:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的最后部分是适用于OS X/macOS的，如下所示：
- en: '[PRE35]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Since there’s no release file of any kind, I used the `sw_vers` command instead,
    which is only available on OS X and macOS. The output from this command looks
    like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有任何类型的发行版文件，我改用了`sw_vers`命令，这个命令仅在OS X和macOS上可用。该命令的输出如下所示：
- en: '[PRE36]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: And yes, that is a very old version of the Mac operating system. But, the machine
    is a mid-2010 model Mac Pro, and this is the newest version that it will run.
    (Well, it can run a more recent version, but I’ll have to perform some unnatural
    acts that aren’t authorized by Apple in order to do it. This involves installing
    the OpenCore Legacy Patcher, which will modify the Mac’s bootloader so that you
    can install a newer version of macOS. Be aware though that things can go wrong
    with this, which could render your Mac unbootable. Trust me, I know.)
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，那是一个非常旧的Mac操作系统版本。但是，这台机器是2010年中期型号的Mac Pro，而这是它可以运行的最新版本。（嗯，它可以运行更近期的版本，但我必须执行一些苹果未授权的非正常操作才能实现。这涉及安装OpenCore
    Legacy Patcher，它将修改Mac的引导程序，让你能够安装更新的macOS版本。不过要注意，可能会发生问题，导致你的Mac无法启动。相信我，我知道这是什么感觉。）
- en: I also had to use a different combination of option switches for `uname`, because
    macOS uses a different implementation of `uname`. (Again, look at the man page
    for `uname` on your Mac machine to see what the option switches are doing.)
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我还不得不为`uname`使用不同的选项组合，因为macOS使用的是不同版本的`uname`。（再说一遍，查看你Mac上`uname`的man页面，看看选项开关的作用。）
- en: 'That’s it for the function library file. Now, we need to look at the `system_info.sh`
    script that uses this library. Here’s the top part:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是函数库文件的全部内容。现在，我们需要查看使用这个库的`system_info.sh`脚本。以下是顶部部分：
- en: '[PRE37]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The shebang line, which we first talked about in *Chapter 8, Basic Shell Script
    Construction*, has to be `#!/bin/bash`, because some of the alternate shells that
    are referenced by `#!/bin/sh` aren’t compatible with some of the programming constructs
    that I need to use. So, if you’re running this script on either Alpine Linux or
    FreeBSD, you’ll need to install `bash`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*第8章，基本Shell脚本构建*中讨论过的shebang行必须是`#!/bin/bash`，因为一些由`#!/bin/sh`引用的替代Shell与我需要使用的某些编程结构不兼容。因此，如果你在Alpine
    Linux或FreeBSD上运行此脚本，你需要安装`bash`。
- en: The rest of this top portion just reads in the function library and sets up
    the variables that I’ll use in the rest of the script. So, there’s nothing hard
    there.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的顶部部分只是读取函数库并设置我将在脚本其余部分使用的变量。所以，这里没有什么难的。
- en: 'The next portion consists of the *here document*, which inserts the proper
    HTML tags and invokes several functions, as you see here:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 下一部分是*here文档*，它插入了正确的HTML标签并调用了几个函数，如下所示：
- en: '[PRE38]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: So again, there’s nothing hard here.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，再次强调，这里没有什么难的。
- en: 'The final portion of the script converts the `.html` output file to a `.pdf`
    file, if the `pandoc` package is installed. If it’s not, then it will just leave
    the `.html` file alone. Here’s how that looks:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的最后一部分将`.html`输出文件转换为`.pdf`文件，前提是已经安装了`pandoc`包。如果没有安装，它将保持`.html`文件不变。如下所示：
- en: '[PRE39]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As much as I’d like to always have a `.pdf` file, that’s not possible on OpenIndiana.
    As I’ve mentioned before, `pandoc` isn’t in the OpenIndiana repository. The only
    other `.pdf` creation tool I’ve seen for OpenIndiana is `groff`, but that involves
    using a whole different markup language.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我希望总是有一个`.pdf`文件，但在OpenIndiana上这是不可能的。正如我之前提到的，`pandoc`不在OpenIndiana的仓库中。我看到的唯一其他可用于OpenIndiana的`.pdf`创建工具是`groff`，但那涉及使用完全不同的标记语言。
- en: When you run this script, you’ll need to use your `sudo` privileges in order
    to access information about other users. Also, don’t be alarmed if you get error
    messages about directories that the script can’t access, because that happens
    even with `sudo`. For example, here on my Fedora workstation, the script can’t
    access the `pCloud` directory that’s in my home directory, because it’s a mount
    point for a remote drive.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个脚本时，你需要使用`sudo`权限才能访问其他用户的信息。另外，如果你收到关于脚本无法访问的目录的错误消息，不必惊慌，因为即使使用`sudo`，这也会发生。例如，在我的Fedora工作站上，脚本无法访问位于我的主目录中的`pCloud`目录，因为它是远程驱动器的挂载点。
- en: This is all I’ll say about *here documents* for now. But, in *Chapter 20, Shell
    Script Portability*, I’ll show you more about them, and will also show you more
    ways to make scripts run across a variety of operating systems and shells. For
    now though, let’s look at what to expect next.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 关于*here文档*，我现在就说这么多。但在*第20章，Shell脚本可移植性*中，我会进一步介绍它们，并展示更多让脚本能够跨各种操作系统和Shell运行的方法。不过现在，让我们看看接下来会发生什么。
- en: Automating Responses with expect
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用expect自动化响应
- en: There may be times when you’ll need to run a script that stops multiple times
    to prompt you for some sort of input. That can get a bit tedious after a while,
    especially if you need to run the script multiple times on multiple servers or
    workstations. Wouldn’t it be nice to automate the responses? Well, with all due
    respect, you can with `expect`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有一些时候，你需要运行一个会多次暂停，提示你输入某些信息的脚本。如果需要多次在多个服务器或工作站上运行这个脚本，这可能会变得有些繁琐。难道不希望能够自动化输入吗？那么，恕我直言，你可以使用`expect`来做到这一点。
- en: 'So, what is `expect`? Well, it’s a programming environment, similar to what
    you have with `bash`. If you have an interactive shell script that *expects* certain
    responses, you can use `expect` to automatically send the correct responses. Let’s
    begin with the simplest of examples. First, create the `interactive_script.sh`
    script, like so:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，`expect`是什么呢？它是一个编程环境，类似于你在`bash`中使用的环境。如果你有一个交互式的shell脚本，它*期望*某些响应，你可以使用`expect`自动发送正确的响应。让我们从最简单的例子开始。首先，创建`interactive_script.sh`脚本，如下所示：
- en: '[PRE40]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: When you run this script, it will pause at each `read $reply` command so that
    you can type in a response. Of course, that’s not a big deal for this simple script.
    But now, pretend that you’ve written some sort of software testing script that’s
    long and complex, and that requires the software tester to constantly enter responses.
    Unless you enjoy pain, and I doubt that you do, you probably don’t want to be
    glued to your workstation, constantly entering responses for those long tests.
    So, your best bet is to automate the process, and your best bet for that is to
    use `expect`. You should find it already installed on a Mac, but for everything
    else you’ll have to install it yourself.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个脚本时，它会在每个`read $reply`命令处暂停，以便你输入响应。当然，这对于这个简单的脚本来说不是什么大问题。但现在，假设你写了一个长且复杂的软件测试脚本，需要软件测试人员不断输入响应。如果你不喜欢痛苦（我怀疑你会喜欢），你可能不想一直坐在工作站前，不停地为这些长时间的测试输入响应。因此，你最好的选择是自动化这个过程，而自动化的最佳方式就是使用`expect`。在Mac上你应该会发现它已经预装好了，但对于其他操作系统，你需要自行安装它。
- en: 'Verify whether it’s installed by doing:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下命令验证它是否已安装：
- en: '[PRE41]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If it’s not installed, it should be in your distro’s repository as the `expect`
    package. On FreeBSD, you’ll need to take the additional step of creating a symbolic
    link, so that you won’t have to modify your scripts to run on FreeBSD. Do it like
    this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它没有安装，它应该可以在你使用的发行版的仓库中找到，作为`expect`包提供。在FreeBSD上，你需要额外创建一个符号链接，这样你就不需要修改脚本就能在FreeBSD上运行。可以这样做：
- en: '[PRE42]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now that it’s installed, create the `interactive_script.exp` companion script.
    The easiest way to do that is to use `autoexpect`, like this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，创建`interactive_script.exp`伴随脚本。最简单的做法是使用`autoexpect`，像这样：
- en: '[PRE43]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As you see, `autoexpect` runs the original `interactive_script.sh` script, and
    prompts you for responses. The responses get saved to the `interactive_script.exp`
    script that you specified with the `-f` option. Note that if the original script
    is in your home directory, you’ll need to precede its name with a `./` so that
    `autoexpect` can find it. The entire `interactive_script.exp` script is too long
    to show, so I’ll show you some snippets, along with some explanation.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`autoexpect`运行原始的`interactive_script.sh`脚本，并提示你输入响应。响应将被保存到你通过`-f`选项指定的`interactive_script.exp`脚本中。注意，如果原始脚本位于你的主目录中，你需要在脚本名之前加上`./`，这样`autoexpect`才能找到它。由于整个`interactive_script.exp`脚本太长，无法显示，我将展示一些片段并做些解释。
- en: 'The first thing to note is that expect scripts have their own shebang line,
    which looks like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 首先需要注意的是，`expect`脚本有自己的shebang行，格式如下：
- en: '[PRE44]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `-f` means that responses will be read from this file.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`-f`表示响应将从此文件读取。'
- en: 'The next thing I want to show you is the spawn command, which looks like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我想展示的是`spawn`命令，它是这样的：
- en: '[PRE45]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: When I run the `expect` script, it will automatically start the original shell
    script.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当我运行`expect`脚本时，它将自动启动原始的shell脚本。
- en: 'Next, let’s look at how the expect script provides responses:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们来看一下`expect`脚本如何提供响应：
- en: '[PRE46]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `expect` commands duplicate the questions from the original shell script.
    By including the `-exact` option, the questions must be identical to the originals.
    The first `expect` command only asks for my name, and all of the others both send
    back the response and then pull in the next question. The `\r` at the end of each
    line provides a carriage return, so that the next response or question will show
    on a new line. (Note that this isn’t the Windows-type of carriage return that
    can cause so much trouble in text files or configuration files.)
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`expect` 命令复制了原始 shell 脚本中的问题。通过包含 `-exact` 选项，问题必须与原始问题完全相同。第一个 `expect` 命令只会询问我的名字，其他所有命令既会返回响应，又会拉取下一个问题。每行末尾的
    `\r` 提供了回车符，使得下一个响应或问题会显示在新的一行。（请注意，这并不是那种在文本文件或配置文件中可能引发麻烦的 Windows 类型回车符。）'
- en: 'The very last line of the expect script looks like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`expect` 脚本的最后一行如下所示：'
- en: '[PRE47]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As you might expect, this indicates the End of File.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所料，这表示文件结束。
- en: 'Another cool thing about `autoexpect` is that it automatically sets the executable
    permission on the script files that it generates. So, you won’t have to do that
    yourself. Now, here’s what happens when I run this `expect` script:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`autoexpect` 另一个酷的功能是，它会自动为它生成的脚本文件设置可执行权限。因此，你不必自己做这件事。现在，这是我运行这个 `expect`
    脚本时发生的情况：'
- en: '[PRE48]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: All of the questions got answered automatically, without me having to interact
    with the script at all.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的问题都自动得到了回答，我完全没有与脚本进行任何交互。
- en: Now, as cool as `autoexpect` is, there are some drawbacks. First, it only comes
    with the `expect` packages that are in the repositories for the various Linux
    distros. For some strange reason, it’s not available for FreeBSD, OpenIndiana,
    or macOS. So, if you ever need to create an `expect` script for any of those operating
    systems, your best bet is to create it on a Linux machine, and then transfer it
    over to the non-Linux machine. Secondly, if you use it with a software installation
    script that uses `curl` or `wget` to download the software, the output from `curl`
    or `wget` that shows the status of the download will become part of the expect
    script. You’ll need to remove all of that from the `expect` script by hand so
    that the script will work correctly. And lastly, you can’t expect `autoexpect`
    to do everything. Sometimes, you’ll just need to hand-code the `expect` scripts
    yourself.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如此强大的 `autoexpect` 也有一些缺点。首先，它仅随 Linux 发行版的 `expect` 软件包提供。在一些奇怪的情况下，它没有提供给
    FreeBSD、OpenIndiana 或 macOS。因此，如果你需要为这些操作系统创建 `expect` 脚本，最好的方法是先在 Linux 机器上创建，再将其传输到非
    Linux 机器。其次，如果你用它来处理使用 `curl` 或 `wget` 下载软件的软件安装脚本，`curl` 或 `wget` 显示下载状态的输出会成为
    `expect` 脚本的一部分。你需要手动从 `expect` 脚本中删除这些内容，才能确保脚本正常运行。最后，你不能指望 `autoexpect` 做所有事情。有时，你需要亲自编写
    `expect` 脚本。
- en: Security Implications with expect
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `expect` 的安全隐患
- en: There are lots of ways to use `expect`, but in my own opinion, it’s most useful
    for the automation of software testing or installation. Most other tutorials you’ll
    find show you how to automate either `ssh` login sessions or `scp` file transfers,
    but you need to be careful if you use `expect` for anything like that. The problem
    is that the password of the destination machine will get stored in plain-text
    format in the `expect` script, which is also plain text. Making things even worse,
    is that some of these tutorials have you access the root user account of the destination
    machine like this.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多使用 `expect` 的方法，但在我个人看来，它在软件测试或安装的自动化中最为有用。你会发现大多数其他教程展示了如何自动化 `ssh` 登录会话或
    `scp` 文件传输，但如果你用 `expect` 做类似的事情，必须小心。问题是目标机器的密码会以明文格式存储在 `expect` 脚本中，而这个脚本本身也是明文的。更糟糕的是，一些教程让你像这样访问目标机器的
    root 用户帐户。
- en: Now, my own general rule is to never enable the root user account when setting
    up a server, as long as the operating system installer gives me that choice. When
    setting up something like FreeBSD, where that isn’t a choice, I like to install
    and configure `sudo` as my first post-installation step, and then disable the
    root account. However, there are times when it’s necessary to enable the root
    user account, as well as to use `scp` to transfer files to the root user’s account.
    If that is ever necessary, it’s more secure to disable password authentication
    on the server, and instead use key-based authentication.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我的通用规则是在设置服务器时永远不启用root用户账户，只要操作系统安装程序给我这个选择。当设置像FreeBSD这样的系统时，如果没有这个选择，我喜欢将`sudo`安装并配置为我的第一个安装后步骤，然后禁用root账户。然而，有时确实需要启用root用户账户，并使用`scp`将文件传输到root用户账户。如果确实需要这样做，那么禁用服务器上的密码认证，并改用基于密钥的认证会更安全。
- en: Even then, I only feel comfortable accessing the root user account from within
    a tightly-controlled local network, rather than from across the Internet. Having
    said all this, if you still ever find it necessary to store plain-text `ssh` passwords
    in an expect script, be sure to store the script in a location that only you or
    trusted members of your team can access. (But hopefully though, you’ll find another
    way to do things that won’t require placing passwords into the `expect` scripts.)
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 即便如此，我只在严格控制的本地网络内访问root用户账户，而不是通过互联网。说到这些，如果你仍然觉得有必要在expect脚本中存储明文`ssh`密码，一定要将脚本存储在只有你或你团队的信任成员能访问的地方。（但希望你能找到其他不需要将密码放入`expect`脚本中的方法。）
- en: The only other thing I’ll say about `expect` is that it is a vast topic, and
    at least one entire book has been written about it. (I’ll leave a link for it
    in the *Further Reading* section for anyone who might be interested.)
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我对`expect`唯一要说的就是它是一个庞大的话题，至少有一本完整的书已经写了它。（如果有人感兴趣，我会在*进一步阅读*部分提供链接。）
- en: Okay, let’s wrap this chapter up and move on.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们结束本章并继续下一章。
- en: Summary
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, I’ve shown you some cool tricks to help automate your scripts.
    I first showed you *here documents*, and how to use them in a few different ways.
    Then, I showed you expect, which is a whole scripting language unto itself. I
    showed you some ways to use expect, and then talked about some of its security
    implications.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我向你展示了一些很酷的技巧，帮助你自动化脚本。首先我向你展示了*here文档*，以及如何用几种不同的方式使用它们。接着，我向你展示了expect，它本身就是一种完整的脚本语言。我展示了几种使用expect的方法，并讨论了它的一些安全影响。
- en: In the next chapter, I’ll show you some scripting tricks for ImageMagick. I’ll
    see you there.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我将向你展示一些用于ImageMagick的脚本技巧。我们在那里见。
- en: Questions
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is a here document?
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是here文档？
- en: It shows your current location.
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它显示了你当前的位置。
- en: It’s a block of code for a specific purpose.
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它是一个特定目的的代码块。
- en: It’s a type of executable script.
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它是一种可执行脚本类型。
- en: It’s a block of static data.
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它是一个静态数据块。
- en: Which of the following statements is true?
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪项陈述是正确的？
- en: A here document uses its own scripting language.
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: here文档使用它自己的脚本语言。
- en: A here document can only be used in bash scripts.
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: here文档只能在bash脚本中使用。
- en: A here document can be used with a variety of programming and scripting languages.
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: here文档可以与多种编程和脚本语言一起使用。
- en: A here document can only be used to display comments or other static data.
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: here文档只能用于显示注释或其他静态数据。
- en: How do you define a here document?
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何定义一个here文档？
- en: Place `#!/`bin/here in the script as the shebang line.
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本中加入`#!/`bin/here作为shebang行。
- en: Surround the entire here document with a pair of double quotes.
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用一对双引号包围整个here文档。
- en: Surround the entire here document with a pair of single quote.
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用一对单引号包围整个here文档。
- en: Surround the entire *here document* with a pair of limit strings.
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用一对限制字符串包围整个*here文档*。
- en: Which of the following statements is true?
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪项陈述是正确的？
- en: You can use `autoexpect` for any situation, and then use the resultant `expect`
    scripts without any editing.
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以在任何情况下使用`autoexpect`，然后无需编辑即可使用生成的`expect`脚本。
- en: The `expect` scripts that `autoexpect` creates might need to be hand-edited
    to make them work correctly.
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`autoexpect`创建的`expect`脚本可能需要手动编辑才能正常工作。'
- en: You can use `autoexpect` on any operating system, including Linux, FreeBSD,
    macOS, and OpenIndiana.
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以在任何操作系统上使用`autoexpect`，包括Linux、FreeBSD、macOS和OpenIndiana。
- en: You should never use `autoexpect` for anything.
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你绝不应该使用`autoexpect`来做任何事情。
- en: What is one implication of using `expect`?
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`expect`有什么一个影响？
- en: When using `expect` to automate `ssh` logins or `scp` transfers, the password
    for the destination server will be stored in plain-text within the `expect` script.
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`expect`自动化`ssh`登录或`scp`传输时，目标服务器的密码会以明文存储在`expect`脚本中。
- en: There are no implications.
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有什么影响。
- en: It’s not very efficient.
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这并不是很高效。
- en: It’s too hard to create an expect script.
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建expect脚本太难了。
- en: Further Reading
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'How to Use “Here Documents” in Bash on Linux: [https://www.howtogeek.com/719058/how-to-use-here-documents-in-bash-on-linux/](https://www.howtogeek.com/719058/how-to-use-here-documents-in-bash-on-linux/)'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在Linux中使用“Here Documents”： [https://www.howtogeek.com/719058/how-to-use-here-documents-in-bash-on-linux/](https://www.howtogeek.com/719058/how-to-use-here-documents-in-bash-on-linux/)
- en: 'How to Create TXT Template Scripts in BASH: [https://www.maketecheasier.com/create-txt-template-scripts-bash/](https://www.maketecheasier.com/create-txt-template-scripts-bash/)'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在BASH中创建TXT模板脚本： [https://www.maketecheasier.com/create-txt-template-scripts-bash/](https://www.maketecheasier.com/create-txt-template-scripts-bash/)
- en: 'Here Documents: [https://tldp.org/LDP/abs/html/here-docs.html](https://tldp.org/LDP/abs/html/here-docs.html)'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Here Documents： [https://tldp.org/LDP/abs/html/here-docs.html](https://tldp.org/LDP/abs/html/here-docs.html)
- en: 'How to Use Heredoc in Shell Scripting: [https://www.tecmint.com/use-heredoc-in-shell-scripting/](https://www.tecmint.com/use-heredoc-in-shell-scripting/)'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在Shell脚本中使用Heredoc： [https://www.tecmint.com/use-heredoc-in-shell-scripting/](https://www.tecmint.com/use-heredoc-in-shell-scripting/)
- en: 'Writing Shell Scripts-Lesson 3: Here scripts: [http://linuxcommand.org/lc3_wss0030.php](http://linuxcommand.org/lc3_wss0030.php)'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写Shell脚本-第3课：Here脚本： [http://linuxcommand.org/lc3_wss0030.php](http://linuxcommand.org/lc3_wss0030.php)
- en: 'How to Use Here Document (heredoc) in Linux Shell Script: [https://linuxtldr.com/heredoc/](https://linuxtldr.com/heredoc/)'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在Linux Shell脚本中使用Here Document（heredoc）： [https://linuxtldr.com/heredoc/](https://linuxtldr.com/heredoc/)
- en: 'Linux expect Command with Examples: [https://phoenixnap.com/kb/linux-expect](https://phoenixnap.com/kb/linux-expect)'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux expect命令示例： [https://phoenixnap.com/kb/linux-expect](https://phoenixnap.com/kb/linux-expect)
- en: 'Automate Input to Linux Scripts with the expect Command: [https://www.howtogeek.com/devops/automate-inputs-to-linux-scripts-with-the-expect-command/](https://www.howtogeek.com/devops/automate-inputs-to-linux-scripts-with-the-expect-command/)'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用expect命令自动化输入到Linux脚本： [https://www.howtogeek.com/devops/automate-inputs-to-linux-scripts-with-the-expect-command/](https://www.howtogeek.com/devops/automate-inputs-to-linux-scripts-with-the-expect-command/)
- en: 'Expect Command in Linux with Examples: [https://www.geeksforgeeks.org/expect-command-in-linux-with-examples/](https://www.geeksforgeeks.org/expect-command-in-linux-with-examples/)'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux中的Expect命令与示例： [https://www.geeksforgeeks.org/expect-command-in-linux-with-examples/](https://www.geeksforgeeks.org/expect-command-in-linux-with-examples/)
- en: 'Expect Command and How to Automate Shell Scripts like Magic: [https://likegeeks.com/expect-command/](https://likegeeks.com/expect-command/)'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Expect命令及如何像魔法一样自动化Shell脚本： [https://likegeeks.com/expect-command/](https://likegeeks.com/expect-command/)
- en: 'Automating Responses to Scripts on Linux Using expect and autoexpect: [https://www.networkworld.com/article/969513/automating-responses-to-scripts-on-linux-using-expect-and-autoexpect.html](https://www.networkworld.com/article/969513/automating-responses-to-scripts-on-linux-using-expect-and-autoexpect.html)'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用expect和autoexpect在Linux上自动化响应脚本： [https://www.networkworld.com/article/969513/automating-responses-to-scripts-on-linux-using-expect-and-autoexpect.html](https://www.networkworld.com/article/969513/automating-responses-to-scripts-on-linux-using-expect-and-autoexpect.html)
- en: 'Exploring Expect: [https://amzn.to/3MSNqAV](https://amzn.to/3MSNqAV)'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索Expect： [https://amzn.to/3MSNqAV](https://amzn.to/3MSNqAV)
- en: Answers
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回答
- en: b
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b
- en: c
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: c
- en: d
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: d
- en: b
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b
- en: a
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a
- en: Join our community on Discord!
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord社区！
- en: Read this book alongside other users, Linux experts, and the author himself.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、Linux专家和作者本人一起阅读这本书。
- en: Ask questions, provide solutions to other readers, chat with the author via
    Ask Me Anything sessions, and much more. Scan the QR code or visit the link to
    join the community.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 提问，提供解决方案给其他读者，通过“问我任何问题”环节与作者聊天，等等。扫描二维码或访问链接加入社区。
- en: '[https://packt.link/SecNet](https://packt.link/SecNet)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/SecNet](https://packt.link/SecNet)'
- en: '![](img/QR_Code10596186092701843.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code10596186092701843.png)'
