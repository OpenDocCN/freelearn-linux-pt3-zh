<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Configuration Management with Ansible</h1>
                </header>
            
            <article>
                
<p>So far in this book, <span>we have established a solid framework for our Enterprise Linux infrastructure, one that lends i</span><span>tself well to the large-scale deployments typical in an enterprise, and to automated management with Ansible at this scale.</span> In this chapter, we now <span>proceed to go into depth on the automated management aspect of this infrastructure, starting with the installation and configuration of software packages.</span></p>
<p>In just about every enterprise, one task is almost guaranteed to be required during the lifespan of a standardized Linux system—the installation and configuration of a service. This might simply involve the configuration of an existing system service, or possibly even the installation of the service itself, followed by post-configuration work. </p>
<p>We will cover the following topics in this chapter, to explore Ansible configuration management in greater depth:</p>
<ul>
<li>Installing new software</li>
<li>Making configuration changes with Ansible</li>
<li>Managing configuration at an enterprise scale</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>This chapter includes examples based on the following technologies:</p>
<ul>
<li>Ubuntu Server 18.04 LTS</li>
<li>CentOS 7.6</li>
<li>Ansible 2.8</li>
</ul>
<p>To run through these examples, you will need access to two servers or virtual machines running one of each of the operating systems listed here, and also Ansible. Note that the examples given in this chapter may be destructive in nature (for example, they install and uninstall software packages and make changes to server configuration), and if run as-is, they are only intended to be run in an isolated test environment. </p>
<p>Once you are satisfied that you have a safe environment in which to operate, let's get started on looking at the installation of new software packages with Ansible.</p>
<p><span>All example code discussed in this chapter is available from GitHub, at the following URL:</span><span> <a href="https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux/tree/master/chapter07">https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux/tree/master/chapter07</a></span>.</p>
<p> </p>
<p> </p>
<p> </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing new software</h1>
                </header>
            
            <article>
                
<p class="mce-root">Depending on your requirements, it is quite possible that your SOE operating system build has sufficient software installed, and requires only configuration work. However, for many people, that will not be the case, so we will begin this chapter with a section covering the installation of software. As with all our work so far, our desire is that anything we do here is repeatable and lends itself well to automation, and thus, even if new software is required, it is desirable that we do not install it by hand.</p>
<p>Let's start by looking at the simplest possible case here—installing a native operating system package.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing a package from operating system default repositories</h1>
                </header>
            
            <article>
                
<p>Suppose that you are rolling out a new service that requires a database server—for example, MariaDB. It is unlikely that you will have installed and enabled MariaDB in all of your SOE images, and hence, the first task before you do anything else will be to install the software package.</p>
<p>Both of our example operating systems in this book (and indeed, many of their derivatives) include native packages for MariaDB, so we could quite easily make use of these. When it comes to package installation, there is, of course, a need to understand what is going on behind the scenes in our target operating system. For example, on Ubuntu, we know that we would normally install our chosen software by using the<span> </span>APT<span> </span>package manager. Thus, if we wanted to install this manually, including the matching client for management purposes, we would issue the following command:</p>
<pre><strong># sudo apt install mariadb-server mariadb-client</strong></pre>
<p>Of course, on CentOS, things are quite different—even though packages are available for MariaDB, the command to install them would instead be the following one:</p>
<pre><strong># sudo yum install mariadb mariadb-server</strong></pre>
<p>Although Ansible can automate a great deal of your Enterprise Linux requirements, it cannot abstract away some of the fundamental differences between different Linux operating systems. Fortunately, though, Ansible makes everything else quite straightforward. Consider the following inventory:</p>
<pre>[servers]<br/>ubuntu-testhost<br/>centos-testhost</pre>
<p>We have advocated building a standard operating environment throughout this book, so this inventory is rather unlikely to occur in real life—however, it serves as a good example here as we can demonstrate how to install a MariaDB server on two differing platforms. As with earlier examples in this book, we'll complete this task by making use of roles.</p>
<p>Building on our work on templates from earlier in this book, consider the following role:</p>
<pre>---<br/>- name: Install MariaDB Server on Ubuntu or Debian<br/>  apt:<br/>    name: "{{ item }}"<br/>    state: present<br/>  loop:<br/>    - mariadb-server<br/>    - mariadb-client<br/>  when: ansible_distribution == 'Debian' or ansible_distribution == 'Ubuntu'<br/><br/>- name: Install MariaDB Server on CentOS or RHEL<br/>  yum:<br/>    name: "{{ item }}"<br/>    state: present<br/>  loop:<br/>    - mariadb-server<br/>    - mariadb<br/>  when: ansible_distribution == 'CentOS' or ansible_distribution == 'Red Hat Enterprise Linux'</pre>
<p>This neatly packaged role will operate correctly on both Ubuntu and CentOS (and, indeed, <strong>Red Hat Enterprise Linux</strong> (<strong>RHEL</strong>) and Debian, if required), and takes account of both the differing package managers and different package names. Naturally, if you are fortunate enough to have an environment that is completely unified (for example, only Ubuntu Server-based), then the code can be simplified even further.</p>
<div class="packt_tip">There exists an Ansible module called <kbd>package</kbd> that attempts to detect the correct package manager to use, based on the operating system the playbook is run against. Although this removes the need for separate yum- and apt- based tasks, such as the ones we used previously, you still need to take into account the different package naming between different Linux operating systems, so you may still require a <kbd>when</kbd> clause. </div>
<p>We will define a simple playbook to call the role, as follows:</p>
<pre>---<br/>- name: Install MariaDB<br/>  hosts: all<br/>  become: yes<br/><br/>  roles:<br/>    - installmariadb</pre>
<p>Now, we can run the playbook and observe what happens, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e4e725fc-b55e-466c-9a15-af9836f065e1.png" style="width:54.33em;height:38.08em;"/></p>
<p>From the preceding output, you can see how the tasks that are irrelevant to each system are skipped, while the successful installation of our desired package results in a<span> </span><kbd>changed</kbd><span> </span>status. Also, note that the task status returned was<span> </span><kbd>ok</kbd><span> </span>when installing the MariaDB client package called<span> </span><kbd>mariadb</kbd><span> </span>on our CentOS test system. The reason for this is that the<span> </span><kbd>loop</kbd><span> </span>defined in our<span> </span><kbd>role</kbd><span> </span>iterates over each listed package in turn, installing it; on CentOS, the<span> </span><kbd>mariadb</kbd><span> </span>package is a dependency of the<span> </span><kbd>mariadb-server</kbd><span> </span>package, and so it was installed when that particular task was run.</p>
<p>Although specifying this manually could be seen as redundant, it does no harm to keep it in our role as it ensures that whatever happens, the client package is present. It is also a form of self-documentation—in a few years, someone could come back to this playbook and understand that both the MariaDB client and server packages were required, even if they were unaware of this nuance of the CentOS 7 operating system.</p>
<p>Before we build on this example, a note on package removal. Ansible tasks are, as we have discussed previously, idempotent. For example, if we run our playbook a second time, we will see that the results returned are all<span> </span><kbd>ok</kbd>. In the following instance, Ansible has detected that our chosen packages are already installed, and doesn't attempt a second installation:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/786cc962-eb89-4d1f-b0b6-d3dd70619b3a.png" style="width:38.08em;height:26.75em;"/></p>
<p>However, what if you need to tidy something up? Perhaps a package that features in the standard image has become obsolete or needs removing, for security reasons. In this instance, it is not sufficient simply to remove the playbook or role. While the presence of our example role ensures the installation of packages, the removal of the role does not reverse this. In short, we must manually uninstall or remove changes if they are not required. Backing out of our installation would require a role such as this:</p>
<pre>---<br/>- name: Uninstall MariaDB Server on Ubuntu or Debian<br/>  apt:<br/>    name: "{{ item }}"<br/>    state: absent<br/>  loop:<br/>    - mariadb-server<br/>    - mariadb-client<br/>  when: ansible_distribution == 'Debian' or ansible_distribution == 'Ubuntu'<br/><br/>- name: Uninstall MariaDB Server on CentOS or RHEL<br/>  yum:<br/>    name: "{{ item }}"<br/>    state: absent<br/>  loop:<br/>    - mariadb-server<br/>    - mariadb<br/>  when: ansible_distribution == 'CentOS' or ansible_distribution == 'Red Hat Enterprise Linux'</pre>
<p>Notice the almost identical nature of the role, except that we are now using <kbd>state: absent</kbd> instead of <kbd>state: present</kbd>. This is common to most Ansible tasks you might run—if you want to define a procedure for backing out or otherwise reverting a change, you will need to write that separately. Now, when we run the preceding role by calling it from a suitable playbook, we can see that the packages are cleanly uninstalled, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1afc7d9c-e3a7-48cb-933c-2143ebd5e33b.png" style="width:44.08em;height:26.25em;"/></p>
<p>Sometimes, of course, the packages we want to install are not available as part of the default operating system package repositories.</p>
<p>In the next section, we will look at how to handle this in accordance with the automation principles we have set out so far.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing non-native packages</h1>
                </header>
            
            <article>
                
<p>Thankfully, the installation of non-native packages is not significantly more difficult with Ansible than with native ones. Ideally, in an enterprise environment, all required packages would be served out of an internal repository, and indeed, we will cover this later in the book. In this instance, the enterprise repository would be used in conjunction with Ansible roles, such as those from the previous section.</p>
<p>Occasionally, though, this may not be possible, or desirable. Take, for instance, a development or test system where a new package is being evaluated—here, you would probably not want to upload a test package to an enterprise repository server when it is not known whether there will be a requirement for the package moving forward. Nonetheless, we wish to adhere to our principles of automation and ensure that we perform our testing in a repeatable, self-documenting manner.</p>
<p>Suppose you are evaluating the Duplicati backup software for your enterprise and need to install the latest beta version to perform some testing. Obviously, you could download this manually from their releases page, copy it across to your target server, and install it by hand. However, this is inefficient, and certainly not a repeatable process. Luckily, the<span> </span><kbd>apt</kbd> and<span> </span><kbd>yum</kbd><span> </span>modules we used earlier support the installation of packages, both from a local path and a remote URL.</p>
<p>Thus, to test the installation of Duplicati beta version 2.0.4.23, you could write a role such as this:</p>
<pre>---<br/>- name: Install Duplicati beta on Ubuntu<br/>  apt:<br/>    deb: https://github.com/duplicati/duplicati/releases/download/v2.0.4.23-2.0.4.23_beta_2019-07-14/duplicati_2.0.4.23-1_all.deb<br/>  when: ansible_distribution == 'Debian' or ansible_distribution == 'Ubuntu'<br/><br/>- name: Install Duplicati beta on CentOS or RHEL<br/>  yum:<br/>    name: https://github.com/duplicati/duplicati/releases/download/v2.0.4.23-2.0.4.23_beta_2019-07-14/duplicati-2.0.4.23-2.0.4.23_beta_20190714.noarch.rpm<br/>    state: present<br/>  when: ansible_distribution == 'CentOS' or ansible_distribution == 'Red Hat Enterprise Linux'</pre>
<p>As you can see from this role, the installation proceeds without needing to separately download the package first, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2cca5511-c3bd-4179-82f3-0ed287f9e8e9.png" style="width:32.67em;height:19.42em;"/></p>
<p>Thus, in this way, whether for testing or production purposes, you can install packages that are not available in the default package repositories of your chosen operating system, and maintain the benefits of automation. In the next section, we will explore how Ansible can install software that is not packaged at all and that requires manual installation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing unpackaged software</h1>
                </header>
            
            <article>
                
<p>Some software, of course, doesn't come neatly packaged and requires a more manual approach to installation. Take, for example, the hosting control panel software <strong>Virtualmin</strong>. This, at the time of writing, normally requires the user to download a shell script and execute it to perform the installation.</p>
<p>Fortunately, once again, Ansible can help here—consider the following role:</p>
<pre>---<br/>- name: download virtualmin install script<br/>  get_url:<br/>   url: http://software.virtualmin.com/gpl/scripts/install.sh<br/>   dest: /root/install.sh<br/>   mode: 0755<br/><br/>- name: virtualmin install (takes around 10 mins) you can see progress using: tail -f /root/virtualmin-install.log<br/>  shell: /root/install.sh --force --hostname {{ inventory_hostname }} --minimal --yes<br/>  args:<br/>    chdir: /root</pre>
<p>Here, we are making use of the Ansible<span> </span><kbd>get_url</kbd><span> </span>module to download the installation script and then using the<span> </span><kbd>shell</kbd><span> </span>module to run it. Notice also how we can put helpful instructions into the task names—although no substitute for good documentation, this is incredibly helpful as it tells anyone running the script how to check on the progress of the installation using the<span> </span><kbd>tail</kbd><span> </span>command.</p>
<div class="packt_infobox">Note that the <kbd>shell</kbd> module requires some care in its use—as it cannot possibly know whether the shell task you have given it has been run before, it runs the command every time the playbook is run. Thus, if you run the preceding role a second time, it will attempt to install Virtualmin again. You should use a <kbd>when</kbd> clause under your <kbd>shell</kbd> task to ensure it only runs under certain conditions—perhaps in the preceding example, when <kbd>/usr/sbin/virtualmin</kbd> (which is installed by <kbd>install.sh</kbd>) is not present.</div>
<p>This method could be extended to almost any software you can imagine—you could even download a source code tarball and extract it and build the code using a series of <kbd>shell</kbd> module calls in Ansible. This is an unlikely case, of course, but the emphasis here is that Ansible can help you create repeatable installations, even if you don't have access to pre-packaged software in an RPM or DEB format.</p>
<p>In this manner, almost any software can be installed—after all, the process of software installation is to download a file (or archive), put it into the right location, and configure it. This is, in essence, what package managers such as <kbd>yum</kbd> and <kbd>apt</kbd> are doing behind the scenes, and Ansible can handle this kind of activity just as well, as we have demonstrated here. In the next section, we will explore the use of Ansible to make configuration changes on systems on which you have built and/or installed software.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Making configuration changes with Ansible</h1>
                </header>
            
            <article>
                
<p>When it comes to configuring a new service, the task is rarely completed by simply installing the required software. There is almost always a configuration stage required after the installation.</p>
<p>Let's consider in detail some fundamental examples of the myriad of configuration changes that might be required.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Making small configuration changes with Ansible</h1>
                </header>
            
            <article>
                
<p>When it comes to making configuration changes, the<span> </span><kbd>lineinfile</kbd><span> </span>Ansible module is often your first port of call and can handle a lot of the small-scale changes that might be required. Consider the example of deploying a MariaDB server that we started earlier in this chapter. Although we successfully installed the packages, they will have been installed with their default configuration, and this is unlikely to suit all but the most basic of use cases.</p>
<p>For example, the default bind address for the MariaDB server is<span> </span><kbd>127.0.0.1</kbd>, meaning that it is not possible to make use of our MariaDB installation from an external application. We have well established the need to make changes in a reliable, repeatable manner, so let's take a look at how we might change this using Ansible.</p>
<p>In order to change this configuration, the first thing we need to do is establish where the default configuration is located and what it looks like. From here, we will define an Ansible task, to rewrite the configuration.</p>
<p>Taking our Ubuntu server by way of example, the service bind-address is configured in the <kbd>/etc/mysql/mariadb.conf.d/50-server.cnf</kbd> file<span>—</span>the default directive looks like this:</p>
<pre>bind-address       = 127.0.0.1</pre>
<p>Thus, in order to change this, we might employ a simple role, like this:</p>
<pre>---<br/>- name: Reconfigure MariaDB Server to listen for external connections<br/>  lineinfile:<br/>    path: /etc/mysql/mariadb.conf.d/50-server.cnf<br/>    regexp: '^bind-address\s+='<br/>    line: 'bind-address = 0.0.0.0'<br/>    insertafter: '^\[mysqld\]'<br/>    state: present<br/><br/>- name: Restart MariaDB to pick up configuration changes<br/>  service:<br/>    name: mariadb<br/>    state: restarted</pre>
<p>Let's break the<span> </span><kbd>lineinfile</kbd><span> </span>task down and look at it in more detail:</p>
<ul>
<li><kbd>path</kbd>: Tells the module which configuration file to modify.</li>
<li><kbd>regexp</kbd>: Used to locate an existing line to modify if there is one so that we don't end up with two conflicting<span> </span><kbd>bind-address</kbd><span> </span>directives.</li>
<li><kbd>line</kbd>: The line to replace/insert into the configuration file.</li>
</ul>
<ul>
<li><kbd>insertafter</kbd>: If the<span> </span><kbd>regexp</kbd><span> </span>is not matched (that is, the line is not present in the file), this directive ensures that the<span> </span><kbd>lineinfile</kbd><span> </span>module inserts a new line after the<span> </span><kbd>[mysqld]</kbd><span> </span>statement, thus ensuring it is in the correct part of the file.</li>
<li><kbd>state</kbd>: Setting this to<span> </span><kbd>present</kbd><span> state </span>ensures that the line is present in the file, even if the original<span> </span><kbd>regexp</kbd><span> </span>is not matched—in this instance, a line is added to the file in accordance with the value of <kbd>line</kbd>.</li>
</ul>
<p>Following on from this modification, we know that the MariaDB server will not pick up any configuration changes unless we restart it, so we do exactly that at the end of the role. Now, if we run this, we can see that it has the desired effect, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/60622338-2858-477d-9329-d34bce89455a.png" style="width:45.00em;height:21.75em;"/></p>
<p>For simple configuration adjustments such as this, on a small number of systems, this achieves exactly the result that we desire. There are, however, drawbacks to this approach that need to be addressed, especially when it comes to not just the point in time where the change is made, but also to the long-term integrity of the system. Even with the best automation strategies in the world, someone making manual changes can remove the consistency and standardization that is core to good automation practice, and hence there is a real need to ensure that future playbook runs will still yield the desired end result. We will explore this issue in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Maintaining configuration integrity</h1>
                </header>
            
            <article>
                
<p>The issue with making changes in this manner is that they do not scale well. Tuning a MariaDB server for a production workload often requires setting perhaps half a dozen, or more, parameters. Thus, that simple role that we wrote previously could well grow to become a tangle of regular expressions and directives that are difficult to decipher, let alone manage.</p>
<p>Regular expressions themselves are not foolproof and are only as good as they are written to be. In our previous example, we used the following line to look for the bind-address directive, with a view to changing it. The regular expression<span> </span><kbd>^bind-address\s+=</kbd><span> </span>means to look for lines in the file that have the following:</p>
<ul>
<li>Have the bind-address <span>literal string </span>at the start of the line (denoted by the<span> </span><kbd>^</kbd>)</li>
<li>Have one or more spaces after the <kbd>bind-address</kbd> <span>literal string</span><span> </span></li>
<li>Have a<span> </span><kbd>=</kbd><span> </span>sign after these spaces</li>
</ul>
<p>The idea behind this regular expression is to ensure that we ignore comments such as the following one:</p>
<pre>#bind-address = 0.0.0.0</pre>
<p>However, MariaDB is quite tolerant of whitespace in its configuration files, and the regular expression we have defined here will fail to match the following permutations of this line, all of which are equally valid:</p>
<pre>bind-address=127.0.0.1<br/> bind-address = 127.0.0.1</pre>
<p>In these instances, since the<span> </span><kbd>regexp</kbd><span> </span>parameter didn't match, our role will add a new line to the configuration file with the<span> </span><kbd>bind-address = 0.0.0.0</kbd> <span>directive. </span>As MariaDB treats the preceding examples as valid configuration, we end up with two configuration directives in the file which, may well give you unexpected results. Different software packages will handle this differently too, adding to the confusion. There are other complexities to consider too. Many Linux services feature highly complex configurations that are often broken down across multiple files to make them easier to manage. The documentation that comes with the native MariaDB server package on our test Ubuntu system states the following:</p>
<pre># The MariaDB/MySQL tools read configuration files in the following order:<br/># 1. "/etc/mysql/mariadb.cnf" (this file) to set global defaults,<br/># 2. "/etc/mysql/conf.d/*.cnf" to set global options.<br/># 3. "/etc/mysql/mariadb.conf.d/*.cnf" to set MariaDB-only options.<br/># 4. "~/.my.cnf" to set user-specific options.</pre>
<p>However, this configuration order is dictated by the<span> </span><kbd>/etc/mysql/mariadb.cnf</kbd> <span>file, </span>which at the bottom has directives to include the files listed on lines 2 and 3 in the preceding code block. It is entirely possible for someone (well-meaning or otherwise) to simply come along and overwrite<span> </span><kbd>/etc/mysql/mariadb.cnf</kbd><span> </span>with a new version that removes the include statements for these subdirectories, and instead includes the following:</p>
<pre>[mysqld]<br/>bind-address = 127.0.0.1</pre>
<p>As our role that makes use of<span> </span><kbd>lineinfile</kbd><span> </span>is completely unaware of this file, it will faithfully set the parameter in<span> </span><kbd>/etc/mysql/mariadb.conf.d/50-server.cnf</kbd><span>, </span>without understanding that this configuration file is no longer being referenced, and again, the results on the server will—at best—be unpredictable.</p>
<p>While the goal of enterprise automation is that all systems should have their changes managed centrally with a tool such as Ansible, the reality is that you cannot always guarantee that this will occur. Occasionally, things will break, and people who are in a hurry to fix them may be forced to bypass processes to save time. Equally, new staff members who are unfamiliar with systems may make changes in a manner such as we have suggested here.</p>
<p>Alternatively, take—for example—our proposed SSH daemon configuration from <a href="3802fb48-9f14-4a52-98c5-280d381260a4.xhtml" target="_blank">Chapter 5</a>, <em>Using Ansible to Build Virtual Machine Templates for Deployment</em>. Here, we proposed a simple role (shown again in the following code block, for reference) that would disable root logins over SSH, one of a number of recommended security parameters for the SSH daemon: </p>
<pre>---<br/>- name: Disable root logins over SSH<br/>  lineinfile:<br/>    dest: /etc/ssh/sshd_config<br/>    regexp: "^PermitRootLogin"<br/>    line: "PermitRootLogin no"<br/>    state: present</pre>
<p>Note that our <kbd>regexp</kbd> has the same weaknesses as our other role when it comes to whitespace. When<span> </span><kbd>sshd</kbd><span> </span>has two duplicate parameters in its configuration file, it takes the first value as the correct one. Thus, if I knew that the role listed in the previous code block was being run against a system, all I would have to do is put these lines at the <em>very top</em> of<span> </span><kbd>/etc/ssh/sshd_config</kbd>:</p>
<pre># Override Ansible roles<br/>  PermitRootLogin yes</pre>
<p>Thus, our Ansible role will run faithfully against this server and report that it has successfully managed the SSH daemon configuration, while in reality, we have overridden it and enabled root logins.</p>
<p>These examples show us two things. First of all, be very careful when working with regular expressions. The more thorough you can be, especially when dealing with whitespace, the better. Obviously, in an ideal world, this would not even be necessary, but unexpected changes such as this have brought down many systems. To prevent the preceding SSH daemon example from being possible, we might try the following regular expression:</p>
<pre>^\s*PermitRootLogin\s+</pre>
<p>This will take account of zero or more spaces before the <kbd>PermitRootLogin</kbd> <span>keyword, </span>and then take account of one or more spaces afterward, all while taking account of the whitespace tolerance built into <kbd>sshd</kbd>. However, regular expressions are very literal, and we haven't even taken account of tabs yet!</p>
<p>Ultimately, this brings us to the second factor demonstrated through these examples—that to maintain configuration and, hence, system integrity at enterprise scale, and ensure that you have a high degree of confidence in both your automation and the systems it produces, another approach might be required for configuration management. This is exactly what we go on to explore in the next section—techniques for reliably managing configuration at large, enterprise scales.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Managing configuration at an enterprise scale</h1>
                </header>
            
            <article>
                
<p>Clearly, from these examples, another approach is required for the management of configuration at an enterprise scale. There is nothing wrong with the<span> </span><kbd>lineinfile</kbd><span> </span>approach we discussed previously when it comes to making small numbers of changes in a well-controlled environment, yet let us consider a more robust approach to configuration management, better suited to a large organization.</p>
<p>We will start by considering scalable methods for simple static configuration changes (that is, those that are the same across all servers) in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Making scalable static configuration changes</h1>
                </header>
            
            <article>
                
<p>It is vital that the configuration changes that we make are version controlled, repeatable, and reliable—thus, let's consider an approach that achieves this aim. Let's start with a simple example by revisiting our SSH daemon configuration. On most servers, this is likely to be static, as requirements such as restricting remote root logins and disabling password-based logins are likely to apply across an entire estate. Equally, the SSH daemon is normally configured through one central file—<kbd>/etc/ssh/sshd_config</kbd>.</p>
<p>On an Ubuntu server, the default configuration is very simple, consisting of just six lines if we remove all the whitespace and comments. Let's make some modifications to this file so that remote root logins are denied, <kbd>X11Forwarding</kbd> is disabled, and only key-based logins are allowed, as follows:</p>
<pre>ChallengeResponseAuthentication no<br/>UsePAM yes<br/>X11Forwarding no<br/>PrintMotd no<br/>AcceptEnv LANG LC_*<br/>Subsystem sftp /usr/lib/openssh/sftp-server<br/>PasswordAuthentication no<br/>PermitRootLogin no</pre>
<p>We will store this file within our <kbd>roles/</kbd> directory structure and deploy it with the following role tasks:</p>
<pre>---<br/>- name: Copy SSHd configuration to target host<br/>  copy:<br/>    src: files/sshd_config<br/>    dest: /etc/ssh/sshd_config<br/>    owner: root<br/>    group: root<br/>    mode: 0644<br/><br/>- name: Restart SSH daemon<br/>  service:<br/>    name: ssh<br/>    state: restarted</pre>
<p>Here, we use the Ansible<span> </span><kbd>copy</kbd><span> </span>module to copy the<span> </span><kbd>sshd_config</kbd><span> </span>file we have created and stored within the role itself to our target host and ensure it has the ownership and mode that's suitable for the SSH daemon. Finally, we restart the SSH daemon to pick up the changes (note that this service name is valid on Ubuntu Server and may vary on other Linux distributions). Thus, our completed <kbd>roles</kbd> directory structure looks like this:</p>
<pre>roles/<br/>└── securesshd<br/>    ├── files<br/>    │   └── sshd_config<br/>    └── tasks<br/>        └── main.yml</pre>
<p>Now, we can run this to deploy the configuration to our test host, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a3db5082-bbf1-4afb-997a-02eb6f7f5834.png" style="width:55.50em;height:26.92em;"/></p>
<p>Now, deploying the configuration through this means gives us a number of advantages over the methods we have explored previously, as listed here:</p>
<ul>
<li>The role itself can be committed to a version control system, thus implicitly bringing the configuration file itself (in the<span> </span><kbd>files/</kbd><span> </span>directory of the role) under version control.</li>
<li>Our role tasks are very simple—it is very easy for someone else to pick up this code and understand what it does, without the need to decipher the regular expressions.</li>
</ul>
<ul>
<li>It doesn't matter what happens to our target machine configuration, especially in terms of whitespace or configuration format. The pitfalls discussed at the end of the previous section are avoided completely because we simply overwrite the file on deployment.</li>
<li>All machines have an identical configuration, not just in terms of directives, but in terms of order and formatting, thus ensuring it is easy to audit configuration across an enterprise. </li>
</ul>
<p>Thus, this role represents a big step forward in terms of enterprise-scale configuration management. However, let's see what happens if we run the role against the same host a second time. The resulting output can be seen in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a3db5082-bbf1-4afb-997a-02eb6f7f5834.png"/></p>
<p>From the preceding screenshot, we can see that Ansible has determined that the SSH configuration file is unmodified from the last run, and hence, the<span> </span><kbd>ok</kbd><span> </span>status is returned. However, in spite of this, the<span> </span><kbd>changed</kbd><span> </span>status of the<span> </span><kbd>Restart SSH daemon</kbd><span> </span>task indicates that the SSH daemon has been restarted, even though no configuration change was made. Restarting system services is normally disruptive, and so it should be avoided unless absolutely necessary. In this case, we would not wish to restart the SSH daemon unless a configuration change is made.</p>
<p>The recommended way to handle this is with a<span> </span><kbd>handler</kbd>. A<span> </span><kbd>handler</kbd><span> </span>is an Ansible construct that is much like a task, except that it only gets called when a change is made. Also, when multiple changes are made to a configuration, the handler can be notified multiple times (once for each applicable change), and yet the Ansible engine batches up all handler calls and runs the handler once, only after the tasks complete. This ensures that when it is used to restart a service, such as in this example, the service is only restarted once, and only then when a change is made. Let's test this now, as follows:</p>
<ol>
<li>First of all, remove the service restart task from the role and add a <kbd>notify</kbd> clause to notify the handler (we shall create this in a minute). The resulting role tasks should look like this:</li>
</ol>
<pre style="padding-left: 60px">---<br/>- name: Copy SSHd configuration to target host<br/>  copy:<br/>    src: files/sshd_config<br/>    dest: /etc/ssh/sshd_config<br/>    owner: root<br/>    group: root<br/>    mode: 0644<br/>  notify:<br/>    - Restart SSH daemon</pre>
<ol start="2">
<li>Now, we need to create a<span> </span><kbd>handlers/</kbd><span> </span>directory in the role and add our previously removed handler code to it so that it looks like this:</li>
</ol>
<pre style="padding-left: 60px">---<br/>- name: Restart SSH daemon<br/>  service:<br/>    name: ssh<br/>    state: restarted</pre>
<ol start="3">
<li>The resulting <kbd>roles</kbd> directory structure should now look like this:</li>
</ol>
<pre style="padding-left: 60px">roles/<br/>└── securesshd<br/>    ├── files<br/>    │   └── sshd_config<br/>    ├── handlers<br/>    │   └── main.yml<br/>    └── tasks<br/>        └── main.yml</pre>
<ol start="4">
<li>Now, when we run the playbook twice on the same server (having initially reverted the SSH configuration to the original one), we see that the SSH daemon is only restarted in the instance where we have actually changed the configuration, as shown in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/fa05dc02-d7f8-4f14-bebe-7de0a2ec42c8.png" style="width:45.08em;height:37.08em;"/></p>
<p>To further demonstrate handlers before we move on, let's consider this enhancement to the role tasks:</p>
<pre>---<br/>- name: Copy SSHd configuration to target host<br/>  copy:<br/>    src: files/sshd_config<br/>    dest: /etc/ssh/sshd_config<br/>    owner: root<br/>    group: root<br/>    mode: 0644<br/>  notify:<br/>    - Restart SSH daemon<br/><br/>- name: Perform an additional modification<br/>  lineinfile:<br/>    path: /etc/ssh/sshd_config<br/>    regexp: '^\# Configured by Ansible'<br/>    line: '# Configured by Ansible on {{ inventory_hostname }}'<br/>    insertbefore: BOF<br/>    state: present<br/>  notify:<br/>    - Restart SSH daemon</pre>
<p>Here, we deploy our configuration file and perform an additional modification. We are putting a comment into the head of the file, which includes an Ansible variable, with the hostname of the target host.</p>
<p>This will result in two changed statuses on our target host, and yet, if we revert to the default SSH daemon configuration and then run our new playbook, we see the following:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/fc3fea96-62c6-4b72-bdd6-7054844eff25.png" style="width:45.25em;height:25.42em;"/></p>
<p>Pay careful attention to the preceding output and the sequence in which the tasks are run. You will note that the handler is not run in sequence and is actually run once at the end of the play.</p>
<div class="packt_tip">Even though our tasks both changed and hence would have notified the handler twice, the handler was only run at the end of the playbook run, minimizing restarts, just as required.</div>
<p>In this manner, we can make changes to static configuration files at large scales, across many hundreds—if not thousands—of machines. In the next section, we will build on this to demonstrate ways of managing configuration where dynamic data is required—for example, configuration parameters that might change on a per-host or per-group basis.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Making scalable dynamic configuration changes</h1>
                </header>
            
            <article>
                
<p>While the preceding examples resolve many of the challenges of making automated configuration changes at scale in an enterprise, it is noticeable that our final example was somewhat inefficient. We deployed a static, version-controlled configuration file, and made a change to it using the<span> </span><kbd>lineinfile</kbd><span> </span>module again.</p>
<p>This allowed us to insert an Ansible variable into the file, which in many instances is incredibly useful, especially when configuring more complex services. However, it is—at best—inelegant to split this change across two tasks. Also, reverting to the use of the<span> </span><kbd>lineinfile</kbd><span> </span>module again exposes us to the risks we discussed earlier and means we would need one<span> </span><kbd>lineinfile</kbd><span> </span>task for every variable we wish to insert into a configuration.</p>
<p>Thankfully, Ansible includes just the answer to such a problem. In this case, the concept of Jinja2 templating comes to our rescue.</p>
<p>Jinja2 is a templating language for Python that is incredibly powerful and easy to use. As Ansible is coded almost entirely in Python, it lends itself well to the use of Jinja2 templates. So, what is a Jinja2 template? At its most fundamental level, it is a static configuration file, such as the one we deployed for the SSH daemon earlier, but with the possibility of variable substitutions. Of course, Jinja2 is far more powerful than that—it is, in essence, a language in its own right, and features common language constructs such as<span> </span><kbd>for</kbd><span> </span>loops and<span> </span><kbd>if...elif...else</kbd><span> </span>constructs, just as you would find in other languages. This makes it incredibly powerful and flexible, and entire sections of a configuration file (for example) can be omitted, depending on how an <kbd>if</kbd> statement evaluates.</p>
<p>As you can imagine, Jinja2 deserves a book of its own to cover the detail of the language—however, here, we will provide a practical hands-on introduction to Jinja2 templating for the automation of configuration management in an enterprise.</p>
<p>Let's go back to our SSH daemon example for a minute, where we wanted to put the target hostname into a comment at the head of the file. While this is a contrived example, progressing it from the<span> </span><kbd>copy</kbd>/<kbd>lineinfile</kbd><span> </span>example to a single<span> </span><kbd>template</kbd><span> </span>task will show the benefits that templating brings. From here, we can progress to a more comprehensive example. To start with, let's define our Jinja2 template for the<span> </span><kbd>sshd_config</kbd><span> </span>file, as follows:</p>
<pre># Configured by Ansible {{ inventory_hostname }}<br/>ChallengeResponseAuthentication no<br/>UsePAM yes<br/>X11Forwarding no<br/>PrintMotd no<br/>AcceptEnv LANG LC_*<br/>Subsystem sftp /usr/lib/openssh/sftp-server<br/>PasswordAuthentication no<br/>PermitRootLogin no</pre>
<p>Notice that the file is identical to the file we deployed using the copy module earlier, only now, we have included the comment in the file header and used the Ansible variable construct (denoted by pairs of curly braces) to insert the<span> </span><kbd>inventory_hostname</kbd><span> </span>variable.</p>
<p>Now, for the sake of our sanity, we will call this file<span> </span><kbd>sshd_config.j2</kbd><span> </span>to ensure we can differentiate templates from flat configuration files. Templates are normally placed into a<span> </span><kbd>templates/</kbd><span> </span>subdirectory within the role, and so are subject to version control in the same way that playbook, roles, and any associated flat configuration files are.</p>
<p>Now, rather than copying the flat file and then performing substitutions with one or more <kbd>lineinfile</kbd> tasks, we can use the Ansible<span> </span><kbd>template</kbd><span> </span>module to deploy this template and parse all Jinja2 constructs.</p>
<p>Thus, our tasks now look like this:</p>
<pre>---<br/>- name: Copy SSHd configuration to target host<br/>  template:<br/>    src: templates/sshd_config.j2<br/>    dest: /etc/ssh/sshd_config<br/>    owner: root<br/>    group: root<br/>    mode: 0644<br/>  notify:<br/>    - Restart SSH daemon</pre>
<p>Notice that the task is almost identical to our earlier<span> </span><kbd>copy</kbd><span> </span>task and that we call our handler, just as before.</p>
<p>The completed module directory structure now looks like this:</p>
<pre>roles<br/>└── securesshd<br/>    ├── handlers<br/>    │   └── main.yml<br/>    ├── tasks<br/>    │   └── main.yml<br/>    └── templates<br/>        └── sshd_config.j2</pre>
<p>Let's run this and evaluate the results, which can be seen in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0f735768-f96d-47c3-b238-69fd6252aa07.png" style="width:53.58em;height:40.33em;"/></p>
<p>As can be seen here, the template has been copied across to the target host, and the variable in the header comment has been processed and the appropriate value substituted.</p>
<p>This becomes incredibly powerful as our configuration becomes more complex as, no matter how large and complex the template, the role still only requires the one <kbd>template</kbd> task. Returning to our MariaDB server, suppose that we want to set a number of parameters on a per-server basis to effect tuning appropriate to the different workloads we are deploying. Perhaps we want to set the following:</p>
<ul>
<li>The server bind-address, defined by<span> </span><kbd>bind-address</kbd></li>
<li>The maximum binary log size, defined by <kbd>max_binlog_size</kbd></li>
<li>The TCP port that MariaDB listens on, as defined by<span> </span><kbd>port</kbd></li>
</ul>
<p>All of these parameters are defined in<span> </span><kbd>/etc/mysql/mariadb.conf.d/50-server.cnf</kbd>. However, as discussed earlier, we need to also ensure the integrity of<span> </span><kbd>/etc/mysql/mariadb.cnf</kbd><span> </span>to ensure it includes this (and other) files, to reduce the possibility of someone overriding our configuration. Let's start building our templates—first of all, a simplified version of the<span> </span><kbd>50-server.cnf</kbd><span> </span>file, with some variable substitutions. The first part of this file is shown in the following code—note the <kbd>port</kbd> and <kbd>bind-address</kbd> parameters, which are now defined using Ansible variables, denoted in the usual manner with pairs of curly braces:</p>
<pre>[server]<br/>[mysqld]<br/>user = mysql<br/>pid-file = /var/run/mysqld/mysqld.pid<br/>socket = /var/run/mysqld/mysqld.sock<br/>port = {{ mariadb_port }}<br/>basedir = /usr<br/>datadir = /var/lib/mysql<br/>tmpdir = /tmp<br/>lc-messages-dir = /usr/share/mysql<br/>skip-external-locking<br/>bind-address = {{ mariadb_bind_address }}</pre>
<p>The second part of this file looks as follows—you will observe here the presence of the <kbd>mariadb_max_binlog_size</kbd> variable, while all other parameters remain static:</p>
<pre>key_buffer_size = 16M<br/>max_allowed_packet = 16M<br/>thread_stack = 192K<br/>thread_cache_size = 8<br/>myisam_recover_options = BACKUP<br/>query_cache_limit = 1M<br/>query_cache_size = 16M<br/>log_error = /var/log/mysql/error.log<br/>expire_logs_days = 10<br/>max_binlog_size = {{ mariadb_max_binlog_size }}<br/>character-set-server = utf8mb4<br/>collation-server = utf8mb4_general_ci<br/>[embedded]<br/>[mariadb]<br/>[mariadb-10.1]</pre>
<p>Now, let's also add in a templated version of<span> </span><kbd>/etc/mysql/mariadb.cnf</kbd>, as follows:</p>
<pre>[client-server]<br/>!includedir /etc/mysql/conf.d/<br/>!includedir /etc/mysql/mariadb.conf.d/</pre>
<p>This file might be short, but it serves a really important purpose. It is the first file that is read by the MariaDB service when it loads, and it references other files or directories to be included. If we did not maintain control of this file using Ansible, then anyone with sufficient privileges could log in and edit the file, possibly including entirely different configurations and bypassing our Ansible-defined configuration entirely. Whenever you deploy configuration with Ansible, it is important to consider factors such as this, as otherwise, your configuration changes might be bypassed by a well-meaning (or otherwise) administrator.</p>
<div class="packt_tip">A template doesn't have to have any Jinja2 constructs in it—if there are no variables to insert, as in our second example, the file will simply be copied as-is to the target machine.</div>
<p>Obviously, it would be slightly more efficient to use the copy module to send this static configuration file to the remote server, but this requires two tasks, where we can use just one with a loop to process all our templates. Such an example is shown in the following code block:</p>
<pre>---<br/>- name: Copy MariaDB configuration files to host<br/>  template:<br/>    src: {{ item.src }}<br/>    dest: {{ item.dest }}<br/>    owner: root<br/>    group: root<br/>    mode: 0644<br/>  loop:<br/>    - { src: 'templates/mariadb.cnf.j2', dest: '/etc/mysql/mariadb.cnf' }<br/>    - { src: 'templates/50-server.cnf.j2', dest: '/etc/mysql/mariadb.conf.d/50-server.cnf' }<br/>  notify:<br/>    - Restart MariaDB Server</pre>
<p>Finally, we define a handler to restart MariaDB if the configuration has changed, as follows:</p>
<pre>---<br/>- name: Restart MariaDB Server<br/>  service:<br/>    name: mariadb<br/>    state: restarted</pre>
<p>Now, before we run this, a word on variables. In Ansible, variables can be defined at a wide number of levels. In a case such as this, where we are applying a different configuration to different hosts with differing purposes, it makes sense to define the variables at the host or hostgroup level. However, what happens if someone were to forget to put these in the inventory, or in another appropriate location? Fortunately, we can leverage the variable precedence order of Ansible to our advantage here and define default variables for our role. These are second lowest on the order of precedence, so are almost always overridden by another setting elsewhere, yet they provide a safety net, should they be missed accidentally. As our preceding templates have been written, if the variables are not defined anywhere, the configuration file will be invalid and the MariaDB server will refuse to start—a case we would definitely like to avoid.</p>
<p>Let's define the default values for these variables in our role now under <kbd>defaults/main.yml</kbd>, as follows:</p>
<pre>---<br/>mariadb_bind_address: "127.0.0.1"<br/>mariadb_port: "3306"<br/>mariadb_max_binlog_size: "100M"</pre>
<p>With this complete, our role structure should look like this:</p>
<pre>roles/<br/>└── configuremariadb<br/>    ├── defaults<br/>    │   └── main.yml<br/>    ├── handlers<br/>    │   └── main.yml<br/>    ├── tasks<br/>    │   └── main.yml<br/>    └── templates<br/>        ├── 50-server.conf.j2<br/>        └── mariadb.cnf.j2</pre>
<p>Naturally, we want to override the default values, so we will define these in our inventory grouping—this is a good use case for inventory groups. All MariaDB servers that serve the same function would go in one inventory group, and then have a common set of inventory variables assigned to them, such that they all receive the same configuration. However, the use of templates in our role means that we can reuse this role in a number of situations, simply by providing differing configurations through variable definition. We will create an inventory for our test host that looks like this:</p>
<pre>[dbservers]<br/>ubuntu-testhost<br/><br/>[dbservers:vars]<br/>mariadb_port=3307<br/>mariadb_bind_address=0.0.0.0<br/>mariadb_max_binlog_size=250M</pre>
<p>With this complete, we can finally run our playbook and observe what happens. The result is shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/33ce9b9d-89fb-489d-ae12-f0c91c7fe9b9.png" style="width:42.08em;height:23.92em;"/></p>
<p>With this successfully run, we have shown a complete end-to-end example of how to manage configuration on an enterprise scale, all while avoiding the pitfalls of regular expression substitutions and multi-part configurations. Although these examples are simple, they should serve as the basis for any well-thought-out enterprise automation strategy where a configuration is required.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Managing configuration across an enterprise Linux estate is filled with pitfalls and the potential for configuration drift. This can be caused by people with good intentions, even in <em>break-fix</em> scenarios where changes have to be made in a hurry. However, it can also be caused by those with malicious intent, seeking to circumvent security requirements. Good use of Ansible, especially templating, enables the construction of easy-to-read, concise playbooks that make it easy to ensure configuration management is reliable, repeatable, auditable, and version-controlled—all the basic tenets we set out earlier in this book for good enterprise automation practice.</p>
<p>In this chapter, you gained practical experience in extending a Linux machine with new software packages. You then learned how to apply simple, static configuration changes to those packages, and the potential pitfalls associated with this. Finally, you learned best practices for managing configuration across an enterprise using Ansible. In the next chapter, we proceed to look at internal repository management with Pulp.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What are the different Ansible modules commonly used for making changes to configuration files?</li>
<li>How does templating work in Ansible?</li>
<li>Why must you consider configuration file structure when making changes with Ansible?</li>
<li>What are the pitfalls of using regular expressions when making file modifications?</li>
<li>How does a template behave if there are no variables in it?</li>
<li>How can you check that a configuration template you have deployed is valid before committing it to disk?</li>
<li>How can you quickly audit the configuration of 100 machines against a known template with Ansible?</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li>For an in-depth understanding of Ansible, please refer to <em>Mastering Ansible, Third Edition</em>, by<em> James Freeman</em> and <em>Jesse Keating</em> (<a href="https://www.packtpub.com/gb/virtualization-and-cloud/mastering-ansible-third-edition">https://www.packtpub.com/gb/virtualization-and-cloud/mastering-ansible-third-edition</a>).</li>
</ul>


            </article>

            
        </section>
    </body></html>