<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div id="_idContainer110" class="Basic-Text-Frame">
    <h1 class="chapterNumber"><a id="_idTextAnchor341"/>10</h1>
    <h1 id="_idParaDest-311" class="chapterTitle"><a id="_idTextAnchor342"/>Updating Software in the Field</h1>
    <p class="normal">In previous chapters, we discussed various ways to build software for a Linux device and how to create system images for various types of mass storage. When you go into production, you just need to copy the system image to the flash memory, and it is ready to be deployed. Now I want to consider the life of the device beyond the first shipment.</p>
    <p class="normal">As we move into the era of the <em class="italic">Internet of Things</em>, the devices that we create are very likely to be connected to the internet. At the same time, software is becoming exponentially more complex. More software means more bugs. Connection to the internet means those bugs can be exploited from afar. Consequentially, we have a common requirement to be able to update software <em class="italic">in the field</em>. By “in the field,” we mean “outside of the factory.” Software updates bring more advantages than fixing bugs. They open the door to adding value to existing hardware by enabling new features and improving system performance over time.</p>
    <p class="normal">In this chapter, we will cover the following topics:</p>
    <ul>
      <li class="bulletList">From where do updates originate?</li>
      <li class="bulletList">What to update</li>
      <li class="bulletList">Basics of software updates</li>
      <li class="bulletList">Types of update mechanism</li>
      <li class="bulletList">OTA updates</li>
      <li class="bulletList">Using Mender for local updates</li>
      <li class="bulletList">Using Mender for OTA updates</li>
    </ul>
    <h1 id="_idParaDest-312" class="heading-1"><a id="_idTextAnchor343"/>Technical requirements</h1>
    <p class="normal">To follow along with the examples, make sure you have the following:</p>
    <ul>
      <li class="bulletList">An Ubuntu 24.04 or later LTS host system with at least 90 GB of free disk space</li>
      <li class="bulletList">Yocto 5.0 (scarthgap) LTS release</li>
    </ul>
    <p class="normal">You should have already built the 5.0 (scarthgap) LTS release of Yocto in <a href="Chapter_04.xhtml#_idTextAnchor110"><em class="italic">Chapter 6</em></a>. If you have not, then please refer to the <em class="italic">Compatible Linux Distributions</em> and <em class="italic">Build Host Packages</em> sections of the <em class="italic">Yocto Project Quick Build</em> guide (<a href="https://docs.yoctoproject.org/brief-yoctoprojectqs/)"><span class="url">https://docs.yoctoproject.org/brief-yoctoprojectqs/)</span></a> before building Yocto on your Linux host according to the instructions in <a href="Chapter_04.xhtml#_idTextAnchor110"><em class="italic">Chapter 6</em></a>.</p>
    <p class="normal">The code used in this chapter can be found in the chapter folder in this book’s GitHub repository: <a href="https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter10"><span class="url">https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter10</span></a>.</p>
    <h1 id="_idParaDest-313" class="heading-1"><a id="_idTextAnchor344"/>From where do updates originate?</h1>
    <p class="normal">There are many approaches to software updates. Broadly, I characterize them as the following:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Local updates</strong>: Performed by a technician who carries the update on a portable medium such as a USB flash drive<a id="_idIndexMarker743"/> or an SD card and has to access each system individually.</li>
      <li class="bulletList"><strong class="keyWord">Remote updates</strong>: Initiated by the user <a id="_idIndexMarker744"/>or a technician locally, but downloaded from a remote server.</li>
      <li class="bulletList"><strong class="keyWord">Over-the-air</strong> (<strong class="keyWord">OTA</strong>) <strong class="keyWord">updates</strong>: Pushed and <a id="_idIndexMarker745"/>managed entirely remotely<a id="_idIndexMarker746"/> without any need for local input.</li>
    </ul>
    <p class="normal">I will begin by describing several approaches to software updates, then I will show an example using Mender.</p>
    <h1 id="_idParaDest-314" class="heading-1"><a id="_idTextAnchor345"/>What to update</h1>
    <p class="normal">Embedded Linux devices are very diverse in their design and implementation. However, they all have these<a id="_idIndexMarker747"/> basic components:</p>
    <ul>
      <li class="bulletList">Bootloader</li>
      <li class="bulletList">Kernel</li>
      <li class="bulletList">Root filesystem</li>
      <li class="bulletList">System applications</li>
      <li class="bulletList">Device-specific data</li>
    </ul>
    <p class="normal">Some components are harder to update than others, as summarized in this diagram:</p>
    <figure class="mediaobject"><img src="../Images/B18466_10_01.png" alt="Figure 10.1 – Components of an update" width="1023" height="715"/></figure>
    <p class="packt_figref">Figure 10.1 – Components of an update</p>
    <p class="normal">Let’s look at each component in turn.</p>
    <h2 id="_idParaDest-315" class="heading-2"><a id="_idTextAnchor346"/>Bootloader</h2>
    <p class="normal">The bootloader is the first piece of code to run when the processor is powered up. The way the processor locates the bootloader is very device-specific, but in most cases, there is only one such location, so there can only be <a id="_idIndexMarker748"/>one bootloader. If there is no backup, then updating the bootloader is risky: what happens if the system powers down midway? Consequently, most update solutions leave the bootloader alone. This is not a big problem, because the bootloader only runs for a short time at power-on and is not normally a great source of runtime bugs.</p>
    <h2 id="_idParaDest-316" class="heading-2"><a id="_idTextAnchor347"/>Kernel</h2>
    <p class="normal">The Linux kernel is a critical <a id="_idIndexMarker749"/>component that will certainly need updating from time to time.</p>
    <p class="normal">There are several parts to the kernel:</p>
    <ul>
      <li class="bulletList">A binary image loaded by the bootloader, often stored in the root filesystem.</li>
      <li class="bulletList">Many devices also have a <strong class="keyWord">device tree binary</strong> (<strong class="keyWord">DTB</strong>) that describes hardware to the kernel, and so must be updated in<a id="_idIndexMarker750"/> tandem. The DTB is usually stored alongside the kernel binary.</li>
      <li class="bulletList">There may be kernel modules in the root filesystem.</li>
    </ul>
    <p class="normal">The kernel and DTB may be stored in the root filesystem if the bootloader can read the filesystem format, or it may be in a dedicated partition. In either case, it is possible and safer to have redundant copies.</p>
    <h2 id="_idParaDest-317" class="heading-2"><a id="_idTextAnchor348"/>Root filesystem</h2>
    <p class="normal">The root filesystem contains the essential system libraries, utilities, and scripts needed to make the system work. It is very <a id="_idIndexMarker751"/>desirable to be able to replace and upgrade all of these. The mechanism depends on the filesystem implementation.</p>
    <p class="normal">Common formats for embedded root filesystems are the following:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">RAM disk</strong>: Loaded from raw flash memory or a disk image at boot. To update it, simply overwrite the RAM disk image and reboot.</li>
      <li class="bulletList"><strong class="keyWord">Read-only compressed filesystems (squashfs</strong>): Stored in a flash partition. Since these filesystems don’t have a write function, the only way to update them is to write a complete filesystem image to the partition.</li>
      <li class="bulletList"><strong class="keyWord">Normal filesystem types</strong>: JFFS2 and UBIFS formats are common for raw flash memory. For managed flash memory such as eMMC and SD cards, the format is likely to be ext4 or F2FS. Since these are writable at runtime, it is possible to update them file by file.</li>
    </ul>
    <h2 id="_idParaDest-318" class="heading-2"><a id="_idTextAnchor349"/>System applications</h2>
    <p class="normal">The system applications are the main payload of the device; they implement its primary function. As such, they are likely to be<a id="_idIndexMarker752"/> updated frequently to fix bugs and add features. They may be bundled with the root filesystem, but it is also common for them to be placed in a separate filesystem to make updating easier and to maintain separation between the system files, which are usually open source, and the application files, which are often proprietary.</p>
    <h2 id="_idParaDest-319" class="heading-2"><a id="_idTextAnchor350"/>Device-specific data</h2>
    <p class="normal">This is the combination of files that are <a id="_idIndexMarker753"/>modified at runtime. Device-specific data includes configuration settings, logs, user-supplied data, and similar files. It is not often that they need to be updated, but they do need to be preserved during an update. Such data needs to be stored in a partition of its own.</p>
    <h2 id="_idParaDest-320" class="heading-2"><a id="_idTextAnchor351"/>Components that need to be updated</h2>
    <p class="normal">In summary, an update may include new versions of the kernel, root filesystem, and system applications. The device will have other partitions that should not be disturbed by an update, as is the case with the device runtime data.</p>
    <p class="normal">The cost of software updates <a id="_idIndexMarker754"/>failing can be catastrophic. Secure software updates are also a major concern within both enterprise and home internet environments. Before we can ship any hardware, we need to be able to update the software with confidence.</p>
    <h1 id="_idParaDest-321" class="heading-1"><a id="_idTextAnchor352"/>Basics of software updates</h1>
    <p class="normal">Updating software seems, at first sight, to be a simple task: you just need to overwrite some files with new copies. But then your engineer training kicks in as you begin to realize all the things that could go wrong. What if the power goes down during the update? What if a bug missed during testing of the update<a id="_idIndexMarker755"/> renders a percentage of the devices unbootable? What if a third party sends a fake update that enlists your device as part of a botnet? At the very least, the software update mechanism must be:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Robust</strong> so that an update does not render the device unusable.</li>
      <li class="bulletList"><strong class="keyWord">Fail-safe</strong> so that there is a fallback mode if all else fails.</li>
      <li class="bulletList"><strong class="keyWord">Secure</strong> to prevent the device from being hijacked by people installing unauthorized updates.</li>
    </ul>
    <p class="normal">In other words, we need a system that is not susceptible to Murphy’s law. Murphy’s law states that if something can go wrong, then it eventually will go wrong. Some of these problems are non-trivial. Deploying software to a device in the field is different from deploying software to the cloud. Embedded Linux systems need to detect and respond to mishaps like kernel panics or boot loops without any human intervention.</p>
    <h2 id="_idParaDest-322" class="heading-2"><a id="_idTextAnchor353"/>Making updates robust</h2>
    <p class="normal">You might think that the problem of updating Linux systems was solved a long time ago − we all have Linux desktops that we update regularly (don’t we?). Also, there are vast numbers of Linux servers running in data centers that are similarly kept up to date. However, there is a difference between a server and a <a id="_idIndexMarker756"/>device. The former operates in a protected environment. It is unlikely to suffer a sudden loss of power or network connectivity. In the unlikely event that an update does fail, it is always possible to get access to the server and use external mechanisms to repeat the installation.</p>
    <p class="normal">Devices, on the other hand, are often deployed at remote sites with intermittent power and a poor network connection, making it much more likely that an update will be interrupted. Therefore, consider that it may be very expensive to get access to a device to take remedial action over a failed update. What if, for example, the device is an environmental monitoring station at the top of a mountain or controlling the valves of an oil well at the bottom of the sea? In consequence, it is much more important for embedded devices to have a robust update mechanism that will not result in the system becoming unusable.</p>
    <p class="normal">The key word here is <strong class="keyWord">atomicity</strong>. To be atomic, there should be no stage of the update where only part of the system is updated. There<a id="_idIndexMarker757"/> must be a single, uninterruptible change to the system that switches to the new version of the software.</p>
    <p class="normal">This removes the most obvious update mechanism from consideration: that of simply updating individual files by extracting an archive over parts of the filesystem. There is just no way to ensure that there will be a consistent set of files if the system is reset during the update. Even using a package manager such as <code class="inlineCode">apt</code>, <code class="inlineCode">dnf</code>, or <code class="inlineCode">pacman</code> does not help. If you look at the internals of all these package managers, you will see that they do indeed work by extracting an archive over the filesystem and running scripts to configure the package both before and after the update. Package managers are fine for the protected world of the data center, or even your desktop, but not for a device.</p>
    <p class="normal">To achieve atomicity, the update must be installed alongside the running system, and then a switch is thrown to move from the old to the new. In later sections, we will describe two different approaches to achieving atomicity. The first is to have two copies of the root filesystem and other major components. One copy is live, while the other can receive updates. When the update is complete, the switch is thrown so that, on reboot, the bootloader selects the updated copy. This<a id="_idIndexMarker758"/> is known as a <strong class="keyWord">symmetric image update</strong> or an <strong class="keyWord">A/B image update</strong>. A variant of this theme is to use a special <strong class="keyWord">recovery mode</strong> operating <a id="_idIndexMarker759"/>system that is responsible for updating the main operating system. The guarantee of atomicity is shared between the bootloader and the recovery operating system. This is known<a id="_idIndexMarker760"/> as an <strong class="keyWord">asymmetric image update</strong>. It is the approach taken by Android prior to the Nougat 7.x version. The second approach is to have two or more copies of the root filesystem in different subdirectories of the system partition, and then use <code class="inlineCode">chroot(8)</code> at boot time to select one of them. Once Linux is running, the update client can install updates into the other root filesystem, and then when everything is complete and checked, it can throw <a id="_idIndexMarker761"/>the switch and reboot. This is known as an <strong class="keyWord">atomic file update</strong> and<a id="_idIndexMarker762"/> is exemplified by <strong class="keyWord">OSTree</strong>.</p>
    <h2 id="_idParaDest-323" class="heading-2"><a id="_idTextAnchor354"/>Making updates fail-safe</h2>
    <p class="normal">The next problem to consider is that of recovering from an update that was installed correctly but that contains code that stops the system from booting. Ideally, we want the system to detect this case and revert to a previous <a id="_idIndexMarker763"/>working image.</p>
    <p class="normal">There are several failure modes that can lead to a non-operational system. The first is a kernel panic, typically caused by a bug in a kernel device driver or being unable to run the <code class="inlineCode">init</code> program. A sensible place to start is by configuring the kernel to reboot a number of seconds after a panic. </p>
    <p class="normal">You can do this either when you build the kernel by setting <code class="inlineCode">CONFIG_PANIC_TIMEOUT</code> or by setting the kernel command line to <code class="inlineCode">panic</code>. For example, to reboot 5 seconds after a panic, you would add <code class="inlineCode">panic=5</code> to the kernel command line.</p>
    <p class="normal">You may want to go further and configure the kernel to <code class="inlineCode">panic</code> on an Oops. Remember that an Oops is generated when the kernel encounters a fatal error. In some cases, it will be able to recover from the error, in other cases not. But in all cases, something has gone wrong and the system is not working as it should. To enable panic on Oops in the kernel configuration, set <code class="inlineCode">CONFIG_PANIC_ON_OOPS=y</code> or, on the kernel command line, <code class="inlineCode">oops=panic</code>.</p>
    <p class="normal">A second failure mode occurs when the kernel launches <code class="inlineCode">init</code> successfully but for some reason the main application fails to run. For this, you <a id="_idIndexMarker764"/>need a watchdog. A <strong class="keyWord">watchdog</strong> is a hardware or software timer that restarts the system if the timer is not reset before it expires. If you are using <code class="inlineCode">systemd</code>, you can use the built-in watchdog function, which I’ll describe in <a href="Chapter_13.xhtml#_idTextAnchor431"><em class="italic">Chapter 13</em></a>. If not, then you may want to enable the watchdog support built into Linux as described in <code class="inlineCode">Documentation/watchdog</code> from the kernel source code.</p>
    <p class="normal">Both failures result in <strong class="keyWord">boot loops</strong>: either a<a id="_idIndexMarker765"/> kernel panic or a watchdog timeout causes the system to reboot. If the problem is persistent, the system will reboot continually. To break out of the boot loop, we need some code in the bootloader to detect the case and to revert to the previously known good version. A typical approach is to <a id="_idIndexMarker766"/>use a <strong class="keyWord">boot count</strong> that is incremented by the bootloader on each boot and that is reset to zero in user space once the system is up and running. If the system enters a boot loop, the counter is not reset and so continues to increase. The bootloader is then configured to take remedial action if the counter exceeds a threshold.</p>
    <p class="normal">In U-Boot this is handled by three variables:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">bootcount</code>: Incremented each time the processor boots.</li>
      <li class="bulletList"><code class="inlineCode">bootlimit</code>: If <code class="inlineCode">bootcount</code> exceeds <code class="inlineCode">bootlimit</code>, U-Boot runs the commands in <code class="inlineCode">altbootcmd</code> instead of <code class="inlineCode">bootcmd</code>.</li>
      <li class="bulletList"><code class="inlineCode">altbootcmd</code>: Contains the alternative boot commands, for example, to roll back to a previous version of the software or to start the recovery-mode operating system.</li>
    </ul>
    <p class="normal">For this to work, there must be a way for a user-space program to reset the boot count. We can do that using U-Boot utilities that allow the U-Boot environment to be accessed at runtime:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">fw_printenv</code>: Prints the value of a U-Boot variable</li>
      <li class="bulletList"><code class="inlineCode">fw_setenv</code>: Sets the value of a U-Boot variable</li>
    </ul>
    <p class="normal">These two commands need to know where the U-Boot environment block is stored, for which there is a configuration file in <code class="inlineCode">/etc/fw_env.config</code>. For example, if the U-Boot environment is stored at offset <code class="inlineCode">0x800000</code> from the start of the eMMC memory with a backup copy at <code class="inlineCode">0x1000000</code>, then the configuration would look like this:</p>
    <pre class="programlisting code"><code class="hljs-code"># cat /etc/fw_env.config
/dev/mmcblk0 0x800000 0x40000
/dev/mmcblk0 0x1000000 0x40000
</code></pre>
    <p class="normal">There is one final thing to <a id="_idIndexMarker767"/>cover in this section. Incrementing the boot count on each boot and then resetting it when the application starts leads to unnecessary writes to the environment block that wear out the flash memory. To prevent this from happening on all reboots, U-Boot has an additional variable named <code class="inlineCode">upgrade_available</code>. If <code class="inlineCode">upgrade_available</code> is <code class="inlineCode">0</code>, then <code class="inlineCode">bootcount</code> is not incremented since there is no unproven upgrade to guard against. <code class="inlineCode">upgrade_available</code> is set to <code class="inlineCode">1</code> after an update has been installed so that the boot count protection is only enabled when needed.</p>
    <h2 id="_idParaDest-324" class="heading-2"><a id="_idTextAnchor355"/>Making updates secure</h2>
    <p class="normal">The final problem relates to the potential misuse of the update mechanism itself. Your prime intention when implementing an<a id="_idIndexMarker768"/> update mechanism is to provide a reliable automated or semi-automated method to install security patches and new features. However, others may use the same mechanism to install unauthorized versions of software and hijack the device. We need to ensure that this does not happen.</p>
    <p class="normal">The biggest vulnerability is that of a fake remote update. To prevent this, we need to authenticate the update server before starting the download. We also need a secure transfer channel, such as HTTPS, to guard against tampering with the download stream. Checksums offer a second line of defense. A checksum is generated for each update and published on the server. The update only gets applied if the checksum validates against the download. I will return to the topic of server authenticity when I describe OTA updates.</p>
    <p class="normal">There is also the question of image authenticity. One way to detect a bogus update is to use a Secure Boot protocol in the bootloader. If the kernel image is signed at the factory with a digital key, the bootloader can check the signature before it loads the kernel and refuse to load it if verification fails. As long as the keys are kept private by the manufacturer, it will not be possible to load a kernel that is not authorized. U-Boot implements such a mechanism, which is described in the online documentation at <a href="https://docs.u-boot.org/en/latest/usage/fit/verified-boot.html.%0D%0A"><span class="url">https://docs.u-boot.org/en/latest/usage/fit/verified-boot.html.</span></a></p>
    <div class="note">
      <p class="normal"><strong class="keyWord">IMPORTANT NOTE</strong></p>
      <p class="normal">Secure Boot: good or bad?</p>
      <p class="normal">If I have purchased a device that has a software update feature, then I am trusting the vendor of that device to deliver useful updates. I definitely do not want a malicious third party to install software without my knowledge. But should I be allowed to install the software myself? If I own the device outright, should I not be entitled to modify it, including loading new software? Recall the TiVo set-top box, which ultimately led to the creation of the GPL v3 license. Remember the Linksys WRT54G Wi-Fi router. When access to the hardware became easy, it spawned a whole new industry, including the OpenWrt project. This is a complex issue that sits at the crossroads between freedom and control. It is my opinion that some device manufacturers use security as an excuse to protect their (sometimes shoddy) software. </p>
    </div>
    <p class="normal">Updating software may seem mundane but a bad update can do catastrophic damage to your business. The CrowdStrike outage of July 2024 is a perfect example. For that reason, it is important to roll out <a id="_idIndexMarker769"/>updates incrementally using safe techniques like blue-green deployments. That way, if something goes bad, you can roll back a software release without impacting many of your users. Now that we know what is required, how do we go about updating software on embedded Linux systems?</p>
    <h1 id="_idParaDest-325" class="heading-1"><a id="_idTextAnchor356"/>Types of update mechanism</h1>
    <p class="normal">In this section, I will describe three approaches to applying software updates: symmetric, or A/B, image update; asymmetric image <a id="_idIndexMarker770"/>update, also known as <em class="italic">recovery mode update</em>; and finally, atomic file update.</p>
    <h2 id="_idParaDest-326" class="heading-2"><a id="_idTextAnchor357"/>Symmetric image update</h2>
    <p class="normal">In this scheme, there are two copies of the<a id="_idIndexMarker771"/> operating system, each comprising the Linux kernel, root filesystem, and system applications. They are labeled as <strong class="screenText">A</strong> and <strong class="screenText">B</strong> in the<a id="_idIndexMarker772"/> following diagram:</p>
    <figure class="mediaobject"><img src="../Images/B18466_10_02.png" alt="Figure 10.2 – Symmetric image update" width="930" height="624"/></figure>
    <p class="packt_figref">Figure 10.2 – Symmetric image update</p>
    <p class="normal">Symmetric image updates work as follows:</p>
    <ol>
      <li class="numberedList" value="1">The bootloader has a flag that indicates which image it should load. Initially, the flag is set to <strong class="screenText">A</strong>, so the bootloader loads OS image <strong class="screenText">A</strong>.</li>
      <li class="numberedList">To install an update, the updater application, which is part of the operating system, overwrites OS image <strong class="screenText">B</strong>.</li>
      <li class="numberedList">When complete, the updater changes the boot flag to <strong class="screenText">B</strong> and reboots.</li>
      <li class="numberedList">Now the bootloader will load the new operating system.</li>
      <li class="numberedList">When a further update is installed, the updater overwrites image <strong class="screenText">A</strong> and changes the boot flag to <strong class="screenText">A</strong>, so you ping-pong between the two copies.</li>
      <li class="numberedList">If an update fails before the boot flag is changed, the bootloader continues to load the good operating system.</li>
    </ol>
    <p class="normal">There are several open-source <a id="_idIndexMarker773"/>projects that implement symmetric image updates. One is the <strong class="keyWord">Mender</strong> client operating in standalone mode, which I will describe in the <em class="italic">Using Mender for local updates</em> section. Another is <strong class="keyWord">SWUpdate</strong> (<a href="https://github.com/sbabic/swupdate"><span class="url">https://github.com/sbabic/swupdate</span></a>), which can receive multiple image updates in a CPIO <a id="_idIndexMarker774"/>format package and then deploy those updates to different parts of the system. It allows you to write plugins in the Lua language to do custom processing. </p>
    <p class="normal">SWUpdate also has filesystem support for raw flash memory that is accessed as MTD flash partitions, for storage organized into UBI volumes, and for SD/eMMC storage with a disk partition table. A third <a id="_idIndexMarker775"/>example is <strong class="keyWord">RAUC</strong>, the <strong class="keyWord">Robust Auto-Update Controller</strong> (<a href="https://github.com/rauc/rauc"><span class="url">https://github.com/rauc/rauc</span></a>). It too has support for raw flash storage, UBI volumes, and SD/eMMC<a id="_idIndexMarker776"/> devices. The images can be signed and verified using OpenSSL keys. A fourth example is <strong class="keyWord">fwup</strong> (<a href="https://github.com/fwup-home/fwup"><span class="url">https://github.com/fwup-home/fwup</span>)</a> by long-time Buildroot contributor Frank Hunleth.</p>
    <p class="normal">There are some drawbacks to this scheme. One is that by updating an entire filesystem image, the size of the update package is<a id="_idIndexMarker777"/> large, which can put a strain on the network infrastructure connecting the devices. This can be mitigated by sending only the filesystem blocks that have changed by performing a binary <code class="inlineCode">diff</code> of the new filesystem with the previous version. SWUpdate, RAUC, and fwup all have support for such <strong class="keyWord">delta updates</strong>. So does the commercial edition of Mender.</p>
    <p class="normal">A second drawback is the need<a id="_idIndexMarker778"/> to keep storage space for a redundant copy of the root filesystem and other components. If the root filesystem is the largest component, it comes close to doubling the amount of flash memory you need to fit both copies. It is for this reason that the asymmetric update scheme is used.</p>
    <h2 id="_idParaDest-327" class="heading-2"><a id="_idTextAnchor358"/>Asymmetric image update</h2>
    <p class="normal">You can reduce storage requirements<a id="_idIndexMarker779"/> by keeping a minimal<a id="_idIndexMarker780"/> recovery operating system purely for updating the main one as shown here:</p>
    <figure class="mediaobject"><img src="../Images/B18466_10_03.png" alt="Figure 10.3 – Asymmetric image update" width="918" height="610"/></figure>
    <p class="packt_figref">Figure 10.3 – Asymmetric image update</p>
    <p class="normal">To install an asymmetric update, do the following:</p>
    <ol>
      <li class="numberedList" value="1">Set the boot flag to point to the recovery OS and reboot.</li>
      <li class="numberedList">Once the recovery OS is running, it can stream updates to the main operating system image.</li>
      <li class="numberedList">If the update is interrupted, the bootloader will again boot into the recovery OS, which can resume the update.</li>
      <li class="numberedList">Only when the update is complete and verified will the recovery OS clear the boot flag and reboot again—this time, loading the new main operating system.</li>
      <li class="numberedList">The fallback in the case of a correct but buggy update is to drop the system back into recovery mode, which can attempt remedial actions, possibly by requesting an earlier update version.</li>
    </ol>
    <p class="normal">The recovery OS is usually a lot smaller than the main operating system, maybe only a few megabytes, and so the storage overhead is not great. As a matter of interest, this is the scheme that was adopted by Android<a id="_idIndexMarker781"/> prior to the Nougat release. For open-source implementations of an asymmetric image update, consider SWUpdate or RAUC.</p>
    <p class="normal">A major drawback of this scheme<a id="_idIndexMarker782"/> is that while the recovery OS is running, the device is not operational. Such a scheme also does not allow for updates of the recovery OS itself. That would require something like A/B image updates, thus defeating the whole purpose.</p>
    <h2 id="_idParaDest-328" class="heading-2"><a id="_idTextAnchor359"/>Atomic file updates</h2>
    <p class="normal">Another approach is to have redundant copies of a root filesystem present in multiple directories of a single filesystem and then <a id="_idIndexMarker783"/>use the <code class="inlineCode">chroot(8)</code> command to<a id="_idIndexMarker784"/> choose one of them at boot time. This allows one directory tree to be updated while another is mounted as the root directory. Furthermore, rather than making copies of files that have not changed between versions of the root filesystem, you could use links. That would save a lot of disk space and reduce the amount of data to be downloaded in an update package. These are the basic ideas behind atomic file updates.</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">IMPORTANT NOTE</strong></p>
      <p class="normal">The <code class="inlineCode">chroot</code> command runs a program in an existing directory. The program sees this directory as its root directory and so cannot access any files or directories at a higher level. It is often used to run a program in a constrained environment, which is<a id="_idIndexMarker785"/> sometimes referred to as <strong class="keyWord">chroot jail</strong>.</p>
    </div>
    <p class="normal">The <strong class="keyWord">libostree</strong> project (<a href="https://github.com/ostreedev/ostree"><span class="url">https://github.com/ostreedev/ostree</span></a>), formerly <strong class="keyWord">OSTree</strong>, is the most popular<a id="_idIndexMarker786"/> implementation of this<a id="_idIndexMarker787"/> idea. OSTree started around 2011 as a means of deploying updates to the GNOME desktop developers and improving their continuous integration testing. </p>
    <p class="normal">It has since been adopted as an update solution for embedded devices. It is one of the update methods available in <strong class="keyWord">Automotive Grade Linux</strong> (<strong class="keyWord">AGL</strong>), and it is <a id="_idIndexMarker788"/>available in The Yocto Project through the <code class="inlineCode">meta-updater</code> layer, which is supported by <strong class="keyWord">Advanced Telematic Systems</strong> (<strong class="keyWord">ATS</strong>).</p>
    <p class="normal">With OSTree, the files are stored on the<a id="_idIndexMarker789"/> target in the <code class="inlineCode">/ostree/repo/objects</code> directory. They are given names such that several versions of the same file can exist in the repository. Then, a given set of files is linked into a deployment directory which has a name such as <code class="inlineCode">/ostree/deploy/os/29ff9…/</code>. This is referred to as <em class="italic">checking out</em> since it has some similarities to the way a branch is checked out of a Git repository. Each deployment directory contains the files that make up a root filesystem. There can be any number of them, but by default there are only two. For example, here are two <code class="inlineCode">deploy</code> directories, each with links back into the <code class="inlineCode">repo</code> directory:</p>
    <pre class="programlisting code"><code class="hljs-code">/ostree/repo/objects/...
/ostree/deploy/os/a3c83.../
 /usr/bin/bash
 /usr/bin/echo
/ostree/deploy/os/29ff9.../
 /usr/bin/bash
 /usr/bin/echo
</code></pre>
    <p class="normal">To boot from an OSTree directory:</p>
    <ol>
      <li class="numberedList" value="1">The bootloader boots the<a id="_idIndexMarker790"/> kernel with an <code class="inlineCode">initramfs</code> passing on the kernel command line the path of the deployment to use:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attribute">bootargs</span><span class="hljs-operator">=</span>ostree<span class="hljs-operator">=/</span>ostree/deploy/os/deploy/<span class="hljs-number">29</span>ff9...
</code></pre>
      </li>
      <li class="numberedList">The <code class="inlineCode">initramfs</code> contains an <code class="inlineCode">init</code> program named <code class="inlineCode">ostree-init</code> that reads the command line and executes the <code class="inlineCode">chroot</code> to the path given.</li>
      <li class="numberedList">When a system update is installed, the files that have changed are downloaded into the <code class="inlineCode">repo</code> directory by the OSTree install agent.</li>
      <li class="numberedList">When complete, a new <code class="inlineCode">deploy</code> directory is created with links to the collection of files that will make up the new root filesystem. Some of these will be new files. Some will be the same as before.</li>
      <li class="numberedList">Finally, the OSTree install agent will change the bootloader’s boot flag so that on the next reboot, it will <code class="inlineCode">chroot</code> to the new <code class="inlineCode">deploy</code> directory.</li>
      <li class="numberedList">The bootloader implements the check on the boot count and falls back to the previous root if a boot loop is detected.</li>
    </ol>
    <p class="normal">Even though a developer can operate the updater or install the client manually on a target device, eventually software updates need to happen automatically OTA.</p>
    <h1 id="_idParaDest-329" class="heading-1"><a id="_idTextAnchor360"/>OTA updates</h1>
    <p class="normal">Updating <strong class="keyWord">OTA</strong> means having the ability to push software to a device or group of devices via a network, usually without any <a id="_idIndexMarker791"/>end user interaction with the device. For this to happen, we need a central server to control the update process and a protocol for downloading the update to the update client. In a typical implementation, the client polls the update server from time to time to check if there are any updates pending. The polling interval needs to be long enough that the poll traffic does not take a significant portion of the network bandwidth, but short enough that the updates can be delivered in a timely fashion. An interval of tens of minutes to several hours is often a good compromise. The poll messages from the device contain some sort of unique identifier, such as a serial number or MAC address, and the current software version. From this the update server can see if an update is needed. The poll messages may also contain other status information such as uptime, environmental parameters, or anything that would be useful for the central management of the devices.</p>
    <p class="normal">The update server is usually linked to a management system that will assign new versions of software to the various populations of devices under its control. If the device population is large, it may send updates in batches to avoid overloading the network. There will be some sort of status display where the current state of the devices can be shown and problems highlighted.</p>
    <p class="normal">Of course, the update mechanism must be secure so that fake updates cannot be sent to the end devices. This involves the client and server being able to authenticate each other by an exchange of certificates. Then the client can validate that the packages downloaded are signed by the key that is expected.</p>
    <p class="normal">Here are three examples <a id="_idIndexMarker792"/>of open-source projects that you can use for OTA updates:</p>
    <ul>
      <li class="bulletList">Mender in managed mode</li>
      <li class="bulletList">balena</li>
      <li class="bulletList">Eclipse hawkBit (<a href="https://github.com/eclipse/hawkbit"><span class="url">https://github.com/eclipse/hawkbit</span>)</a> in conjunction with an updater client such as SWUpdate or RAUC</li>
    </ul>
    <p class="normal">We will walk through Mender in detail.</p>
    <h1 id="_idParaDest-330" class="heading-1"><a id="_idTextAnchor361"/>Using Mender for local updates</h1>
    <p class="normal">So much for the theory. In the remaining sections of this chapter, I will demonstrate how these principles work in practice. The first set of examples involves Mender. Mender uses a symmetric A/B image update<a id="_idIndexMarker793"/> mechanism with a fallback in the event of a failed update. It can operate in <em class="italic">standalone mode</em> for local updates or in <em class="italic">managed mode</em> for OTA updates. I will begin with standalone mode.</p>
    <p class="normal">Mender is written and supported by Northern.tech. There is much more information about the software in the <strong class="screenText">Documentation</strong> <a id="_idIndexMarker794"/>section of the website (<a href="https://mender.io"><span class="url">https://mender.io</span></a>). I will not delve deeply into the configuration of the software here since my aim is to illustrate the principles of software updates. Let’s begin with the Mender client.</p>
    <h2 id="_idParaDest-331" class="heading-2"><a id="_idTextAnchor362"/>Building the Mender client</h2>
    <p class="normal">The Mender client is available as a Yocto meta layer. These examples use the scarthgap release of The Yocto Project, which is the same one that we used in <a href="Chapter_04.xhtml#_idTextAnchor110"><em class="italic">Chapter 6</em></a>.</p>
    <p class="normal">Start by fetching the <code class="inlineCode">meta-mender</code> layer as follows:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span><span class="language-bash">git </span><span class="hljs-con-built_in">clone</span><span class="language-bash"> -b scarthgap https://github.com/mendersoftware/meta-mender</span>
</code></pre>
    <p class="normal">You want to navigate one level above the <code class="inlineCode">poky</code> directory before cloning the <code class="inlineCode">meta-mender</code> layer so that the two directories are<a id="_idIndexMarker795"/> located next to each other at the same level.</p>
    <p class="normal">The Mender client requires some changes to the configuration of U-Boot to handle the boot flag and boot count variables. The stock Mender client layer has sub-layers for sample implementations of this U-Boot integration that we can use straight out of the box, such as <code class="inlineCode">meta-mender-qemu</code> and <code class="inlineCode">meta-mender-raspberrypi</code>. We will use QEMU.</p>
    <p class="normal">The next step is to create a build directory and add the layers for this configuration:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span><span class="hljs-con-built_in">source</span><span class="language-bash"> poky/oe-init-build-env build-mender-qemu</span>
<span class="hljs-con-meta">$ </span><span class="language-bash">bitbake-layers add-layer ../meta-openembedded/meta-oe</span>
<span class="hljs-con-meta">$ </span><span class="language-bash">bitbake-layers add-layer ../meta-mender/meta-mender-core</span>
<span class="hljs-con-meta">$ </span><span class="language-bash">bitbake-layers add-layer ../meta-mender/meta-mender-demo</span>
<span class="hljs-con-meta">$ </span><span class="language-bash">bitbake-layers add-layer ../meta-mender/meta-mender-qemu</span>
</code></pre>
    <p class="normal">Then, we need to set up the environment by adding some settings to <code class="inlineCode">conf/local.conf</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><a id="_idTextAnchor363"/>1 MENDER_ARTIFACT_NAME = "release-1"
<a id="_idTextAnchor364"/>2 INHERIT += "mender-full"
<a id="_idTextAnchor365"/>3 MACHINE = "vexpress-qemu"
<a id="_idTextAnchor366"/>4 INIT_MANAGER = "systemd"
<a id="_idTextAnchor367"/>5 IMAGE_FSTYPES = "ext4"
</code></pre>
    <p class="normal">Omit the line numbers (<em class="italic">1</em> to <em class="italic">5</em>) from <code class="inlineCode">conf/local.conf</code>. <em class="italic">Line 2</em> includes a BitBake class named <code class="inlineCode">mender-full</code>, which is responsible for the special processing of the image required to create the A/B image format. <em class="italic">Line 3</em> selects a machine named <code class="inlineCode">vexpress-qemu</code>, which uses QEMU to emulate an Arm Versatile <a id="_idIndexMarker796"/>Express board instead of the Versatile PB that is the default for The Yocto Project. <em class="italic">Line 4</em> selects <code class="inlineCode">systemd</code> as the i<code class="inlineCode">nit</code> daemon in place of the default System V <code class="inlineCode">init</code>. I describe <code class="inlineCode">init</code> daemons in more detail in <a href="Chapter_13.xhtml#_idTextAnchor431"><em class="italic">Chapter 13</em></a>. <em class="italic">Line 5</em> causes the root filesystem images to be generated in <code class="inlineCode">ext4</code> format.</p>
    <p class="normal">Now we can build an image:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span><span class="language-bash">bitbake core-image-full-cmdline</span>
</code></pre>
    <p class="normal">As usual, the results of the build are in <code class="inlineCode">tmp/deploy/images/vexpress-qemu</code>. You will notice some new things here compared to The Yocto Project builds we have done in the past. There is a file named <code class="inlineCode">core-image-full-cmdline-vexpress-qemu-grub-&lt;timestamp&gt;.mender</code> and another similarly named file that ends with <code class="inlineCode">.uefiimg</code>. The <code class="inlineCode">.mender</code> file is required for the next subsection: <em class="italic">Installing an update with Mender</em>. The <code class="inlineCode">.uefiimg</code> file is created using a tool from The Yocto Project known as <code class="inlineCode">wic</code>. The output is an image that contains a partition table and that is ready to be copied directly to an SD card or eMMC chip.</p>
    <p class="normal">We can run the QEMU target using the script provided by the Mender layer, which will first boot U-Boot and then load the Linux kernel:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span><span class="language-bash">../meta-mender/meta-mender-qemu/scripts/mender-qemu</span>
&lt;…&gt;
[  OK  ] Started Boot script to demo Mender OTA updates.
[  OK  ] Started Periodic Command Scheduler.
         Starting D-Bus System Message Bus...
[  OK  ] Started Getty on tty1.
         Starting IPv6 Packet Filtering Framework...
         Starting IPv4 Packet Filtering Framework...
         Starting Mender-configure device configuration...
[  OK  ] Started Serial Getty on ttyAMA0.
&lt;…&gt;
[  OK  ] Finished Wait for Network to be Configured.
[  OK  ] Started Time &amp; Date Service.
[  OK  ] Finished Mender-configure device configuration.
Poky (Yocto Project Reference Distro) 5.0.7 vexpress-qemu ttyAMA0
vexpress-qemu login:
</code></pre>
    <p class="normal">If, instead of a login prompt, you see an error like this:</p>
    <pre class="programlisting con"><code class="hljs-con">mender-qemu: 117: qemu-system-arm: not found
</code></pre>
    <p class="normal">Then install <code class="inlineCode">qemu-system-arm</code> on your system and rerun the script:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span><span class="language-bash">sudo apt install qemu-system-arm</span>
</code></pre>
    <p class="normal">Log on as <code class="inlineCode">root</code> with no password. Looking<a id="_idIndexMarker797"/> at the layout of the partitions on the target, we can see this:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"># </span><span class="language-bash">fdisk -l /dev/mmcblk0</span>
Disk /dev/mmcblk0: 1 GiB, 1073741824 bytes, 2097152 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: gpt
Disk identifier: 00000000-0000-0000-0000-00004D9B9EF0
Device           Start     End Sectors  Size Type
/dev/mmcblk0p1   16384   49151   32768   16M EFI System
/dev/mmcblk0p2   49152  933887  884736  432M Linux filesystem
/dev/mmcblk0p3  933888 1818623  884736  432M Linux filesystem
/dev/mmcblk0p4 1818624 2097118  278495  136M Linux filesystem
</code></pre>
    <p class="normal">There are four partitions in all:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Partition 1</strong> contains the U-Boot boot files.</li>
      <li class="bulletList"><strong class="keyWord">Partitions 2 and 3</strong> contain the A/B root filesystems (identical at this stage).</li>
      <li class="bulletList"><strong class="keyWord">Partition 4</strong> is just an extension partition that contains the remaining space.</li>
    </ul>
    <p class="normal">Running the <code class="inlineCode">mount</code> command shows that the second partition is being used as the root filesystem, leaving the third to receive updates:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"># </span><span class="language-bash">mount | </span><span class="hljs-con-built_in">head</span><span class="language-bash"> -1</span>
/dev/mmcblk0p2 on / type ext4 (rw,relatime)
</code></pre>
    <p class="normal">With the Mender client now on board, we can begin installing updates.</p>
    <h2 id="_idParaDest-332" class="heading-2"><a id="_idTextAnchor368"/>Installing an update with Mender</h2>
    <p class="normal">Now we want to make a change<a id="_idIndexMarker798"/> to the root filesystem and then install it as an update:</p>
    <ol>
      <li class="numberedList" value="1">Open another shell and put yourself back in the working build directory:
        <pre class="programlisting con"><code class="hljs-con">$ source poky/oe-init-build-env build-mender-qemu
</code></pre>
      </li>
      <li class="numberedList">Make a copy of the image we just built. This will be the live image that we are going to update:
        <pre class="programlisting con"><code class="hljs-con">$ cd tmp/deploy/images/vexpress-qemu
$ cp core-image-full-cmdline-vexpress-qemu-grub.uefiimg \
core-image-live-vexpress-qemu-grub.uefiimg
$ cd -
</code></pre>
      </li>
    </ol>
    <p class="normal">If we don’t do this, the QEMU script will just load the latest image generated by BitBake including updates, which<a id="_idIndexMarker799"/> defeats the object of the demonstration.</p>
    <ol>
      <li class="numberedList" value="3">Next, change the hostname of the target, which will be easy to see when it is installed. To do this, edit <code class="inlineCode">conf/local.conf</code> and add this line:
        <pre class="programlisting con"><code class="hljs-con">hostname:pn-base-files = "vexpress-qemu-release2"
</code></pre>
      </li>
      <li class="numberedList">Now we can build the image in the same way as before:
        <pre class="programlisting con"><code class="hljs-con">$ bitbake core-image-full-cmdline
</code></pre>
      </li>
    </ol>
    <p class="normal">This time we are not interested in the <code class="inlineCode">.uefiimg</code> file, which contains a completely new image. Instead, we want to take only the new root filesystem, which is in <code class="inlineCode">core-image-full-cmdline-vexpress-qemu-grub.mender</code>. The <code class="inlineCode">.mender</code> file is in a format that is recognizessssd by the Mender client. The <code class="inlineCode">.mender</code> file format consists of version information, a header, and the root filesystem image bundled together in a compressed .<code class="inlineCode">tar</code> archive.</p>
    <ol>
      <li class="numberedList" value="5">The next step is to deploy the new artifact to the target, initiating the update locally on the device, but receiving the update from a server. Stop the emulator you started in the previous Terminal session by pressing <em class="italic">Ctrl + A</em> then <em class="italic">x</em> to terminate it. This extra step ensures that QEMU boots with the previous image rather than the latest image. To boot QEMU with the previous image:
        <pre class="programlisting con"><code class="hljs-con">$ ../meta-mender/meta-mender-qemu/scripts/mender-qemu \
core-image-live
</code></pre>
      </li>
      <li class="numberedList">Check that the network is configured with QEMU at <code class="inlineCode">10.0.2.15</code> and the host at <code class="inlineCode">10.0.2.2</code>:
        <pre class="programlisting con"><code class="hljs-con"># ping 10.0.2.2
PING 10.0.2.2 (10.0.2.2) 56(84) bytes of data.
<a id="_idTextAnchor369"/>64 bytes from 10.0.2.2: icmp_seq=1 ttl=255 time=0.842 ms
^C
--- 10.0.2.2 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 0.842/0.842/0.842/0.000 ms
</code></pre>
      </li>
      <li class="numberedList">Now, in another<a id="_idIndexMarker800"/> Terminal session, start a web server on the host that can serve up the update:
        <pre class="programlisting con"><code class="hljs-con">$ cd tmp/deploy/images/vexpress-qemu
$ python3 -m http.server
Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...
</code></pre>
      </li>
      <li class="numberedList">It is listening on port <code class="inlineCode">8000</code>. When you are done with the web server, press <em class="italic">Ctrl + C</em> to terminate it.</li>
      <li class="numberedList">Back on the target, issue this command to get the update:
        <pre class="programlisting con"><code class="hljs-con"># mender-update --log-level info install \
&gt; http://10.0.2.2:8000/core-image-full-cmdline-vexpress-qemu-grub.mender
Installing artifact...
100%
&lt;…&gt;
Installed, but not committed.
Use 'commit' to update, or 'rollback' to roll back the update.
At least one payload requested a reboot of the device it updated.
</code></pre>
      </li>
    </ol>
    <p class="normal">The update was written to the third partition (<code class="inlineCode">/dev/mmcblk0p3</code>) while our root filesystem is still on the second partition (<code class="inlineCode">/dev</code>/<code class="inlineCode">mmcblk0p2</code>).</p>
    <ol>
      <li class="numberedList" value="10">Reboot QEMU by entering <code class="inlineCode">reboot</code> from the QEMU command line. Note that now the root filesystem is mounted on partition 3 and that the hostname has changed:
        <pre class="programlisting con"><code class="hljs-con"># mount
/dev/mmcblk0p3 on / type<span class="hljs-class"> ext4 (</span>rw<span class="hljs-class">,</span>relatime<span class="hljs-class">)</span>
&lt;…&gt;
# hostname
vexpress-qemu-release2
</code></pre>
      </li>
    </ol>
    <p class="normal">Success!</p>
    <ol>
      <li class="numberedList" value="11">There is one more thing to do. We need to consider the issue of boot loops. Use <code class="inlineCode">grub-mender-grubenv-print</code> to look at the relevant U-Boot variables:
        <pre class="programlisting con"><code class="hljs-con"># grub-mender-grubenv-print upgrade_available
upgrade_available=1
# grub-mender-grubenv-print bootcount
bootcount=1
</code></pre>
      </li>
    </ol>
    <p class="normal">If the system reboots without<a id="_idIndexMarker801"/> clearing <code class="inlineCode">bootcount</code>, U-Boot should detect it and fall back to the previous installation.</p>
    <p class="normal">Let’s test U-Boot’s fallback behavior:</p>
    <ol>
      <li class="numberedList" value="1">Reboot the QEMU target immediately.</li>
    </ol>
    <p class="normal">When the target comes up again, we see that U-Boot has reverted to the previous installation:</p>
    <pre class="programlisting con"><code class="hljs-con"># mount
/dev/mmcblk0p2 on / type<span class="hljs-class"> ext4 (</span>rw<span class="hljs-class">,</span>relatime<span class="hljs-class">)</span>
&lt;…&gt;
# hostname
vexpress-qemu
</code></pre>
    <ol>
      <li class="numberedList" value="2">Now, let’s repeat the update procedure:
        <pre class="programlisting con"><code class="hljs-con"># mender-update rollback
Rolled back.
# mender-update --log-level info install \
&gt; http://10.0.2.2:8000/core-image-full-cmdline-vexpress-qemu-grub.mender
# reboot
</code></pre>
      </li>
      <li class="numberedList">This time, after the reboot, commit the change:
        <pre class="programlisting con"><code class="hljs-con"># mender-update commit
Committed.
# grub-mender-grubenv-print upgrade_available
upgrade_available=0
# grub-mender-grubenv-print bootcount
bootcount=1
</code></pre>
      </li>
    </ol>
    <p class="normal">Once <code class="inlineCode">upgrade_available</code> is cleared, U-Boot will no longer check <code class="inlineCode">bootcount</code>, and so the device will continue to mount this updated root filesystem. When a further update is loaded, the Mender client will clear <code class="inlineCode">bootcount</code> and set <code class="inlineCode">upgrade_available</code> once again.</p>
    <p class="normal">This example uses the Mender client from the command line to initiate an update locally. The update itself came from a server but could just as easily have been provided on a USB flash drive or an SD card. In place of Mender we could have used one of the other image update clients mentioned: SWUpdate, RAUC, or fwup. They each have their advantages, but the basic technique is the same.</p>
    <h1 id="_idParaDest-333" class="heading-1"><a id="_idTextAnchor370"/>Using Mender for OTA updates</h1>
    <p class="normal">Once again, we will be using<a id="_idIndexMarker802"/> the Mender client on the device, but this time operating it in managed mode. In addition, we will be configuring a server to deploy the update so that no local interaction<a id="_idIndexMarker803"/> is needed. Mender provides an open-source server for this. For documentation on how to set up this demo server, see <a href="https://docs.mender.io/2.4/getting-started/on-premise-installation"><span class="url">https://docs.mender.io/2.4/getting-started/on-premise-installation</span>.</a></p>
    <p class="normal">The installation requires Docker Engine version 19.03 or later. It also requires Docker Compose version 1.25 or later. Refer to the Docker website at <a href="https://docs.docker.com/engine/install/"><span class="url">https://docs.docker.com/engine/install/</span></a> and <a href="https://docs.docker.com/compose/install/"><span class="url">https://docs.docker.com/compose/install/</span></a> for each.</p>
    <p class="normal">To verify which versions of Docker and Docker Compose you have on your system, use these commands:</p>
    <pre class="programlisting con"><code class="hljs-con">$ docker --version
Docker version 26.1.3, build 26.1.3-0ubuntu1~24.04.1
$ docker-compose --version
docker-compose version 1.29.2, build unknown
</code></pre>
    <p class="normal">Docker Compose started being bundled with Docker in 2022. If the second command fails, try invoking Docker Compose without the hyphen:</p>
    <pre class="programlisting con"><code class="hljs-con">$ docker compose
</code></pre>
    <p class="normal">The Mender server also requires a command-line JSON parser called <code class="inlineCode">jq</code>:</p>
    <pre class="programlisting con"><code class="hljs-con">$ sudo apt install jq
</code></pre>
    <p class="normal">Once all three are installed, install the Mender integration environment as shown:</p>
    <pre class="programlisting con"><code class="hljs-con">$ git clone -b \
3.7.9 https://github.com/mendersoftware/integration.git integration-3.7.9
$ cd integration-3.7.9
$ ./demo up
Starting the Mender demo environment...
&lt;…&gt;
Creating a new user...
****************************************
Username: mender-demo@example.com
Login password: F26E0B14587A
****************************************
Please keep the password available, it will not be cached by the login script.
Mender demo server ready and running in the background. Copy credentials above and log in at https://localhost
Press Enter to show the logs.
Press Ctrl-C to stop the backend and quit.
</code></pre>
    <p class="normal">When you run <code class="inlineCode">./demo up</code>, you will see that the script downloads several hundred megabytes of Docker images, which may take some time depending on your internet connection speed. After a while, you will see that it creates a new demo user and password. This means that the server is up and running.</p>
    <p class="normal">With the Mender web <a id="_idIndexMarker804"/>interface now running on <code class="inlineCode">https://localhost/</code>, point a web browser at that URL and accept the certificate warning that pops up. The warning appears because the web service is using a self-signed certificate that the browser will not recognize. Enter the username and password generated by the Mender server into the login page.</p>
    <p class="normal">We now need to make a change to<a id="_idIndexMarker805"/> the configuration of the target so that it will poll our local server for updates. For this demonstration, we map the <code class="inlineCode">docker.mender.io</code> and <code class="inlineCode">s3.docker.mender.io </code>server URLs to the <code class="inlineCode">10.0.2.2</code> localhost address by appending a line to the <code class="inlineCode">hosts</code> file. To make this change with The Yocto Project, do the following:</p>
    <ol>
      <li class="numberedList" value="1">First, navigate one level above the directory where you cloned Yocto.</li>
      <li class="numberedList">Next, create a layer with a file that appends to the recipe that creates the <code class="inlineCode">hosts</code> file, which is <code class="inlineCode">recipes-core/base-files/base-files_%.bbappend</code>.</li>
      <li class="numberedList">There is already a suitable layer in <code class="inlineCode">MELD/Chapter10/meta-ota</code> that you can copy:
        <pre class="programlisting con"><code class="hljs-con">$ cp -a MELD/Chapter10/meta-ota .
</code></pre>
      </li>
      <li class="numberedList">Source the working build directory:
        <pre class="programlisting con"><code class="hljs-con">$ source poky/oe-init-build-env build-mender-qemu
</code></pre>
      </li>
      <li class="numberedList">Add the <code class="inlineCode">meta-ota</code> layer:
        <pre class="programlisting con"><code class="hljs-con">$ bitbake-layers add-layer ../meta-ota
</code></pre>
      </li>
    </ol>
    <p class="normal">Your layer structure should now contain eight layers including <code class="inlineCode">meta-oe</code>, <code class="inlineCode">meta-mender-core</code>, <code class="inlineCode">meta-mender-demo</code>, <code class="inlineCode">meta-mender-qemu</code>, and <code class="inlineCode">meta-ota</code>.</p>
    <ol>
      <li class="numberedList" value="6">Build the new image using the following command:
        <pre class="programlisting con"><code class="hljs-con">$ bitbake core-image-full-cmdline
</code></pre>
      </li>
      <li class="numberedList">Then, make a copy. This <a id="_idIndexMarker806"/>will be our live image for the session:
        <pre class="programlisting con"><code class="hljs-con">$ cd tmp/deploy/images/vexpress-qemu
$ cp core-image-full-cmdline-vexpress-qemu-grub.uefiimg \
core-image-live-ota-vexpress-qemu-grub.uefiimg
$ cd -
</code></pre>
      </li>
      <li class="numberedList">Stop any emulator you may have started by pressing <em class="italic">Ctrl + A</em> then <em class="italic">x</em> in that Terminal session.</li>
      <li class="numberedList">Boot up the live image:
        <pre class="programlisting con"><code class="hljs-con">$ ../meta-mender/meta-mender-qemu/scripts/mender-qemu \
core-image-live-ota
</code></pre>
      </li>
      <li class="numberedList">After a few seconds, you will see a new device appear on the dashboard of the web interface. This happens so quickly because the Mender client has been configured to poll the server every <a id="_idIndexMarker807"/>5 seconds for the purpose of demonstrating the system. A much longer polling interval would be used in production—30 minutes is recommended.</li>
      <li class="numberedList">See how this polling interval is configured by looking at the <code class="inlineCode">/etc/mender/mender.conf</code> file on the target:
        <pre class="programlisting con"><code class="hljs-con"># cat /etc/mender/mender.conf
{
 "InventoryPollIntervalSeconds": 5,
 "RetryPollIntervalSeconds": 30,
 "ServerURL": "https://docker.mender.io",
 "TenantToken": "dummy",
 "UpdatePollIntervalSeconds": 5
}
</code></pre>
      </li>
    </ol>
    <p class="normal">Notice the server URL in there as well.</p>
    <ol>
      <li class="numberedList" value="12">Back in the web UI, click on the green checkmark to authorize the new device:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18466_10_04.png" alt="Figure 10.4 – Accept device" width="1517" height="861"/></figure>
    <p class="packt_figref">Figure 10.4 – Accept device</p>
    <ol>
      <li class="numberedList" value="13">Then, click on the entry for the device to see the details.</li>
    </ol>
    <p class="normal">Once again, we can create an <a id="_idIndexMarker808"/>update and deploy it – this time OTA:</p>
    <ol>
      <li class="numberedList" value="1">Update the following line in <code class="inlineCode">conf/local.conf</code>:
        <pre class="programlisting con"><code class="hljs-con">MENDER_ARTIFACT_NAME = "OTA-update1"
</code></pre>
      </li>
      <li class="numberedList">Build the image once again:
        <pre class="programlisting con"><code class="hljs-con">$ bitbake core-image-full-cmdline
</code></pre>
      </li>
    </ol>
    <p class="normal">This will <a id="_idIndexMarker809"/>produce a new <code class="inlineCode">core-image-full-cmdline-vexpress-qemu-grub.mender</code> file in <code class="inlineCode">tmp/deploy/images/vexpress-qemu</code>.</p>
    <ol>
      <li class="numberedList" value="3">Import this into the web interface by opening the <strong class="screenText">Releases</strong> tab and clicking on the purple <strong class="screenText">Upload</strong> button.</li>
      <li class="numberedList">Browse for the <code class="inlineCode">core-image-full-cmdline-vexpress-qemu-grub.mender</code> file in <code class="inlineCode">tmp/deploy/images/vexpress-qemu</code> and upload it:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18466_10_05.png" alt="Figure 10.5 – Upload an Artifact" width="1518" height="1022"/></figure>
    <p class="packt_figref">Figure 10.5 – Upload an Artifact</p>
    <p class="normal">The Mender server should<a id="_idIndexMarker810"/> copy the file into the server data store, and a new artifact <a id="_idIndexMarker811"/>with the name <strong class="screenText">OTA-update1</strong> should appear under <strong class="screenText">Releases</strong>.</p>
    <p class="normal">To deploy the update to our QEMU device, do the following:</p>
    <ol>
      <li class="numberedList" value="1">Click on the <strong class="screenText">Devices</strong> tab and select the device.</li>
      <li class="numberedList">Click on the <strong class="screenText">Create deployment for this device</strong> option at the bottom right of the device information.</li>
      <li class="numberedList">Select the <strong class="screenText">OTA-update1</strong> artifact and click on the <strong class="screenText">CREATE DEPLOYMENT</strong> button:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18466_10_06.png" alt="Figure 10.6 – Create a deployment" width="1518" height="1100"/></figure>
    <p class="packt_figref">Figure 10.6 – Create a deployment</p>
    <p class="normal">The <a id="_idIndexMarker812"/>deployment should<a id="_idIndexMarker813"/> shortly transition from <strong class="screenText">Pending</strong> to <strong class="screenText">In Progress</strong>.</p>
    <ol>
      <li class="numberedList" value="4">Click on the <strong class="screenText">View details</strong> button.</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18466_10_07.png" alt="Figure 10.7 – In Progress" width="1526" height="1186"/></figure>
    <p class="packt_figref">Figure 10.7 – In Progress</p>
    <ol>
      <li class="numberedList" value="5">After about 13 minutes, the Mender client should finish writing the update to the spare filesystem<a id="_idIndexMarker814"/> image. At that point, QEMU will reboot and commit the update. The web UI should report <strong class="screenText">Finished</strong> and now the client is running <strong class="screenText">OTA-update1</strong>.</li>
    </ol>
    <p class="normal">Mender is neat and is used in <a id="_idIndexMarker815"/>many commercial products, but sometimes we just want to deploy a software project to a small fleet of popular dev boards as quickly as possible.</p>
    <div class="packt_tip">
      <p class="normal"><strong class="keyWord">TIP</strong></p>
      <p class="normal">After a few experiments with the Mender server, you may want to clear the state and start all over again. You can do that with these two commands from the <code class="inlineCode">integration-3.7.9</code> directory:</p>
      <pre class="programlisting con"><code class="hljs-con">./demo down
./demo up
</code></pre>
    </div>
    <p class="normal">Containers are the quickest way to deploy software to edge devices. We will revisit containerized software updates in <a href="Chapter_01.xhtml#_idTextAnchor030"><em class="italic">Chapter 16</em></a>.</p>
    <h1 id="_idParaDest-334" class="heading-1"><a id="_idTextAnchor371"/>Using SWUpdate for local updates</h1>
    <p class="normal">Like Mender, SWUpdate uses a symmetric A/B image update mechanism with a fallback in the event of a failed update. SWUpdate can receive multiple image updates in a CPIO format package and then deploy those updates to different parts of the system. It allows you to write plugins in the Lua language to <a id="_idIndexMarker816"/>do custom processing. Lua is a powerful scripting language that is easy to embed in applications. SWUpdate is a client-only solution, so unlike Mender there is no corresponding enterprise hosting plan to pay for. Instead, you deploy your own OTA server using something like hawkBit.</p>
    <p class="normal">The SWUpdate project (<a href="https://github.com/sbabic/swupdate"><span class="url">https://github.com/sbabic/swupdate</span>)</a> was started and is still maintained by Stefano Babic, an employee of DENX Software Engineering, the same folks behind U-Boot. There is extensive documentation (<a href="https://sbabic.github.io/swupdate/"><span class="url">https://sbabic.github.io/swupdate/</span>)</a> beginning with motives for robust and fail-safe updates followed by clear explanations of various update strategies.</p>
    <h1 id="_idParaDest-335" class="heading-1"><a id="_idTextAnchor372"/>Summary</h1>
    <p class="normal">Being able to update the software on devices in the field is at the very least a useful attribute. If the device is connected to the internet, then updating software in the field is an absolute must. And yet, all too often it is a feature that is left until the last part of a project, on the assumption that it is not a hard problem to solve. In this chapter, I hope that I have illustrated the various problems associated with designing an effective and robust update mechanism. There are also several open-source options readily available. You do not have to reinvent the wheel anymore.</p>
    <p class="normal">The two approaches used most often are the symmetric image (A/B) update or its cousin, the asymmetric (recovery) image update. Here, you have the choice of SWUpdate, RAUC, Mender, and fwup. A more recent innovation is the atomic file update in the form of OSTree. Atomic file update reduces the amount of data that needs to be downloaded and the amount of redundant storage that needs to be fitted on the target. Lastly, with the proliferation of Docker came the desire for containerized software updates. This is the approach that balena takes.</p>
    <p class="normal">It is quite common to deploy updates on a small scale by visiting each site and applying the update from a USB memory stick or SD card. However, if you want to deploy to remote locations, or deploy at scale, an OTA update option will be needed.</p>
    <p class="normal">The next chapter describes how you control the hardware components of your system with device drivers, both in the conventional sense of drivers that are part of the kernel and the extent to which you can control hardware from user space.</p>
  </div>
</div></div></body></html>