- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Diving into BitBake Metadata
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point in this book, we know how to generate images and packages and
    how to use package feeds – basically, everything we must know for the simple usage
    of Poky. Hereafter, we will learn how to control the behavior of Poky to accomplish
    our goals and achieve maximum benefit from the Yocto Project as a whole.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will help enhance our understanding of the BitBake metadata syntax.
    We will learn to use the BitBake operators to alter the content of variables,
    variable expansions, and so on. These are the key concepts we can use to make
    our recipes and the customization that we will learn about in the following chapters.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Understanding BitBake’s metadata
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The amount of metadata used by BitBake is enormous. Therefore, to get the maximum
    benefit from Poky, we must master it. As we learned in [*Chapter 4*](B19361_04.xhtml#_idTextAnchor071),
    *Meeting the BitBake Tool*, metadata covers three major areas:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '`.conf` files): The configuration files define the global content that configures
    how the classes and recipes will work.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.bbclass` files): Classes can be inherited for easier maintenance and to promote
    code reuse and avoid code duplication.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.bb` or `.bbappend` files): The recipes describe the tasks to be run and provide
    the required information to allow BitBake to generate the required task chain.
    They are the most commonly used metadata, as they define the variables and tasks
    for the recipes. The most common types of recipes generate packages and images.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The classes and recipes use a mix of Python and Shell Script code, which is
    parsed by BitBake, generating a massive number of tasks and local states that
    must still be executed after being parsed.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: We will also learn about the operators and essential concepts we need to build
    our recipes.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Working with metadata
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The syntax used by BitBake metadata can be misleading and sometimes hard to
    trace. However, we can check the value of each variable in BitBake-generated,
    pre-processed recipe data by using the `bitbake` option (`-e` or `--environment`),
    as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – How to display the BitBake environment](img/Figure_8.01_B19361.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – How to display the BitBake environment
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: To understand how BitBake works, please refer to *BitBake User Manual* ([https://docs.yoctoproject.org/bitbake/2.0](https://docs.yoctoproject.org/bitbake/2.0)).
    The following sections will show most of the syntax commonly used in recipes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: The basic variable assignment
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The assignment of a variable can be done as shown here:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – An example of a variable assignment](img/Figure_8.02_B19361.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – An example of a variable assignment
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, the value of the `FOO` variable is assigned to `bar`.
    Variable assignment is core to the BitBake metadata syntax, as most examples use
    variables.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: The variable expansion
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'BitBake supports variable referencing. The syntax closely resembles Shell Script,
    such as the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – An example of variable expansion](img/Figure_8.03_B19361.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – An example of variable expansion
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding example results in `A` containing `aValue` and `B` containing
    `before-aValue-after`. An important thing to bear in mind is that the variable
    only expands when it is used, as shown here:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – The variables are only expanded when used](img/Figure_8.04_B19361.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 – The variables are only expanded when used
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 8**.4* illustrates the *lazy evaluation* used by BitBake evaluation.
    The `B` variable value is `before-${A}-after` until a task requires the variable
    value. The `A` variable has been assigned to `aNewValue` in line 3; consequently,
    `B` evaluates `before-aNewValue-after`.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Assigning a value if the variable is unassigned, using ?=
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When there is a need to assign a variable only if the variable is still unassigned,
    the `?=` operator can be used. The following code shows its use:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – An example of value](img/Figure_8.05_B19361.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 – An example of value
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'The same behavior happens if there are multiple `?=` assignments to a single
    variable. The first use of the `?=` operator is responsible for assigning the
    variable. Let’s look at the following example:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6 – An example of a second assignment being ignored](img/Figure_8.06_B19361.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
- en: Figure 8.6 – An example of a second assignment being ignored
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: The `A` variable has been assigned to `value` on line 1, before the assignment
    of `ignoredAsAlreadyAssigned` on line 2, which is ignored.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to consider that the `=` operator is stronger than the `?=` operator,
    as it assigns the value independently of the previous variable state, as shown
    here:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7 – An example showing that the ?= operator is weaker than the =
    operator](img/Figure_8.07_B19361.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
- en: Figure 8.7 – An example showing that the ?= operator is weaker than the = operator
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Hence, the `A` variable is assigned as `changeValue`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Assigning a default value using ??=
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using the `??=` operator is intended to provide a default value for a variable
    and is a weaker version of the `?=` operator.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8 – An example of how default values are assigned](img/Figure_8.08_B19361.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
- en: Figure 8.8 – An example of how default values are assigned
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: In line 1, the `A` default value is assigned to `firstValue`, and then in line
    2, the `A` default value is changed to `secondValue`. As no other assignment is
    made to the `A` variable, the final value is `secondValue`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '`?=` is an assignment operator, as seen before, and takes precedence over the
    `??=` operator, as can be seen in the following example:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.9 – An example of the ??= operator being weaker than the ?= operator](img/Figure_8.09_B19361.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
- en: Figure 8.9 – An example of the ??= operator being weaker than the ?= operator
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: The final value of `A` variable is `thirdValue`, as no assignment has been made
    until line 3.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: The immediate variable expansion
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `:=` operator is used when there is a need to force the immediate expansion
    of a variable. It results in the variable’s contents being expanded immediately
    rather than when the variable is used, as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.10 – An example of immediate variable expansion](img/Figure_8.10_B19361.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
- en: Figure 8.10 – An example of immediate variable expansion
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: The value for `B` is assigned immediately, in line 2, and expands to `aValue-after`.
    However, the value for `C` is only assigned when used and then set to `newValue`,
    as `A` value has been set in line 3.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: The list appending and prepending
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `+=` operator, known as *list appending*, adds a new value after the original
    one, separated with a space, as shown here:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.11 – An example of list appending](img/Figure_8.11_B19361.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
- en: Figure 8.11 – An example of list appending
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the final value for `A` is `originalValue appendedValue`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'The `=+` operator, known as *list prepending*, adds a new value before the
    original one, separated with a space, as shown here:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.12 – An example of list prepending](img/Figure_8.12_B19361.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
- en: Figure 8.12 – An example of list prepending
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the final value for `A` is `prependedValue originalValue`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: The string appending and prepending
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `.=` operator, known as *string appending*, adds a new value after the
    original one, with no extra space, as shown here:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.13 – An example of string appending](img/Figure_8.13_B19361.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
- en: Figure 8.13 – An example of string appending
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the final value for `A` is `originalValueAppendedValue`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'The `=.` operator, known as *string prepending*, adds the new value before
    the original one with no extra space, as shown here:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.14 – An example of string prepending](img/Figure_8.14_B19361.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
- en: Figure 8.14 – An example of string prepending
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the final value for `A` is `prependedValueOriginalValue`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: The :append and :prepend operators
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `:append` operator adds a new value after the original with no extra space,
    as shown here:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.15 – An example of how to use the :append operator](img/Figure_8.15_B19361.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
- en: Figure 8.15 – An example of how to use the :append operator
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the final value for `A` is `originalValueAppendedValue`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'The `:prepend` operator adds the new value before the original with no extra
    space, as shown here:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.16 – An example of how to use the :prepend operator](img/Figure_8.16_B19361.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
- en: Figure 8.16 – An example of how to use the :prepend operator
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the final value for `A` is `prependedValueOriginalValue`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that the `:append` and `:prepend` operators resemble the
    string appending (`.=`) and prepending (`=.`) operators. Still, there is a subtle
    difference between how the `:append` and `:prepend` operators and the string appending
    and string prepending operators are parsed, as shown here:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 8.17 – An example of the difference between \uFEFF:append and the\
    \ .= operator](img/Figure_8.17_B19361.jpg)"
  id: totrans-84
  prefs: []
  type: TYPE_IMG
- en: Figure 8.17 – An example of the difference between :append and the .= operator
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Using the `:append` operator queues the operation for execution, which happens
    after the *line 2* assignment, resulting in `A` becoming `valueAppendedValue`.
    The `.=` operator is immediate, so the assignment of *line 4* replaces the value
    set on *line 3*, resulting in `B` becoming `value`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: The list item removal
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `:remove` operator drops a list item from the original content. For example,
    see the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.18 – An example of how to use the :remove operator](img/Figure_8.18_B19361.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
- en: Figure 8.18 – An example of how to use the :remove operator
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: In this example, `A` is now `value1 value3`. The `:remove` operator considers
    the variable value as a list of strings separated by spaces so that the operator
    can remove one or more items from the list. Note that every appending and prepending
    operation has already finished when `:remove` is executed.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Conditional metadata sets
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: BitBake provides a very easy-to-use way to write conditional metadata through
    a mechanism called **overrides**.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: The `OVERRIDES` variable contains values separated by colons (`:`) and evaluated
    from left to right. Each value is an item that we want to have conditional metadata.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider the next example:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.19 – An example of the OVERRIDES variable](img/Figure_8.19_B19361.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
- en: Figure 8.19 – An example of the OVERRIDES variable
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'The `linux` override is less specific than `arm` and `mymachine`. The following
    example shows how we can use `OVERRIDES` to set the `A` variable conditionally:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.20 – An example of using OVERRIDES conditional setting](img/Figure_8.20_B19361.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
- en: Figure 8.20 – An example of using OVERRIDES conditional setting
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: In this example, `A` will be `linuxSpecificValue`, due to the condition of `linux`
    being in `OVERRIDES`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Conditional appending
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'BitBake also supports appending and prepending variables, based on whether
    something is in `OVERRIDES`, as shown in the following example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.21 – An example of using OVERRIDES conditional appending](img/Figure_8.21_B19361.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
- en: Figure 8.21 – An example of using OVERRIDES conditional appending
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, `A` is set to `value armValue`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: File inclusion
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: BitBake provides two directives for file inclusion – `include` and `require`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: With the `include` keyword, BitBake attempts to insert the file at the keyword
    location, so it is optional. Let’s suppose the path specified on the `include`
    line is relative; then, BitBake locates the first instance it can find within
    `BBPATH`. By contrast, the `require` keyword raises `ParseError` if the required
    file cannot be found.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: The convention generally adopted in the Yocto Project is to use a `.inc` file
    to share the common code between two or more recipe files.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Python variable expansion
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'BitBake makes it easy to use Python code in variable expansion with the following
    syntax:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.22 – An example of Python expansion syntax](img/Figure_8.22_B19361.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
- en: Figure 8.22 – An example of Python expansion syntax
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'This gives enormous flexibility to a user. We can see a Python function call
    in the following example:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.23 – An example of a Python command to print the current date](img/Figure_8.23_B19361.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
- en: Figure 8.23 – An example of a Python command to print the current date
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: This results in the `A` variable containing today’s date.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Defining executable metadata
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Metadata recipes (`.bb`) and class files (`.bbclass`) can use Shell Script
    code, as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.24 – An example of a task definition](img/Figure_8.24_B19361.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
- en: Figure 8.24 – An example of a task definition
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: The task definition is identical to setting a variable, except that this variable
    happens to be an executable Shell Script code. When writing the task code, we
    should not use Bash or Zsh-specific features, as the tasks can only rely on POSIX-compatible
    features. When in doubt, an excellent way to test whether your code is safe is
    to use the Dash shell to try it out.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to inject code is by using Python code, as shown here:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.25 – An example of a Python task definition](img/Figure_8.25_B19361.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
- en: Figure 8.25 – An example of a Python task definition
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: The task definition is similar, but it flags the task as Python so that BitBake
    knows how to run it accordingly.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Defining Python functions in a global namespace
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we need to generate a value for a variable or some other use, this can
    be quickly done in recipes (`.bb`) and classes (`.bbclass`) using code similar
    to the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.26 – A code example to handle variable values in Python code](img/Figure_8.26_B19361.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
- en: Figure 8.26 – A code example to handle variable values in Python code
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Usually, we need to access the BitBake datastore when writing a Python function.
    Therefore, a convention among all metadata is the use of an argument called `d`
    to point to BitBake’s datastore. It is usually in the last parameter of the function.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 8**.26*, we ask the datastore for the value of the `SOMECONDITION`
    variable in line 2 and return a value depending on it.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: The example results in the value for the `DEPENDS` variable containing `dependencyWithConditon`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: The inheritance system
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `inherit` directive specifies which classes of functionality our recipe
    (`.bb`) offers a rudimentary inheritance mechanism, such as object-oriented programming
    languages. For example, we can abstract the tasks involved in using the Autoconf
    and Automake building tools and put them into the class for our recipes to reuse.
    A given `.bbclass` is located by searching for `classes/filename.bbclass` in `BBPATH`.
    So, in a recipe that uses Autoconf or Automake, we can use the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.27 – An example of how to inherit a class](img/Figure_8.27_B19361.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
- en: Figure 8.27 – An example of how to inherit a class
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.27 – 如何继承一个类的示例
- en: Line 1 from *Figure 8**.27* instructs BitBake to use `inherit autotools.bbclass`,
    providing the default tasks that work fine for most Autoconf- or Automake-based
    projects.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8.27* 的第 1 行指示 BitBake 使用 `inherit autotools.bbclass`，为大多数基于 Autoconf 或
    Automake 的项目提供默认任务。'
- en: Summary
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned in detail about the BitBake metadata syntax, its
    operators to manipulate variable contents, and variable expansions, including
    some usage examples.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们详细学习了 BitBake 元数据语法、用于操作变量内容的运算符，以及变量展开，包括一些使用示例。
- en: In the next chapter, we will learn how to use Poky to create external compilation
    tools and produce a `root` filesystem suitable for target development.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用Poky创建外部编译工具，并生成适合目标开发的`root`文件系统。
