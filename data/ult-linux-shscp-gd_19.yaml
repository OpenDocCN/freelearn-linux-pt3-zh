- en: '19'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '19'
- en: Shell Script Portability
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Shell脚本的可移植性
- en: As we’ll see in a bit, many different shells are available for Linux, Unix,
    and Unix-like operating systems. Thus far though, we’ve mainly just been working
    with `bash`. The big advantage of `bash` is that it comes already installed on
    most Linux distros, macOS, and OpenIndiana. It normally isn’t installed by default
    on the BSD-type distros, but you can install it yourself, if you need to.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们稍后会看到，Linux、Unix和类Unix操作系统有很多不同的Shell可用。但到目前为止，我们主要一直在使用`bash`。`bash`的一个大优点是它已经在大多数Linux发行版、macOS和OpenIndiana上预装了。它通常不会在BSD类型的发行版上默认安装，但如果需要，你可以自行安装。
- en: The big advantage of `bash` is that it can use different scripting constructs
    that can make life easier for scripters. The big disadvantage of `bash` is that
    many of these `bash` constructs aren’t always available in non-`bash` shells.
    That’s not a big problem if you can install `bash` on all of your machines, but
    that’s not always possible. (I’ll explain why in just a bit.)
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '`bash`的一个大优点是它可以使用不同的脚本结构，这些结构能让脚本编写者的工作变得更轻松。`bash`的一个大缺点是许多这些`bash`结构在非`bash`的Shell中并不总是可用。如果你能在所有机器上安装`bash`，那这并不是一个大问题，但并不是每次都能做到这一点。（稍后我会解释为什么。）'
- en: In this chapter, I’ll show you some of the `bash` alternatives that you might
    encounter, and how to make your shell scripts run on a wide variety of these shells.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我将展示一些你可能遇到的`bash`替代方案，以及如何让你的Shell脚本在这些Shell上运行。
- en: 'Topics in this chapter include:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容包括：
- en: Running `bash` on non-Linux systems
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在非Linux系统上运行`bash`
- en: Understanding POSIX compliance
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解POSIX合规性
- en: Understanding the differences between shells
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Shell之间的差异
- en: Understanding bashisms
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解bashisms
- en: Testing scripts for POSIX compliance
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试脚本的POSIX合规性
- en: That about does it for the introduction. So now, let’s dig in.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 介绍部分就到这里。现在，让我们深入探讨一下。
- en: Technical Requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'I’m using Fedora, Debian, and FreeBSD virtual machines for this chapter. If
    any of you are using a Mac, you can try the scripts on it as well, if you like.
    As always, you can get grab the scripts from GitHub by doing:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这一章中使用了Fedora、Debian和FreeBSD虚拟机。如果你们中的任何人使用的是Mac，也可以尝试在上面运行这些脚本。如果你愿意，像往常一样，你可以从GitHub获取脚本：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Running bash on Non-Linux Systems
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在非Linux系统上运行bash
- en: Before we talk about the alternatives to `bash`, let’s talk about using `bash`
    on non-Linux operating systems. I mean, the easiest way to make your shell scripts
    portable is to have the same shell everywhere.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论`bash`的替代方案之前，让我们先谈谈在非Linux操作系统上使用`bash`。我的意思是，确保脚本在每个地方都使用相同的Shell，是让你的Shell脚本具备移植性最简单的方式。
- en: 'As I mentioned in the introduction, `bash` is already installed on most Linux-based
    operating systems, as well as on macOS and OpenIndiana. If you want to use `bash`
    on a BSD-type distro, such as FreeBSD or OpenBSD, you’ll need to install it yourself.
    I’ve already shown you how to install `bash` on FreeBSD in *Chapter 8, Basic Shell
    Script Construction*. To refresh your memory, I’ll show you again:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在介绍中提到的，`bash`已经在大多数基于Linux的操作系统中安装好了，也包括macOS和OpenIndiana。如果你想在BSD类型的发行版上使用`bash`，比如FreeBSD或OpenBSD，你需要自己安装它。我已经在*第8章
    基本Shell脚本构建*中展示了如何在FreeBSD上安装`bash`。为了提醒你，我再展示一遍：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It’s just as easy on any other BSD-type distro, except that they all use different
    package managers. Here’s the table of commands for the various BSDs:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何其他BSD类型的发行版上安装`bash`同样简单，只是它们使用不同的包管理器。下面是各种BSD系统的命令表：
- en: '| **BSD Distro** | **Command to install bash** |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| **BSD发行版** | **安装bash的命令** |'
- en: '| FreeBSD | `sudo pkg install bash` |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| FreeBSD | `sudo pkg install bash` |'
- en: '| OpenBSD | `sudo pkg_add bash` |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| OpenBSD | `sudo pkg_add bash` |'
- en: '| DragonflyBSD | `sudo pkg install bash` |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| DragonflyBSD | `sudo pkg install bash` |'
- en: '| NetBSD | `sudo pkgin install bash` |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| NetBSD | `sudo pkgin install bash` |'
- en: 'Table 19.1: Commands to install bash on the BSD distros'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 表19.1：在BSD发行版上安装bash的命令
- en: 'Now, if you were to run a script with the `#!/bin/bash` shebang line on any
    of these BSD distros, you would get an error message that looks like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你在这些BSD发行版中的任何一个上运行带有`#!/bin/bash`的脚本，你会看到一个错误信息，类似下面这样：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This message is a bit misleading because it gives the impression that the shell
    can’t find the script. In reality, the script can’t find `bash`. That’s because,
    unlike what you’re used to seeing on Linux and OpenIndiana, `bash` isn’t in the
    `/bin/` directory on BSD distros. Instead, the BSD distros have `bash` in the
    `/usr/local/bin/` directory. There are a couple of ways to fix this, which we’ll
    look at next.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这个消息有点误导，因为它给人一种shell找不到脚本的印象。实际上，脚本找不到的是`bash`。这是因为，与在Linux和OpenIndiana中看到的不同，`bash`在BSD发行版的`/bin/`目录中并不存在。相反，BSD发行版将`bash`放在`/usr/local/bin/`目录中。有几种方法可以解决这个问题，我们接下来会看到。
- en: Using env to Set the bash Environment
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用env设置bash环境
- en: 'The first way to ensure that your scripts can always find `bash` is to replace
    the `#!/bin/bash` line in your scripts with:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的脚本总是能找到`bash`的第一种方法是将脚本中的`#!/bin/bash`行替换为：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This causes the script to look for the `bash` executable in the user’s `PATH`
    environment, instead of in a specific, hard-coded location.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这会导致脚本在用户的`PATH`环境中查找`bash`可执行文件，而不是在特定的硬编码位置查找。
- en: I’ve shown you in *Chapter 3, Understanding Variables and Pipelines* how to
    use the `env` command to view the environmental variables that are set in `bash`.
    In this case, I’m using `env` to specify the shell that I want to use to interpret
    this script.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我在*第3章，理解变量和管道*中向你展示了如何使用`env`命令查看在`bash`中设置的环境变量。在这种情况下，我使用`env`来指定我希望用来解释该脚本的shell。
- en: This is the easiest method, but there are a few potential problems with it.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最简单的方法，但也存在一些潜在问题。
- en: If you specify an interpreter for which multiple versions are installed, you
    won’t know which version will be invoked by the script. If for some crazy reason
    a machine has multiple versions of `bash` installed, you won’t know which version
    that `#!/usr/bin/env bash` will invoke.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你为一个已安装多个版本的解释器指定路径，你将无法知道脚本会调用哪个版本。如果机器上安装了多个`bash`版本，你就无法知道`#!/usr/bin/env
    bash`会调用哪个版本。
- en: Using `#!/usr/bin/env bash` could be a security problem. The normal `bash` executable
    is always installed in a directory for which only someone with root privileges
    can add, remove, or modify files. But, let’s say that a malicious hacker were
    to gain access to your own normal user account. In that case, he or she wouldn’t
    need to obtain root privileges in order to plant a malicious fake `bash` in your
    own home directory, and to alter your `PATH` environment so that the fake `bash`
    would be invoked instead of the real `bash`. Using the hard-coded `#!/bin/bash`
    line would prevent that problem.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`#!/usr/bin/env bash`可能会存在安全问题。正常的`bash`可执行文件总是安装在一个只有root权限的用户才能添加、删除或修改文件的目录中。但假设恶意黑客获得了你正常用户账户的访问权限。在这种情况下，他或她就不需要获取root权限，便可以在你的家目录中植入一个恶意的伪`bash`，并更改你的`PATH`环境变量，使得伪`bash`被调用，而不是实际的`bash`。使用硬编码的`#!/bin/bash`行可以避免这个问题。
- en: With `#!/usr/bin/env bash`, you won’t be able to invoke any `bash` options on
    the shebang line. For example, let’s say that you need to troubleshoot a troublesome
    script, and you want to run the script in debug mode. Using `#!/bin/bash --debug`
    will work, but using `#!/usr/bin/env bash --debug` won’t work. That’s because
    the `env` command can only recognize one option parameter, which in this case
    would be `bash`. (It will never see the `--debug` option.)
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`#!/usr/bin/env bash`时，你将无法在shebang行中调用任何`bash`选项。例如，假设你需要排查一个有问题的脚本，并且想以调试模式运行该脚本。使用`#!/bin/bash
    --debug`可以正常工作，但使用`#!/usr/bin/env bash --debug`则不行。原因在于，`env`命令只能识别一个选项参数，这个选项在此情况下是`bash`。(它永远不会看到`--debug`选项。)
- en: For now, don’t worry about what the `--debug` option is doing. I’ll show you
    more about debugging shell scripts in *Chapter 21, Debugging Shell Scripts*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 暂时不用担心`--debug`选项的作用。我会在*第21章，调试Shell脚本*中向你展示更多关于调试脚本的内容。
- en: Although using `#!/usr/bin/env bash` seems like the simplest solution, I prefer
    to avoid it whenever possible. So, let’s look at another solution that’s a bit
    more secure and reliable.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使用`#!/usr/bin/env bash`看起来是最简单的解决方案，但我更倾向于在可能的情况下避免使用它。所以，让我们看一下另一个稍微更安全和可靠的解决方案。
- en: Creating a Symbolic Link to bash
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建指向bash的符号链接
- en: 'My preferred solution for ensuring that your scripts can find `bash` works
    the same on all of the BSD distros. You just have to create a symbolic link to
    the `bash` executable in the `/bin/` directory. Here’s how it looks:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我推荐的解决方案是确保你的脚本在所有BSD发行版上都能找到`bash`，你只需要在`/bin/`目录下创建一个指向`bash`可执行文件的符号链接。下面是操作步骤：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To use the `ln -s` command to create a link, you would first specify the path
    to the file to which you want to link. Then, specify the path and name for the
    link that you want to create. Note how after I created the link, the `which` command
    now finds `bash` in the `/bin/` directory, instead of in the `/usr/local/bin/`
    directory. That’s because `/bin/` is listed before `/usr/local/bin/` in the default
    `PATH` setting, as you see here:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ln -s`命令创建符号链接时，你首先需要指定要链接的文件路径。然后，指定你想要创建的链接的路径和名称。注意，在我创建链接之后，`which`命令现在能在`/bin/`目录下找到`bash`，而不是在`/usr/local/bin/`目录下。那是因为`/bin/`在默认的`PATH`设置中排在`/usr/local/bin/`之前，正如你在这里看到的：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can now use the `#!/bin/bash` shebang line on your BSD machine, the same
    as you would on a Linux machine.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以在你的BSD机器上使用`#!/bin/bash`的shebang行，就像在Linux机器上一样。
- en: Okay, this is all good if you can have `bash` installed on all of your systems.
    But, what if you can’t? What if you need to write scripts that will run on `bash`
    as well as on alternate shells? To answer that, we’ll first need to look at something
    called **POSIX**.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，如果你能在所有系统上安装`bash`，那这都没问题。但如果不能呢？如果你需要编写能够在`bash`以及其他Shell上运行的脚本呢？为了回答这个问题，我们首先需要了解一下叫做**POSIX**的东西。
- en: Understanding POSIX compliance
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解POSIX合规性
- en: Way back in the Stone Age of Computing, there was no such thing as standardization.
    In order to keep things relevant, let’s begin our history with the advent of Unix.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机的远古时代，没有所谓的标准化。为了让事情有意义，我们从Unix的出现开始讲述历史。
- en: AT&T, who created Unix in the early 1970s, wasn’t allowed to market it until
    1983\. This was due to an anti-trust legal case that the U.S. government had filed
    against AT&T back in 1956\. (I don’t know the details of the case, so please don’t
    ask.) But, they were allowed to license the code to other vendors so that they
    could sell their own modified implementations. Because of this, several different
    implementations of Unix emerged, which weren’t always completely compatible with
    each other. These different implementations included the **Berkeley Software Distribution**
    (**BSD**), **Microsoft Xenix**, and **SunOS**. In 1983, AT&T was finally allowed
    to market its own **System V Unix**. Making things more interesting was the wide
    variety of shells that eventually became available for these various Unix systems.
    The Thompson shell came first, and was superseded by the Bourne shell a few years
    later. Other shells, such as the C shell and the Korn shell, soon followed. Finally,
    in the early 1990s, Linus Torvalds created the Linux kernel, which was a clean
    slate reimplementation of the Unix kernel. Nowadays, Linux-based operating systems
    have mostly supplanted Unix-based systems, and the Bourne Again Shell (`bash`)
    is the dominant shell for Linux-based systems.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: AT&T在1970年代初期创造了Unix，但直到1983年才被允许将其推向市场。这是由于美国政府在1956年对AT&T提起的反垄断法律案件。（我不了解这个案件的详细情况，所以请不要问。）但他们被允许将代码许可给其他厂商，以便他们可以销售自己的修改版实现。因此，多个不同的Unix实现相继出现，它们之间并不总是完全兼容。这些不同的实现包括**伯克利软件发行版**（**BSD**）、**微软Xenix**和**SunOS**。1983年，AT&T终于被允许推销自己的**System
    V Unix**。更有趣的是，最终出现了多种不同的Shell，供这些不同的Unix系统使用。最初是汤普森Shell，几年后被Bourne Shell所取代。其他Shell，如C
    Shell和Korn Shell，紧随其后。最后，在1990年代初，Linus Torvalds创建了Linux内核，它是Unix内核的干净重写。如今，基于Linux的操作系统基本上取代了基于Unix的系统，而Bourne
    Again Shell（`bash`）是Linux系统中占主导地位的Shell。
- en: In the 1980s, customers began demanding some semblance of standardization between
    the various Unix vendors. This culminated in the creation of the **POSIX** standard
    by the **IEEE Computer Society** in 1988.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在1980年代，客户开始要求不同Unix厂商之间有某种程度的标准化。这最终导致了**IEEE计算机学会**在1988年创建了**POSIX**标准。
- en: '**IEEE** stands for **Institute of Electrical and Electronics Engineers**.
    Curiously however, all you’ll see on their website is IEEE, with no explanation
    of what it stands for.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**IEEE**代表**电气和电子工程师协会**。有趣的是，您在他们的网站上看到的仅仅是IEEE，而没有解释它的全称。'
- en: POSIX stands for **Portable Operating System Interface**.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX代表**可移植操作系统接口**。
- en: Finally, for those of you who are outside the U.S., AT&T stands for **American
    Telephone and Telegraph**.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于在美国以外的你们，AT&T代表**美国电话电报公司**。
- en: And yes, it really is true that Microsoft used to be a Unix vendor.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 没错，微软曾经是一个Unix厂商。
- en: The main purpose of POSIX is to ensure that shells and utilities work the same
    way across all implementations of Unix. For example, if you know how to use the
    `ps` utility on Solaris/OpenIndiana, then you also know how to use it on FreeBSD.
    The big problem is that while many Unix implementations and their default shells
    are POSIX-compliant, some are only partially compliant. On the other hand, most
    Linux-based operating systems are only partially POSIX-compliant. That’s because
    many Linux utilities use different option switches that their Unix/Unix-like brethren
    don’t use, and `bash` itself has programming features that aren’t available in
    POSIX-compliant shells. For example, you can use an `if [ -f /bin/someprogram
    ]` type of construct to test for the presence of a file in a POSIX-compliant shell,
    but you can’t use `if [[ -f /bin/someprogram ]]`. (I’ll explain more about this
    in a few moments.)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX 的主要目的是确保所有 Unix 实现中的 shell 和工具以相同的方式工作。例如，如果你知道如何在 Solaris/OpenIndiana
    上使用 `ps` 工具，那么你也知道如何在 FreeBSD 上使用它。问题在于，虽然许多 Unix 实现及其默认 shell 符合 POSIX 标准，但有些仅部分符合。另一方面，大多数基于
    Linux 的操作系统只是部分符合 POSIX 标准。这是因为许多 Linux 工具使用一些 Unix/Unix-like 系统没有的选项开关，而 `bash`
    本身有一些 POSIX shell 无法提供的编程特性。例如，你可以在符合 POSIX 标准的 shell 中使用 `if [ -f /bin/someprogram
    ]` 这种构造来测试文件是否存在，但你不能使用 `if [[ -f /bin/someprogram ]]`。 （稍后我会详细解释这一点。）
- en: POSIX also defines which programming libraries must come with any given implementation
    of Unix. However, this is mainly of interest to actual programmers, rather than
    to shell scripters.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX 还定义了任何给定 Unix 实现必须包含哪些编程库。然而，这主要对实际的程序员有用，而非对 shell 脚本编写者。
- en: To be fair, I’ll admit that POSIX compliance might never become an issue for
    you if you only work on Linux servers or workstations. But, let’s say that you
    work with a large fleet of servers with a mix of Unix, BSD, and Linux systems.
    Now, let’s say that some of those Unix and BSD servers are still running legacy
    systems for which `bash` isn’t available. You might find it necessary to create
    POSIX-compliant shell scripts that will run on every server in the fleet without
    modification. Also, **Internet of Things** (**IoT**) devices are generally very
    low-resource devices that might not be able to run `bash`. Instead, they’ll have
    something more lightweight, such as `ash` or `dash`. In general, these lightweight,
    non-`bash` shells will be POSIX-compliant, and won’t be able to run scripts that
    use `bash`-specific features.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 公平地说，我承认如果你只在 Linux 服务器或工作站上工作，POSIX 合规性可能永远不会成为问题。但假设你正在处理一大批服务器，包含了 Unix、BSD
    和 Linux 系统的混合配置。现在，假设这些 Unix 和 BSD 服务器中的一些仍在运行没有 `bash` 的旧版系统，你可能需要创建 POSIX 合规的
    shell 脚本，以便在整个服务器群集上运行而不需要修改。此外，**物联网**（**IoT**）设备通常是资源非常有限的设备，可能无法运行 `bash`。相反，它们会使用更轻量级的工具，如
    `ash` 或 `dash`。一般来说，这些轻量级的非 `bash` shell 会符合 POSIX 标准，且无法运行使用 `bash` 特有功能的脚本。
- en: Now that you have a good understanding of what POSIX is all about, let’s talk
    about the differences between the various shells.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对 POSIX 有了较好的理解，让我们来谈谈不同 shell 之间的差异。
- en: Understanding the Differences Between Shells
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Shell 之间的差异
- en: 'In addition to defining a specific shell that you want to use, such as `/bin/bash`
    or `/bin/zsh`, you can also define the generic `/bin/sh` shell to make your scripts
    more portable, as you see here:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 除了定义你想使用的特定 shell，例如 `/bin/bash` 或 `/bin/zsh`，你还可以定义通用的 `/bin/sh` shell，使你的脚本更具可移植性，如下所示：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This generic `sh` shell allows you to run your scripts on different systems
    that might or might not have `bash` installed. But, here’s the problem. Years
    ago, `sh` used to always be the Bourne shell. Nowadays, `sh` is still the Bourne
    shell on some operating systems, but is something else entirely on other operating
    systems. Here’s the breakdown of how it works:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个通用的 `sh` shell 允许你在可能安装也可能没有安装 `bash` 的不同系统上运行脚本。但问题是，很多年前，`sh` 总是指 Bourne
    shell。如今，`sh` 在一些操作系统中仍然是 Bourne shell，但在其他操作系统中则完全不同。以下是它的工作原理：
- en: On most BSD-type systems, such as FreeBSD and OpenBSD, `sh` is the old-school
    Bourne shell. According to the `sh` man page, it only supports POSIX-compliant
    features, plus a few BSD extensions.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在大多数 BSD 类型的系统上，如 FreeBSD 和 OpenBSD，`sh` 是传统的 Bourne shell。根据 `sh` 的手册页，它仅支持符合
    POSIX 标准的功能，以及一些 BSD 扩展。
- en: On Red Hat-type systems, `sh` is a symbolic link that points to the `bash` executable.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Red Hat 类型的系统上，`sh` 是一个符号链接，指向 `bash` 可执行文件。
- en: On Debian/Ubuntu-type systems, `sh` is a symbolic link that points to the `dash`
    executable. `dash` stands for **Debian Almquist Shell**, which is a faster, more
    lightweight implementation of the Bourne shell.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Debian/Ubuntu 类型的系统上，`sh`是指向`dash`可执行文件的符号链接。`dash`代表**Debian Almquist Shell**，它是
    Bourne shell 的一个更快、更轻量级的实现。
- en: On Alpine Linux, `sh` is a symbolic link that points to `ash`, which is a lightweight
    shell that’s built into the `busybox` executable. (On Alpine Linux, `bash` is
    not installed by default.)
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Alpine Linux 上，`sh`是一个指向`ash`的符号链接，`ash`是一个轻量级的 shell，内置在`busybox`可执行文件中。（在
    Alpine Linux 上，默认情况下并未安装`bash`。）
- en: On OpenIndiana, which is a **Free Open Source Software** fork of Oracle’s Solaris
    operating system, `sh` is a symbolic link that points to the `ksh93` shell. This
    shell, which is also known as the Korn shell, is somewhat compatible with `bash`.
    (It was created by a guy named David Korn, and has nothing to do with any vegetable.)
    However, the default login shell for OpenIndiana is `bash`.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 OpenIndiana 上，OpenIndiana 是 Oracle Solaris 操作系统的一个**自由开源软件**分支，`sh`是指向`ksh93`的符号链接。这个
    shell，也叫 Korn shell，在某种程度上与`bash`兼容。（它是由名为 David Korn 的人创建的，和任何蔬菜无关。）不过，OpenIndiana
    的默认登录 shell 是`bash`。
- en: On macOS, `sh` points to the `bash` executable. Interestingly, `zsh` is now
    the default user login shell for macOS, but `bash` is still installed and available
    for use.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 macOS 上，`sh`指向`bash`可执行文件。有趣的是，`zsh`现在是 macOS 的默认用户登录 shell，但`bash`仍然安装并可以使用。
- en: Using `#!/bin/sh` will only work if you’re careful about making your scripts
    portable. If `sh` on your machine points to something other than `bash`, it won’t
    work for scripts that require advanced features that are specific to `bash`. So,
    if you use `sh`, be sure to test it on different systems to ensure that everything
    works as it should.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`#!/bin/sh`只在你小心地使脚本具有移植性时有效。如果你机器上的`sh`指向的是其他 shell，而不是`bash`，那么对于需要 `bash`
    特有高级功能的脚本，它将无法工作。所以，如果你使用`sh`，请务必在不同的系统上测试，以确保一切如预期那样运行。
- en: Before we get to the testing part though, let’s look at the concept of bashisms,
    and how to avoid them.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，在进入测试部分之前，让我们先了解一下 bashism 的概念，以及如何避免它们。
- en: Understanding Bashisms
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Bash 特性
- en: A **bashism** is any feature that’s specific to `bash`, and that won’t work
    with other shells. Let’s look at a few examples.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**bashism**指的是任何特定于`bash`的功能，而这些功能在其他 shell 中无法使用。让我们看几个例子。'
- en: Using Portable Tests
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用可移植的测试
- en: 'For our first example, try running this command on your Fedora virtual machine:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的第一个例子，试着在你的 Fedora 虚拟机上运行这个命令：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, I’m testing for the presence of the `ls` executable file in the `/bin/`
    directory. The file is there, so the `echo` command is invoked. Now, let’s run
    the same command on a FreeBSD virtual machine:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我正在测试`/bin/`目录中是否存在`ls`可执行文件。该文件存在，因此调用了`echo`命令。现在，让我们在 FreeBSD 虚拟机上运行相同的命令：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This time I get an error, because the default user login shell on FreeBSD is
    `sh`, instead of `bash`. The problem here is that the `[[. . .]]` construct isn’t
    supported on the FreeBSD implementation of `sh`. Let’s see if we can fix that:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我遇到了一个错误，因为 FreeBSD 上的默认用户登录 shell 是`sh`，而不是`bash`。问题在于 FreeBSD 中的`sh`实现不支持`[[.
    . .]]`构造。让我们看看是否能解决这个问题：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Very cool, this works. So now, you’re wondering why anyone would use the non-POSIX
    `[[. . .]]` construct instead of the more portable `[. . .]`. Well, it’s mainly
    because certain types of tests don’t work with `[. . .]`. For example, let’s look
    at the `test-test-1.sh` script:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 非常酷，这个方法有效。那么现在，你可能在想为什么有人会使用非 POSIX 的`[[. . .]]`构造，而不是更具移植性的`[. . .]`。嗯，主要是因为某些类型的测试无法与`[.
    . .]`一起使用。例如，让我们看一下`test-test-1.sh`脚本：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When I invoke this script, I’ll supply a word as the `$1` positional parameter.
    If the first letter of the word is “z”, then the pattern will match.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当我调用这个脚本时，我会提供一个单词作为`$1`位置参数。如果单词的第一个字母是“z”，那么模式将匹配。
- en: In this script, `z*` is a regular expression. We’re using this regular expression
    to match all words that begin with the letter “z”. Any time you do regular expression
    matching within a test, you have to place it within a double square bracket, or
    `[[. . .]]`, construct.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中，`z*`是一个正则表达式。我们使用这个正则表达式来匹配所有以字母“z”开头的单词。每次在测试中使用正则表达式时，必须将其放在双中括号`[[.
    . .]]`构造内。
- en: (I explained about regular expressions in *Chapter 9, Filtering Text with grep,
    sed, and Regular Expressions*.)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: （我在*第9章，使用 grep、sed 和正则表达式过滤文本*中解释了正则表达式。）
- en: 'Here’s how it works:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是它的工作原理：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, look at the `test-test-2.sh` script, which uses `[. . .]`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看一下`test-test-2.sh`脚本，它使用了`[. . .]`：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is identical to the first script, except that it uses single square brackets
    for the test instead of double square brackets. Here’s what happens when I run
    the script:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本与第一个脚本完全相同，唯一的不同是它使用了单括号进行测试，而不是双括号。下面是我运行该脚本时发生的情况：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You see that this test doesn’t work with the single square brackets. That’s
    because the single square bracket construct doesn’t recognize the use of regular
    expressions. But, if using double square brackets doesn’t work on certain implementations
    of `sh`, then how can I make this script portable? Well, here’s one solution:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到，这个测试在单括号下不起作用。因为单括号构造不识别正则表达式的使用。但是，如果在某些`sh`实现中双括号不起作用，那么我该如何使这个脚本具有可移植性呢？好吧，这里有一个解决方案：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Instead of using the `z*` regular expression to match any word that begins with
    the letter “z”, I’m just echoing the word into the `cut -c1` command in order
    to isolate the first letter. I also changed the `==` in the test to `=`, because
    `==` is also considered a bashism.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我并没有使用`z*`正则表达式来匹配任何以字母“z”开头的单词，而是将单词传递给`cut -c1`命令，以便提取首字母。我还将测试中的`==`改为`=`，因为`==`也被认为是bash语法。
- en: The `==` actually does work with the FreeBSD implementation of `sh`, but it
    might not work on other implementations. For example, it doesn’t work on `dash`,
    which is invoked by `#!/bin/sh` on Debian/Ubuntu-type distros.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`==`实际上在FreeBSD的`sh`实现中有效，但可能在其他实现中不起作用。例如，在Debian/Ubuntu类型的发行版中，`#!/bin/sh`调用的`dash`就不支持它。'
- en: 'While I was at it, I changed the shebang line to `#!/bin/sh`, because I’ll
    also want to test this on FreeBSD with the Bourne shell. So, will this work? Let’s
    try it on Fedora, on which `#!/bin/sh` points to `bash`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在此过程中，我将shebang行更改为`#!/bin/sh`，因为我也想在FreeBSD上使用Bourne shell进行测试。那么，这能行吗？让我们在Fedora上试试，在Fedora上，`#!/bin/sh`指向的是`bash`：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Yeah, it works fine on Fedora. Now, let’s see what happens on FreeBSD:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，在Fedora上运行正常。现在，让我们看看在FreeBSD上会发生什么：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Yes indeed, it works like a champ. And, for the record, I also tested it on
    a Debian machine with `dash`, and it works fine on it, as well.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，它运行得非常顺利。而且，作为记录，我还在一台使用`dash`的Debian机器上进行了测试，它也能正常工作。
- en: Now, let’s look at our next portability problem.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下下一个可移植性问题。
- en: Making Portable Arrays
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建可移植的数组
- en: 'Sometimes, you need to create and manipulate lists of items in your shell scripts.
    With `bash`, you can create variable arrays the same as you can with languages
    such a C, C++, or Java. For example, let’s look at the `ip-2.sh` script:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你需要在Shell脚本中创建和操作项目列表。在`bash`中，你可以像在C、C++或Java等语言中一样创建变量数组。例如，让我们来看一下`ip-2.sh`脚本：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This is identical to the `ip.sh` script that I showed you in *Chapter 8, Basic
    Shell Script Construction*, except that I changed the shebang line to `#!/bin/sh`.
    To refresh your memory, I’m using the `declare -a` command to create the `ip`
    array, and the `ip=` line to populate the array. This should work fine on my Fedora
    machine, since the Fedora `sh` points to `bash`. Let’s see if it does:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本与我在*第8章，基本Shell脚本构建*中展示的`ip.sh`脚本完全相同，唯一不同的是我将shebang行改为`#!/bin/sh`。为了提醒你，我使用了`declare
    -a`命令来创建`ip`数组，并用`ip=`行来填充数组。这应该能在我的Fedora机器上正常工作，因为Fedora的`sh`指向的是`bash`。让我们看看它是否能正常工作：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Yes, it does work.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，它确实有效。
- en: 'Now, let’s see how it looks on FreeBSD:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看在FreeBSD上的表现如何：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The problem this time is that the Bourne (`sh`) shell on FreeBSD can’t use
    variable arrays. To make this script portable, we’ll need to find a work-around.
    So, let’s try this `ip-3.sh` script:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这次的问题是，FreeBSD上的Bourne（`sh`）shell不能使用变量数组。为了使脚本具备可移植性，我们需要找到一个解决方法。那么，让我们尝试这个`ip-3.sh`脚本：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Instead of building an actual array this time, I’m using the `set` command
    to create a list of IP addresses that I can access with positional parameters.
    I know, you thought that positional parameters were only for passing arguments
    in from the command line when you invoke the script. But what you see here is
    just another way to use them. The big question though is, does this work? Let’s
    see what it does on the FreeBSD machine:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我没有构建实际的数组，而是使用`set`命令创建了一个IP地址列表，并通过位置参数访问它。我知道，你可能认为位置参数仅仅用于在调用脚本时从命令行传递参数。但这里展示的其实是另一种使用位置参数的方法。大问题是，这能行吗？让我们看看它在FreeBSD机器上的效果：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Once again, we have achieved coolness.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次成功了。
- en: Note that when using `set` and positional parameters, we’re not creating an
    actual array. Instead, we’re just *simulating* an array. But hey, whatever works,
    right?
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在使用`set`和位置参数时，我们并没有创建一个真正的数组。我们只是*模拟*了一个数组。不过，管它的，反正有用，不是吗？
- en: 'You can also build a simulated array from a text file, using the `cat` command.
    First, let’s create the `iplist.txt` file, which looks like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以从文本文件中构建一个模拟数组，使用`cat`命令。首先，让我们创建`iplist.txt`文件，它看起来像这样：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, create the `ip-4.sh` script, like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建`ip-4.sh`脚本，如下所示：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And, here’s what I get when I run this on FreeBSD:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我在FreeBSD上运行时的结果：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: So yeah, it’s looking good.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，看起来不错。
- en: Next, let’s address something that hasn’t been a problem for us yet, but could
    be in the future. That is, the use of `echo`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们处理一个到目前为止还没有成为问题的事情，但未来可能会成为问题的。那就是，`echo`的使用。
- en: Understanding Portability Problems with echo
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解`echo`的可移植性问题
- en: 'So far, we haven’t encountered any problems with using `echo` in our scripts.
    That’s only because we haven’t used any of `echo`''s advanced formatting features.
    To demonstrate, run this command on your Fedora virtual machine:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在我们的脚本中使用`echo`没有遇到任何问题。那只是因为我们没有使用`echo`的高级格式化功能。为了演示这一点，请在你的Fedora虚拟机上运行这个命令：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `\v` that you see in the `\vto the moon` string inserts a vertical tab,
    which causes the output to be broken into two lines, with preceding tabs on the
    second line.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你在`\vto the moon`字符串中看到的`\v`插入了一个垂直制表符，导致输出被分成两行，第二行前面有制表符。
- en: 'To use the `\v` tag, I had to use `echo` with the `-e` option. Now, try this
    again without the `-e`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用`\v`标签，我必须在`echo`命令中使用`-e`选项。现在，尝试不使用`-e`命令：
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You see that without the `-e`, the `\v` doesn’t insert the vertical tab as it’s
    supposed to do.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，在没有`-e`选项的情况下，`\v`并没有按预期插入垂直制表符。
- en: 'The big problem with `echo` is that there’s no consistency in how the various
    non-`bash` shells handle its option switches. For example, let’s open a `dash`
    session on our Debian machine to see what happens on it:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`echo`的大问题是不同的非`bash`shell处理其选项开关的方式不一致。例如，让我们在Debian机器上打开一个`dash`会话，看看它上面发生了什么：'
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You see that on `dash`, `echo -e` inserts a `-e` at the beginning of the output
    string. But, if we omit the `-e`, the output displays correctly. That’s because
    the POSIX standard doesn’t define the `-e` option for `echo`. Instead, it just
    allows `echo` to recognize the backslash formatting options, such as `\v`, by
    default.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到在`dash`中，`echo -e`在输出字符串的开头插入了`-e`。但是，如果我们省略`-e`，输出仍然正确显示。这是因为POSIX标准并没有为`echo`定义`-e`选项。相反，它只是允许`echo`默认识别反斜杠格式化选项，如`\v`。
- en: 'The best way to have consistent output from your scripts is to use `printf`
    instead of `echo`. Here’s what that looks like on `dash`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 保证脚本输出一致的最好方法是使用`printf`而不是`echo`。以下是在`dash`中显示的情况：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When using `printf`, you need to place the formatting options ahead of the string
    that you want to output. In this case, the `%b` enables the use of the backslash
    formatting options within the output string, and the `\n` means to append a newline
    to the end of the output. You see that I’ve combined these two options within
    the `"%b\n"` construct. The cool part is that you can run this command on any
    of your virtual machines, with any shell, and the output will always be consistent.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`printf`时，你需要将格式化选项放在要输出的字符串前面。在这种情况下，`%b`启用在输出字符串中使用反斜杠格式化选项，而`\n`表示在输出的末尾附加换行符。你会看到，我将这两个选项组合在`"%b\n"`构造中。酷的是，你可以在任何虚拟机上、任何Shell中运行这个命令，输出总是会一致的。
- en: 'Finally, let’s look at the `ip-5.sh` script, which uses `printf` instead of
    echo:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们来看一下`ip-5.sh`脚本，它使用`printf`而不是`echo`：
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'For all but one of the `printf` lines, I used the `"%s\n"` formatting option,
    which just means to print out the specified text string with a newline at the
    end. In the fourth `printf` line, I used the `"%b\n"` option, which means to allow
    the use of backslash formatting options in the text. You then see that I surrounded
    the `$2` positional parameter with a pair of `\v` options in order to insert a
    pair of vertical tabs. Here’s how it looks when I run the script:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 除了一个`printf`行之外，我在所有`printf`行中都使用了`"%s\n"`格式化选项，它的意思是打印指定的文本字符串，并在末尾添加换行符。在第四行`printf`中，我使用了`"%b\n"`选项，它表示允许在文本中使用反斜杠格式化选项。你会看到，我将位置参数`$2`用一对`\v`选项括起来，以便插入一对垂直制表符。运行脚本时，它的输出如下所示：
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The cool part is, as I said before, the `printf` output will be consistent on
    all shells.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 酷的是，正如我之前所说，`printf`的输出在所有的shell中都会保持一致。
- en: Okay, now that you’ve seen some examples of bashisms, let’s look at how to test
    our scripts for POSIX compliance.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，现在你已经看到了 bashism 的一些例子，我们来看看如何测试我们的脚本是否符合 POSIX 标准。
- en: Testing Scripts for POSIX Compliance
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试脚本的 POSIX 合规性
- en: It’s always important to test your shell scripts before putting them into production.
    This becomes even more important when you create scripts that need to run on a
    wide variety of operating systems and shells. In this section, we’ll look at a
    few ways to perform that testing.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在将 shell 脚本投入生产环境之前，测试它们始终非常重要。当你创建需要在多种操作系统和 shell 上运行的脚本时，这一点尤其重要。在这一部分，我们将介绍一些测试方法。
- en: Creating Scripts on a POSIX-compliant Shell
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在符合 POSIX 标准的 Shell 上创建脚本
- en: 'When you first start creating your scripts, you might want to use an interpreter
    shell that’s completely POSIX-compliant. Be aware though, that some POSIX-compliant
    shells still allow you to use certain bashisms. That’s because POSIX defines a
    *minimum* standard that an operating system or shell must meet, and doesn’t prohibit
    adding extensions. For example, `sh` on FreeBSD allows these two bashisms:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次开始编写脚本时，可能会想使用一个完全符合 POSIX 标准的解释器 shell。但是需要注意的是，一些符合 POSIX 标准的 shell 仍然允许你使用某些
    bashism。这是因为 POSIX 定义了操作系统或 shell 必须满足的*最低*标准，并没有禁止添加扩展。例如，FreeBSD 上的 `sh` 允许使用以下两个
    bashism：
- en: Using `echo -e` for output.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `echo -e` 输出。
- en: Using `==` for text string comparisons.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `==` 进行文本字符串比较。
- en: Now, I haven’t extensively tested `sh` on FreeBSD to see exactly how many bashisms
    it allows. But, the fact that it allows at least these two means that we can’t
    use it to determine if our scripts will work on our entire network.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我还没有在 FreeBSD 上对 `sh` 进行广泛测试，以查看它到底允许多少 bashism。但是，至少允许这两个特性意味着我们不能仅凭它来确定我们的脚本是否能在整个网络上运行。
- en: The most fully POSIX-compliant shell that comes already installed on any operating
    system is `dash`. I’ve already mentioned that if you run a `#!/bin/sh` script
    on a Debian/Ubuntu-type system, it will use `dash` as the script interpreter.
    The benefit is that if you create a script that will run on `dash`, it will most
    likely also run correctly on every other shell.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最符合 POSIX 标准的 shell 是 `dash`，它已预装在任何操作系统中。我已经提到过，如果在 Debian/Ubuntu 类型的系统上运行一个
    `#!/bin/sh` 脚本，它会使用 `dash` 作为脚本解释器。好处是，如果你创建一个在 `dash` 上运行的脚本，它很可能也能在其他所有 shell
    上正确运行。
- en: 'Well, almost. Remember what I showed you just a while ago with `echo -e`. I
    showed you that on `bash`, you must use the `-e` option to include any backslash
    formatting options. Here’s what I mean:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，差不多吧。记住我刚才给你演示的 `echo -e`。我告诉你在 `bash` 中，必须使用 `-e` 选项才能包含任何反斜杠格式化选项。我的意思是这个：
- en: '[PRE31]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'So on `bash`, the `\v` formatting option doesn’t work unless you use `echo`
    with the `-e` switch. On `dash`, it’s the opposite, as you see here:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在 `bash` 上，`\v` 格式选项除非使用带有 `-e` 开关的 `echo`，否则无法使用。而在 `dash` 上，正好相反，正如你在这里看到的：
- en: '[PRE32]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: So, if you use `echo` commands in your scripts, they might work properly on
    `dash`, but not on `bash`. Your best bet, as I’ve mentioned before, is to use
    `printf` instead of `echo`. Aside from that though, if you do create scripts that
    will run on `dash`, you’ll also want to test them on `bash`. I don’t know how
    many POSIX-specific things there are that will run on `dash` but not on `bash`.
    But, we do know about this `echo -e` thing.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果你在脚本中使用 `echo` 命令，它们可能在 `dash` 上正常工作，但在 `bash` 上却不行。正如我之前提到的，最好的方法是使用 `printf`
    替代 `echo`。除此之外，如果你确实创建了将在 `dash` 上运行的脚本，你还需要在 `bash` 上对它们进行测试。我不清楚有多少 POSIX 特性可以在
    `dash` 上运行，但在 `bash` 上却不行。但是，我们确实知道这个 `echo -e` 问题。
- en: The **Policy-compliant Ordinary Shell** (`posh`) is a shell that’s even more
    strictly POSIX-compliant than `dash`. The main problem with it is that the Debian/Ubuntu-type
    distros appear to be the only ones that have it in their repositories. On the
    other hand, you can easily install `dash` on pretty much any Linux distro, as
    well as on some of the Unix-like distros, such as FreeBSD.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**符合政策的普通 Shell**（`posh`）是一种比 `dash` 更严格符合 POSIX 标准的 shell。它的主要问题是，似乎只有 Debian/Ubuntu
    类型的发行版在其仓库中包含它。另一方面，您几乎可以在任何 Linux 发行版上轻松安装 `dash`，以及一些类 Unix 发行版，如 FreeBSD。'
- en: 'At any rate, you can read more about `posh` here:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，您可以在这里阅读更多关于`posh`的内容：
- en: 'How to check your shell scripts for portability: [https://people.redhat.com/~thuth/blog/general/2021/04/27/portable-shell.html](https://people.redhat.com/~thuth/blog/general/2021/04/27/portable-shell.html)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如何检查您的 shell 脚本的可移植性：[https://people.redhat.com/~thuth/blog/general/2021/04/27/portable-shell.html](https://people.redhat.com/~thuth/blog/general/2021/04/27/portable-shell.html)
- en: And, speaking of testing, let’s look at ways to do that.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 说到测试，让我们看看如何进行测试。
- en: Using checkbashisms
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用checkbashisms
- en: 'This cool `checkbashisms` utility will look through your scripts for anything
    that might not work on non-`bash` shells. First though, you’ll need to install
    it. Here’s how to do it:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个很酷的`checkbashisms`工具会检查你的脚本，看看其中是否有可能在非`bash` shell上无法运行的内容。但首先，你需要安装它。下面是安装的方法：
- en: 'On Fedora:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在Fedora上：
- en: '[PRE33]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'On Debian/Ubuntu:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在Debian/Ubuntu上：
- en: '[PRE34]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'On FreeBSD:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在FreeBSD上：
- en: '[PRE35]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'On macOS:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS上：
- en: 'Install the Homebrew system, and then install the `checkbashisms` package with:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Homebrew系统，然后使用以下命令安装`checkbashisms`包：
- en: '[PRE36]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'For directions on how to install the Homebrew system on your Mac, go to: [https://brew.sh](https://brew.sh)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道如何在Mac上安装Homebrew系统，请访问：[https://brew.sh](https://brew.sh)
- en: 'Basic usage of `checkbashisms` is easy. If the script that you want to test
    has `#!/bin/sh` as its shebang line, then just enter:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`checkbashisms`的基本用法很简单。如果你想测试的脚本的shebang行是`#!/bin/sh`，那么只需输入：'
- en: '[PRE37]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'By default, `checkbashims` only checks scripts that have the `#!/bin/sh` shebang
    line. If your script uses something else as the shebang line, such as `#!/bin/bash`,
    then use the `-f` option to force it to check the script, like so:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`checkbashims`只检查包含`#!/bin/sh` shebang行的脚本。如果你的脚本使用了其他作为shebang行的内容，例如`#!/bin/bash`，那么可以使用`-f`选项强制它检查该脚本，像这样：
- en: '[PRE38]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'For the first example, let’s take another look at the `ip-2.sh` script:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个示例，让我们再看一下`ip-2.sh`脚本：
- en: '[PRE39]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, let’s see what `checkbashisms` has to say about it:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`checkbashisms`对此有什么看法：
- en: '[PRE40]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Well, that’s certainly no surprise, because we already established that some
    non-`bash` shells can’t do arrays. And, I’ve already shown you how to deal with
    that.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这倒不奇怪，因为我们已经确定一些非`bash`的shell无法处理数组。而且，我已经展示过如何处理这个问题。
- en: 'Okay, here’s a bashism that you haven’t seen yet, in the `math6.sh` script:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这是你在`math6.sh`脚本中还没有见过的一个bashism：
- en: '[PRE41]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This is a while loop that echoes the number 0 through 10, followed by a string
    of three dots, each on its own line. Here’s how its output looks:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个while循环，输出数字0到10，后面跟着一个字符串“三个点”，每个都在单独的一行。它的输出如下：
- en: '[PRE42]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'It looks good here on Fedora with `bash`. But, will it work on Debian with
    `dash`? Let’s see:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在Fedora上，使用`bash`看起来一切正常。但是，它能在使用`dash`的Debian上工作吗？我们来看一下：
- en: '[PRE43]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'What’s the problem? Perhaps `checkbashisms` can tell us:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 有什么问题吗？也许`checkbashisms`能告诉我们：
- en: '[PRE44]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The problem is in line 6\. It’s just that `bash` can use the `[. . .]` construct
    for performing integer math. But, other shells have to use the `((. . .))` construct.
    So, let’s fix that in the `math7.sh` script:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 问题出在第6行。因为只有`bash`可以使用`[ . . . ]`结构进行整数运算。而其他shell则必须使用`(( . . . ))`结构。我们来在`math7.sh`脚本中修复这个问题：
- en: '[PRE45]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'That should work much better, right? Well, let’s see:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 那样应该会好很多，对吧？好吧，我们来看看：
- en: '[PRE46]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'No, it’s still broken. So, let’s give it another `checkbashisms` scan:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 不，它仍然有问题。所以，让我们再给它一次`checkbashisms`扫描：
- en: '[PRE47]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Whoa, now. What’s going on here? The `checkbashisms` scan says that my code
    is good, yet the script is still clearly broken when running on `dash`. What’s
    up with that? Well, after a bit of experimentation, I discovered that surrounding
    the variable name that’s within the math expression with a pair of quotes is also
    a bashism. But, it’s one that `checkbashisms` doesn’t catch. Let’s fix that in
    the `math8.sh` script:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，怎么回事？`checkbashisms`扫描说我的代码是好的，但脚本在`dash`上运行时仍然明显有问题。怎么回事呢？经过一番实验，我发现把数学表达式中的变量名用一对引号括起来也是一个bashism。但这是`checkbashisms`没捕捉到的。我们来在`math8.sh`脚本中修复这个问题：
- en: '[PRE48]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Okay, will this now finally work? Drum roll, please!
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这次应该终于能行吗？请听鼓声！
- en: '[PRE49]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Indeed, it now works like a champ.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，现在它工作得非常顺利。
- en: So, you’ve seen that `checkbashisms` is a great utility that can really help
    you out. But, as with most things that mankind has invented, it isn’t perfect.
    It can flag a lot of problematic, non-POSIX code, but it does allow some `bash`-specific
    things to slip through. (It would be nice if there were a list of things that
    `checkbashisms` misses, but there isn’t.)
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你已经看到`checkbashisms`是一个很棒的工具，能帮助你发现问题。但正如人类发明的大多数东西一样，它并不完美。它能够标记许多有问题的、非POSIX的代码，但它也允许一些特定于`bash`的东西漏过。（如果能有一份`checkbashisms`漏掉的内容清单就好了，但目前没有。）
- en: All right, let’s move on to our next code-checking utility.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们继续看下一个代码检查工具。
- en: Using shellcheck
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用shellcheck
- en: 'The `shellcheck` utility is another great code-checking tool that can also
    check for bashisms. It’s available on most Linux and BSD distros. Here’s how to
    install it:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`shellcheck`工具是另一个很棒的代码检查工具，也能检查bashisms。它在大多数Linux和BSD发行版上都可以使用。下面是如何安装它：'
- en: 'On Fedora:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在Fedora上：
- en: '[PRE50]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'On Debian/Ubuntu:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Debian/Ubuntu 上：
- en: '[PRE51]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'On FreeBSD:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在 FreeBSD 上：
- en: '[PRE52]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'On macOS with Homebrew installed:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装了 Homebrew 的 macOS 上：
- en: '[PRE53]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'To demo this, let’s go back to the Debian machine, and scan the same scripts
    that we scanned with `checkbashisms`. We’ll begin with the `ip-2.sh` script. Here
    are the relevant parts of the output:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这个问题，让我们回到 Debian 机器，扫描与 `checkbashisms` 一起扫描的相同脚本。我们从 `ip-2.sh` 脚本开始。以下是相关的输出部分：
- en: '[PRE54]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: You see that `shellcheck` does warn us that we can’t use arrays in POSIX-compliant
    scripts. It also warns us about issues involving good programming practices that
    aren’t necessarily POSIX issues. In this case, it reminds us that we should surround
    variable expansion constructs, `${ip[0]}` in this case, with a pair of double
    quotes in order to prevent whitespace problems. Of course, that’s a moot point
    here, because the `${ip[0]}` construct here is part of the array definition that
    we can’t use anyway.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到，`shellcheck` 确实警告我们在 POSIX 兼容的脚本中不能使用数组。它还会提醒我们一些良好编程实践方面的问题，这些问题不一定是 POSIX
    的问题。在这个案例中，它提醒我们应该将变量扩展构造 `${ip[0]}`（在这种情况下）用一对双引号括起来，以防止空白问题。当然，这在这里并不重要，因为 `${ip[0]}`
    构造本身是我们无法使用的数组定义的一部分。
- en: 'Now, let’s try the `math6.sh` script:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试一下 `math6.sh` 脚本：
- en: '[PRE55]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: As expected, `shellcheck` detects the non-POSIX way of doing math. So, that’s
    good.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，`shellcheck` 检测到了一种非 POSIX 的数学运算方式。所以，这很好。
- en: 'Scanning `math7.sh` gives us this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描 `math7.sh` 会得到以下结果：
- en: '[PRE56]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Here, we see the same problem that we saw with `checkbashisms`. That is, `math7.sh`
    has the variable name that’s within the math construct surrounded by a pair of
    double quotes, as you see in the `start=$(("$start"+1))` line. We’ve already established
    that this works on `bash` but not on `dash`, yet `shellcheck` doesn’t flag this
    as a problem.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到与 `checkbashisms` 一样的问题。也就是说，`math7.sh` 中数学构造内的变量名被一对双引号包围，就像你在 `start=$(("$start"+1))`
    这一行中看到的那样。我们已经确认这种方式在 `bash` 上有效，但在 `dash` 上无效，然而 `shellcheck` 并没有将此标记为问题。
- en: 'Finally, let’s try this with `math8.sh`. As you’ll recall, this is the script
    that we finally got to work on `dash`. Here’s how that looks:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们尝试一下 `math8.sh`。正如你所记得的，这就是我们最终在 `dash` 上能正常工作的脚本。它的样子是这样的：
- en: '[PRE57]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In this case, the script works perfectly well on our Debian/`dash` machine.
    Here, `shellcheck` is pointing out a stylistic issue that doesn’t affect whether
    the script will actually work. If you recall from *Chapter 11, Performing Mathematical
    Operations*, I showed you that when recalling the value of a variable that’s within
    a math construct, it’s not necessary to preface the variable name with a `$`.
    I mean, it doesn’t hurt anything if you do, but it’s not necessary.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，脚本在我们的 Debian/`dash` 机器上运行得非常顺利。在这里，`shellcheck` 提出了一个风格问题，这个问题不会影响脚本是否真正运行。如果你还记得
    *第11章，执行数学运算*，我曾经向你展示过，当回调一个在数学构造中的变量时，变量名前不需要加 `$`。我的意思是，如果你加了也没关系，但实际上并不需要。
- en: Specifying a Shell with the -s Option
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `-s` 选项指定 Shell
- en: 'Another benefit of using `shellcheck` is that you can use the `-s` option to
    specify which shell that you want to use for testing your script. Even if the
    shebang line in your script is `#!/bin/sh`, and `sh` on your machine points to
    a non-`bash` shell, you can still test it against `bash`, like this:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `shellcheck` 的另一个好处是，你可以使用 `-s` 选项指定你想要用来测试脚本的 Shell。即使你的脚本中的 shebang 行是
    `#!/bin/sh`，而且你机器上的 `sh` 指向的是非 `bash` 的 Shell，你仍然可以像这样使用 `bash` 进行测试：
- en: '[PRE58]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: By testing against `bash`, we no longer get the warning about how we can’t use
    arrays. All we get this time is just a reminder that we should surround variable
    names with double quotes.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 `bash` 上测试，我们不再收到关于不能使用数组的警告。这次我们收到的只是一个提醒，告诉我们应该将变量名用双引号括起来。
- en: With the `-s` option, you can specify `sh`, `bash`, `dash`, or `ksh`. (Curiously,
    it doesn’t work with `zsh`.)
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `-s` 选项，你可以指定 `sh`、`bash`、`dash` 或 `ksh`。 （奇怪的是，它在 `zsh` 上无法使用。）
- en: Hands-on Lab – Using -s to Scan Function Libraries
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实践实验室 – 使用 -s 扫描函数库
- en: You can also use the `-s` option to scan function library files that don’t have
    a shebang line. To see how that’s done, let’s scan the `sysinfo.lib` file that
    we last encountered back in *Chapter 14, Using awk-Part 1*.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 `-s` 选项扫描没有 shebang 行的函数库文件。要查看如何做，让我们扫描一下在 *第14章，使用 awk-第一部分* 中最后遇到的
    `sysinfo.lib` 文件。
- en: The scripts and library files in this section are too large to show here in
    their entirety. So, be sure to download them from the GitHub repository.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的脚本和库文件过大，无法在此处完全显示。因此，务必从 GitHub 仓库下载它们。
- en: 'First, copy the `sysinfo.lib` file to `sysinfo_posix.lib`, like so:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将`sysinfo.lib`文件复制到`sysinfo_posix.lib`，如下所示：
- en: '[PRE59]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Then, scan it for `bash`, since it was originally only meant to be used on
    `bash`. Here’s the relevant output:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，扫描它以查找`bash`，因为它最初只打算在`bash`上使用。以下是相关的输出：
- en: '[PRE60]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'For `bash`, `shellcheck` didn’t find any show-stopping problems. But, it does
    suggest some improvements that could prevent problems. First, it suggests that
    I surround the `uname` command substitutions with double quotes, in case `uname`
    returns a text string that contains either white space or special characters that
    the shell could misinterpret. In reality, though, this will never be a problem
    in this script, because we know that `uname` will never return anything except
    for a plain-text, purely alphabetic string. But, let’s fix it anyway. In this
    case, the `if [ $(uname) = SunOS ]; then` line will become:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`bash`，`shellcheck`并没有发现任何阻碍的问题。但它确实建议了一些可以避免问题的改进。首先，它建议我用双引号将`uname`命令的替换包围起来，以防`uname`返回的文本字符串中包含空格或特殊字符，这些字符可能会被Shell误解。实际上，这在本脚本中永远不会成为问题，因为我们知道`uname`返回的永远是一个纯文本、仅包含字母的字符串。但我们还是做了修改。在这种情况下，`if
    [ $(uname) = SunOS ]; then`这一行将变成：
- en: '[PRE61]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We’ll do the same thing for every occurrence of the uname command substitution.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会对每个`uname`命令替换的出现位置做同样的处理。
- en: 'The second suggestion we see is to insert a graceful exit mechanism in case
    the script can’t `cd` into the /`Users/` directory. Again, we know that this won’t
    be a problem in this script, because we know that the specified directory will
    always be present. But again, let’s fix it anyway. Let’s take that `cd /Users`
    line and change it to:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们看到的第二个建议是，在脚本无法`cd`进入`/Users/`目录时插入一个优雅的退出机制。同样，我们知道在本脚本中这不会成为问题，因为我们知道指定的目录始终会存在。但我们还是做了修改。我们将那条`cd
    /Users`命令改成：
- en: '[PRE62]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We’ll do the same thing for all of the `cd` commands in the `open_files_users()`
    function. That way, if a `cd` command fails, the script will just continue running
    without this function.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会对`open_files_users()`函数中的所有`cd`命令做同样的处理。这样，如果`cd`命令失败，脚本将继续运行，而不会中断这个函数。
- en: 'Now, let’s say that we want to make this script portable, so that we won’t
    have to install `bash` on all of our systems. As I mentioned before, `dash` is
    the most POSIX-compliant shell that’s widely available for most Linux and BSD-type
    distros. So, let’s use `-s dash` to scan the file again:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，假设我们希望使这个脚本具有可移植性，这样我们就不必在所有系统上都安装`bash`。如我之前提到的，`dash`是大多数Linux和BSD类型发行版中最符合POSIX标准的Shell。所以，我们再次使用`-s
    dash`来扫描文件：
- en: '[PRE63]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We’ve seen the first problem in previous scripts. It’s just that the `[[. .
    .]]` construct isn’t supported on some non-`bash` shells, such as `dash`. Fortunately,
    there’s no reason that requires us to use the double square brackets in this case,
    so we can just replace them with single square brackets. So, we’ll change the
    offending line to:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在之前的脚本中已经看到第一个问题。只是`[[. . .]]`结构在一些非`bash`的Shell中不被支持，比如`dash`。幸运的是，这里没有任何原因要求我们必须使用双中括号，所以我们可以直接将它们替换为单中括号。所以，我们将修改出问题的那一行：
- en: '[PRE64]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The second problem is one that we haven’t seen yet. The `"${os:12}"` type of
    variable expansion is another bashism that won’t work on either Bourne shell or
    `dash`. To refresh your memory, the `os` variable is defined in the `system_info()`
    function that’s toward the end of the file. The variable definition, when done
    from the command-line, looks like this:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个问题是我们之前还没有遇到的。`"${os:12}"`类型的变量扩展是另一个`bash`特性，在Bourne shell或`dash`中无法使用。为了提醒你记忆，`os`变量是在文件末尾的`system_info()`函数中定义的。从命令行定义时，变量是这样的：
- en: '[PRE65]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'But, we don’t want the `PRETTY_NAME=` part to show up in the report. All we
    want is just the name of the operating system. This `PRETTY_NAME=` string consists
    of 12 characters. On `bash`, we can strip those 12 characters away by doing:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们不希望`PRETTY_NAME=`部分出现在报告中。我们只想要操作系统的名称。这个`PRETTY_NAME=`字符串包含12个字符。在`bash`中，我们可以通过如下方式去掉这12个字符：
- en: '[PRE66]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'It looks good there, but watch what happens when I try this in a `dash` session:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 它在那里看起来不错，但看看我在`dash`会话中尝试时会发生什么：
- en: '[PRE67]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Oh dear, that doesn’t work at all. Fortunately, this is an easy fix. We’ll
    just use a POSIX-compliant form of variable expansion, which looks like this:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀，这根本不起作用。幸运的是，这很容易修复。我们只需使用一种符合POSIX标准的变量扩展形式，看起来是这样的：
- en: '[PRE68]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Instead of specifying the number of characters to strip from the beginning of
    the text string, we just specify the actual portion of the text string to strip.
    And, I replaced the `:` with a `#`. Easy, right?
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再指定要从文本字符串开头去除的字符数，而是直接指定要去除的文本部分。而且，我将 `:` 替换为了 `#`。简单吧？
- en: This is one of the great mysteries of life that I haven’t yet figured out. Most
    bashisms were created as either a simpler way to do things, or to allow `bash`
    to do things that other shells can’t do at all. In this case, the `bash` way of
    performing variable expansion isn’t any easier than the POSIX way. So why did
    the `bash` developers even bother to give us this new, non-POSIX way? Your guess
    is as good as mine.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我至今尚未弄明白的生活之谜之一。大多数 bashism 是作为一种更简单的方式来完成某些事情，或是为了让 `bash` 执行其他 shell 完全无法做到的任务。在这种情况下，`bash`
    执行变量扩展的方式并不比 POSIX 的方式更简便。那么，为什么 `bash` 的开发者还要为我们提供这种新的非 POSIX 方式呢？你我猜测一样。
- en: 'At any rate, you can read more about POSIX-compliant variable expansion here:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，你可以在这里阅读更多关于 POSIX 兼容的变量扩展的内容：
- en: 'POSIX shell cheat sheet: [https://steinbaugh.com/posts/posix.html](https://steinbaugh.com/posts/posix.html)'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX shell备忘单：[https://steinbaugh.com/posts/posix.html](https://steinbaugh.com/posts/posix.html)
- en: 'Next, we need to scan the script that uses this function library. Start by
    copying the `system_info.sh` to `system_info_posix.sh`:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要扫描使用此函数库的脚本。首先，将 `system_info.sh` 复制为 `system_info_posix.sh`：
- en: '[PRE69]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now, scan the `system_info_posix.sh` script for `dash` compatibility:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，扫描 `system_info_posix.sh` 脚本以检查其是否与 `dash` 兼容：
- en: '[PRE70]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The first thing we see is that “In dash, HOSTNAME is not supported.” That seems
    strange, because all I’m doing here is calling the value of an environmental variable.
    But, it says that it doesn’t work, so I’ll change it to use command substitution
    with the `hostname` command, like so:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先看到的是，“在 dash 中，HOSTNAME 不受支持。”这听起来有点奇怪，因为我在这里做的只是调用一个环境变量的值。但它说这不起作用，因此我将其改为使用
    `hostname` 命令的命令替换，像这样：
- en: '[PRE71]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The next problem is the same old problem that we’ve seen before with the double
    square brackets. It’s another case where double square brackets aren’t necessary
    anyway, so I’ll change it to single square brackets, like so:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个问题是我们之前看到过的那个老问题——双中括号。又是一个不需要双中括号的情况，所以我将其更改为单中括号，如下所示：
- en: '[PRE72]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Next, let’s copy the `sysinfo_posix.lib` file to its proper place in the `/usr/local/lib/`
    directory:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将 `sysinfo_posix.lib` 文件复制到 `/usr/local/lib/` 目录中的正确位置：
- en: '[PRE73]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Now, edit the `system_info_posix.sh` script so that it will source the new
    function library, and use `sh` as the interpreter shell. Make the top part of
    the script look like this:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编辑 `system_info_posix.sh` 脚本，使其加载新的函数库，并使用 `sh` 作为解释器。使脚本的顶部部分看起来像这样：
- en: '[PRE74]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Finally, copy the `system_info_posix.sh` script and the `sysinfo_posix.lib`
    file to other machines with other operating systems. You should find that this
    script and function library will work well on other Linux distros, as well as
    on FreeBSD, OpenIndiana, and macOS.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将 `system_info_posix.sh` 脚本和 `sysinfo_posix.lib` 文件复制到其他操作系统的机器上。你应该会发现，这个脚本和函数库在其他
    Linux 发行版、FreeBSD、OpenIndiana 和 macOS 上也能很好地工作。
- en: End of lab
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 实验结束
- en: So, we’ve covered `checkbashisms` and `shellcheck`. Shall we cover one more
    handy script-checking utility? Indeed we shall, and we shall do it now.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 到此，我们已经介绍了 `checkbashisms` 和 `shellcheck`。我们还要介绍另一个有用的脚本检查工具吗？当然要，我们现在就来介绍。
- en: Using shall
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 shall
- en: The `checkbashisms` and `shellcheck` utilities act as **static code checkers**.
    This means that instead of actually running the scripts to see if they work, these
    two utilities just look through the code to detect problems. Sometimes though,
    it’s helpful to have a **dynamic code checker** that will actually run the code
    to see what happens. That’s where `shall` comes in.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`checkbashisms` 和 `shellcheck` 工具作为 **静态代码检查工具**。这意味着，这两个工具并不是实际运行脚本来验证它们是否有效，而是直接扫描代码以检测潜在问题。不过，有时使用
    **动态代码检查器** 会更有帮助，动态检查器会实际运行代码以观察其结果。这时，`shall` 就派上用场了。'
- en: '`shall` is a `bash` script that you can download from the author’s GitHub repository.
    The easiest way to install it is to clone the repository, like this:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`shall` 是一个 `bash` 脚本，你可以从作者的 GitHub 仓库下载。最简单的安装方法是克隆该仓库，如下所示：'
- en: '[PRE75]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Then, go into the `shall/bin/` directory, and copy the `shall` script to the
    `/usr/local/bin/` directory, like so:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，进入 `shall/bin/` 目录，将 `shall` 脚本复制到 `/usr/local/bin/` 目录中，如下所示：
- en: '[PRE76]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Now, here’s the cool part. With only a single command, `shall` can test your
    scripts against `sh`, `bash`, `dash`, `zsh`, and `ksh`. (It doesn’t matter which
    interpreter shell you specify in the scripts’ shebang line.) Most Linux and BSD
    distros have these various shells in their package repositories, so you can install
    ones that aren’t installed already.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这是最酷的部分。通过一个命令，`shall`可以测试你的脚本是否适用于`sh`、`bash`、`dash`、`zsh`和`ksh`。（不管你在脚本的shebang行中指定的是哪个解释器Shell。）大多数Linux和BSD发行版的包仓库中都有这些不同的Shell，所以你可以安装那些还没有安装的Shell。
- en: 'Of course, `dash` and `bash` are already installed on our Debian machine, so
    let’s install `zsh` and `ksh`:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`dash`和`bash`已经安装在我们的Debian机器上了，所以我们来安装`zsh`和`ksh`：
- en: '[PRE77]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Let’s begin by testing our `ip-2.sh` script. The output is too long to show
    in its entirety, so I’ll just show some relevant sections. Here’s the top part:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从测试我们的`ip-2.sh`脚本开始。输出太长，无法完全显示，所以我只会展示一些相关的部分。这里是顶部内容：
- en: '[PRE78]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The first check was for `sh`, which on Debian really means `dash`. You see
    here that the script couldn’t run, because `dash` can’t work with arrays. The
    next check is for `bash`, which looks like this:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个检查是针对`sh`的，在Debian中实际上意味着`dash`。你可以看到脚本无法运行，因为`dash`无法处理数组。接下来的检查是针对`bash`的，看起来是这样的：
- en: '[PRE79]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The `zsh` and `ksh` checks that follow look the same. At the very bottom of
    the output, you’ll see this:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 后面的`zsh`和`ksh`检查看起来是一样的。在输出的最底部，你会看到这样的内容：
- en: '[PRE80]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: This means that our `ip-2.sh` script runs fine on `bash`, `zsh`, and `ksh`,
    but it won’t run on `dash`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们的`ip-2.sh`脚本在`bash`、`zsh`和`ksh`上运行正常，但在`dash`上不能运行。
- en: 'But, as cool as `shall` is, it isn’t quite perfect. To see what I mean, create
    the `fly.sh` script, like this:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，尽管`shall`非常酷，它也并不完美。为了说明这一点，创建一个`fly.sh`脚本，像这样：
- en: '[PRE81]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'This is just a simple little script that demonstrates the problem with using
    `echo -e` in your scripts, as I showed you a few pages back. Here’s what happens
    when I test `fly.sh` with `shall`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个简单的小脚本，演示了使用`echo -e`时在脚本中遇到的问题，正如我在几页前向你展示的那样。当我使用`shall`测试`fly.sh`时，会发生这样的情况：
- en: '[PRE82]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: So, `shall` says that the script ran correctly on all four shells. But, at the
    top of the output, you see that the `-e` shows up in the `echo` output with `dash`,
    which is the problem that I showed you before. The bottom line here is that when
    you use `shall`, don’t just depend on what the status line at the bottom of the
    output says. Look at the output for all of the shells, and ensure that the output
    is what you really want to see.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，`shall`表示脚本在所有四个Shell上都运行正确。但是，在输出的顶部，你会看到`-e`在`echo`输出中出现了`dash`，这就是我之前向你展示的问题。关键是，当你使用`shall`时，不要仅仅依赖输出底部状态行所显示的内容。查看所有Shell的输出，确保输出是你真正想看到的。
- en: The only other problem with `shall` isn’t really with `shall`, but with `sh`.
    Remember that `sh` points to a different shell on different Linux, BSD, and Unix
    distros. You can install `shall` on any of these distros, as long as you can install
    `bash` on them. Then, just copy the `shall` script to the machine on which you
    want to test `sh` scripts.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`shall`的唯一其他问题其实并不在`shall`本身，而是在`sh`。记住，`sh`在不同的Linux、BSD和Unix发行版上指向不同的Shell。你可以在这些发行版上安装`shall`，只要你能够在它们上安装`bash`。然后，只需将`shall`脚本复制到你想要测试`sh`脚本的机器上。'
- en: 'A man page is embedded into the `shall` script. To see it, just do:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`shall`脚本中嵌入了一个手册页面。要查看它，只需执行：'
- en: '`shall --man`'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`shall --man`'
- en: Okay, I think that about does it for this chapter. Let’s summarize and move
    on.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我想这一章就到此为止。让我们总结一下并继续下一章。
- en: Summary
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Script portability is important if you need to create scripts that will run
    on a wide variety of Linux, Unix, or Unix-like operating systems. I began by showing
    you how to install bash on various BSD-type distros, and how to ensure that your
    scripts will find `bash` on them. After that, I explained the POSIX standard,
    and why it’s needed. Then, I showed you some bashisms, and some cool utilities
    that can test your scripts for them.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要编写可以在各种Linux、Unix或类Unix操作系统上运行的脚本，脚本的可移植性非常重要。我首先向你展示了如何在各种BSD类发行版上安装bash，并确保你的脚本能够在这些系统上找到`bash`。之后，我解释了POSIX标准及其必要性。然后，我展示了一些bash特性和一些可以测试脚本的实用工具。
- en: In the next chapter, we’ll talk about shell script security. I’ll see you there.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将讨论Shell脚本的安全性。到时候见。
- en: Questions
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: For shell scripters, what is the most important reason for following the POSIX
    standard?
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于Shell脚本编写者，遵循POSIX标准的最重要原因是什么？
- en: To ensure that scripts will only run on Linux operating systems.
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保脚本仅在Linux操作系统上运行。
- en: To ensure that scripts can run on a wide variety of Linux, Unix, and Unix-like
    operating systems.
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保脚本能够在各种 Linux、Unix 和类似 Unix 的操作系统上运行。
- en: To ensure that all operating systems are running `bash`.
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保所有操作系统都运行`bash`。
- en: To ensure that scripts can use the advanced features of `bash`.
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保脚本能够使用`bash`的高级功能。
- en: Which of the following is a dynamic code checker?
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪项是动态代码检查器？
- en: '`checkbashisms`'
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`checkbashisms`'
- en: '`shellcheck`'
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`shellcheck`'
- en: '`shall`'
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`shall`'
- en: '`will`'
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`will`'
- en: Which of the following statements about `sh` is true?
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下关于`sh`的说法哪项正确？
- en: On every operating system, `sh` is always the Bourne shell.
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个操作系统上，`sh` 总是 Bourne shell。
- en: On every operating system, `sh` is a symbolic link that points to `bash`.
  id: totrans-313
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个操作系统上，`sh` 都是一个指向`bash`的符号链接。
- en: '`sh` represents a different shell on different operating systems.'
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sh` 在不同操作系统上代表不同的 shell。'
- en: You want to solve a math problem, and assign its value to a variable. Which
    of the following constructs would you use for best portability?
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你想解决一个数学问题，并将其值赋给一个变量。你会使用以下哪种构造来确保最佳的可移植性？
- en: '`var=$(3*4)`'
  id: totrans-316
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`var=$(3*4)`'
- en: '`var=$[3*4]`'
  id: totrans-317
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`var=$[3*4]`'
- en: '`var=$[[3*4]]`'
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`var=$[[3*4]]`'
- en: '`var=$((3*4))`'
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`var=$((3*4))`'
- en: Further Reading
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'UNIX Vs Linux: How Are They Different?: [https://www.maketecheasier.com/unix-vs-linux-how-are-they-different/](https://www.maketecheasier.com/unix-vs-linux-how-are-they-different/)'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'UNIX与Linux：它们有什么不同？: [https://www.maketecheasier.com/unix-vs-linux-how-are-they-different/](https://www.maketecheasier.com/unix-vs-linux-how-are-they-different/)'
- en: 'What is the difference between “#!/usr/bin/env bash” and “#!/usr/bin/bash”?:
    [https://stackoverflow.com/questions/16365130/what-is-the-difference-between-usr-bin-env-bash-and-usr-bin-bash](https://stackoverflow.com/questions/16365130/what-is-the-difference-between-usr-bin-env-bash-and-usr-bin-bash)'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '“#!/usr/bin/env bash”和“#!/usr/bin/bash”之间有什么区别？: [https://stackoverflow.com/questions/16365130/what-is-the-difference-between-usr-bin-env-bash-and-usr-bin-bash](https://stackoverflow.com/questions/16365130/what-is-the-difference-between-usr-bin-env-bash-and-usr-bin-bash)'
- en: 'Writing Bash Scripts that aren’t Only Bash: Checking for Bashisms and Using
    Dash: [https://www.bowmanjd.com/bash-not-bash-posix/](https://www.bowmanjd.com/bash-not-bash-posix/)'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '编写不仅仅是 Bash 的 Bash 脚本：检查 Bashisms 和使用 Dash: [https://www.bowmanjd.com/bash-not-bash-posix/](https://www.bowmanjd.com/bash-not-bash-posix/)'
- en: 'A Brief POSIX Advocacy: [https://www.usenix.org/system/files/login/articles/login_spring16_09_tomei.pdf](https://www.usenix.org/system/files/login/articles/login_spring16_09_tomei.pdf)'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '简短的 POSIX 推广: [https://www.usenix.org/system/files/login/articles/login_spring16_09_tomei.pdf](https://www.usenix.org/system/files/login/articles/login_spring16_09_tomei.pdf)'
- en: 'A Guide to POSIX: [https://www.baeldung.com/linux/posix](https://www.baeldung.com/linux/posix)'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'POSIX指南: [https://www.baeldung.com/linux/posix](https://www.baeldung.com/linux/posix)'
- en: 'How can I test for POSIX compliance of shell scripts?: [https://unix.stackexchange.com/questions/48786/how-can-i-test-for-posix-compliance-of-shell-scripts](https://unix.stackexchange.com/questions/48786/how-can-i-test-for-posix-compliance-of-shell-scripts)'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '如何测试 shell 脚本的 POSIX 合规性？: [https://unix.stackexchange.com/questions/48786/how-can-i-test-for-posix-compliance-of-shell-scripts](https://unix.stackexchange.com/questions/48786/how-can-i-test-for-posix-compliance-of-shell-scripts)'
- en: 'Making Unix Shell Scripts POSIX-compliant: [https://stackoverflow.com/questions/40916071/making-unix-shell-scripts-posix-compliant](https://stackoverflow.com/questions/40916071/making-unix-shell-scripts-posix-compliant)'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '使 Unix Shell 脚本符合 POSIX 标准: [https://stackoverflow.com/questions/40916071/making-unix-shell-scripts-posix-compliant](https://stackoverflow.com/questions/40916071/making-unix-shell-scripts-posix-compliant)'
- en: 'Rich’s sh (POSIX shell) Tricks: [http://www.etalabs.net/sh_tricks.html](http://www.etalabs.net/sh_tricks.html)'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Rich的 sh（POSIX shell）技巧: [http://www.etalabs.net/sh_tricks.html](http://www.etalabs.net/sh_tricks.html)'
- en: 'Dash–ArchWiki: [https://wiki.archlinux.org/title/Dash](https://wiki.archlinux.org/title/Dash)'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Dash–ArchWiki: [https://wiki.archlinux.org/title/Dash](https://wiki.archlinux.org/title/Dash)'
- en: 'POSIX shell cheat sheet: [https://steinbaugh.com/posts/posix.html](https://steinbaugh.com/posts/posix.html)'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'POSIX shell备忘单: [https://steinbaugh.com/posts/posix.html](https://steinbaugh.com/posts/posix.html)'
- en: 'Is there a minimally POSIX.2 compliant shell?: [https://stackoverflow.com/questions/11376975/is-there-a-minimally-posix-2-compliant-shell](https://stackoverflow.com/questions/11376975/is-there-a-minimally-posix-2-compliant-shell)'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '是否有符合 POSIX.2 最小要求的 shell？: [https://stackoverflow.com/questions/11376975/is-there-a-minimally-posix-2-compliant-shell](https://stackoverflow.com/questions/11376975/is-there-a-minimally-posix-2-compliant-shell)'
- en: Answers
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: b
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b
- en: c
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: c
- en: c
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: c
- en: d
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: d
- en: Join our community on Discord!
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区！
- en: Read this book alongside other users, Linux experts, and the author himself.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 和其他用户、Linux 专家以及作者本人一起阅读这本书。
- en: Ask questions, provide solutions to other readers, chat with the author via
    Ask Me Anything sessions, and much more. Scan the QR code or visit the link to
    join the community.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 提出问题，为其他读者提供解决方案，通过“问我任何问题”环节与作者聊天，等等。扫描二维码或访问链接加入社区。
- en: '[https://packt.link/SecNet](https://packt.link/SecNet)'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/SecNet](https://packt.link/SecNet)'
- en: '![](img/QR_Code10596186092701843.png)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code10596186092701843.png)'
