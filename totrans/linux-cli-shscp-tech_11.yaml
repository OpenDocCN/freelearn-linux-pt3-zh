- en: '*Chapter 11*: Working with Variables'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 11 章*：与变量一起工作'
- en: '`if` statements.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` 语句。'
- en: 'We will cover the following recipes in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下内容：
- en: Using shell variables
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 shell 变量
- en: Using variables in shell scripting
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 shell 脚本中使用变量
- en: Quoting in the shell
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shell 中的引号
- en: Performing operations on variables
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对变量执行操作
- en: Variables via external commands
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过外部命令使用变量
- en: We are going to cover the most important things you need to know about variables,
    but as with almost everything else, this chapter will require you to practice.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖你需要了解的有关变量的最重要内容，但和几乎所有其他内容一样，本章内容需要你进行实践。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The machine you can use for these recipes is the same as in the previous chapters
    on scripting—basically, anything that can run bash is going to work. In our case,
    we are using a **virtual machine** (**VM**) with Linux and Ubuntu 20.10 installed.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用的机器与前几章脚本编写中的机器相同——基本上，任何能够运行 bash 的机器都能使用。在我们的案例中，我们使用的是安装了 Linux 和 Ubuntu
    20.10 的**虚拟机**（**VM**）。
- en: So, start your VM, and let's get cracking!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，启动你的虚拟机，咱们开始吧！
- en: Using shell variables
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 shell 变量
- en: Variables are something that you probably understand, even if only conceptually.
    We are not talking about programming here; our everyday life is full of variables.
    Basically, a variable is something that holds a value and that can provide us
    with that value once we need it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 变量是你可能已经理解的概念，即使只是从概念上理解。我们这里说的不是编程；我们的日常生活中充满了变量。基本上，变量是能够存储一个值的东西，且在我们需要它时可以为我们提供这个值。
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In everyday language, we could say an activity such as driving is full of variables.
    This means that the weather temperature, the amount of ambient light, the quality
    of the road surface, and many other things are going to change as you move along.
    Even though they are changing all the time, it is important that at any given
    point, we are able to see what the actual *value* of the weather is, what is the
    actual value of the temperature, how much light we have, and how the road behaves
    or how it is structured.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 用日常语言来说，我们可以说像开车这样的活动充满了变量。这意味着，天气温度、环境光照、路面质量等许多因素在你行驶过程中都会发生变化。尽管它们不断变化，但重要的是，在任何给定的时刻，我们能够看到天气的实际*值*、温度的实际值、光照的强度，以及道路的情况或结构。
- en: This is what we mean by variables and looking variables up.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们所说的变量以及查找变量的方式。
- en: As soon as we establish what the weather is actually like, it stops being a
    variable since it has an actual value. Variables work the same way when we're
    talking about programming. What we do is we give a name to a space that we are
    going to use to store some value. In our code, we refer to this space to store
    and read values from it. Depending on the language, this *space* can *hold* different
    things, but right now, we just refer to the variable as something that can hold
    a value.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确认了天气的实际情况，它就不再是变量了，因为它已经有了实际的值。当我们谈论编程时，变量的工作方式也是一样的。我们所做的是给一个空间起个名字，然后用它来存储某个值。在我们的代码中，我们引用这个空间来存储和读取其中的值。根据编程语言的不同，这个*空间*可以*存储*不同的内容，但现在我们只把变量看作是能够存储值的东西。
- en: In `bash`, variables are a lot simpler than in many other languages, and they
    can basically hold two different types of values. One is a string; it can be any
    sequence of numbers and letters, and it can include special characters.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `bash` 中，变量比许多其他语言中的变量简单得多，基本上它们可以存储两种不同类型的值。一个是字符串，它可以是任何数字和字母的组合，也可以包括特殊字符。
- en: Another one is a number, and the only reason that there is a difference between
    those two types of variables is that some operators and some operations are different
    when we are dealing with strings or dealing with numbers.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个类型是数字，之所以这两种变量之间存在区别，是因为在处理字符串和数字时，一些运算符和操作是不同的。
- en: How to do it…
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: When you start to work with variables, there are two things that you need to
    learn.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始使用变量时，有两件事是你需要学习的。
- en: First, you need to know how to assign a value to a variable. This is usually
    called *assigning* a variable or *instancing* a variable. A variable has a name
    and a value. In `bash`, when we want to create a variable, we are simply going
    to choose a name and assign a value to it. After that, our shell knows that this
    is a variable, and it keeps track of the value or values we assign to it. Before
    we assign a value, a variable simply does not exist, and any reference to it will
    be invalid.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要了解如何为变量赋值。通常称为*赋值*变量或*实例化*变量。一个变量有一个名称和一个值。在`bash`中，当我们想创建一个变量时，我们只需选择一个名称并给它赋值。之后，我们的
    shell 知道这是一个变量，并且会跟踪我们赋给它的值。在我们赋值之前，变量是不存在的，任何对它的引用都是无效的。
- en: So, how do you choose a name for a variable?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何为变量选择一个名称呢？
- en: Every variable has its own name, which is used to reference a variable inside
    the script or inside your working environment in the shell. The choice of name
    is completely up to you. The name should be something that you can easily remember
    and something that you will not confuse with other variables. A good choice is
    usually either something that identifies what purpose the variable has or a completely
    abstract name that will hint at what the meaning is of the variable.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 每个变量都有一个名称，用于在脚本或 shell 环境中引用该变量。名称的选择完全由你决定。名称应该是你容易记住的，并且不会与其他变量混淆。通常，一个好的选择是能够标识变量用途的名称，或者是一个完全抽象的名称，暗示该变量的含义。
- en: One thing that you should always avoid using when naming variables are keywords,
    especially those that already have a meaning in `bash`. For example, we cannot
    use `continue` as a variable name since this is the name of a command. This will
    inevitably generate an error since the shell is going to get confused about what
    to do with the variable itself.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在为变量命名时，你应该始终避免使用关键词，特别是那些在`bash`中已经有特定含义的关键词。例如，我们不能使用`continue`作为变量名，因为这是一个命令的名称。这将不可避免地产生错误，因为
    shell 会对该变量产生混淆，无法知道该怎么处理它。
- en: We mentioned environment variables. In an interactive shell, there are quite
    a few variables that are used to store information about your environment. This
    information describes different things that are required by different applications—things
    such as the username, your shell, and so on.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到了环境变量。在交互式 shell 中，有许多变量用于存储有关你环境的信息。这些信息描述了不同应用程序所需的各种内容——例如用户名、你的 shell
    等等。
- en: 'Let''s do a few quick examples. We assign a variable exactly as we mentioned,
    by giving a value to a name. In our case, we are going to assign a `value` string
    value to a variable called `VAR1`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做几个简单的例子。我们按之前提到的方式给变量赋值，通过为名称赋一个值。在我们的例子中，我们将把一个`value`字符串值赋给名为`VAR1`的变量：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'That was easy. Now, let''s read from the variable we just created:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 很简单吧。现在，让我们读取刚才创建的变量：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As we can see, in order to read the variable, we need to prefix the variable
    name with the `$` character. Also, we need to use the same case in the variable
    name that we used when creating the variable itself, as names are case-sensitive.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，为了读取变量，我们需要在变量名之前加上`$`字符。此外，变量名在创建时使用的大小写需要一致，因为变量名是区分大小写的。
- en: 'If we don''t do that, we are not going to get any useful value out of our `echo`
    command, but be very aware that neither of these examples gave us any errors:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不这样做，我们将无法从`echo`命令中获得任何有用的值，但要非常注意，这两个例子都没有给出错误：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We made these errors on purpose to make a few small points. When using an `echo`
    command, we tell it to display a string. If the string contains a variable name,
    it has to be prefixed; otherwise, the `echo` command is just going to output it
    directly as it was written, without the variable value.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们故意犯这些错误是为了强调几个小点。当使用`echo`命令时，我们告诉它显示一个字符串。如果字符串包含变量名，它必须加上前缀；否则，`echo`命令将直接输出字符串内容，而不显示变量的值。
- en: As we said, names are case-sensitive, but if we make a mistake, there won't
    be any errors displayed—we will simply get an empty line. This can be changed,
    and we will deal with this behavior later when we start using variables in scripts.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所说，变量名区分大小写，但如果我们犯了错误，系统不会显示任何错误——我们只是会得到一个空行。这个行为是可以更改的，稍后当我们在脚本中使用变量时会处理这个问题。
- en: Let's now do something else—we'll try to use our variable in a script. Remember
    that we assigned a variable in the shell, but now, we are going to reference it
    in a script.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们做点别的——我们将尝试在脚本中使用我们的变量。记住，我们在 shell 中分配了一个变量，但现在，我们将在脚本中引用它。
- en: 'The script is going to be the simplest possible—create a file, name it `referencing.sh`,
    and enter the following code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本将是最简单的：创建一个文件，命名为 `referencing.sh`，并输入以下代码：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'What happens when we run it? Let''s have a look:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 运行它时会发生什么？让我们看一下：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We see we have a problem. When we are reading the variable from the command
    line, everything is fine, but this variable does not exist inside our scripts.
    The reason is not as simple as it seems, though. We mentioned contexts and environment
    variables before. Each variable exists in the current environment and is not implicitly
    inherited by any command. When we start a script, we are actually creating a new
    environment and a new context that inherits all the variables that are marked
    as inheritable. Since we just assigned a value to our variable and didn't do anything
    else to it, this variable will remain visible only to our shell, and not to any
    commands or scripts that we run from it.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现了一个问题。当我们从命令行读取变量时，一切正常，但这个变量在我们的脚本中不存在。问题的原因并不像看起来那么简单。我们之前提到过上下文和环境变量。每个变量都存在于当前环境中，并且不会被任何命令隐式继承。当我们启动一个脚本时，实际上是在创建一个新的环境和新的上下文，该上下文继承所有标记为可继承的变量。由于我们只是给变量赋了一个值，而没有做其他操作，因此该变量只会对我们的
    shell 可见，而对从 shell 启动的任何命令或脚本不可见。
- en: 'To fix this, we will need to *export* a variable. Exporting means flagging
    our variable to tell the environment that we want the value of the variable to
    be available to the commands and scripts that are running as its child processes.
    To do that, we need to use a command called `export`. The syntax couldn''t be
    simpler:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要 *导出* 变量。导出意味着标记我们的变量，告诉环境我们希望变量的值对作为其子进程运行的命令和脚本可用。为此，我们需要使用一个叫做
    `export` 的命令。语法再简单不过了：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As we can see, our script now knows the value of our variable, and it got inherited
    from the `bash` shell.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们的脚本现在知道变量的值，并且该值是从 `bash` shell 继承而来的。
- en: 'If we just type in `export`, we will see a list of all the variables that are
    exported and available to our scripts:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只输入 `export`，我们将看到所有已导出的变量列表，这些变量可以供我们的脚本使用：
- en: '![Figure 11.1 – Different exported variables exist for every user'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.1 – 每个用户都有不同的导出变量'
- en: '](img/Figure_11.1_B16269.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.1_B16269.jpg)'
- en: Figure 11.1 – Different exported variables exist for every user
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 – 每个用户都有不同的导出变量
- en: 'Notice one important thing: every line starts with the `declare -x` command,
    followed by a variable name and value. This points us to another extremely useful
    command: `declare`.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意一件重要的事情：每行都以 `declare -x` 命令开头，后面跟着变量名和值。这指向了另一个非常有用的命令：`declare`。
- en: When we are creating a variable and giving it a value, we are using only part
    of what can be done with variables in `bash`. Remember how we exported the variable?
    Variables have attributes that are additional information about how the variable
    should behave. Having a variable being exported is one of the attributes, but
    we can also make a variable read-only, change the variable name case, and even
    change the type of information that the variable holds. For all that, we use `declare`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个变量并给它赋值时，我们只使用了 `bash` 中处理变量的一个部分。记得我们是如何导出变量的吗？变量有一些属性，这些属性是关于变量应如何行为的额外信息。将变量导出是其中一个属性，但我们还可以将变量设置为只读，改变变量名称的大小写，甚至改变变量所持有信息的类型。要做到这一点，我们使用
    `declare`。
- en: How it works…
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: The only thing left to do is to give you more information about environment
    variables.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一剩下的就是给你提供更多关于环境变量的信息。
- en: The environment can be, depending on your system and its configuration, huge.
    It contains a lot of things, and it is different from system to system because
    variables in the environment and their values are dependent on different programs
    and options installed on your particular system. For example, if you use a shell
    other than `bash`, you may have different variables specific to that shell. If
    you use `declare -p` or `env`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 环境可能非常庞大，这取决于你的系统及其配置。它包含很多内容，并且因系统而异，因为环境中的变量及其值依赖于在特定系统上安装的不同程序和选项。例如，如果你使用的是
    `bash` 之外的 shell，你可能会有特定于该 shell 的不同变量。如果你使用 `declare -p` 或 `env`。
- en: 'The difference between those two is very important. The `declare` statement
    is a `bash` built-in command. It will read every variable there is in the environment
    and show you all of them. `env`, on the other hand, is an application. It will
    run, create its own environment to run in, and then show you all the variables
    in that environment:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这两者的区别非常重要。`declare` 语句是 `bash` 的内建命令。它会读取环境中所有的变量并显示出来。而 `env` 则是一个应用程序。它会运行，创建自己的环境来运行，然后显示该环境中的所有变量：
- en: '![Figure 11.2 – The environment can be checked at least two ways, but we usually
    use the env command'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 11.2 – 可以通过至少两种方式检查环境，但我们通常使用 env 命令'
- en: '](img/Figure_11.2_B16269.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.2_B16269.jpg)'
- en: Figure 11.2 – The environment can be checked at least two ways, but we usually
    use the env command
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 11.2 – 可以通过至少两种方式检查环境，但我们通常使用 env 命令
- en: 'We are going to mention some of those most important:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将提到一些最重要的内容：
- en: '`USER`—Holds the username of the current user. This is extremely important
    if you need to check under which user the script is running. An alternative to
    this is to run the `whoami` command.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`USER`—保存当前用户的用户名。如果你需要检查脚本是以哪个用户身份运行的，这一点至关重要。这个命令的替代方法是运行 `whoami` 命令。'
- en: '`PWD`—Holds the absolute path to the current directory. This is also important
    to any script since it can help you find which running directory the script was
    called from. An alternative to this command is `pwd`.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PWD`—保存当前目录的绝对路径。这对任何脚本来说都很重要，因为它可以帮助你找出脚本是从哪个运行目录调用的。这个命令的替代方法是 `pwd`。'
- en: '`LOGNAME`—Provides the same information as `USER`, specifically the username
    of the logged-on user, hence the name.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOGNAME`—提供与 `USER` 相同的信息，特别是当前登录用户的用户名，因此得名。'
- en: '`SHELL`—Contains the entire path to the current user''s login shell. This is
    not the same as the running shell; we can run any shell and work from it, and
    this variable returns what our login shell is set to. This value comes from the
    `/etc/passwd` file.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SHELL`—包含当前用户登录 shell 的完整路径。这与正在运行的 shell 不同；我们可以运行任何 shell 并从中工作，而此变量返回的是我们的登录
    shell 设置的路径。这个值来自 `/etc/passwd` 文件。'
- en: '`SHLVL`—When you run your shell initially, you are one level into your environment.
    What this means is that there is nothing else running *above* your shell—or, to
    be more precise, your shell was started by your system directly. As you work,
    you can run other shells, scripts, and even shells inside shells. Each time you
    run a shell inside your shell, you increase your `SHLVL`. This is useful when
    trying to find out whether your script was run from another shell or directly
    by the system.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SHLVL`—当你最初运行 shell 时，你处于环境中的第一层。这意味着没有其他东西在你的 shell *之上*运行，或者更准确地说，是你的系统直接启动了你的
    shell。随着你的工作进行，你可以运行其他的 shell、脚本，甚至是在 shell 中再启动 shell。每次你在 shell 内部运行一个 shell
    时，`SHLVL` 就会增加。这在尝试找出你的脚本是从另一个 shell 中运行的还是直接由系统启动时非常有用。'
- en: '`PATH`—`PATH` contains a list of directories that your shell is going to look
    in when trying to find any command that you try to execute. Since almost everything
    on Linux is a command, this piece of information is crucial—if a certain path
    is not in the `PATH` variable, it won''t be searched, and commands from it can
    only be executed if you reference them directly. This is useful if you don''t
    want to reference commands directly all the time, or you have some reasons to
    prefer a command in one directory over another.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PATH`—`PATH` 包含了一个目录列表，shell 在尝试查找你执行的任何命令时会搜索这些目录。由于 Linux 上几乎所有东西都是命令，这个信息非常重要——如果某个路径不在
    `PATH` 变量中，它将不会被搜索，且只有在你直接引用时，才能执行该路径下的命令。这在你不想每次都直接引用命令，或者你有某些理由更倾向于使用某个目录中的命令时非常有用。'
- en: 'Before we go on to the next recipe, there is another way to get variables listed,
    and that is by using `set` without any parameter:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续下一个食谱之前，还有另一种列出变量的方法，那就是不带任何参数使用 `set`：
- en: '![Figure 11.3 – set not only shows you variables but is also capable of configuring
    the shell'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 11.3 – set 不仅可以显示变量，还能够配置 shell'
- en: '](img/Figure_11.3_B16269.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.3_B16269.jpg)'
- en: Figure 11.3 – set not only shows you variables but is also capable of configuring
    the shell
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 11.3 – set 不仅可以显示变量，还能够配置 shell
- en: 'Of course, since there is a lot of variables active at any given time, it is
    much better to use some sort of filtering:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，由于在任何给定时刻都有很多活动的变量，使用某种过滤方式要更好：
- en: '![Figure 11.4 – The only way to quickly find things is to use grep'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 11.4 – 唯一快速查找事物的方式是使用 grep'
- en: '](img/Figure_11.4_B16269.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.4_B16269.jpg)'
- en: Figure 11.4 – The only way to quickly find things is to use grep
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4 – 查找事物的唯一快速方法是使用 grep
- en: See also
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'We are going to give you just the place to start since this topic is massive:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为你提供一个起点，因为这个主题非常庞大：
- en: '[https://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-5.html](https://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-5.html)'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-5.html](https://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-5.html)'
- en: '[https://ryanstutorials.net/bash-scripting-tutorial/bash-variables.php](https://ryanstutorials.net/bash-scripting-tutorial/bash-variables.php)'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://ryanstutorials.net/bash-scripting-tutorial/bash-variables.php](https://ryanstutorials.net/bash-scripting-tutorial/bash-variables.php)'
- en: Using variables in shell scripting
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 shell 脚本中使用变量
- en: Variables sometimes look simple enough—they are there to enable you to put a
    changing value in your code. The problem is that in this simplicity, there are
    a couple of things you should know about where you actually place a variable—in
    something called a context. We are going to deal with that in this chapter.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 变量有时看起来很简单——它们的作用是让你在代码中放入一个不断变化的值。问题在于，在这种简单性中，有几件事情你需要知道关于变量的实际位置——它存在于一个叫做上下文的地方。我们将在本章中讨论这一点。
- en: Getting ready
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: When we're talking about scripting, things are a little different than they
    are when we are working in an interactive environment. Every environment variable
    that is available to you when you use the interactive shell is also available
    to you in the script. There is, however, one important thing you must always remember.
    As we said earlier, your script is running in a certain context. This context
    is defined by the user that has run the script. In a previous chapter, we wanted
    you to make sure that you have appropriate permissions to do tasks that you need
    in the script.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论脚本时，情况与我们在交互式环境中工作时略有不同。当你使用交互式 shell 时，你能使用的每个环境变量也能在脚本中使用。然而，有一件事你必须始终记住。正如我们之前所说，脚本是在某个特定的上下文中运行的。这个上下文是由运行脚本的用户定义的。在前一章中，我们让你确保拥有执行脚本中所需任务的适当权限。
- en: In this recipe, we are going to make sure you understand this also applies to
    variables. Unless we have explicitly set the variable in our script, we need to
    make sure that the one we got from the environment is something that we expect.
    Also, a lot of times, we will simply check if the variable is there in the first
    place since it may not be exported from the shell and will hence be invisible
    to us.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将确保你理解，这同样适用于变量。除非我们在脚本中显式设置变量，否则我们需要确保从环境中获得的变量是我们期望的。而且，很多时候，我们会先检查变量是否存在，因为它可能没有从
    shell 导出，因此对我们不可见。
- en: There is also a special class of variables that are set right at the moment
    the script is run and contain a certain amount of information very important to
    successfully running a script.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一类特殊的变量，它们在脚本运行的瞬间被设置，并包含一些对成功运行脚本至关重要的信息。
- en: What we are going to do is to start with how the script interacts with the shell
    using variables.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的就是从脚本如何与 shell 使用变量交互开始。
- en: How to do it…
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'We are, as always, going to start simple. First, we are going to do the most
    basic thing we can do—`Hello World`, but with variables:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往地，我们从简单的开始。首先，我们要做的是我们能做的最基础的事情——`Hello World`，但使用变量：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is basically what we mentioned before but in a script. We have created
    a variable, assigned it a value, and then used that value to output text.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上是我们之前提到过的内容，只不过是在脚本中。我们创建了一个变量，给它赋了一个值，然后使用这个值输出文本。
- en: Now, let's try something more useful. When writing scripts, there are things
    that we need to calculate or prepare in some way so that we can use them in different
    parts of the script. Variables are a good way to do this clearly so that they
    can be reused in the code.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试做一些更有用的事情。在编写脚本时，我们需要计算或以某种方式准备一些东西，以便在脚本的不同部分使用它们。变量是一个很好的方式，可以清晰地做到这一点，以便它们可以在代码中重用。
- en: 'For example, we can create a string that will contain today''s date. We can
    then use a variable instead of running the appropriate command every time to create
    a date in a given format over and over again:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以创建一个包含今天日期的字符串。然后，我们可以使用变量，而不是每次都运行适当的命令，以重复创建指定格式的日期：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After we run this one, the output is going to be interesting:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行这个之后，输出将会很有趣：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can see that the file was created correctly and that our date looks OK. What
    we didn't expect was the error. The reason for the error is simple—`tar` starts
    creating files by first creating an output file and then reading the directory
    it must archive. If the archive file is created in the directory it is trying
    to archive, this means that the `tar` command will try to run on the archive itself,
    creating this error. This is normal in these circumstances but try to avoid doing
    this archive loop. The solution is to archive to a place outside of the directory
    we are archiving.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到文件已正确创建，日期看起来也正常。我们没有预料到的是错误。错误的原因很简单——`tar`首先创建一个输出文件，然后读取它必须归档的目录。如果归档文件是在它要归档的目录中创建的，那么`tar`命令会尝试对归档文件本身运行，从而产生这个错误。在这种情况下这是正常的，但应尽量避免这种归档循环。解决方案是将归档文件保存到我们要归档目录之外的地方。
- en: Now for the fun part—passing arguments to your scripts. Up to this point, we
    have made scripts that were completely unaware of their surroundings. We need
    to change that since we need to be able to both pass information to our script
    and make our script report back what has happened.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在进入有趣的部分——向脚本传递参数。到目前为止，我们创建的脚本完全不关心它们的运行环境。我们需要改变这一点，因为我们不仅需要能够向脚本传递信息，还需要让脚本报告发生了什么。
- en: Any script, regardless of the way it was executed, can have arguments. This
    is so common that we usually don't even think about it. Arguments are basically
    strings that come after the script name when we execute the script.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 任何脚本，不论它是如何执行的，都可以有参数。这是如此常见，以至于我们通常不会特意去考虑它。参数基本上是执行脚本时，脚本名称后面的字符串。
- en: 'This is precisely how arguments work in scripts—the shell takes whatever is
    in the command line that started the script and passes it along using a variable
    that has a number as the name. Here''s an example:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是脚本中参数的工作方式——shell 会将启动脚本时命令行中的内容传递给脚本，并通过一个以数字为名称的变量传递它。下面是一个例子：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, here''s how we can run it in a few different ways:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，来看一下我们如何以几种不同的方式运行它：
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If we don''t give it any parameters, everything works as well as if we give
    it three parameters we expect:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不给它任何参数，它也能正常工作，就像我们给它传递三个预期的参数时一样：
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'But let''s try to use more than three:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们尝试使用超过三个参数：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We see a problem here. Variables that hold the parameter value are *positional*,
    and it is up to us to correctly reference everything in the parameter line. The
    way to do it is to read the number of `arguments` variable, and then create a
    loop of some kind to read the arguments.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到一个问题。保存参数值的变量是*位置性的*，我们必须正确地引用参数行中的所有内容。解决方法是读取`arguments`变量的数量，然后创建一个循环来读取这些参数。
- en: 'You may be wondering: *What about $0?* Programmers tend to count from zero,
    not from one, and this is no exception—there is a variable called `$0` and it
    contains the name of the script itself. This is extremely convenient for scripting.
    We are creating a script called `parameters1.sh` and running it:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想：*那$0呢？* 程序员通常从零开始计数，而不是从一开始，这里也不例外——有一个叫做`$0`的变量，它包含了脚本本身的名称。这对于脚本编写来说非常方便。我们创建了一个名为`parameters1.sh`的脚本并运行它：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As we can see, this script could not be simpler. But in this simplicity is
    one neat trick:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这个脚本可以说是极其简单的。但在这种简单中，隐藏着一个巧妙的技巧：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The point we are trying to make here is that the variable holds a value that
    contains not only the name of the script but also the entire path that was used
    to run the script. This can be used to determine how the script was run if we
    are running from `crontab` or another script.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要表达的重点是，变量保存的值不仅包含脚本的名称，还包含用于运行脚本的完整路径。如果我们是从`crontab`或其他脚本运行的，这可以用来确定脚本是如何被运行的。
- en: To continue, we need to learn about a new concept—the `shift` statement.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要学习一个新的概念——`shift`语句。
- en: There are two ways to parse arguments to a script—one is by using a loop that
    is going to run for `$#` iterations, which means that we are going to run for
    each argument that the script has once. This is a completely valid way, but there
    is also another, rather more elegant way to deal with this problem. `shift` is
    an in-built statement that enables you to parse your arguments one at a time without
    knowing how many of them there are.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以解析脚本的参数——一种是使用一个循环，循环运行`$#`次，这意味着我们将对脚本的每个参数运行一次。这是一种完全有效的方法，但也有另一种更优雅的方式来处理这个问题。`shift`是一个内建语句，它使你可以一次解析一个参数，而不需要知道参数的总数。
- en: How it works…
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'The way shifting works is completely intuitive once you understand what it
    does. Let''s quote from the `help` page:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你理解它的作用，移位的方式就完全是直观的。让我们引用一下`help`页面的内容：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Basically, we only need to read the `$1` parameter and then invoke `shift`.
    The command is going to delete this parameter and shift all of them to the left,
    making the next one `$1`, and so on.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们只需要读取`$1`参数，然后调用`shift`。该命令将删除这个参数并将所有参数向左移位，使下一个变成`$1`，依此类推。
- en: 'This enables us to do these kinds of things:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们可以做以下事情：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We need to explain a few things here. The reason we are using `shift` instead
    of a f`or` loop is that we are parsing arguments that can be different options.
    Our script has three possible switches: `-n` that can be written down as `—name`,
    `-s` that can also be used as `-surname`, and `-h` or `—help`. After the first
    two arguments, our script expects to have some string. If none of the arguments
    is used or we choose `-h`, our script is going to write a small reminder on the
    usage parameters.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在这里解释一些事情。我们使用`shift`而不是`for`循环的原因是我们正在解析可以是不同选项的参数。我们的脚本有三个可能的开关：`-n`，可以写作`—name`，`-s`，也可以用作`-surname`，以及`-h`或`—help`。在前两个参数之后，我们的脚本期望有一个字符串。如果没有使用任何参数，或者我们选择`-h`，我们的脚本将写出一个关于使用参数的小提示。
- en: If you tried to do this in a `for` loop, you would have a problem—we would need
    to read the option, store it somewhere, read the `option` parameters in the next
    loop, and then loop again, trying to decide if what follows is an option or an
    argument.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试在`for`循环中做这个，你会遇到问题——我们需要读取选项，将其存储到某个地方，然后在下一个循环中读取`option`参数，然后再次循环，尝试判断接下来的内容是选项还是参数。
- en: By using `shift`, things are much simpler—we read an argument, and if we find
    any option we shift it; the parameters then become stored in `$1` and we can print
    and use them.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`shift`，事情变得简单得多——我们读取一个参数，如果找到任何选项，我们就移位；然后参数就存储在`$1`中，我们可以打印并使用它们。
- en: If we don't find an option, we simply ignore what is inside the variable.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有找到选项，我们就忽略变量中的内容。
- en: See also
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: 'The topic of using arguments is very complicated and is needed in almost every
    script. So, there are open source solutions for that, such as these:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用参数的话题非常复杂，几乎在每个脚本中都需要。所以，针对这个问题有一些开源的解决方案，比如这些：
- en: '[https://dev.to/unfor19/parsing-command-line-arguments-in-bash-3b51](https://dev.to/unfor19/parsing-command-line-arguments-in-bash-3b51)'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://dev.to/unfor19/parsing-command-line-arguments-in-bash-3b51](https://dev.to/unfor19/parsing-command-line-arguments-in-bash-3b51)'
- en: '[https://www.baeldung.com/linux/use-command-line-arguments-in-bash-script](https://www.baeldung.com/linux/use-command-line-arguments-in-bash-script)'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.baeldung.com/linux/use-command-line-arguments-in-bash-script](https://www.baeldung.com/linux/use-command-line-arguments-in-bash-script)'
- en: Quoting in the shell
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Shell中的引号
- en: Quotes are something that we take for granted, not only in Linux but also in
    a lot of other applications. In this recipe, we are going to deal with how quotes
    work, which quotes to use, and how to make sure that your quoted part of the script
    behaves as you intended.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 引号是我们理所当然认为的东西，不仅在Linux中，在许多其他应用程序中也是如此。在这个教程中，我们将讨论引号是如何工作的，应该使用哪些引号，以及如何确保你引用的脚本部分按预期行为运行。
- en: Getting ready
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Using quotes is incredibly important in Linux, not only in shell scripts but
    also in any other application that uses text. In this context, quotes behave pretty
    much the same way as brackets do in mathematical expressions—they offer us the
    way to change how an expression is evaluated. Almost all command-line tools use
    a space as a delimiter that tells the tool where one string ends and another one
    begins. You probably ran into this when you tried to use a file or a directory
    that has a space in its name. Usually, we solve this problem by using an escape
    character (`\`), but it makes it much easier to read if we apply quotes.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，使用引号非常重要，不仅仅是在shell脚本中，也是在任何其他使用文本的应用程序中。在这种情况下，引号的行为与数学表达式中的括号几乎一样——它们提供了一种改变表达式评估方式的方式。几乎所有的命令行工具都使用空格作为分隔符，告诉工具一个字符串在哪里结束，另一个字符串从哪里开始。当你尝试使用名称中有空格的文件或目录时，你可能遇到过这个问题。通常，我们通过使用转义字符（`\`）来解决这个问题，但如果我们使用引号，它就变得更易于阅读。
- en: This is not the only reason we use quotes, so we are going to pay much more
    attention to them right now.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是我们使用引号的唯一原因，因此我们现在要更加关注它们。
- en: 'First, we must define different quotation symbols that we can use and outline
    what they mean:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须定义可以使用的不同引号符号，并概述它们的含义：
- en: 'Double quotation marks: `""""`'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双引号：`""""`
- en: Used to quote strings and stop a shell from using a space as a delimiter. This
    quotation style will use shell expansion characters such as `$`, `` ` ``, `\`,
    and `!` as expansion characters, not quoting them but instead replacing them in
    the normal way. You will use this quotation style all the time.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 用于引用字符串并防止 shell 将空格当作分隔符。这个引用风格会使用像 `$`、`` ` ``、`\` 和 `!` 等 shell 扩展字符，且不会引用它们，而是按通常的方式替换它们。你会一直使用这种引用风格。
- en: 'Single quotation marks: `''`'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单引号：`'`
- en: These behave almost exactly the same as double quotes, but with an important
    twist. Everything inside single quotation marks is treated *as is* and will not
    be changed in any way. Even if you use special characters, this will have no influence—they
    are going to be used as part of a string.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的行为几乎与双引号完全相同，但有一个重要的区别。单引号中的所有内容都会被*原样*处理，且不会被以任何方式更改。即使使用了特殊字符，这也不会产生影响——它们将作为字符串的一部分使用。
- en: 'Backticks: ``"`"``'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '反引号：``"`"`` '
- en: The backtick character is sometimes considered a quote and often mistaken for
    a single quote.Note that this is a completely separate character—on a standard
    **United States** (**US**) keyboard, you can find it in the upper row, on the
    key left of the number *1* key, furthest to the left. The difference is in the
    slope of the character, so the name *backtick* really means that it is oriented
    differently than the quote character. In the shell, it is used to run a command—or,
    to be more precise, to run a command and then use its output in its place.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 反引号有时被视为引号，且常常与单引号混淆。注意，这是一个完全不同的字符——在标准的**美国**(**US**)键盘上，你可以在数字键*1*键左边的键上找到它，它位于最左边。区别在于字符的倾斜角度，因此“反引号”这个名称意味着它与引号字符的方向不同。在
    shell 中，它用于运行命令——或者更准确地说，用于运行命令并将其输出替换在其位置上。
- en: Even though backticks are not strictly quotes, in most learning materials you
    may find them mentioned as such. This is either because they look like quotes,
    or because they are the most probable character to get changed automatically to
    a quote in any text editor.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 即使反引号严格来说不是引号，在大多数学习资料中你可能会看到它们被提到作为引号。这要么是因为它们看起来像引号，要么是因为它们是最可能在任何文本编辑器中自动变成引号的字符。
- en: How to do it…
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'To understand quotes, we are going to make a few script examples, starting
    with a simple `if` statement, just to remind you what it looks like. We are going
    to create a file called `quotes1.sh` using this code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解引号的使用，我们将做几个脚本示例，从一个简单的 `if` 语句开始，只是提醒你它长什么样。我们将创建一个名为 `quotes1.sh` 的文件，并使用以下代码：
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Once we run this, the results are as we expected:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行它，结果如我们所预期：
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, let''s just make one small change in `quotes1.sh` and save it as `quotes2.sh`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在 `quotes1.sh` 中做一个小改动并将其保存为 `quotes2.sh`：
- en: '[PRE19]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this case, when we run the command, the result is going to be quite different.
    Since we used single quotes, the shell is not displaying our variable, and instead,
    we are seeing our actual variable name with its prefix:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当我们运行命令时，结果会完全不同。由于我们使用了单引号，Shell 不会显示我们的变量，而是会显示我们实际的变量名及其前缀：
- en: '[PRE20]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'There is also a special case that we need to mention, and that is when we use
    double quotes inside single quotes and the other way around. In the case of double
    quotes being outside, they will negate the single quotes, so we get the usual
    expansion of variables. This time, create a file called `undeterdouble.sh` and
    get this code typed into it:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个特殊的情况需要提及，那就是当我们在单引号内使用双引号，或者反过来。当双引号位于外部时，它们会否定单引号，因此我们会看到通常的变量扩展。这时，创建一个名为
    `undeterdouble.sh` 的文件，并将以下代码输入其中：
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When we run it, we get this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行它时，得到的是：
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice that the shell inserted another set of quotes to separate the variable
    value and the rest of the string.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Shell 插入了另一对引号，以将变量值和字符串的其余部分分开。
- en: 'If we turn it the other way around, we are going to end up with everything
    being quoted, since the single quotes mean just that:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们把它反过来，那么所有内容都会被引用，因为单引号的作用就是这样：
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Notice there are no additional quotes in the string:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，字符串中没有额外的引号：
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How it works…
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: The shell needs to know when to expand variables and when not to do this. Spaces
    are also a big problem in scripting—more often than not, your script is going
    to completely miss some part of the string because it will cut it up into single
    words divided by spaces.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 需要知道何时扩展变量，何时不扩展。空格在脚本中也是一个大问题——大多数时候，你的脚本会因为将字符串拆分成由空格分隔的单词而完全错过某些部分。
- en: Both quotes have their uses, but you are going to be using double quotes most
    of the time. The reason is that you will usually have a string with spaces but
    also with different variables in it. By using double quotes, you will have your
    variables expanded while keeping the text.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 单引号和双引号各有其用途，但你大多数时候会使用双引号。原因是，你通常会有一个包含空格的字符串，但其中也包含不同的变量。使用双引号时，你的变量会被展开，同时保留文本内容。
- en: See also
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: 'When it comes to single and double quotes, there are only a couple of resources
    since they are straightforward:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 关于单引号和双引号，资源并不多，因为它们是直接明了的：
- en: '[https://bash.cyberciti.biz/guide/Quoting](https://bash.cyberciti.biz/guide/Quoting)'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://bash.cyberciti.biz/guide/Quoting](https://bash.cyberciti.biz/guide/Quoting)'
- en: '[https://www.gnu.org/software/bash/manual/html_node/Quoting.html](https://www.gnu.org/software/bash/manual/html_node/Quoting.html)'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.gnu.org/software/bash/manual/html_node/Quoting.html](https://www.gnu.org/software/bash/manual/html_node/Quoting.html)'
- en: Performing operations on variables
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对变量执行操作
- en: Variables are great since they can hold any value that we can think of. Often,
    we need more than just holding a value inside a variable. In this recipe, we are
    going to deal with a lot of different things that we can do to a variable, sometimes
    changing it and sometimes completely replacing it.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 变量非常有用，因为它们可以存储我们能想到的任何值。通常，我们不仅仅需要在变量中存储一个值。在这个教程中，我们将处理许多关于如何操作变量的不同内容，有时修改它，有时完全替换它。
- en: Getting ready
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In order to be able to change variables, you will need to understand one simple
    concept. `bash` cannot change the variable itself; we are going to mention this
    a little later, but if you need to change something in a variable, you will have
    to reassign it.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够修改变量，你需要理解一个简单的概念。`bash` 不能直接修改变量本身；我们稍后会提到这一点，但如果你需要修改变量中的某些内容，你必须重新赋值。
- en: How to do it…
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: There is a lot of things that can be done to a variable. Sometimes, we want
    to know more about what it contains; sometimes, we need to change something in
    order to use it later; or, we may simply want to know if the variable even has
    a value.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可以做很多事情。有时，我们想了解它包含了什么；有时，我们需要修改其中的内容，以便以后使用；或者，我们可能只是想知道该变量是否有值。
- en: In this recipe, we are going to use the command line a lot since it makes explaining
    things much easier.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将大量使用命令行，因为它使得解释事物变得更加容易。
- en: 'Before we begin, we are going to introduce one thing we haven''t mentioned
    yet: arrays.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我们要介绍一个我们尚未提到的东西：数组。
- en: An array is a variable that holds separate strings divided by spaces. You could
    say it's a string itself, but for a lot of reasons to do with flexibility, `bash`
    is able to address different parts of the array individually, keeping the values
    in one variable.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是一个变量，它包含由空格分隔的多个字符串。你可以说它本身是一个字符串，但出于灵活性的考虑，`bash` 可以单独访问数组的不同部分，同时将所有值保存在一个变量中。
- en: 'We are going to define an array that will have four strings in it. The way
    to define a variable is by using brackets and enclosing strings inside them:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一个包含四个字符串的数组。定义变量的方式是使用括号，并将字符串放入其中：
- en: '[PRE25]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, we can see how many elements there are in our array. This is where things
    get a little strange. Remember when we said that counting in `bash` starts at
    zero?
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看到数组中有多少个元素。这时事情会变得有些奇怪。记得我们曾说过，`bash` 中的计数是从零开始的吗？
- en: '[PRE26]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We see that we got the right information—our array has exactly four elements.
    The way we got this was by using curly brackets together with some special characters.
    Our expression starts with `$ {`, which tells `bash` that we are going to do something
    with an array. Then comes the `#` sign, which means that we are expecting a count
    of something, either the length or number of elements. After that, we have our
    array name followed by square brackets and the `@` sign inside brackets. In shell
    syntax, this tells `bash` that we want all elements in the array.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到得到了正确的信息——我们的数组确实有四个元素。我们得到这个结果的方法是使用大括号和一些特殊字符。我们的表达式以 `$ {` 开头，告诉 `bash`
    我们要操作一个数组。然后是 `#` 符号，表示我们期待得到某个计数，无论是长度还是元素数量。接着，我们有数组的名称，后面跟着方括号和方括号中的 `@` 符号。在
    shell 语法中，这告诉 `bash` 我们想要数组中的所有元素。
- en: 'Translated into plain English, this command says: show me the count of how
    many elements there are in the `TestArray` array.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 用通俗易懂的英文来说，这个命令的意思是：显示 `TestArray` 数组中有多少个元素。
- en: 'But beware—things are extremely sensitive when it comes to syntax. For example,
    if you omit the `[@]` part, this is a completely valid command, but it gives you
    also completely different information:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 但要小心——在语法方面，事情是极其敏感的。例如，如果你省略了`[@]`部分，这仍然是一个完全有效的命令，但它会给你完全不同的信息：
- en: '[PRE27]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The number we get is actually the length of the first string in the array,
    not the array itself. This is because if we try to just use the array name, we
    are going to get only the first string as a result:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的数字实际上是数组中第一个字符串的长度，而不是数组本身的长度。这是因为如果我们只使用数组名，我们将只获得第一个字符串作为结果：
- en: '[PRE28]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To avoid this, we should always use square brackets and a number inside them.
    This is the right way of referencing the positions of strings in our array. Have
    in mind that the first string has an index of `0`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况，我们应该始终使用方括号并在其中放入数字。这是引用数组中字符串位置的正确方式。请记住，第一个字符串的索引是`0`：
- en: '[PRE29]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now that we have seen how to reference arrays and their parts, let''s see if
    a variable even exists and what is the way to check its length. We already know
    how to do that—we just need to use `${#variablename}` to have the shell output
    the length:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到如何引用数组及其部分内容，让我们来看看如何检查一个变量是否存在以及如何检查其长度。我们已经知道如何做——我们只需要使用`${#variablename}`来让shell输出长度：
- en: '[PRE30]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As we can see, since we put a string in the quotes, our variable contains all
    the spaces and characters in a single string. The length is then correctly calculated.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，由于我们在引号中放入了一个字符串，我们的变量包含了字符串中的所有空格和字符。然后长度会被正确计算。
- en: What about checking if a variable exists by looking at its length?
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何通过查看变量的长度来检查它是否存在呢？
- en: '[PRE31]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The length is in this particular case `0`. If you are not used to this kind
    of calculation, you will probably expect not to get a valid number but to have
    the shell report that the variable is not defined, but `bash` does it differently.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的例子中，长度是`0`。如果你不习惯这种计算方式，你可能会期望得到一个无效的数字，而不是shell报告变量未定义，但`bash`的做法是不同的。
- en: 'The next thing we can do is do substitutions of variables. An extremely useful
    thing is being able to check if a variable has a value, and if it doesn''t have
    a value, just substitute another value in its place. In other words, before you
    use a variable, always make sure it has a value since `bash` is by default going
    to return an empty result if the variable is not defined. Here''s an example:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以做的是变量的替换。一项非常有用的功能是能够检查一个变量是否有值，如果没有值，就用另一个值替代它。换句话说，在使用一个变量之前，始终确保它有值，因为默认情况下，`bash`会在变量未定义时返回空结果。以下是一个例子：
- en: '[PRE32]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: What we are doing here is testing if the `TEST` variable has a value. If not,
    we are going to output `empty` as a string. As soon as our variable is set, the
    output is going to revert to the value of the variable.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的是测试`TEST`变量是否有值。如果没有，我们将输出`empty`字符串。一旦我们的变量被设置，输出将恢复为变量的值。
- en: How it works…
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'The things we have mentioned up to now were simple substitutions of a whole
    variable. What is much more common is having to change something inside a variable.
    This can be done using a special syntax. What we can do is extract strings from
    our variable. This is not going to change the variable itself; instead, we need
    to save this string into another variable if we need it for something later. The
    syntax we are going to use is shown here:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们提到的内容只是整个变量的简单替换。更常见的是需要修改变量内部的内容。这可以通过使用特殊的语法来实现。我们可以从变量中提取字符串。这不会改变变量本身；相反，如果我们以后需要这个字符串做某些事情，我们需要将其保存在另一个变量中。我们将使用的语法如下：
- en: '[PRE33]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`VAR` is the variable name. `OFFSET` and `LENGTH` are self-explanatory—they
    basically mean *take this many characters starting from this exact position*.
    The easiest way to explain this functionality is to show you a couple of examples:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`VAR`是变量名。`OFFSET`和`LENGTH`是不言自明的——它们基本上意味着*从这个精确位置开始提取这么多字符*。解释这个功能的最简单方式是给你几个示例：'
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Notice that we can also use negative numbers. If we do that, we are going to
    get the part of the string from the given offset up to the last *X* characters,
    *X* being the negative number we used.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们也可以使用负数。如果我们这样做，我们将从给定的偏移位置提取字符串的一部分，直到最后的*X*个字符，*X*是我们使用的负数。
- en: 'The last thing we wanted to show you is replacing patterns in variables. For
    that, we use this syntax:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想向你展示的最后一件事是替换变量中的模式。为此，我们使用以下语法：
- en: '[PRE35]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The same things apply as when we talked about extracting parts of the variable—we
    are not changing the variable itself, we are just modifying the output:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们讨论提取变量的部分时一样，所做的改变并不是修改变量本身，而只是修改了输出：
- en: '[PRE36]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: See also
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: 'Variable operations contain a lot more possibilities. Check them out here:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 变量操作包含更多的可能性。请在此查看它们：
- en: '[https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_10_03.html](https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_10_03.html)'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_10_03.html](https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_10_03.html)'
- en: '[https://opensource.com/article/18/5/you-dont-know-bash-intro-bash-arrays](https://opensource.com/article/18/5/you-dont-know-bash-intro-bash-arrays)'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://opensource.com/article/18/5/you-dont-know-bash-intro-bash-arrays](https://opensource.com/article/18/5/you-dont-know-bash-intro-bash-arrays)'
- en: Variables via external commands
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过外部命令获取变量
- en: Sometimes, while writing a script, you will have to run a certain command and
    then use its output to do something in your script. A complicated way to do that
    is by using redirection. We say *complicated* because once you have to use redirection,
    you are unable to use it for other things. You could redirect to different file
    descriptors, but that is going to complicate things even more.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在编写脚本时，你需要运行某个命令，并将其输出用于脚本中的其他操作。一种复杂的做法是使用重定向。我们说它是*复杂的*，因为一旦你使用了重定向，就不能再用它做其他事情了。你可以重定向到不同的文件描述符，但这样会使事情变得更加复杂。
- en: Getting ready
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: You will soon notice that it is hard to separate different things related to
    shell commands and functions. The reason for this is that there are a few fundamental
    rules that then get repeated in a different way. We are going to mention some
    of them a few times through this book, not because we like redundancy but because
    you need to completely understand those rules to be able to write good scripts.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你很快就会发现，区分与 Shell 命令和函数相关的不同内容是很困难的。原因在于有一些基本规则会以不同的方式重复出现。我们将在本书中几次提到它们，不是因为我们喜欢冗余，而是因为你需要完全理解这些规则，才能编写出好的脚本。
- en: This is why shell expansion exists, and there are two ways to put it into action
    to accomplish our task.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么 Shell 扩展存在的原因，它有两种方式可以将其应用到我们的任务中。
- en: How to do it…
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: 'There are two syntaxes we can use for this. One is by enclosing the command
    with all its parameters into backticks, like this: `command`. Another is by using
    `$(command)`. Both have the same result—whatever is the output of the command
    is going to get translated into a group of strings and used instead of the original
    command:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 对此我们可以使用两种语法。一种是将命令及其所有参数用反引号括起来，像这样：`command`。另一种是使用`$(command)`。这两种方式得到的结果相同——无论命令的输出是什么，它都会被转换为一组字符串，并代替原始命令使用：
- en: '[PRE37]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This was just to show you how this sort of expansion behaves. Using a single
    `echo` command makes no sense; we are going to try with something more complicated:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是为了向你展示这种扩展是如何运作的。仅使用一个`echo`命令是没有意义的；我们将尝试用更复杂的方式：
- en: '[PRE38]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'What we are doing is getting a list of files from the current directory, and
    then using this list to try different extensions. This way of working with files
    is the most common thing you will use in your scripts. When iterating like this,
    there are going to be either files or lines in the file:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的是从当前目录获取文件列表，然后使用这个列表尝试不同的扩展名。这种处理文件的方式是你在脚本中最常用的。这样迭代时，可能会有文件或文件中的行：
- en: '[PRE39]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This shell capability is amazing but it has its own limitations, the main one
    being that the output of the command inside brackets has to be *clean*. By cleanliness,
    we mean that it has to contain only the information that can be directly used
    as parameters. Consider this minuscule change in our script:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Shell 功能很强大，但也有其局限性，主要的限制是括号内命令的输出必须是*干净的*。这里的“干净”指的是输出必须仅包含可以直接用作参数的信息。考虑到在我们的脚本中做出这个微小的修改：
- en: '[PRE40]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We changed two characters in the `ls` command by adding `-l` to make it output
    in a long format. If we now run it, this is not even remotely what we expected:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过添加`-l`选项更改了`ls`命令的两个字符，使其以长格式输出。如果我们现在运行它，得到的结果完全不符合预期：
- en: '[PRE41]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We stopped the output here.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里停止了输出。
- en: How it works…
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: This way of getting information from one command is probably one of the simplest
    things to understand in entire `bash` scripting. What the shell does is execute
    the command, get its output, and then behave as if it is a long list of separate
    strings using a space as a separator.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个命令获取信息的方式可能是整个`bash`脚本中最简单的理解方式。Shell 所做的是执行命令，获取其输出，然后表现得就像它是一个使用空格作为分隔符的长字符串列表。
- en: This is also the reason why we have to pay special attention to what is going
    to be the output of the application. The shell is unable to *understand* what
    we want out of it; it simply parses whatever it sees and treats spaces as separators.
    What will happen then rests entirely on you—the command that you embedded this
    expression in can treat the end result completely differently.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是为什么我们必须特别注意应用程序的输出是什么原因。Shell 无法*理解*我们希望从中得到什么；它只是解析它所看到的内容，并将空格当作分隔符。接下来会发生什么完全取决于你——你将这个表达式嵌入的命令可能会完全不同地处理最终结果。
- en: See also
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: '[https://tldp.org/HOWTO/Bash-Prompt-HOWTO/x279.html](https://tldp.org/HOWTO/Bash-Prompt-HOWTO/x279.html)'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://tldp.org/HOWTO/Bash-Prompt-HOWTO/x279.html](https://tldp.org/HOWTO/Bash-Prompt-HOWTO/x279.html)'
- en: '[http://www.compciv.org/topics/bash/variables-and-substitution/](http://www.compciv.org/topics/bash/variables-and-substitution/)'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.compciv.org/topics/bash/variables-and-substitution/](http://www.compciv.org/topics/bash/variables-and-substitution/)'
