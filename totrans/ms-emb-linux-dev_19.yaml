- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: Packaging Python
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包Python
- en: '**Python** is the most popular programming language for **machine learning**
    (**ML**). Combine that with the proliferation of ML in our day-to-day lives and
    it is no surprise that the desire to run Python on edge devices is intensifying.
    Even in this era of transpilers and WebAssembly, packaging Python applications
    for deployment remains an unsolved problem. In this chapter, you will learn what
    choices are out there for bundling Python modules together and when to use one
    method over another.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python**是最流行的**机器学习**（**ML**）编程语言。再加上机器学习在我们日常生活中的普及，Python在边缘设备上运行的需求不断增加也就不足为奇了。即使在转译器和WebAssembly的时代，将Python应用程序打包部署依然是一个未解决的问题。在本章中，你将了解有哪些选择可以将Python模块打包在一起，并在何时使用某种方法而非另一种方法。'
- en: We start with a look back at the origins of today’s Python packaging solutions,
    from the built-in standard `distutils` to its successor, `setuptools`. Next, we
    examine the `pip` package manager, before moving on to `venv` for Python virtual
    environments, followed by `conda`, the reigning general-purpose cross-platform
    solution.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从回顾今天Python打包解决方案的起源开始，从内建的标准`distutils`到其继任者`setuptools`。接下来，我们将审视`pip`包管理器，然后转到用于Python虚拟环境的`venv`，最后是`conda`，这个通用的跨平台解决方案。
- en: Since Python is an interpreted language, you cannot compile a program into a
    standalone executable like you can with a language such as Go. This makes deploying
    Python applications complicated. Running a Python application requires installing
    a Python interpreter and several runtime dependencies. These requirements need
    to be code-compatible for the application to work. That requires the precise versioning
    of software components. Solving these deployment problems is what Python packaging
    is all about.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Python是解释型语言，你不能像使用Go等语言那样将程序编译为独立的可执行文件。这使得Python应用程序的部署变得复杂。运行Python应用程序需要安装Python解释器和若干运行时依赖项。这些要求需要与代码兼容才能使应用程序正常运行。这就需要软件组件的精确版本管理。解决这些部署问题正是Python打包的核心内容。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将覆盖以下主题：
- en: Retracing the origins of Python packaging
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回顾Python打包的起源
- en: Installing Python packages with `pip`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`pip`安装Python包
- en: Managing Python virtual environments with `venv`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`venv`管理Python虚拟环境
- en: Installing precompiled binaries with `conda`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`conda`安装预编译的二进制文件
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with the examples, make sure you have the following software
    installed on your Linux host system:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随示例进行操作，请确保在你的Linux主机系统上安装了以下软件：
- en: 'Python: Python 3 interpreter and standard library'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python：Python 3解释器和标准库
- en: '`pip`: Package installer for Python 3'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pip`：Python 3的包管理器'
- en: '`venv`: Python module for creating and managing lightweight virtual environments'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`venv`：用于创建和管理轻量级虚拟环境的Python模块'
- en: 'Miniconda: Minimal installer for the `conda` package and virtual environment
    manager'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Miniconda：`conda`包和虚拟环境管理器的最小安装程序
- en: 'I recommend using Ubuntu 24.04 LTS or later for this chapter. Even though Ubuntu
    24.04 LTS runs on the Raspberry Pi 4, I still prefer to develop on an x86-64 desktop
    PC or laptop. Ubuntu also comes with Python 3 and `pip` already installed since
    Python is used extensively throughout the system. Do not uninstall `python3` or
    you will render Ubuntu unusable. To install `venv` on Ubuntu, enter the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我推荐使用Ubuntu 24.04 LTS或更高版本来进行本章的操作。尽管Ubuntu 24.04 LTS可以在Raspberry Pi 4上运行，但我仍然更喜欢在x86-64桌面PC或笔记本电脑上进行开发。Ubuntu还预装了Python
    3和`pip`，因为Python在系统中被广泛使用。不要卸载`python3`，否则你将无法使用Ubuntu。要在Ubuntu上安装`venv`，请输入以下命令：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**IMPORTANT NOTE**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要说明**'
- en: Do not install Miniconda until you get to the section on `conda` because it
    interferes with the earlier `pip` exercises that rely on the system Python installation.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在到达`conda`部分之前，不要安装Miniconda，因为它会干扰依赖于系统Python安装的早期`pip`练习。
- en: Retracing the origins of Python packaging
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回顾Python打包的起源
- en: The Python packaging landscape is a vast graveyard of failed attempts and abandoned
    tools. Best practices around dependency management change often within the Python
    community, and the recommended solution one year may be a broken nonstarter the
    next. As you research this topic, remember to look at when the information was
    published and do not trust any advice that may be out of date.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Python打包的生态系统是一个庞大的失败尝试和被遗弃工具的墓地。Python社区内关于依赖管理的最佳实践经常变化，一年的推荐解决方案可能在下一年就变成了一个行不通的方案。在研究这个话题时，记得查看信息发布的时间，并且不要相信任何可能已经过时的建议。
- en: Most Python libraries are distributed using `setuptools`, including all the
    packages found on the **Python Package Index** (**PyPI**). This distribution method
    relies on a `setup.py` project specification file that the **package installer
    for Python** (**pip**) uses to install a package. `pip` can also generate or *freeze*
    a precise list of dependencies after a project is installed. This optional `requirements.txt`
    file is used by `pip` in conjunction with `setup.py` to ensure that project installations
    are repeatable.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Python库都使用`setuptools`进行分发，包括在**Python软件包索引**（**PyPI**）上找到的所有包。此分发方法依赖于`setup.py`项目规范文件，**Python包安装器**（**pip**）使用该文件来安装包。`pip`还可以在项目安装后生成或*冻结*一个精确的依赖关系列表。这个可选的`requirements.txt`文件由`pip`与`setup.py`一起使用，以确保项目安装是可重复的。
- en: distutils
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: distutils
- en: '**distutils** is the original packaging system for Python. It was included
    in the Python standard library from Python 2.0 until its removal in Python 3.12\.
    `distutils` provided a Python package of the same name that could be imported
    by your `setup.py` script. Now that `distutils` is deprecated, direct usage of
    the package is no longer supported. `setuptools` has become its preferred replacement.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**distutils**是Python的原始打包系统。从Python 2.0开始，直到Python 3.12版本，它一直被包含在Python标准库中。`distutils`提供了一个同名的Python包，可以被你的`setup.py`脚本导入。现在由于`distutils`已被弃用，直接使用该包不再受支持。`setuptools`已成为其首选替代品。'
- en: While `distutils` may continue to work for simple projects, the community has
    moved on. Today, `distutils` survives only for legacy reasons. Many Python libraries
    were first published back when `distutils` was the only game in town. Porting
    them to `setuptools` now would take considerable effort and could break existing
    users.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`distutils`可能仍适用于简单项目，但社区已经向前发展。如今，`distutils`仅因遗留原因而存在。许多Python库最初是在`distutils`是唯一选择的时候发布的。将它们迁移到`setuptools`现在将需要大量工作，并可能破坏现有用户的使用。
- en: setuptools
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: setuptools
- en: '**setuptools** extends `distutils` by adding support for complex constructs
    that make larger applications based on web frameworks like Flask and FastAPI easier
    to distribute. It has become the de facto packaging system within the Python community.
    Like `distutils`, `setuptools` offers a Python package of the same name that you
    can import into your `setup.py` script. `distribute` was an ambitious fork of
    `setuptools` that eventually merged back into `setuptools 0.7`, cementing the
    status of `setuptools` as the definitive choice for Python packaging.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**setuptools**通过增加对复杂结构的支持，扩展了`distutils`，使得基于Flask和FastAPI等Web框架构建的大型应用程序更容易分发。它已成为Python社区事实上的打包系统。像`distutils`一样，`setuptools`也提供了一个同名的Python包，你可以在`setup.py`脚本中导入它。`distribute`是`setuptools`的一个雄心勃勃的分支，最终合并回`setuptools
    0.7`，巩固了`setuptools`作为Python打包的终极选择的地位。'
- en: '`setuptools` introduced a command-line utility known as `easy_install` (now
    deprecated) and a Python package called `pkg_resources` for runtime package discovery
    and access to resource files. `setuptools` can also produce packages that act
    as plugins for other extensible packages (for example, frameworks and applications).
    You do this by registering entry points in your `setup.py` script for the other
    overarching package to import.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`setuptools`引入了一个命令行工具，称为`easy_install`（现在已弃用），以及一个名为`pkg_resources`的Python包，用于运行时的包发现和资源文件访问。`setuptools`还可以生成充当其他可扩展包（例如框架和应用程序）插件的包。你可以通过在`setup.py`脚本中为其他主包注册入口点来实现这一点，以便让其他包导入。'
- en: The term *distribution* means something different in the context of Python.
    A distribution is a versioned archive of packages, modules, and other resource
    files used to distribute a release. A *release* is a versioned snapshot of a Python
    project taken at a given point in time. To make matters worse, the terms *package*
    and *distribution* are overloaded and often used interchangeably by Pythonistas.
    For our purposes, let’s say that a distribution is what you download, and a package
    is the module that gets installed and imported.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python的上下文中，术语*distribution*有着不同的含义。一个distribution是一个包含包、模块和其他资源文件的版本化存档，用于分发一个发布版本。*release*是某一时刻对Python项目的一个版本化快照。更糟糕的是，*package*和*distribution*这两个术语是多重含义的，Pythonista们常常交替使用这两个词。为了方便起见，我们可以把distribution看作你下载的内容，而package是被安装并导入的模块。
- en: Cutting a release can result in multiple distributions, such as a source distribution
    and one or more built distributions. There can be different built distributions
    for different platforms, such as one that includes a Windows installer. The term
    *built distribution* means that no build step is required before installation.
    It does not necessarily mean precompiled. Some built distribution formats such
    as **Wheel** (`.whl`) exclude compiled Python files, for example. A built distribution
    containing compiled extensions is known as a *binary distribution*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 切割一个发行版可能会产生多个分发文件，例如源分发和一个或多个构建分发文件。不同平台可能会有不同的构建分发文件，比如包含 Windows 安装程序的文件。*构建分发*
    这个术语意味着在安装之前不需要构建步骤，但不一定意味着预编译。某些构建分发格式（如 **Wheel**（`.whl`））会排除已编译的 Python 文件。例如，包含已编译扩展的构建分发称为
    *二进制分发*。
- en: An **extension module** is a Python module that is written in C or C++. Every
    extension module compiles down to a single dynamically loaded library, such as
    a shared object (`.so`) on Linux and a dynamic link library (`.pyd`) on Windows.
    Contrast this with pure modules, which must be written entirely in Python. The
    Egg (`.egg`) built distribution format introduced by `setuptools` supports both
    pure and extension modules. Since a Python source code (`.py`) file compiles down
    to a bytecode (`.pyc`) file when the Python interpreter imports a module at runtime,
    you can see how a built distribution format such as Wheel might exclude precompiled
    Python files.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**扩展模块** 是用 C 或 C++ 编写的 Python 模块。每个扩展模块都会编译成一个单独的动态加载库，例如 Linux 上的共享对象（`.so`）和
    Windows 上的动态链接库（`.pyd`）。与此相比，纯模块必须完全用 Python 编写。`setuptools` 引入的 Egg（`.egg`）构建分发格式支持纯模块和扩展模块。由于
    Python 源代码（`.py`）文件在 Python 解释器导入模块时会编译成字节码（`.pyc`）文件，你可以理解像 Wheel 这样的构建分发格式可能会排除预编译的
    Python 文件。'
- en: setup.py
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: setup.py
- en: Say you are developing a small program in Python, maybe something that queries
    a remote REST API and saves response data to a local SQL database. How do you
    package your program together with its dependencies for deployment? You start
    by defining a `setup.py` script that `setuptools` can use to install your program.
    Deploying with `setuptools` is the first step toward more elaborate automated
    deployment schemes.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在开发一个小型的 Python 程序，可能是查询远程 REST API 并将响应数据保存到本地 SQL 数据库。如何将你的程序与其依赖项打包，以便进行部署呢？你可以从定义一个
    `setup.py` 脚本开始，`setuptools` 将使用该脚本来安装你的程序。使用 `setuptools` 进行部署是实现更复杂的自动化部署方案的第一步。
- en: 'Even if your program is small enough to fit comfortably inside a single module,
    chances are it won’t stay that way for long. Let’s say that your program consists
    of a single file named `follower.py`, like so:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你的程序足够小，可以舒适地放在一个模块中，它也很可能不会一直保持这种状态。假设你的程序由一个名为 `follower.py` 的单个文件组成，像这样：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You could then convert this module into a package by splitting `follower.py`
    up into three separate modules and placing them inside a nested directory, also
    named `follower`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以通过将 `follower.py` 拆分成三个独立的模块，并将它们放置在一个名为 `follower` 的嵌套目录中，将这个模块转换为一个包：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `__main__.py` module is where your program starts, so it contains mostly
    top-level, user-facing functionality. The `fetch.py` module contains functions
    for sending HTTP requests to the remote REST API and the `store.py` module contains
    functions for saving response data to the local SQL database. To run this package
    as a script, you need to pass the `-m` option to the Python interpreter as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`__main__.py` 模块是你的程序开始的地方，因此它包含主要的顶层、面向用户的功能。`fetch.py` 模块包含向远程 REST API 发送
    HTTP 请求的函数，`store.py` 模块包含将响应数据保存到本地 SQL 数据库的函数。要将这个包作为脚本运行，你需要向 Python 解释器传递
    `-m` 选项，如下所示：'
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `PYTHONPATH` environment variable points to the directory where a target
    project’s package directories are located. The `follower` argument after the `-m`
    option tells Python to run the `__main__.py` module belonging to the `follower`
    package. Nesting package directories inside a project directory like this paves
    the way for your program to grow into a larger application made up of multiple
    packages each with its own namespace.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`PYTHONPATH` 环境变量指向目标项目的包目录所在的目录。`-m` 选项后的 `follower` 参数告诉 Python 运行 `follower`
    包下的 `__main__.py` 模块。像这样将包目录嵌套在项目目录中，为你的程序发展成由多个具有独立命名空间的包组成的大型应用程序铺平了道路。'
- en: 'With the pieces of your project all in their right place, we are now ready
    to create a minimal `setup.py` script that `setuptools` can use to package and
    deploy it:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目的各个部分都已正确放置后，我们现在准备创建一个最小化的`setup.py`脚本，`setuptools`可以用它来打包和部署项目：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `install_requires` argument is a list of external dependencies that need
    to be installed automatically for a project to work at runtime. Notice that I
    did not specify what versions of these dependencies are needed or where to fetch
    them from in my example. I only asked for libraries that look and act like `requests`
    and `sqlalchemy`. Separating policy from implementation like this allows you to
    easily swap out the official PyPI version of a dependency with your own in case
    you need to fix a bug or add a feature.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`install_requires`参数是一个外部依赖列表，这些依赖需要在项目运行时自动安装。请注意，在我的示例中，我并没有指定这些依赖需要什么版本，也没有指定从哪里获取它们。我只要求使用看起来和行为类似于`requests`和`sqlalchemy`的库。像这样将策略与实现分开，使你可以轻松地将官方
    PyPI 版本的依赖替换为你自己的版本，以防你需要修复一个bug或添加一个功能。'
- en: '**Information note**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**信息提示**'
- en: Adding optional version specifiers to your dependency declarations is fine,
    but hardcoding distribution URLs within `setup.py` as `dependency_links` is wrong
    in principle.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在依赖声明中添加可选的版本说明符是可以的，但在`setup.py`中硬编码分发网址作为`dependency_links`在原则上是错误的。
- en: 'The `packages` argument tells `setuptools` what in-tree packages to distribute
    with a project release. Since every package is defined inside its own subdirectory
    of the parent project directory, the only package being shipped in this case is
    `follower`. I am including data files along with my Python code in this distribution.
    To do that, you need to set the `include_package_data` argument to `True` so that
    `setuptools` looks for a `MANIFEST.in` file and installs all the files listed
    there. Here are the contents of the `MANIFEST.in` file:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`packages`参数告诉`setuptools`要分发项目发布版本中的哪些内部包。由于每个包都在父项目目录的子目录中定义，因此在这种情况下唯一被打包的包是`follower`。我将数据文件与
    Python 代码一起包含在此分发中。为了做到这一点，你需要将`include_package_data`参数设置为`True`，这样`setuptools`就会查找`MANIFEST.in`文件并安装其中列出的所有文件。以下是`MANIFEST.in`文件的内容：'
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If the data directory contained nested directories of data we wanted to include,
    we could glob all of them along with their contents using `recursive-include`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据目录包含我们想要包含的嵌套目录，我们可以使用`recursive-include`将它们及其内容一起包含：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here is the final directory layout:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最终的目录布局：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`setuptools` excels at building and distributing Python packages that depend
    on other packages. It can do this thanks to features such as entry points and
    dependency declarations, which are simply absent from `distutils`. `setuptools`
    works well with `pip` and new releases of `setuptools` arrive on a regular basis.
    The Wheel build distribution format was created to replace the Egg format that
    `setuptools` introduced. That effort has largely succeeded with the addition of
    a popular `setuptools` extension for building wheels and `pip`''s great support
    for installing wheels.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`setuptools`擅长构建和分发依赖于其他包的 Python 包。它之所以能够做到这一点，是因为它具备了入口点和依赖声明等特性，而这些特性在`distutils`中根本没有。`setuptools`与`pip`配合得很好，并且`setuptools`的新版本会定期发布。Wheel
    构建分发格式是为了替代`setuptools`引入的 Egg 格式而创建的。这一努力已经取得了很大成功，得益于一个流行的`setuptools`扩展用于构建
    wheels，并且`pip`对安装 wheels 的良好支持。'
- en: Installing Python packages with pip
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 pip 安装 Python 包
- en: You now know how to define your project’s dependencies in a `setup.py` script.
    But how do you install those dependencies? How do you upgrade a dependency or
    replace it when you find a better one? How do you decide when it is safe to delete
    a dependency you no longer need?
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何在`setup.py`脚本中定义项目的依赖关系。那么，如何安装这些依赖呢？如何在找到更好的依赖时升级或替换它？当你不再需要某个依赖时，如何判断何时可以安全地删除它？
- en: Managing project dependencies is a tricky business. Luckily, Python comes with
    a tool called **pip** that can help, especially in the early stages of your project.
    The name stands for **pip installs Python**, which is a recursive acronym. `pip`
    is the official package manager for Python.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 管理项目依赖是件棘手的事情。幸运的是，Python 自带了一个叫做**pip**的工具，可以在项目初期阶段提供帮助。这个名字代表了**pip 安装 Python**，这是一个递归首字母缩略词。`pip`是
    Python 的官方包管理器。
- en: The initial 1.0 release of `pip` arrived on April 4, 2011, around the same time
    that Node.js and `npm` were taking off. Before it became `pip`, the tool was named
    `pyinstall`. `pyinstall` was created in 2008 as an alternative to `easy_install`,
    which came bundled with `setuptools` at the time. `easy_install` is now deprecated
    and `setuptools` recommends using `pip` instead.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`pip`的初始1.0版本于2011年4月4日发布，正好与Node.js和`npm`的兴起同时发生。在成为`pip`之前，该工具名为`pyinstall`。`pyinstall`于2008年创建，是作为`easy_install`的替代工具，后者当时与`setuptools`一起捆绑。`easy_install`现已弃用，`setuptools`推荐使用`pip`代替。'
- en: 'Since `pip` is included with the Python installer and you can have multiple
    versions of Python installed on your system (for example, 2.7 and 3.13), it helps
    to know which version of `pip` you are running:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`pip`与Python安装程序一起提供，而且你可以在系统上安装多个版本的Python（例如，2.7和3.13），了解你正在运行的`pip`版本是很有帮助的：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If no `pip` executable is found on your system, that probably means you are
    on Ubuntu 20.04 LTS or later and do not have Python 2.7 installed. That is fine.
    We will merely substitute `pip3` for `pip` and `python3` for `python` throughout
    the rest of this section:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果系统中找不到`pip`可执行文件，那可能意味着你使用的是Ubuntu 20.04 LTS或更高版本，并且没有安装Python 2.7。这没问题。我们将仅在本节其余部分中将`pip3`替代为`pip`，`python3`替代为`python`：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If there is `python3` but no `pip3` executable, then install it as shown on
    Debian-based distributions such as Ubuntu:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有`python3`但没有`pip3`可执行文件，则可以按如下方式在基于Debian的发行版（如Ubuntu）中安装它：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`pip` installs packages to a directory called `site-packages`. To find the
    location of your `site-packages` directory, run the following command:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`pip`将包安装到名为`site-packages`的目录中。要找到你的`site-packages`目录的位置，请运行以下命令：'
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**IMPORTANT NOTE**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: Now that Python 2 has been deprecated, `pip3` and `python3` commands are available
    on popular Linux distributions like Ubuntu. If your Linux distribution does not
    have the `pip3` and `python3` commands, then use the `pip` and `python` commands
    instead.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Python 2已经被弃用，`pip3`和`python3`命令在像Ubuntu这样的流行Linux发行版上可用。如果你的Linux发行版没有`pip3`和`python3`命令，则改用`pip`和`python`命令。
- en: 'To get a list of packages already installed on your system, use this command:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取系统中已安装的包的列表，使用以下命令：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The list shows that `pip` is just another Python package, so you could use `pip`
    to upgrade itself, but I would advise you not to do that, at least not in the
    long term. I’ll explain why in the next section when I introduce virtual environments.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 列表显示`pip`只是另一个Python包，因此你可以使用`pip`来升级它自己，但我建议你不要这样做，至少长期来说不要这么做。我将在下一节中介绍虚拟环境时解释原因。
- en: 'To get a list of packages installed in your `site-packages` directory, use
    the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取安装在`site-packages`目录中的包的列表，使用以下命令：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This list should be empty or much shorter than the list of system packages.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表应该是空的，或者比系统包列表要短得多。
- en: 'Go back to the example project from the last section. `cd` into the parent
    `follower` directory where `setup.py` is located. Then run the following command:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到上一节中的示例项目。`cd`进入包含`setup.py`的父级`follower`目录。然后运行以下命令：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`pip` will use `setup.py` to fetch and install the packages declared by `install_requires`
    to your `site-packages` directory. The `--user` option instructs `pip` to install
    packages to your `site-packages` directory rather than globally. The `--ignore-installed`
    option forces `pip` to re-install any required packages already present on the
    system to `site-packages` so that no dependencies go missing. The `--break-system-packages`
    option is required on Debian-based Linux distributions like Ubuntu, which discourages
    users from installing non-Debian-packaged packages system-wide.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`pip`将使用`setup.py`来获取并安装由`install_requires`声明的包到你的`site-packages`目录中。`--user`选项指示`pip`将包安装到`site-packages`目录而不是全局目录。`--ignore-installed`选项强制`pip`重新安装系统中已经存在的任何必需包到`site-packages`，以确保没有依赖项丢失。`--break-system-packages`选项在基于Debian的Linux发行版（如Ubuntu）中是必需的，因为这些发行版不鼓励用户在系统范围内安装非Debian打包的包。'
- en: 'Now list all the packages in your `site-packages` directory again:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次列出`site-packages`目录中的所有包：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This time, you should see that both `requests` and `SQLAlchemy` are in the package
    list.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这次你应该看到`requests`和`SQLAlchemy`都在包列表中。
- en: 'To view details on the `SQLAlchemy` package you just installed, issue the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看刚刚安装的`SQLAlchemy`包的详细信息，发出以下命令：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The details shown contain the `Requires` and `Required-by` fields. Both are
    lists of related packages. You could use the values in these fields and successive
    calls to `pip show` to trace the dependency tree of your project. But it’s probably
    easier to `pip install` a command-line tool called `pipdeptree` and use that instead.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 显示的详细信息包含`Requires`和`Required-by`字段。这两个字段都是相关包的列表。你可以使用这些字段中的值和连续调用`pip show`来追踪你项目的依赖树。但使用`pip
    install`一个名为`pipdeptree`的命令行工具并用它来代替可能更容易。
- en: 'When a `Required-by` field becomes empty, that is a good indicator that it
    is now safe to uninstall a package from your system. If no other packages depend
    on the packages in the deleted package’s `Requires` field, then it’s safe to uninstall
    those as well. This is how you uninstall `sqlalchemy` using `pip`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当`Required-by`字段为空时，这是一个很好的指标，说明现在可以安全地从系统中卸载该包。如果没有其他包依赖于已删除包的`Requires`字段中的包，那么也可以安全地卸载这些包。这就是如何使用`pip`卸载`sqlalchemy`的方式：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The trailing `-y` suppresses the confirmation prompt. To uninstall more than
    one package at a time, simply add more package names before the `-y`. The `--user`
    option is omitted here because `pip` is smart enough to uninstall from `site-packages`
    first when a package is also installed globally.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 末尾的`-y`会抑制确认提示。要一次卸载多个包，只需在`-y`前添加更多包名称。这里省略了`--user`选项，因为`pip`足够智能，能够在全局安装的包也存在时，优先从`site-packages`中卸载包。
- en: '**TIP**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: Uninstall the `follower` package and all its dependencies from your `site-packages`
    directory so that you do not pollute your Python installation or Linux distribution
    with non-Debian-packaged packages.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 从你的`site-packages`目录中卸载`follower`包及其所有依赖项，以免污染你的Python安装或Linux发行版，避免安装非Debian打包的包。
- en: Sometimes you need a package that serves some purpose or utilizes a particular
    technology, but you don’t know the name of it. You can use `pip` to perform a
    keyword search against PyPI from the command line, but that approach often yields
    too many results. It is much easier to search for packages on the PyPI website
    ([https://pypi.org/search/](https://pypi.org/search/)), which allows you to filter
    results by various classifiers.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你需要一个执行某个特定功能或使用某项技术的包，但你不知道它的名称。你可以使用`pip`在命令行中对PyPI进行关键字搜索，但这种方法通常会返回太多结果。通过在PyPI网站上搜索包（[https://pypi.org/search/](https://pypi.org/search/)）要容易得多，它允许你按各种分类器筛选结果。
- en: requirements.txt
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: requirements.txt
- en: '`pip` `install` will install the latest published version of a package, but
    often you want to install a specific version of a package that you know works
    with your project’s code. Eventually, you will want to upgrade your project’s
    dependencies. But before I show you how to do that, I first need to show you how
    to use `pip freeze` to fix your dependencies.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`pip install`会安装包的最新发布版本，但通常你会想要安装与你的项目代码兼容的特定版本包。最终，你会想要升级你项目的依赖项。但在我展示如何做之前，我首先需要展示如何使用`pip
    freeze`来固定你的依赖项。'
- en: Requirements files allow you to specify exactly which packages and versions
    `pip` should install for your project. By convention, project **requirements files**
    are always named `requirements.txt`. The contents of a requirements file are just
    a list of `pip install` arguments enumerating your project’s dependencies. These
    dependencies are precisely versioned so that there are no surprises when someone
    attempts to rebuild and deploy your project. It is good practice to add a `requirements.txt`
    file to your project’s repo to ensure reproducible builds.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`requirements`文件允许你明确指定`pip`应为你的项目安装哪些包和版本。按照惯例，项目的**requirements文件**始终命名为`requirements.txt`。requirements文件的内容仅仅是一个列出项目依赖项的`pip
    install`参数列表。这些依赖项有精确的版本号，以确保当其他人尝试重新构建和部署你的项目时不会有意外。将`requirements.txt`文件添加到项目的代码库中是一个良好的实践，以确保构建的可复现性。'
- en: 'Returning to our `follower` project, now that we have installed all our dependencies
    and verified that the code works as expected, we are now ready to freeze the latest
    versions of the packages that `pip` installed for us. `pip` has a `freeze` command
    that outputs the installed packages along with their versions. You redirect the
    output from this command to a `requirements.txt` file:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到我们的`follower`项目，现在我们已经安装了所有依赖项并验证代码按预期工作，我们可以冻结`pip`为我们安装的包的最新版本了。`pip`有一个`freeze`命令，输出已安装包及其版本。你将该命令的输出重定向到`requirements.txt`文件：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now that you have a `requirements.txt` file, people who clone your project
    can install all its dependencies using the `-r` option and the name of the requirements
    file:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了一个`requirements.txt`文件，克隆你项目的人可以使用`-r`选项和要求文件的名称来安装所有依赖项：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The autogenerated requirements file format defaults to exact version matching
    (`==`). For example, a line such as `requests==2.32.3` tells `pip` that the version
    of `requests` to install must be exactly `2.32.3`. There are other version specifiers
    you can utilize in a requirements file, such as minimum version (`>=`), version
    exclusion (`!=`), and maximum version (`<=`). Minimum version (`>=`) matches any
    version greater than or equal to the right-hand side. Version exclusion (`!=`)
    matches any version except the right-hand side. Maximum version (`<=`) matches
    any version less than or equal to the right-hand side.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的要求文件格式默认使用精确版本匹配（`==`）。例如，像`requests==2.32.3`这样的行告诉`pip`，要安装的`requests`版本必须是精确的`2.32.3`。在要求文件中，你可以使用其他版本说明符，例如最小版本（`>=`）、版本排除（`!=`）和最大版本（`<=`）。最小版本（`>=`）匹配任何大于或等于右侧版本的版本。版本排除（`!=`）匹配任何除了右侧版本之外的版本。最大版本（`<=`）匹配任何小于或等于右侧版本的版本。
- en: 'You can combine multiple version specifiers in a single line using commas to
    separate them:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在一行中结合多个版本说明符，用逗号分隔它们：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The default behavior when `pip` installs the packages specified in a requirements
    file is to fetch them all from PyPI. You can override PyPI’s URL ([https://pypi.org/simple/)](https://pypi.org/simple/))
    with that of an alternate Python package index by adding a line such as the following
    to the top of your `requirements.txt` file:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当`pip`安装要求文件中指定的包时，默认行为是从PyPI获取它们。你可以通过在`requirements.txt`文件的顶部添加如下行，将PyPI的URL（[https://pypi.org/simple/)](https://pypi.org/simple/))替换为备用Python包索引的URL：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The effort required to stand up and maintain your own private PyPI mirror is
    not insubstantial. When all you need to do is fix a bug or add a feature to a
    project dependency, it makes more sense to override the package source instead
    of the entire package index.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 建立并维护自己的私有PyPI镜像所需的努力不可小觑。当你只需要修复一个bug或为项目依赖项添加一个特性时，覆盖包源而非整个包索引更为合理。
- en: 'I mentioned earlier how hardcoding distribution URLs inside `setup.py` is wrong.
    You can use the `-e` argument form in a requirements file to override individual
    package sources:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到过，硬编码分发URL到`setup.py`中是错误的。你可以在要求文件中使用`-e`参数形式来覆盖单独的包源：
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In this example, I am instructing `pip` to fetch the `flask` package sources
    from my team’s GitHub fork of `pallets/flask.git`. The `-e` argument form also
    takes a Git branch name, commit hash, or tag name:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我指示`pip`从我们团队的GitHub分支`pallets/flask.git`获取`flask`包源。`-e`参数形式还可以接受Git分支名称、提交哈希或标签名称：
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Using `pip` to upgrade a project’s dependencies to the latest versions published
    on PyPI is straightforward:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pip`将项目的依赖项升级到PyPI上发布的最新版本非常简单：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After you have verified that installing the latest versions of your dependencies
    does not break your project, you can then write them back out to the requirements
    file:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在你验证了安装最新版本的依赖项不会破坏你的项目后，你可以将它们重新写入要求文件：
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Make sure that freezing did not overwrite any of the overrides or special version
    handling in your requirements file. Undo any mistakes and commit the updated `requirements.txt`
    file to version control.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 确保冻结操作没有覆盖要求文件中的任何覆盖或特殊版本处理。撤销任何错误并将更新后的`requirements.txt`文件提交到版本控制系统。
- en: At some point, upgrading your project dependencies will result in your code
    breaking. A new package release may introduce a regression or incompatibility
    with your project. The requirements file format provides syntax to deal with these
    situations. Let’s say you have been using version 2.32.3 of `requests` in your
    project and version 3.0 is released. According to the practice of semantic versioning,
    incrementing the major version number indicates that version 3.0 of `requests`
    includes breaking changes to that library’s API.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时刻，升级你的项目依赖项可能会导致代码出现问题。新版本的包可能会引入回归或与项目不兼容的情况。要求文件格式提供了应对这些情况的语法。假设你在项目中使用的是`requests`的2.32.3版本，而版本3.0发布了。根据语义版本控制的实践，增加主版本号表示`requests`的版本3.0包含了对该库API的破坏性更改。
- en: 'You can express the new version requirements like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以这样表达新的版本要求：
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The compatible release specifier (`~=`) relies on semantic versioning. Compatible
    means greater than or equal to the right-hand side and less than the next version’s
    major number (for example, `>= 1.1` and `== 1.*`). You have already seen me express
    these same version requirements for `requests` less ambiguously as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 兼容版本说明符（`~=`）依赖于语义版本控制。兼容意味着大于或等于右侧的版本，并且小于下一个版本的主版本号（例如，`>= 1.1` 和 `== 1.*`）。你已经看到我用更明确的方式表示了对
    `requests` 的相同版本要求，如下所示：
- en: '[PRE27]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: These `pip` dependency management techniques work fine if you only develop a
    single Python project at a time. But chances are you use the same machine to work
    on several Python projects at once, each potentially requiring a different version
    of the Python interpreter. The biggest problem with using only `pip` for multiple
    projects is that it installs all packages to the same user `site-packages` directory
    for a particular version of Python. This makes it very hard to isolate dependencies
    from one project to the next.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一次只开发一个 Python 项目，这些 `pip` 依赖管理技巧是有效的。但很有可能你会使用同一台机器同时进行多个 Python 项目的开发，每个项目可能需要不同版本的
    Python 解释器。仅使用 `pip` 处理多个项目的最大问题是，它将所有包安装到特定 Python 版本的相同用户 `site-packages` 目录中。这使得将一个项目的依赖与另一个项目隔离开来变得非常困难。
- en: As we’ll see in the next chapter, `pip` combines well with Docker for deploying
    Python applications. You can add `pip` to a Buildroot or Yocto-based Linux image
    but that only enables quick on-device experimentation. A Python runtime package
    installer such as `pip` is ill-suited for Buildroot and Yocto environments where
    you want to define the entire contents of your embedded Linux image at build time.
    `pip` works great inside containerized environments such as Docker where the line
    between build time and runtime is often blurry.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在下一章看到的，`pip` 与 Docker 配合得很好，用于部署 Python 应用程序。你可以将 `pip` 添加到基于 Buildroot
    或 Yocto 的 Linux 镜像中，但这仅能实现设备上的快速实验。像 `pip` 这样的 Python 运行时包安装程序并不适合 Buildroot 和
    Yocto 环境，在这些环境中你希望在构建时定义嵌入式 Linux 镜像的所有内容。`pip` 在像 Docker 这样的容器化环境中运行良好，因为在这些环境中，构建时和运行时之间的界限往往是模糊的。
- en: In [*Chapter 7*](Chapter_05.xhtml#_idTextAnchor151), you learned about the Python
    modules available to you in the `meta-python` layer and how to define a custom
    layer for your own application. You can use the `requirements.txt` files generated
    by `pip freeze` to inform the selection of dependencies from `meta-python` for
    your own layer recipes. Buildroot and Yocto both install Python packages in a
    system-wide manner, so the virtual environment techniques we are going to discuss
    next do not apply to embedded Linux builds per se. They do, however, help you
    assemble a complete list of dependencies for your embedded Python applications.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第7章*](Chapter_05.xhtml#_idTextAnchor151)中，你学习了如何在 `meta-python` 层中使用 Python
    模块以及如何为自己的应用定义自定义层。你可以使用 `pip freeze` 生成的 `requirements.txt` 文件来指导从 `meta-python`
    中选择依赖项，以便用于你的自定义层配方。Buildroot 和 Yocto 都是以系统范围的方式安装 Python 包，因此我们接下来要讨论的虚拟环境技术并不直接适用于嵌入式
    Linux 构建。不过，它们有助于你为嵌入式 Python 应用程序组装完整的依赖项列表。
- en: Managing Python virtual environments with venv
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 venv 管理 Python 虚拟环境
- en: A **virtual environment** is a self-contained directory tree containing a Python
    interpreter for a particular version of Python, a `pip` executable for managing
    project dependencies, and a local `site-packages` directory. Switching between
    virtual environments tricks the shell into thinking that the only Python and `pip`
    executables available are the ones present in the active virtual environment.
    Best practice dictates that you create a different virtual environment for each
    of your projects. This form of isolation solves the problem of two projects depending
    on different versions of the same package.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**虚拟环境**是一个自包含的目录树，包含特定版本 Python 的 Python 解释器、用于管理项目依赖项的 `pip` 可执行文件以及本地的 `site-packages`
    目录。在虚拟环境之间切换会让 shell 误认为当前唯一可用的 Python 和 `pip` 可执行文件是活动虚拟环境中存在的那些。最佳实践是为每个项目创建一个不同的虚拟环境。这种隔离方式解决了两个项目依赖于同一包的不同版本的问题。'
- en: Virtual environments are not new to Python. The system-wide nature of Python
    installations necessitates them. Besides enabling you to install different versions
    of the same package, virtual environments also provide an easy way for you to
    run multiple versions of the Python interpreter. Several options exist for managing
    Python virtual environments. A tool that was immensely popular circa 2019 (`pipenv`)
    has since languished. The popular `conda` package manager has supported Python
    virtual environments since late 2014\. Meanwhile, Python 3’s built-in support
    for virtual environments (`venv`) introduced back in 2012 has slowly matured and
    is now widely adopted.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '**venv** has been shipping with Python since version 3.3\. Because it only
    comes bundled with Python 3 installations, `venv` is incompatible with projects
    that require Python 2.7\. As support for Python 2.7 officially ended on January
    1, 2020, this Python 3 limitation is less of a concern. `venv` is based on the
    popular `virtualenv` tool, which is still maintained and available on PyPI. If
    you have one or more projects that still require Python 2.7, then you can use
    `virtualenv` instead of `venv` to work on those.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: By default, `venv` installs the most recent version of Python found on your
    system. If you have multiple versions of Python on your system, you can select
    a specific Python version by running `python3` or whichever version you want when
    creating each virtual environment (*The Python Tutorial*, [https://docs.python.org/3/tutorial/venv.html](https://docs.python.org/3/tutorial/venv.html)).
    Developing with the most recent version of Python is usually fine for greenfield
    projects but unacceptable for most legacy and enterprise software. We will use
    the version of Python 3 that came with your Ubuntu system to create and work with
    a virtual environment.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a virtual environment, first, decide where you want to put it, and
    then run the `venv` module as a script with the target directory path:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'Ensure `venv` is installed on your Ubuntu system:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Create a new directory for your project:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Switch to that new directory:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Create the virtual environment inside a subdirectory named `venv`:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now that you have created a virtual environment, here is how you activate and
    verify it:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch to your project directory if you haven’t already:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Check where your system’s `pip3` executable is installed:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Activate the project’s virtual environment:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Check where your project’s `pip3` executable is installed:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'List the packages that came installed with the virtual environment:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If you enter the `which pip` command from within your virtual environment, you
    will see that `pip` now points to an executable. You can now omit the `3` when
    running either `pip` or `python` from within your virtual environment.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s install a property-based testing library named `hypothesis` into
    our existing virtual environment:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch to your project directory if you haven’t already:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Reactivate the project’s virtual environment if it is not already active:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Install the `hypothesis` package:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'List the packages now installed inside the virtual environment:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Notice that two new packages (`attrs` and `sortedcontainers`) were added to
    the list besides `hypothesis`. `hypothesis` depends on these two packages. Let’s
    say you had another Python project that depended on version 1.5.10 instead of
    version 2.4.0 of `sortedcontainers`. Those two versions would be incompatible
    and thus conflict with each other. Virtual environments allow you to install both
    versions of the same package, a different version for each of the two projects.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that switching out of a project directory does not deactivate
    its virtual environment. Don’t worry. Deactivating a virtual environment is as
    easy as this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This puts you back in the global system environment where you have to enter
    `python3` and `pip3` again. You have now seen everything you need to know to get
    started with Python virtual environments. Creating and switching between virtual
    environments is common practice now when developing in Python. Isolated environments
    make it easier to keep track of and manage your dependencies across multiple projects.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Installing precompiled binaries with conda
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**conda** is a package and virtual environment management system used by the
    **Anaconda** distribution of software for the PyData community. The Anaconda distribution
    includes Python as well as binaries for several hard-to-build open source projects
    such as PyTorch and TensorFlow. `conda` can be installed without the full Anaconda
    distribution, which is very large, or the minimal **Miniconda** distribution,
    which is still over 256 MB.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Even though it was created for Python shortly after `pip`, `conda` has evolved
    into a general-purpose package manager like APT or Homebrew. Now, it can be used
    to package and distribute software for any language. Because `conda` downloads
    precompiled binaries, installing Python extension modules is a breeze. Another
    one of `conda`'s big selling points is that it is cross-platform, with full support
    for Linux, macOS, and Windows.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Besides package management, `conda` is also a full-blown virtual environment
    manager. `conda` virtual environments have all the benefits we have come to expect
    from Python `venv` environments and more. Like `venv`, `conda` lets you use `pip`
    to install packages from PyPI into a project’s local `site-packages` directory.
    If you prefer, you can use `conda`'s own package management capabilities to install
    packages from different channels. Channels are package feeds provided by Anaconda
    and other software distributions.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Environment management
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike `venv`, `conda`'s virtual environment manager can easily juggle multiple
    versions of Python, including Python 2.7\. You will need to have Miniconda installed
    on your Ubuntu system to do the following exercises. You want to use Miniconda
    instead of Anaconda for your virtual environments because Anaconda environments
    come with lots of preinstalled packages, many of which you will never need. Miniconda
    environments are stripped down and allow you to easily install any of Anaconda’s
    packages should you have to.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'To install and update Miniconda on Ubuntu 24.04 LTS:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'Download Miniconda:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Install Miniconda:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Update all the installed packages in the root environment:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Your fresh Miniconda installation comes with `conda` and a root environment
    with a Python interpreter and some basic packages installed. By default, the `python`
    and `pip` executables of `conda`''s root environment are installed in your home
    directory. The `conda` root environment is known as `base`. You can view its location,
    along with the locations of any other available `conda` environments, by issuing
    the following command:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Verify this root environment before creating your own `conda` environment:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Open a new shell after installing Miniconda.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Check where the root environment’s `python` executable is installed:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Check the version of Python:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Check where the root environment’s `pip` executable is installed:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Check the version of `pip`:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'List the packages installed in the root environment:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Next, create and work with your own `conda` environment named `py311`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new virtual environment named `py311`:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Activate your new virtual environment:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Check where your environment’s `python` executable is installed:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Check that the version of Python is 3.11.9:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'List the packages installed in your environment:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Deactivate your environment:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Using `conda` to create a virtual environment with Python 2.7 installed is
    as simple as the following:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'View your `conda` environments again to see whether `py311` and `py27` now
    appear in the list:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Lastly, let’s delete the `py27` environment since we won’t be using it:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Now that you know how to use `conda` to manage virtual environments, let’s use
    it to manage packages within those environments.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Package management
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since `conda` supports virtual environments, we can use `pip` to manage Python
    dependencies from one project to another in an isolated manner, just like we did
    with `venv`. As a general-purpose package manager, `conda` has its own facilities
    for managing dependencies. We know that `conda list` lists all the packages that
    `conda` has installed in the active virtual environment. I also mentioned `conda`''s
    use of package feeds, which are called channels:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get the list of channel URLs `conda` is configured to fetch from by
    entering this command:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Before proceeding any further, let’s reactivate the `py311` virtual environment
    you created during the last exercise:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Most Python development nowadays happens inside a Jupyter notebook, so let’s
    install those packages first:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Enter *y* when prompted. This will install the `jupyter` and `notebook` packages
    along with all their dependencies. When you enter `conda list`, you’ll see that
    the list of installed packages is much longer than before. Now, let’s install
    some more Python packages that we would need for a computer vision project:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Again, enter *y* when prompted. This time, the number of dependencies installed
    is smaller. Both `opencv` and `matplotlib` depend on `numpy`, so `conda` installs
    that package automatically without you having to specify it. If you want to specify
    an older version of `opencv`, you can install the desired version of the package
    this way:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '`conda` will then attempt to *solve* the active environment for this dependency.
    Since no other packages installed in this active virtual environment depend on
    `opencv`, the target version is easy to solve for. If they did, then you might
    encounter a package conflict and the reinstallation would fail. After solving,
    `conda` will prompt you before downgrading `opencv` and its dependencies. Enter
    *y* to downgrade `opencv` to version 4.6.0.'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now let’s say you change your mind or a newer version of `opencv` is released
    that addresses your previous concern. This is how you would upgrade `opencv` to
    the latest version provided by the Anaconda distribution:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This time, `conda` will prompt you to ask whether you want to update `opencv`
    and its dependencies for the latest version. This time, enter *n* to cancel the
    package update. Instead of updating packages individually, it’s often easier to
    update all the packages installed in an active virtual environment at once:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Removing installed packages is also straightforward:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: When `conda` removes `jupyter` and `notebook`, it removes all of their dangling
    dependencies as well. A dangling dependency is an installed package that no other
    installed packages depend on. Like most general-purpose package managers, `conda`
    will not remove any dependencies that other installed packages still depend on.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes you may not know the exact name of a package you want to install.
    Amazon offers an AWS SDK for Python called Boto. Like many Python libraries, there
    is a version of Boto for Python 2 and a newer version (Boto3) for Python 3\. To
    search Anaconda for packages with the word `boto` in their names, enter the following
    command:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'You should see `boto3` and `botocore` in the search results. At the time of
    writing, the most recent version of `boto3` available on Anaconda is 1.36.3\.
    To view details on that specific version of `boto3`, enter the following command:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The package details reveal that `boto3` version 1.36.3 depends on `botocore`
    (`botocore >=1.36.3,<1.37.0`), so installing `boto3` gets you both.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s say you’ve installed all the packages you need to develop an OpenCV
    project inside a Jupyter notebook. How do you share these project requirements
    with someone else so that they can recreate your work environment? The answer
    may surprise you:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'You export your active virtual environment to a YAML file:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Much like the list of requirements that `pip freeze` generates, the YAML that
    `conda` exports is a list of all the packages installed in your virtual environment
    together with their pinned versions. Creating a `conda` virtual environment from
    an environment file requires the `-f` option and the filename:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The environment name is included in the exported YAML, so no `--name` option
    is necessary to create the environment. Whoever creates a virtual environment
    from `my-environment.yaml` will now see `py311` in their list of environments
    when they issue `conda env list`.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`conda` is a very powerful tool in a developer’s arsenal. By combining general-purpose
    package installation with virtual environments, it offers a compelling deployment
    story. `conda` achieves many of the same goals Docker (up next) does, but without
    the use of containers. It has an edge over Docker with respect to Python due to
    its focus on the data science community. Because the leading ML frameworks (such
    as PyTorch and TensorFlow) are largely CUDA-based, finding GPU-accelerated binaries
    is often difficult. `conda` solves this problem by providing multiple precompiled
    binary versions of packages.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Exporting `conda` virtual environments to YAML files for installation on other
    machines offers another deployment option. This solution is popular among the
    data science community, but it does not work in production for embedded Linux.
    `conda` is not one of the three package managers that Yocto supports. Even if
    `conda` was an option, the storage needed to accommodate Miniconda on a Linux
    image is not a good fit for most embedded systems due to resource constraints.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: If your dev board has an NVIDIA GPU such as the NVIDIA Jetson series, then you
    really want to use `conda` for on-device development. Luckily, there is a `conda`
    installer named **Miniforge** ([https://github.com/conda-forge/miniforge)](https://github.com/conda-forge/miniforge))
    that is known to work on 64-bit ARM machines like the Jetsons. With `conda` on
    the device, you can then install `jupyter`, `numpy`, `pandas`, `scikit-learn`,
    and most of the other popular Python data science libraries out there.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, you’re probably asking yourself, “What does any of this Python packaging
    stuff have to do with embedded Linux?” The answer is “not much” but bear in mind
    that the word *development* also happens to be in the title of this book, and
    this chapter has everything to do with modern-day software development. To succeed
    as a developer, you need to be able to deploy your code to production fast, frequently,
    and in a repeatable manner. That means managing your dependencies carefully and
    automating as much of the process as possible. You now know how to do that with
    Python.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Further study
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Python Packaging User Guide*, PyPA – [https://packaging.python.org](https://packaging.python.org)'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*setup.py vs requirements.txt*, by Donald Stufft – [https://caremad.io/posts/2013/07/setup-vs-requirement](https://caremad.io/posts/2013/07/setup-vs-requirement)'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*pip User Guide*, PyPA – [https://pip.pypa.io/en/latest/user_guide/](https://pip.pypa.io/en/latest/user_guide/)'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Conda User Guide*, Anaconda, Inc. – [https://docs.conda.io/projects/conda/en/latest/user-guide](https://docs.conda.io/projects/conda/en/latest/user-guide)'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
