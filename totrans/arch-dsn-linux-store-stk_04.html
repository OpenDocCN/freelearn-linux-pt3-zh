<html><head></head><body>
<div id="_idContainer042">
<h1 class="chapter-number" id="_idParaDest-69"><a id="_idTextAnchor072"/><span class="koboSpan" id="kobo.1.1">4</span></h1>
<h1 id="_idParaDest-70"><a id="_idTextAnchor073"/><span class="koboSpan" id="kobo.2.1">Understanding the Block Layer, Block Devices, and Data Structures</span></h1>
<p><span class="koboSpan" id="kobo.3.1">The first three chapters of this book were centered around the first component of the kernel’s I/O hierarchy, which is the VFS layer. </span><span class="koboSpan" id="kobo.3.2">We explained the functions and purpose of VFS, as well as how it serves as an intermediary layer between the generic system call interface and filesystems, along with its primary data structures. </span><span class="koboSpan" id="kobo.3.3">In addition, we discussed the filesystems that can be found under the VFS layer and introduced some of the essential concepts associated </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">with them.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">We’ll now turn our focus to the second major section in the kernel’s storage hierarchy: the block layer. </span><span class="koboSpan" id="kobo.5.2">The block layer deals with block devices and is responsible for handling I/O operations performed on block devices. </span><span class="koboSpan" id="kobo.5.3">All the user-space programs use the block layer interfaces to address and access the underlying storage devices. </span><span class="koboSpan" id="kobo.5.4">Over the last decade or so, physical storage media has undergone a significant transformation, shifting from slower mechanical drives to faster flash drives. </span><span class="koboSpan" id="kobo.5.5">Consequently, the block layer within the kernel has undergone substantial modifications. </span><span class="koboSpan" id="kobo.5.6">As performance is a critical factor when it comes to storage hardware, several enhancements have been made to the kernel code to enable disk drives to realize their full potential. </span><span class="koboSpan" id="kobo.5.7">In this chapter, we’re going to introduce the block layer, define block devices, and then dive into the major data structures in the </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">block layer.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">Here’s a summary of </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">what follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.9.1">Explaining the role of the </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">block layer</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Defining </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">block devices</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">The defining characteristics of a </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">block device</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Representation of </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">block devices</span></span></li>
<li><a id="_idTextAnchor074"/><span class="koboSpan" id="kobo.17.1">Looking at the major data structures in the </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">block layer</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">The journey of an I/O request in the </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">block layer</span></span></li>
</ul>
<h1 id="_idParaDest-71"><a id="_idTextAnchor075"/><span class="koboSpan" id="kobo.21.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.22.1">The Linux kernel’s block layer is a slightly complex topic. </span><span class="koboSpan" id="kobo.22.2">A good understanding of the material presented in the first three chapters will help you comprehend the interaction between the block layer and various filesystems. </span><span class="koboSpan" id="kobo.22.3">Having experience with the C programming language will help you understand the code presented in this chapter. </span><span class="koboSpan" id="kobo.22.4">Additionally, any practical experience with a Linux system will enhance your understanding of the concepts </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">discussed herein.</span></span></p>
<p><span class="koboSpan" id="kobo.24.1">If you want to download the kernel source, you can download it from </span><a href="https://www.kernel.org"><span class="koboSpan" id="kobo.25.1">https://www.kernel.org</span></a><span class="koboSpan" id="kobo.26.1">. </span><span class="koboSpan" id="kobo.26.2">The code segments referred to in this chapter and book are from </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">kernel </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.28.1">5.19.9</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">.</span></span></p>
<h1 id="_idParaDest-72"><a id="_idTextAnchor076"/><span class="koboSpan" id="kobo.30.1">Explaining the role of the block layer</span></h1>
<p><span class="koboSpan" id="kobo.31.1">The block layer is tasked with implementing the kernel interfaces that enable filesystems to interact with storage devices. </span><span class="koboSpan" id="kobo.31.2">In the context of accessing physical storage, applications use block devices, and any requests to access data on these devices are managed by the block layer. </span><span class="koboSpan" id="kobo.31.3">The kernel also contains a mapping layer just above the block layer. </span><span class="koboSpan" id="kobo.31.4">This layer provides a flexible and powerful way to map one block device to another, allowing for operations such as creating snapshots, encrypting data, and creating logical volumes that span multiple physical devices. </span><span class="koboSpan" id="kobo.31.5">The interfaces that are implemented in the block layer are central to managing physical storage in Linux. </span><span class="koboSpan" id="kobo.31.6">The device files for block devices are created in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.32.1">/</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.33.1">dev</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.34.1"> directory.</span></span></p>
<p><span class="koboSpan" id="kobo.35.1">Like VFS, abstraction is the core function of the block layer. </span><span class="koboSpan" id="kobo.35.2">The VFS layer allows applications to make generic requests for interacting with files without having to worry about the underlying filesystem. </span><span class="koboSpan" id="kobo.35.3">In a similar vein, the block layer allows applications to access storage devices uniformly. </span><span class="koboSpan" id="kobo.35.4">The choice of backend storage medium is not a point of concern for </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.37.1">To highlight the major functions of the block layer, let’s build on the storage hierarchy we defined when describing VFS. </span><span class="koboSpan" id="kobo.37.2">The following figure outlines the major components of the </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">block layer:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer039">
<span class="koboSpan" id="kobo.39.1"><img alt="Figure 4.1 – I/O hierarchy from VFS to the block layer" src="image/B19430_04_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.40.1">Figure 4.1 – I/O hierarchy from VFS to the block layer</span></p>
<p><span class="koboSpan" id="kobo.41.1">Let’s take a brief look at </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">these functions:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.43.1">The block layer provides an upstream interface to filesystems and allows them to access a diverse range of storage devices uniformly. </span><span class="koboSpan" id="kobo.43.2">Likewise, it implements a downstream interface for drivers and storage devices by providing them with a single point of entry from </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">all applications.</span></span></li>
<li><span class="koboSpan" id="kobo.45.1">As we’ll see in this chapter, the block layer incorporates several tricky structures to provide its services generically. </span><span class="koboSpan" id="kobo.45.2">Probably the most important of them is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.46.1">bio</span></strong><span class="koboSpan" id="kobo.47.1"> structure. </span><span class="koboSpan" id="kobo.47.2">The filesystem layer creates a bio structure to represent the I/O request and passes it down to the block layer. </span><span class="koboSpan" id="kobo.47.3">The bio structure is responsible for transporting all I/O requests to the driver. </span><span class="koboSpan" id="kobo.47.4">The mapping layer is in charge of providing an infrastructure to map physical block devices to logical devices. </span><span class="koboSpan" id="kobo.47.5">The mapping layer can achieve this by using the device mapper framework in the kernel. </span><span class="koboSpan" id="kobo.47.6">The device mapper lays the groundwork for several technologies in the kernel. </span><span class="koboSpan" id="kobo.47.7">These include volume management, multipathing, thin provisioning, encryption, and software RAID. </span><span class="koboSpan" id="kobo.47.8">The most well known of these is </span><strong class="bold"><span class="koboSpan" id="kobo.48.1">logical volume management</span></strong><span class="koboSpan" id="kobo.49.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.50.1">LVM</span></strong><span class="koboSpan" id="kobo.51.1">). </span><span class="koboSpan" id="kobo.51.2">The device mapper creates every logical volume as a mapped device. </span><span class="koboSpan" id="kobo.51.3">LVM provides a great deal of flexibility to storage administrators and simplifies </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">storage management.</span></span></li>
<li><span class="koboSpan" id="kobo.53.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.54.1">blk-mq</span></strong><span class="koboSpan" id="kobo.55.1"> framework has become an important part of the block layer as it solved its performance limitations by isolating request queues for every CPU core. </span><span class="koboSpan" id="kobo.55.2">This framework is responsible for shepherding block I/O requests to multiple dispatch queues. </span><span class="koboSpan" id="kobo.55.3">We’ll cover the </span><strong class="source-inline"><span class="koboSpan" id="kobo.56.1">blk-mq</span></strong><span class="koboSpan" id="kobo.57.1"> framework in more detail in </span><a href="B19430_05.xhtml#_idTextAnchor090"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.58.1">Chapter 5</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.59.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.60.1">The block layer also includes several schedulers for handling I/O requests. </span><span class="koboSpan" id="kobo.60.2">These schedulers are pluggable and can be set for individual block devices. </span><span class="koboSpan" id="kobo.60.3">Non-multi-queue schedulers have been deprecated and are no longer supported in modern kernels. </span><span class="koboSpan" id="kobo.60.4">As we’ll see in </span><a href="B19430_06.xhtml#_idTextAnchor101"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.61.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.62.1">, these schedulers make use of several techniques to make intelligent decisions regarding </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">I/O scheduling.</span></span></li>
<li><span class="koboSpan" id="kobo.64.1">Additionally, the block layer implements functions such as error handling and collecting I/O statistics for </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">block devices.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.66.1">At the heart of the block layer are block devices. </span><span class="koboSpan" id="kobo.66.2">Apart from devices that stream data, such as tape drives, most storage devices, such as mechanical drives, and solid-state drives flashcards, are considered block-based devices. </span><span class="koboSpan" id="kobo.66.3">Let’s take a look at the defining traits of a block device and how they’re represented </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">in Linux.</span></span></p>
<h1 id="_idParaDest-73"><a id="_idTextAnchor077"/><span class="koboSpan" id="kobo.68.1">Defining block devices</span></h1>
<p><span class="koboSpan" id="kobo.69.1">There are two major ways that the kernel exchanges data with external devices. </span><span class="koboSpan" id="kobo.69.2">One method is to exchange one character at a time with the device. </span><span class="koboSpan" id="kobo.69.3">Devices addressed through such methods are known as character devices. </span><span class="koboSpan" id="kobo.69.4">Character devices are addressed using a stream of sequential data. </span><span class="koboSpan" id="kobo.69.5">They can be accessed by programs to perform input and output operations one character at a time. </span><span class="koboSpan" id="kobo.69.6">Due to the absence of random access methods, managing character devices is simpler for the kernel. </span><span class="koboSpan" id="kobo.69.7">Devices such as keyboards, text-based consoles, and serial ports are all examples of </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">character devices.</span></span></p>
<p><span class="koboSpan" id="kobo.71.1">Communicating through one character at a time is acceptable when the volume of data is low, such as when using serial ports or keyboards. </span><span class="koboSpan" id="kobo.71.2">A keyboard can only accept one character at a time, so the use of a character interface makes sense. </span><span class="koboSpan" id="kobo.71.3">But this approach becomes untenable when transferring large volumes of data. </span><span class="koboSpan" id="kobo.71.4">When writing to physical disks, we expect them to be able to address more than one character at a time and allow for data to be accessed randomly. </span><span class="koboSpan" id="kobo.71.5">The kernel addresses physical drives in fixed-size chunks, known as blocks. </span><span class="koboSpan" id="kobo.71.6">In addition to traditional disks, devices such as CD-ROMs and flash drives also use this approach. </span><span class="koboSpan" id="kobo.71.7">Such devices are known as block devices. </span><span class="koboSpan" id="kobo.71.8">Block devices are more complex to manage compared to character devices and require more careful considerations from the kernel. </span><span class="koboSpan" id="kobo.71.9">The kernel has to make critical decisions regarding the addressing and organization of block devices as these can significantly impact not only the block device but also the overall </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">system performance.</span></span></p>
<p><span class="koboSpan" id="kobo.73.1">Block devices can exist in memory. </span><span class="koboSpan" id="kobo.73.2">This can be achieved by creating a </span><em class="italic"><span class="koboSpan" id="kobo.74.1">ramdisk</span></em><span class="koboSpan" id="kobo.75.1">. </span><span class="koboSpan" id="kobo.75.2">One of the most notable use cases of ramdisks is during the boot-up sequence in Linux systems. </span><span class="koboSpan" id="kobo.75.3">An </span><strong class="bold"><span class="koboSpan" id="kobo.76.1">initial ramdisk</span></strong><span class="koboSpan" id="kobo.77.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.78.1">initrd</span></strong><span class="koboSpan" id="kobo.79.1">) is responsible for loading a temporary root filesystem in memory to aid in the boot process. </span><span class="koboSpan" id="kobo.79.2">A filesystem can be created on a ramdisk and mounted like any regular filesystem. </span><span class="koboSpan" id="kobo.79.3">The speed of RAM makes ramdisks incredibly fast. </span><span class="koboSpan" id="kobo.79.4">But due to the volatile nature of RAM, any data written to a ramdisk is maintained only until the device is </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">powered on.</span></span></p>
<p><span class="koboSpan" id="kobo.81.1">Although ramdisks are also block-based, they’re rarely used. </span><span class="koboSpan" id="kobo.81.2">As you’ll see, throughout this book, a block device is typically regarded as a persistent data storage medium with a filesystem layer </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">on top.</span></span></p>
<p><span class="koboSpan" id="kobo.83.1">All operations on block devices are performed by the kernel in fixed-size chunks of </span><em class="italic"><span class="koboSpan" id="kobo.84.1">N</span></em><span class="koboSpan" id="kobo.85.1"> bytes, known as </span><em class="italic"><span class="koboSpan" id="kobo.86.1">blocks</span></em><span class="koboSpan" id="kobo.87.1">, which is the currency of exchange when dealing with block devices. </span><span class="koboSpan" id="kobo.87.2">The actual value of </span><em class="italic"><span class="koboSpan" id="kobo.88.1">N</span></em><span class="koboSpan" id="kobo.89.1"> varies across the stack since different layers in the kernel’s I/O hierarchy use chunks of different sizes to address block devices. </span><span class="koboSpan" id="kobo.89.2">Because of this, the term block is defined in several ways, depending on its presence in </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">the stack:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.91.1">User-space applications</span></strong><span class="koboSpan" id="kobo.92.1">: As applications interact with the kernel space through standard system calls, the term </span><strong class="bold"><span class="koboSpan" id="kobo.93.1">block</span></strong><span class="koboSpan" id="kobo.94.1"> in this context refers to the amount of data read from and written to via system calls. </span><span class="koboSpan" id="kobo.94.2">Depending on the application, this can vary </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">in size.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.96.1">Page cache</span></strong><span class="koboSpan" id="kobo.97.1">: The kernel makes extensive use of the VFS page cache to improve the performance of read and write operations. </span><span class="koboSpan" id="kobo.97.2">Here, the fundamental unit of data transfer is a </span><em class="italic"><span class="koboSpan" id="kobo.98.1">page</span></em><span class="koboSpan" id="kobo.99.1">, which is 4 KB </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">in size.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.101.1">Disk-based filesystems</span></strong><span class="koboSpan" id="kobo.102.1">: As explained in </span><a href="B19430_03.xhtml#_idTextAnchor053"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.103.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.104.1">, a block represents the fixed number of bytes in which I/O operations are performed by the filesystem. </span><span class="koboSpan" id="kobo.104.2">Although filesystems allow for higher block sizes, often up to 64 KB, the block size for a filesystem is usually between 512 bytes and 4 KB because of the </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">page size.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.106.1">Physical storage</span></strong><span class="koboSpan" id="kobo.107.1">: On physical disks, the smallest addressable unit is known as a sector, which is usually 512 bytes. </span><span class="koboSpan" id="kobo.107.2">This sector is often further classified as logical </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">or physical.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.109.1">We discussed filesystem blocks in </span><a href="B19430_03.xhtml#_idTextAnchor053"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.110.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.111.1">. </span><span class="koboSpan" id="kobo.111.2">Don’t get confused; the filesystem block’s size is not the fundamental unit of block I/O. </span><span class="koboSpan" id="kobo.111.3">The basic unit of block I/O is a sector. </span><span class="koboSpan" id="kobo.111.4">The data structures in the block layer define a variable of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">sector_t</span></strong><span class="koboSpan" id="kobo.113.1"> type in the kernel code that represents an offset or size that is a multiple of 512. </span><span class="koboSpan" id="kobo.113.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">sector_t</span></strong><span class="koboSpan" id="kobo.115.1"> variable is defined as an unsigned integer type that is large enough to represent the maximum number of sectors that can be addressed by the block device. </span><span class="koboSpan" id="kobo.115.2">It is used extensively throughout the block layer in structures such as “bio” to represent disk addresses </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">and offsets.</span></span></p>
<p><span class="koboSpan" id="kobo.117.1">To summarize, devices that are organized and addressed in terms of blocks are known as block devices. </span><span class="koboSpan" id="kobo.117.2">They allow for random access and offer superior performance compared to character devices. </span><span class="koboSpan" id="kobo.117.3">To take full advantage of block devices, the kernel has to make informed decisions regarding their addressing </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">and organization.</span></span></p>
<p><span class="koboSpan" id="kobo.119.1">Let’s briefly go over some key features that define a </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">block device.</span></span></p>
<h1 id="_idParaDest-74"><a id="_idTextAnchor078"/><span class="koboSpan" id="kobo.121.1">The defining characteristics of a block device</span></h1>
<p><span class="koboSpan" id="kobo.122.1">As discussed earlier, block devices allow far more advanced ways to handle I/O requests. </span><span class="koboSpan" id="kobo.122.2">Some of the defining characteristics of block devices are </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">as follows:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.124.1">Random access</span></strong><span class="koboSpan" id="kobo.125.1">: Block devices allow for random access. </span><span class="koboSpan" id="kobo.125.2">This means that the device can </span><em class="italic"><span class="koboSpan" id="kobo.126.1">seek</span></em><span class="koboSpan" id="kobo.127.1"> from one position </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">to another.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.129.1">Block size</span></strong><span class="koboSpan" id="kobo.130.1">: Block devices address and transfer data in </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">fixed-sized blocks.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.132.1">Stackability</span></strong><span class="koboSpan" id="kobo.133.1">: Block devices can be stacked through the use of the device mapper framework. </span><span class="koboSpan" id="kobo.133.2">This extends the basic functionalities of physical disks and allows for scaling </span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">logical volumes.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.135.1">Buffered I/O</span></strong><span class="koboSpan" id="kobo.136.1">: Block devices use buffered I/O, which means that data is written to a buffer in memory before being written to the device. </span><span class="koboSpan" id="kobo.136.2">Read and write operations on block devices make extensive use of the page cache. </span><span class="koboSpan" id="kobo.136.3">Data that’s read from the block device is loaded and kept in memory for a certain period. </span><span class="koboSpan" id="kobo.136.4">Similarly, any data to be written to a block device is written to the </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">cache first.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.138.1">Filesystems/partitioning</span></strong><span class="koboSpan" id="kobo.139.1">: Block devices can be partitioned into smaller logical units, with separate filesystems created on top </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">of them.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.141.1">Request queues</span></strong><span class="koboSpan" id="kobo.142.1">: Block devices implement the concept of request queues, which are responsible for managing the I/O requests that are submitted to a </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">block device.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.144.1">Let’s see how block devices are represented </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">in Linux.</span></span></p>
<h1 id="_idParaDest-75"><a id="_idTextAnchor079"/><span class="koboSpan" id="kobo.146.1">Looking at the representation of block devices</span></h1>
<p><span class="koboSpan" id="kobo.147.1">When discussing VFS, we saw that abstractions are at the heart of the kernel’s I/O stack. </span><span class="koboSpan" id="kobo.147.2">The block layer is no exception to this rule. </span><span class="koboSpan" id="kobo.147.3">Regardless of the differences in the physical make and model, the kernel should be able to work with storage devices uniformly. </span><span class="koboSpan" id="kobo.147.4">To implement a standard interface for all devices, the operations should be independent of the properties of the underlying </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">storage device.</span></span></p>
<p><span class="koboSpan" id="kobo.149.1">As explained in </span><a href="B19430_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.150.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.151.1">, almost everything is represented in the form of a file, including hardware devices. </span><span class="koboSpan" id="kobo.151.2">A block device is a special file and is named as such because the kernel interacts with it using a fixed number of bytes. </span><span class="koboSpan" id="kobo.151.3">Depending on the nature of the devices, the files representing them are created and stored at specific locations in the system. </span><span class="koboSpan" id="kobo.151.4">The block devices in the system are present in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">/dev</span></strong><span class="koboSpan" id="kobo.153.1"> directory. </span><span class="koboSpan" id="kobo.153.2">Filenames representing disk drives in the system start with </span><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">sd</span></strong><span class="koboSpan" id="kobo.155.1">, followed by a letter representing the order of discovery. </span><span class="koboSpan" id="kobo.155.2">The first drive is named </span><strong class="source-inline"><span class="koboSpan" id="kobo.156.1">sda</span></strong><span class="koboSpan" id="kobo.157.1"> and so on. </span><span class="koboSpan" id="kobo.157.2">Similarly, the first partition on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">sda</span></strong><span class="koboSpan" id="kobo.159.1"> drive is represented as </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">sda1</span></strong><span class="koboSpan" id="kobo.161.1">. </span><span class="koboSpan" id="kobo.161.2">If we look at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">sd*</span></strong><span class="koboSpan" id="kobo.163.1"> devices in </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">/dev</span></strong><span class="koboSpan" id="kobo.165.1">, notice that the file type is </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">b</span></strong><span class="koboSpan" id="kobo.167.1">, for block devices. </span><span class="koboSpan" id="kobo.167.2">You can also list block devices using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">lsblk</span></strong><span class="koboSpan" id="kobo.169.1"> command, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">following figure:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer040">
<span class="koboSpan" id="kobo.171.1"><img alt="Figure 4.2 – Major and minor numbers" src="image/B19430_04_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.172.1">Figure 4.2 – Major and minor numbers</span></p>
<p><span class="koboSpan" id="kobo.173.1">Just before the modification timestamp, note the two numbers separated by a comma. </span><span class="koboSpan" id="kobo.173.2">The kernel represents block devices as a pair of numbers. </span><span class="koboSpan" id="kobo.173.3">These numbers are called major and minor numbers for a device. </span><span class="koboSpan" id="kobo.173.4">The </span><em class="italic"><span class="koboSpan" id="kobo.174.1">major number</span></em><span class="koboSpan" id="kobo.175.1"> identifies the driver associated with the device, whereas the </span><em class="italic"><span class="koboSpan" id="kobo.176.1">minor number</span></em><span class="koboSpan" id="kobo.177.1"> is used for differentiating between </span><span class="No-Break"><span class="koboSpan" id="kobo.178.1">individual devices.</span></span></p>
<p><span class="koboSpan" id="kobo.179.1">In the preceding figure, all three devices – </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">sda</span></strong><span class="koboSpan" id="kobo.181.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">sda1</span></strong><span class="koboSpan" id="kobo.183.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">sda2</span></strong><span class="koboSpan" id="kobo.185.1"> – use the same driver and hence have the same major number, </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">8</span></strong><span class="koboSpan" id="kobo.187.1">. </span><span class="koboSpan" id="kobo.187.2">The minor numbers – </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">0</span></strong><span class="koboSpan" id="kobo.189.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">1</span></strong><span class="koboSpan" id="kobo.191.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">2</span></strong><span class="koboSpan" id="kobo.193.1"> – are used to identify the driver instance for </span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">each device.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer041">
<span class="koboSpan" id="kobo.195.1"><img alt="Figure 4.3 – Device major and minor numbers" src="image/B19430_04_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.196.1">Figure 4.3 – Device major and minor numbers</span></p>
<p><span class="koboSpan" id="kobo.197.1">The device files present in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">/dev</span></strong><span class="koboSpan" id="kobo.199.1"> directory are hooked up to the corresponding device drivers to establish a communication link with the actual hardware. </span><span class="koboSpan" id="kobo.199.2">When a program interacts with the block device file, the kernel uses the major number to identify the appropriate driver for that device and sends the request. </span><span class="koboSpan" id="kobo.199.3">Since a driver can be responsible for handling multiple devices, there has to be a way through which the kernel can distinguish devices</span><a id="_idIndexMarker148"/><span class="koboSpan" id="kobo.200.1"> using the same major</span><a id="_idIndexMarker149"/><span class="koboSpan" id="kobo.201.1"> number. </span><span class="koboSpan" id="kobo.201.2">For this purpose, minor numbers </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">are used.</span></span></p>
<p><span class="koboSpan" id="kobo.203.1">We will now explore the primary data structures that are used in the </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">block layer.</span></span></p>
<h1 id="_idParaDest-76"><a id="_idTextAnchor080"/><span class="koboSpan" id="kobo.205.1">Looking at data structures in the block layer</span></h1>
<p><span class="koboSpan" id="kobo.206.1">Dealing with block devices is fairly</span><a id="_idIndexMarker150"/><span class="koboSpan" id="kobo.207.1"> complex as the kernel has to implement features</span><a id="_idIndexMarker151"/><span class="koboSpan" id="kobo.208.1"> such as queue management, scheduling, and the ability to access data randomly. </span><span class="koboSpan" id="kobo.208.2">The speed of block devices is much higher than character devices. </span><span class="koboSpan" id="kobo.208.3">This makes block devices extremely performance-sensitive and the kernel has to make intelligent decisions to extract their maximum performance. </span><span class="koboSpan" id="kobo.208.4">Thus, it makes sense to handle the two devices differently. </span><span class="koboSpan" id="kobo.208.5">Because of this, there is an entire kernel subsystem dedicated to managing block devices. </span><span class="koboSpan" id="kobo.208.6">All this makes the block layer the most sophisticated piece of code in the </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">Linux kernel.</span></span></p>
<p><span class="koboSpan" id="kobo.210.1">Throughout this book, we’ve referred to the relevant pieces of kernel code so that you can familiarize yourself with the implementations of certain concepts. </span><span class="koboSpan" id="kobo.210.2">If you’re interested in pursuing kernel development, this may seem like a good starting point. </span><span class="koboSpan" id="kobo.210.3">However, if you are more focused on theoretical understanding, the use of code might be mildly confusing. </span><span class="koboSpan" id="kobo.210.4">But it is essential to get a basic idea of how certain things are represented in the kernel. </span><span class="koboSpan" id="kobo.210.5">Talking specifically about the block layer, it is not possible to discuss all the structures that make up its intricate design. </span><span class="koboSpan" id="kobo.210.6">Nevertheless, we must highlight some more important constructs that give us a fair understanding of the representation and organization of block devices in </span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">the kernel.</span></span></p>
<p><span class="koboSpan" id="kobo.212.1">Some of the major data structures</span><a id="_idIndexMarker152"/><span class="koboSpan" id="kobo.213.1"> that are used to work with block devices</span><a id="_idIndexMarker153"/><span class="koboSpan" id="kobo.214.1"> are </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">as follows:</span></span></p>
<ul>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">register_blkdev</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">block_device</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">gendisk</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">buffer_head</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">bio</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">bio_vec</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">request</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">request_queue</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.224.1">Let’s take a look at them one </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">by one.</span></span></p>
<h2 id="_idParaDest-77"><a id="_idTextAnchor081"/><span class="koboSpan" id="kobo.226.1">The register_blkdev function (block device registration)</span></h2>
<p><span class="koboSpan" id="kobo.227.1">To make block devices available</span><a id="_idIndexMarker154"/><span class="koboSpan" id="kobo.228.1"> for use, they must first be registered with the kernel. </span><span class="koboSpan" id="kobo.228.2">The registration process is performed by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">register_blkdev()</span></strong><span class="koboSpan" id="kobo.230.1"> function, which is defined </span><span class="No-Break"><span class="koboSpan" id="kobo.231.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">include/linux/blkdev.h</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.234.1">
int __register_blkdev(unsigned int major, const char *name,
                void (*probe)(dev_t devt))</span></pre>
<p><span class="koboSpan" id="kobo.235.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">register_blkdev</span></strong><span class="koboSpan" id="kobo.237.1"> function is used by block device drivers to register themselves and is a macro that’s directed to </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">__register_blkdev</span></strong><span class="koboSpan" id="kobo.239.1">. </span><span class="koboSpan" id="kobo.239.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">__register_blkdev</span></strong><span class="koboSpan" id="kobo.241.1"> function performs the actual registration process. </span><span class="koboSpan" id="kobo.241.2">The purpose of having a separate internal function is to provide additional error handling and validation before modifying the kernel’s </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">data structures.</span></span></p>
<p><span class="koboSpan" id="kobo.243.1">The registration function performs the </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">following tasks:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.245.1">It requests a major number from the kernel’s dynamic major number allocation pool. </span><span class="koboSpan" id="kobo.245.2">The major number uniquely identifies the block device driver within </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">the system.</span></span></li>
<li><span class="koboSpan" id="kobo.247.1">Once a major number has been successfully obtained, the function creates a </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">block_device</span></strong><span class="koboSpan" id="kobo.249.1"> struct, which represents the block device driver. </span><span class="koboSpan" id="kobo.249.2">This struct contains information such as the major number, the name of the driver, and function pointers to various </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">driver operations.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.251.1">In summary, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">register_blkdev</span></strong><span class="koboSpan" id="kobo.253.1"> function acts as a friendly</span><a id="_idIndexMarker155"/><span class="koboSpan" id="kobo.254.1"> interface through which block device drivers can initiate their registration processes with the kernel’s block layer. </span><span class="koboSpan" id="kobo.254.2">It handles the necessary steps for acquiring a major number, creating a </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">block_device</span></strong><span class="koboSpan" id="kobo.256.1"> struct, and establishing the necessary connections with the </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">block layer.</span></span></p>
<h2 id="_idParaDest-78"><a id="_idTextAnchor082"/><span class="koboSpan" id="kobo.258.1">The block_device structure (representing block devices)</span></h2>
<p><span class="koboSpan" id="kobo.259.1">The block device</span><a id="_idIndexMarker156"/><span class="koboSpan" id="kobo.260.1"> is defined in </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">include/linux/blk_types.h</span></strong><span class="koboSpan" id="kobo.262.1"> by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">block_device</span></strong><span class="koboSpan" id="kobo.264.1"> structure in </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">the kernel:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.266.1">
struct block_device {
        sector_t                bd_start_sect;
        sector_t                bd_nr_sectors;
        struct disk_stats __percpu *bd_stats;
        unsigned long           bd_stamp;
        bool                    bd_read_only;
        dev_t                   bd_dev;
        atomic_t                bd_openers;
        struct inode *          bd_inode;
[……..]</span></pre>
<p><span class="koboSpan" id="kobo.267.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">block_device</span></strong><span class="koboSpan" id="kobo.269.1"> structure instance is created when the device file is opened. </span><span class="koboSpan" id="kobo.269.2">A block device can be a whole disk or a single partition and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">block_device</span></strong><span class="koboSpan" id="kobo.271.1"> structure can represent either. </span><span class="koboSpan" id="kobo.271.2">When using partitions, the individual partitions are identified through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">bd_partno</span></strong><span class="koboSpan" id="kobo.273.1"> field. </span><span class="koboSpan" id="kobo.273.2">Since access to block devices happens through the VFS layer, the corresponding device files are also assigned an inode number. </span><span class="koboSpan" id="kobo.273.3">The inodes for block devices are virtual and are stored in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">bdev</span></strong><span class="koboSpan" id="kobo.275.1"> virtual filesystem. </span><span class="koboSpan" id="kobo.275.2">The inode for a block device also contains information about its major and </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">minor numbers.</span></span></p>
<p><span class="koboSpan" id="kobo.277.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">block_device</span></strong><span class="koboSpan" id="kobo.279.1"> structure</span><a id="_idIndexMarker157"/><span class="koboSpan" id="kobo.280.1"> also provides information about the device, such as its name, size, and block size. </span><span class="koboSpan" id="kobo.280.2">It also contains a pointer to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">gendisk</span></strong><span class="koboSpan" id="kobo.282.1"> structure, which represents the disk, and a list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">request_queues</span></strong><span class="koboSpan" id="kobo.284.1"> structures for handling </span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">I/O requests.</span></span></p>
<h2 id="_idParaDest-79"><a id="_idTextAnchor083"/><span class="koboSpan" id="kobo.286.1">The gendisk structure (representing physical disks)</span></h2>
<p><span class="koboSpan" id="kobo.287.1">An important field</span><a id="_idIndexMarker158"/><span class="koboSpan" id="kobo.288.1"> in the definition of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">block_device</span></strong><span class="koboSpan" id="kobo.290.1"> structure is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">bd_disk</span></strong><span class="koboSpan" id="kobo.292.1"> pointer, which points to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">gendisk</span></strong><span class="koboSpan" id="kobo.294.1"> structure. </span><span class="koboSpan" id="kobo.294.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">gendisk</span></strong><span class="koboSpan" id="kobo.296.1"> structure, which is defined in </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">include/linux/blkdev.h</span></strong><span class="koboSpan" id="kobo.298.1">, represents information about the disk and is used to implement the notion of a physical hard disk in </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">the kernel.</span></span></p>
<p><span class="koboSpan" id="kobo.300.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">gendisk</span></strong><span class="koboSpan" id="kobo.302.1"> structure represents the disk’s properties and the methods used to access it. </span><span class="koboSpan" id="kobo.302.2">It is used to register a block device and its associated I/O operations with the kernel, allowing it to communicate with </span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">the device:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.304.1">
struct gendisk {
        int major;
        int first_minor;
        int minors;
        char disk_name[DISK_NAME_LEN];
        unsigned short events;
        unsigned short event_flags;
[……]</span></pre>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">gendisk</span></strong><span class="koboSpan" id="kobo.306.1"> can be considered a link between the block and filesystem interfaces mentioned previously and the hardware interface. </span><span class="koboSpan" id="kobo.306.2">There will be a </span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">block_device</span></strong><span class="koboSpan" id="kobo.308.1"> structure for representing the entire physical disk defined in </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">gendisk</span></strong><span class="koboSpan" id="kobo.310.1">. </span><span class="koboSpan" id="kobo.310.2">Similarly, there will be separate </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">block_device</span></strong><span class="koboSpan" id="kobo.312.1"> structures that describe individual partitions within </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">gendisk</span></strong><span class="koboSpan" id="kobo.314.1">. </span><span class="koboSpan" id="kobo.314.2">Note that </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">gendisk</span></strong><span class="koboSpan" id="kobo.316.1"> is allocated and controlled by the block device driver and registered with the kernel using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">register_blkdev</span></strong><span class="koboSpan" id="kobo.318.1"> function. </span><span class="koboSpan" id="kobo.318.2">Once registered, the block device driver can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">gendisk</span></strong><span class="koboSpan" id="kobo.320.1"> structure to perform I/O operations on </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">the device.</span></span></p>
<p><span class="koboSpan" id="kobo.322.1">Let’s look at some of the important fields of </span><span class="No-Break"><span class="koboSpan" id="kobo.323.1">this structure:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">major</span></strong><span class="koboSpan" id="kobo.325.1">: This field specifies the major number associated with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">gendisk</span></strong><span class="koboSpan" id="kobo.327.1"> structure. </span><span class="koboSpan" id="kobo.327.2">As discussed earlier, the major number is used by the kernel to identify the driver responsible for handling the </span><span class="No-Break"><span class="koboSpan" id="kobo.328.1">block device.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">first_minor</span></strong><span class="koboSpan" id="kobo.330.1">: This field refers to the smallest minor number that is allocated to a given block device. </span><span class="koboSpan" id="kobo.330.2">This can be thought of as an offset from which the minor numbers for the different partitions of the device </span><span class="No-Break"><span class="koboSpan" id="kobo.331.1">are allocated.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">minors</span></strong><span class="koboSpan" id="kobo.333.1">: This field specifies the total number of minor numbers associated with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">gendisk</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.335.1"> structure.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">fops</span></strong><span class="koboSpan" id="kobo.337.1">: This field points to a structure of file operations that are associated with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">gendisk</span></strong><span class="koboSpan" id="kobo.339.1"> structure. </span><span class="koboSpan" id="kobo.339.2">These file operations are used by the kernel to handle read, write, and other file operations on </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">the device.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">private_data</span></strong><span class="koboSpan" id="kobo.342.1">: This field is used by the driver to store any private data associated with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">gendisk</span></strong><span class="koboSpan" id="kobo.344.1"> structure, such as any </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">driver-specific information.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">queue</span></strong><span class="koboSpan" id="kobo.347.1">: This field points to the request </span><a id="_idIndexMarker159"/><span class="koboSpan" id="kobo.348.1">queue associated with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">gendisk</span></strong><span class="koboSpan" id="kobo.350.1"> structure. </span><span class="koboSpan" id="kobo.350.2">The request queue is responsible for managing the I/O requests that are issued to the device. </span><span class="koboSpan" id="kobo.350.3">This makes it a very important field as it enables the kernel to associate a specific I/O queue with each block device. </span><span class="koboSpan" id="kobo.350.4">By having separate I/O queues for each block device, the kernel can manage multiple block devices independently and handle their I/O operations more efficiently. </span><span class="koboSpan" id="kobo.350.5">This allows the kernel to optimize performance, apply appropriate scheduling policies, and prevent </span><span class="No-Break"><span class="koboSpan" id="kobo.351.1">I/O bottlenecks.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">disk_name</span></strong><span class="koboSpan" id="kobo.353.1">: This field is a string that specifies the name of the device. </span><span class="koboSpan" id="kobo.353.2">The name is used by the kernel</span><a id="_idIndexMarker160"/><span class="koboSpan" id="kobo.354.1"> to identify the device and is usually displayed in </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">system logs.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.356.1">Let us move on to the </span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">next structure.</span></span></p>
<h2 id="_idParaDest-80"><a id="_idTextAnchor084"/><span class="koboSpan" id="kobo.358.1">The buffer_head structure (representing blocks in memory)</span></h2>
<p><span class="koboSpan" id="kobo.359.1">One of the defining features of a block device</span><a id="_idIndexMarker161"/><span class="koboSpan" id="kobo.360.1"> is its extensive use of the page cache. </span><span class="koboSpan" id="kobo.360.2">The read and write operations on a block device are performed in the cache. </span><span class="koboSpan" id="kobo.360.3">When an application reads from a block for the first time, the block is fetched from the physical disk into memory. </span><span class="koboSpan" id="kobo.360.4">Similarly, when a program wants to write some data, the write operation is first performed in the cache. </span><span class="koboSpan" id="kobo.360.5">It is written to the physical disk at a </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">later stage.</span></span></p>
<p><span class="koboSpan" id="kobo.362.1">The block that’s read from the disk or to be written to the disk is stored in a buffer. </span><span class="koboSpan" id="kobo.362.2">This buffer is represented by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">buffer_head</span></strong><span class="koboSpan" id="kobo.364.1"> structure, which is defined in </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">include/linux/buffer_head.h</span></strong><span class="koboSpan" id="kobo.366.1"> in the kernel. </span><span class="koboSpan" id="kobo.366.2">We can say that this buffer is an in-memory representation of an </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">individual block:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.368.1">
struct buffer_head {
        unsigned long b_state;
        struct buffer_head *b_this_page;
        struct page *b_page;
        sector_t b_blocknr;
        size_t b_size;
[………...]</span></pre>
<p><span class="koboSpan" id="kobo.369.1">The fields in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">buffer_head</span></strong><span class="koboSpan" id="kobo.371.1"> structure contain the information required to uniquely identify a particular block in the block device. </span><span class="koboSpan" id="kobo.371.2">The fields in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">buffer_head</span></strong><span class="koboSpan" id="kobo.373.1"> structure are described </span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">as follows:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">b_data</span></strong><span class="koboSpan" id="kobo.376.1">: This field points to the start of the data buffer associated with </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">buffer_head</span></strong><span class="koboSpan" id="kobo.378.1">. </span><span class="koboSpan" id="kobo.378.2">The size of the buffer is determined by the block size of </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">the filesystem.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.380.1">b_size</span></strong><span class="koboSpan" id="kobo.381.1">: This field specifies the size of the buffer </span><span class="No-Break"><span class="koboSpan" id="kobo.382.1">in bytes.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">b_page</span></strong><span class="koboSpan" id="kobo.384.1">: This is a pointer to the page in memory where the block is stored. </span><span class="koboSpan" id="kobo.384.2">This field is typically used in conjunction with fields such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">b_data</span></strong><span class="koboSpan" id="kobo.386.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">b_size</span></strong><span class="koboSpan" id="kobo.388.1">, to manipulate the </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">buffer data.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">b_blocknr</span></strong><span class="koboSpan" id="kobo.391.1">: This field specifies the logical block number of the buffer in the filesystem. </span><span class="koboSpan" id="kobo.391.2">Each block in the filesystem is assigned a unique number called a logical block number. </span><span class="koboSpan" id="kobo.391.3">This number represents</span><a id="_idIndexMarker162"/><span class="koboSpan" id="kobo.392.1"> the order of the block in the filesystem, starting from 0 for the </span><span class="No-Break"><span class="koboSpan" id="kobo.393.1">first block.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">b_state</span></strong><span class="koboSpan" id="kobo.395.1">: This field is a bitfield that represents the state of the buffer. </span><span class="koboSpan" id="kobo.395.2">It can have several values. </span><span class="koboSpan" id="kobo.395.3">For instance, a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">BH_Uptodate</span></strong><span class="koboSpan" id="kobo.397.1"> indicates that the buffer contains up-to-date data, while a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">BH_Dirty</span></strong><span class="koboSpan" id="kobo.399.1"> indicates that the buffer contains dirty (modified) data and needs to be written </span><span class="No-Break"><span class="koboSpan" id="kobo.400.1">to disk.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">b_count</span></strong><span class="koboSpan" id="kobo.402.1">: This field keeps track of the number of users </span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">buffer_head</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.405.1">.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">b_page</span></strong><span class="koboSpan" id="kobo.407.1">: This field points to the page in the page cache that contains the data associated with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">buffer_head</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.409.1"> structure.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">b_assoc_map</span></strong><span class="koboSpan" id="kobo.411.1">: This field is used by some filesystems to track which blocks are currently associated </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">buffer_head</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.414.1">.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">b_private</span></strong><span class="koboSpan" id="kobo.416.1">: This field is a pointer</span><a id="_idIndexMarker163"/><span class="koboSpan" id="kobo.417.1"> to private data associated with </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">buffer_head</span></strong><span class="koboSpan" id="kobo.419.1">. </span><span class="koboSpan" id="kobo.419.2">This can be used by the filesystem to store information related to </span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">the buffer.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">b_bdev</span></strong><span class="koboSpan" id="kobo.422.1">: This field is a pointer to the block device that the buffer </span><span class="No-Break"><span class="koboSpan" id="kobo.423.1">belongs to.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.424.1">b_end_io</span></strong><span class="koboSpan" id="kobo.425.1">: This field is a function pointer that specifies the completion function for an I/O operation on a buffer, and is used to perform any necessary </span><span class="No-Break"><span class="koboSpan" id="kobo.426.1">cleanup operations.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.427.1">By default, as the filesystem’s block size is equal to the page size, a single page in memory can hold a single block. </span><span class="koboSpan" id="kobo.427.2">If the block size is less than the page size, the page can hold more than </span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">one block.</span></span></p>
<p><span class="koboSpan" id="kobo.429.1">The buffer head maintains a mapping between a page in memory and its corresponding on-disk version. </span><span class="koboSpan" id="kobo.429.2">Although it still holds important information, it was an even more integral component of the kernel before version 2.6. </span><span class="koboSpan" id="kobo.429.3">Back then, in addition to maintaining page-to-disk block mapping, it also served as a container for all I/O operations in the block layer. </span><span class="koboSpan" id="kobo.429.4">The use of buffer heads as an I/O container resulted in a significant amount of memory usage. </span><span class="koboSpan" id="kobo.429.5">When dealing with a large block of I/O requests, the kernel had to break it into smaller</span><a id="_idIndexMarker164"/><span class="koboSpan" id="kobo.430.1"> requests, each of which, in turn, had a </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">buffer_head</span></strong><span class="koboSpan" id="kobo.432.1"> structure associated </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">with them.</span></span></p>
<h2 id="_idParaDest-81"><a id="_idTextAnchor085"/><span class="koboSpan" id="kobo.434.1">The bio structure (representing active block I/Os)</span></h2>
<p><span class="koboSpan" id="kobo.435.1">Due to the limitations in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">buffer_head</span></strong><span class="koboSpan" id="kobo.437.1"> structure, the bio structure</span><a id="_idIndexMarker165"/><span class="koboSpan" id="kobo.438.1"> was created to represent an ongoing block I/O operation. </span><span class="koboSpan" id="kobo.438.2">The bio structure has been the fundamental unit of an I/O in the block layer since kernel 2.5. </span><span class="koboSpan" id="kobo.438.3">When an application issues an I/O request, the underlying filesystem translates it into one or more bio structures, which are sent down to the block layer. </span><span class="koboSpan" id="kobo.438.4">The block layer then uses these bio structures to issue I/O requests to the underlying block device. </span><span class="koboSpan" id="kobo.438.5">The bio structure is defined </span><span class="No-Break"><span class="koboSpan" id="kobo.439.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">include/linux/blk_types.h</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.441.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.442.1">
struct bio {
        struct bio              *bi_next;
        struct block_device     *bi_bdev;
        unsigned int            bi_opf;
……
        unsigned short          bi_max_vecs;
        atomic_t                __bi_cnt;
        struct bio_vec          *bi_io_vec;
[……….]</span></pre>
<p><span class="koboSpan" id="kobo.443.1">Some particularly interesting fields are </span><span class="No-Break"><span class="koboSpan" id="kobo.444.1">as follows:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">bi_next</span></strong><span class="koboSpan" id="kobo.446.1">: This is a pointer to the next </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">bio</span></strong><span class="koboSpan" id="kobo.448.1"> structure in a list and is used to link multiple </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">bio</span></strong><span class="koboSpan" id="kobo.450.1"> structures that represent a single I/O operation. </span><span class="koboSpan" id="kobo.450.2">This is important to understand because a single I/O operation may need to be split into multiple </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">bio</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.452.1"> structures.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">bi_vcnt</span></strong><span class="koboSpan" id="kobo.454.1">: This field specifies the number of </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">bio_vec</span></strong><span class="koboSpan" id="kobo.456.1"> structures that are being used to describe the I/O operation. </span><span class="koboSpan" id="kobo.456.2">Each </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">bio_vec</span></strong><span class="koboSpan" id="kobo.458.1"> structure in the vector describes a contiguous block of memory that is transferred between the block device and the user </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">space program.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">bi_io_vec</span></strong><span class="koboSpan" id="kobo.461.1">: This is a pointer to an array of </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">bio_vec</span></strong><span class="koboSpan" id="kobo.463.1"> structures that describes the location and length of the data buffers associated with the I/O operation. </span><span class="koboSpan" id="kobo.463.2">This lays the ground for performing </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">scatter-gather</span></strong><span class="koboSpan" id="kobo.465.1"> I/O – that is, the data can be spread across multiple non-contiguous </span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">memory locations.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">bi_vcnt</span></strong><span class="koboSpan" id="kobo.468.1">: This field specifies the number of data buffers associated with the I/O operation. </span><span class="koboSpan" id="kobo.468.2">Each data buffer is represented by a </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">bio_vec</span></strong><span class="koboSpan" id="kobo.470.1"> structure, which contains a pointer to the memory buffer and the length of </span><span class="No-Break"><span class="koboSpan" id="kobo.471.1">the buffer.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">bi_end_io</span></strong><span class="koboSpan" id="kobo.473.1">: This is a pointer to a function that is called when the I/O operation completes. </span><span class="koboSpan" id="kobo.473.2">This function is responsible for cleaning up any resources associated with the I/O operation and waking up any processes that are waiting for the operation </span><span class="No-Break"><span class="koboSpan" id="kobo.474.1">to complete.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">bi_private</span></strong><span class="koboSpan" id="kobo.476.1">: This is a pointer to any private</span><a id="_idIndexMarker166"/><span class="koboSpan" id="kobo.477.1"> data associated with the </span><span class="No-Break"><span class="koboSpan" id="kobo.478.1">I/O operation.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">bi_opf</span></strong><span class="koboSpan" id="kobo.480.1">: This is a bit mask that specifies any additional options or flags associated with the I/O operation. </span><span class="koboSpan" id="kobo.480.2">This can include options such as </span><em class="italic"><span class="koboSpan" id="kobo.481.1">force synchronous I/O</span></em><span class="koboSpan" id="kobo.482.1"> or </span><em class="italic"><span class="koboSpan" id="kobo.483.1">disable </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.484.1">write caching</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.486.1">When an I/O request is initiated by a user-space application, the bio structure keeps track of all the active I/O transactions at the block layer. </span><span class="koboSpan" id="kobo.486.2">Once the bio structure has been constructed, it is handed over to the block I/O layer through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">submit_bio</span></strong><span class="koboSpan" id="kobo.488.1"> function. </span><span class="koboSpan" id="kobo.488.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">submit_bio()</span></strong><span class="koboSpan" id="kobo.490.1"> function is used to submit I/O requests to block devices. </span><span class="koboSpan" id="kobo.490.2">Once the I/O has been submitted to the block device, it is added to a request queue. </span><span class="koboSpan" id="kobo.490.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">submit_bio()</span></strong><span class="koboSpan" id="kobo.492.1"> function will not wait for the I/O to </span><span class="No-Break"><span class="koboSpan" id="kobo.493.1">be completed.</span></span></p>
<p><span class="koboSpan" id="kobo.494.1">It can be said that the bio structure</span><a id="_idIndexMarker167"/><span class="koboSpan" id="kobo.495.1"> acts as a bridge between the filesystem and the block device layer, enabling the filesystem to perform I/O operations on the </span><span class="No-Break"><span class="koboSpan" id="kobo.496.1">block device.</span></span></p>
<h2 id="_idParaDest-82"><a id="_idTextAnchor086"/><span class="koboSpan" id="kobo.497.1">The bio_vec structure (representing vector I/O)</span></h2>
<p><span class="koboSpan" id="kobo.498.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">bio_vec</span></strong><span class="koboSpan" id="kobo.500.1"> structure defines vector</span><a id="_idIndexMarker168"/><span class="koboSpan" id="kobo.501.1"> or scatter-gather I/O operations in the </span><span class="No-Break"><span class="koboSpan" id="kobo.502.1">block layer.</span></span></p>
<p><span class="koboSpan" id="kobo.503.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">bio_vec</span></strong><span class="koboSpan" id="kobo.505.1"> structure is defined </span><span class="No-Break"><span class="koboSpan" id="kobo.506.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">include/linux/bvec.h</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.508.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.509.1">
struct bio_vec {
        struct page     *bv_page;
        unsigned int    bv_len;
        unsigned int    bv_offset;
};</span></pre>
<p><span class="koboSpan" id="kobo.510.1">The fields are described </span><span class="No-Break"><span class="koboSpan" id="kobo.511.1">as follows:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">bv_page</span></strong><span class="koboSpan" id="kobo.513.1">: This field holds a reference to the page structure (struct page) that contains the data to be transferred. </span><span class="koboSpan" id="kobo.513.2">As we explained in </span><a href="B19430_02.xhtml#_idTextAnchor028"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.514.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.515.1">, a page is a fixed-size block </span><span class="No-Break"><span class="koboSpan" id="kobo.516.1">of memory.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">bv_offset</span></strong><span class="koboSpan" id="kobo.518.1">: This field holds the offset within the page where the data to be </span><span class="No-Break"><span class="koboSpan" id="kobo.519.1">transferred starts.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">bv_len</span></strong><span class="koboSpan" id="kobo.521.1">: This field holds the length of the data to </span><span class="No-Break"><span class="koboSpan" id="kobo.522.1">be transferred.</span></span></li>
</ul>
<p><strong class="bold"><span class="koboSpan" id="kobo.523.1">Scatter-gather I/O</span></strong><span class="koboSpan" id="kobo.524.1"> involves transferring data between a device and the memory. </span><span class="koboSpan" id="kobo.524.2">Usually, data is read from or written to a single contiguous memory buffer. </span><span class="koboSpan" id="kobo.524.3">With scatter-gather I/O, the data is divided into smaller segments and spread across multiple non-contiguous memory buffers, known as </span><strong class="bold"><span class="koboSpan" id="kobo.525.1">scatter lists</span></strong><span class="koboSpan" id="kobo.526.1">, for input operations. </span><span class="koboSpan" id="kobo.526.2">For output operations, the data is then gathered</span><a id="_idIndexMarker169"/><span class="koboSpan" id="kobo.527.1"> from these multiple non-contiguous memory buffers. </span><span class="koboSpan" id="kobo.527.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.528.1">bio_vec</span></strong><span class="koboSpan" id="kobo.529.1"> structure is used to represent a scatter-gather I/O operation. </span><span class="koboSpan" id="kobo.529.2">The block layer may construct a single bio with multiple </span><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">bio_vec</span></strong><span class="koboSpan" id="kobo.531.1"> structures, each representing a different physical page</span><a id="_idIndexMarker170"/><span class="koboSpan" id="kobo.532.1"> in memory and a different offset within </span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">that page.</span></span></p>
<h2 id="_idParaDest-83"><a id="_idTextAnchor087"/><span class="koboSpan" id="kobo.534.1">Requests and request queues (representing pending I/O requests)</span></h2>
<p><span class="koboSpan" id="kobo.535.1">When an I/O request is submitted</span><a id="_idIndexMarker171"/><span class="koboSpan" id="kobo.536.1"> to the block layer, the block</span><a id="_idIndexMarker172"/><span class="koboSpan" id="kobo.537.1"> layer creates a </span><strong class="source-inline"><span class="koboSpan" id="kobo.538.1">request</span></strong><span class="koboSpan" id="kobo.539.1"> structure to represent </span><span class="No-Break"><span class="koboSpan" id="kobo.540.1">the request.</span></span></p>
<p><span class="koboSpan" id="kobo.541.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.542.1">request</span></strong><span class="koboSpan" id="kobo.543.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.544.1">request_queue</span></strong><span class="koboSpan" id="kobo.545.1"> structures are defined in </span><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">include/linux/blk-mq.h</span></strong><span class="koboSpan" id="kobo.547.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">include/linux/blkdev.h</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.549.1">, respectively:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.550.1">
struct request {
        struct request_queue *q;
        struct blk_mq_ctx *mq_ctx;
        struct blk_mq_hw_ctx *mq_hctx;
[……..]</span></pre>
<p><span class="koboSpan" id="kobo.551.1">Some of the major fields are </span><span class="No-Break"><span class="koboSpan" id="kobo.552.1">explained here:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.553.1">struct request_queue *q</span></strong><span class="koboSpan" id="kobo.554.1">: Each I/O request is added to the request queue of a block device. </span><span class="koboSpan" id="kobo.554.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.555.1">q</span></strong><span class="koboSpan" id="kobo.556.1"> field here points to this </span><span class="No-Break"><span class="koboSpan" id="kobo.557.1">request queue.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.558.1">struct blk_mq_ctx *mq_ctx</span></strong><span class="koboSpan" id="kobo.559.1">: The </span><strong class="source-inline"><span class="koboSpan" id="kobo.560.1">blk_mq_ctx *mq_ctx</span></strong><span class="koboSpan" id="kobo.561.1"> field points to the software staging queues; this structure is allocated on a per-CPU core basis. </span><span class="koboSpan" id="kobo.561.2">Each CPU has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.562.1">blk_mq_ctx</span></strong><span class="koboSpan" id="kobo.563.1">, which is used to track the state of requests that are processed on </span><span class="No-Break"><span class="koboSpan" id="kobo.564.1">that CPU.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">struct blk_mq_hw_ctx *mq_hctx</span></strong><span class="koboSpan" id="kobo.566.1">: This field represents the hardware context with which a request queue is associated. </span><span class="koboSpan" id="kobo.566.2">This is used to keep track of which hardware queue the request </span><span class="No-Break"><span class="koboSpan" id="kobo.567.1">belongs to.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">struct list_head queuelist</span></strong><span class="koboSpan" id="kobo.569.1">: This is a linked list of requests that are waiting to be processed. </span><span class="koboSpan" id="kobo.569.2">When a request is submitted to the block layer, it is added to </span><span class="No-Break"><span class="koboSpan" id="kobo.570.1">this list.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">struct request *rq_next</span></strong><span class="koboSpan" id="kobo.572.1">: This is a pointer to the next request in the queue. </span><span class="koboSpan" id="kobo.572.2">It is used to link requests within the </span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">request queue.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.574.1">sector_t sector</span></strong><span class="koboSpan" id="kobo.575.1">: This field specifies the starting sector number of the </span><span class="No-Break"><span class="koboSpan" id="kobo.576.1">I/O operation.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.577.1">struct bio *bio</span></strong><span class="koboSpan" id="kobo.578.1">: This field points to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.579.1">bio</span></strong><span class="koboSpan" id="kobo.580.1"> structure that contains information about the I/O operation, such as its type (read </span><span class="No-Break"><span class="koboSpan" id="kobo.581.1">or write).</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.582.1">struct bio *biotail</span></strong><span class="koboSpan" id="kobo.583.1">: This field points to the last </span><strong class="source-inline"><span class="koboSpan" id="kobo.584.1">bio</span></strong><span class="koboSpan" id="kobo.585.1"> structure in the queue. </span><span class="koboSpan" id="kobo.585.2">When a new bio is added to the queue, it is linked to the end of the list pointed to </span><span class="No-Break"><span class="koboSpan" id="kobo.586.1">by </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.587.1">biotail</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.588.1">.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.589.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.590.1">request_queue</span></strong><span class="koboSpan" id="kobo.591.1"> structure represents</span><a id="_idIndexMarker173"/><span class="koboSpan" id="kobo.592.1"> the request queue associated</span><a id="_idIndexMarker174"/><span class="koboSpan" id="kobo.593.1"> with a block device. </span><span class="koboSpan" id="kobo.593.2">The request queue is responsible for managing all I/O requests that are issued to the </span><span class="No-Break"><span class="koboSpan" id="kobo.594.1">block device:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.595.1">
struct request_queue {
        struct request          *last_merge;
        struct elevator_queue   *elevator;
        struct percpu_ref       q_usage_counter;
[………..]</span></pre>
<p><span class="koboSpan" id="kobo.596.1">Let’s look at some of the </span><span class="No-Break"><span class="koboSpan" id="kobo.597.1">important fields:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.598.1">struct request *last_merge</span></strong><span class="koboSpan" id="kobo.599.1">: This field is used by the I/O scheduler to track the last request that was merged with </span><span class="No-Break"><span class="koboSpan" id="kobo.600.1">another request.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">struct elevator_queue *elevator</span></strong><span class="koboSpan" id="kobo.602.1">: This field points to the I/O scheduler for the request queue. </span><span class="koboSpan" id="kobo.602.2">The I/O scheduler determines the order in which requests </span><span class="No-Break"><span class="koboSpan" id="kobo.603.1">are serviced.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.604.1">struct percpu_ref q_usage_counter</span></strong><span class="koboSpan" id="kobo.605.1">: This field represents the usage counter for the request queue. </span><span class="koboSpan" id="kobo.605.2">The kernel uses a per-CPU counter to track the reference count of a resource on a </span><span class="No-Break"><span class="koboSpan" id="kobo.606.1">per-CPU basis.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.607.1">struct rq_qos *rq_qos</span></strong><span class="koboSpan" id="kobo.608.1">: This field points to a request queue of quality-of-service agreements that the request queue provides to the block device. </span><span class="koboSpan" id="kobo.608.2">These are used to prioritize I/O requests based on different criteria, such as the priority of </span><span class="No-Break"><span class="koboSpan" id="kobo.609.1">the request.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.610.1">const struct blk_mq_ops *mq_ops</span></strong><span class="koboSpan" id="kobo.611.1">: This structure contains function pointers that define the behavior of the request queue for multi-queue </span><span class="No-Break"><span class="koboSpan" id="kobo.612.1">I/O schedulers.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.613.1">struct gendisk *disk</span></strong><span class="koboSpan" id="kobo.614.1">: This field points to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">gendisk</span></strong><span class="koboSpan" id="kobo.616.1"> structure associated with</span><a id="_idIndexMarker175"/><span class="koboSpan" id="kobo.617.1"> the request queue. </span><strong class="source-inline"><span class="koboSpan" id="kobo.618.1">gendisk</span></strong><span class="koboSpan" id="kobo.619.1"> represents</span><a id="_idIndexMarker176"/><span class="koboSpan" id="kobo.620.1"> a generic </span><span class="No-Break"><span class="koboSpan" id="kobo.621.1">disk device.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.622.1">Phew! </span><span class="koboSpan" id="kobo.622.2">There are too many of them. </span><span class="koboSpan" id="kobo.622.3">Let’s summarize the role of each structure and see how they all </span><span class="No-Break"><span class="koboSpan" id="kobo.623.1">work together.</span></span></p>
<h1 id="_idParaDest-84"><a id="_idTextAnchor088"/><span class="koboSpan" id="kobo.624.1">The journey of an I/O request in the block layer</span></h1>
<p><span class="koboSpan" id="kobo.625.1">The following table provides</span><a id="_idIndexMarker177"/><span class="koboSpan" id="kobo.626.1"> a concise overview</span><a id="_idIndexMarker178"/><span class="koboSpan" id="kobo.627.1"> of the structures that were covered in the </span><span class="No-Break"><span class="koboSpan" id="kobo.628.1">previous section:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-4">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.629.1">Structure</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.630.1">Representation of</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.631.1">Description</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.632.1">gendisk</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.633.1">Physical disk</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.634.1">This is used to represent the physical device as a whole and contains information such as the disk’s capacity </span><span class="No-Break"><span class="koboSpan" id="kobo.635.1">and geometry</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.636.1">block_device</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.637.1">Block device</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.638.1">This represents a specific instance of a device and contains information such as the major and minor numbers, partitions, and the queue to handle </span><span class="No-Break"><span class="koboSpan" id="kobo.639.1">I/O requests</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.640.1">buffer_head</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.641.1">Block of data </span><span class="No-Break"><span class="koboSpan" id="kobo.642.1">in memory</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.643.1">This is used to track the data that is read from or written to a block device </span><span class="No-Break"><span class="koboSpan" id="kobo.644.1">in memory</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.645.1">request</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.646.1">I/O request</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.647.1">This includes information such as the type of I/O operation and the starting </span><span class="No-Break"><span class="koboSpan" id="kobo.648.1">block number</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.649.1">request_queue</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.650.1">Queue of </span><span class="No-Break"><span class="koboSpan" id="kobo.651.1">I/O requests</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.652.1">This contains information about the current state of the queue, such as the number of requests waiting to </span><span class="No-Break"><span class="koboSpan" id="kobo.653.1">be processed</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.654.1">bio</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.655.1">Block I/O</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.656.1">This is a higher-level I/O request and can include multiple </span><span class="No-Break"><span class="koboSpan" id="kobo.657.1">request structures</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.658.1">bio_vec</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.659.1">Scatter-gather list of </span><span class="No-Break"><span class="koboSpan" id="kobo.660.1">memory buffers</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.661.1">This is used as a part of the bio structure and describes an individual </span><span class="No-Break"><span class="koboSpan" id="kobo.662.1">data buffer</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.663.1">Table 4.1 – Summary of major block layer structures</span></p>
<p><span class="koboSpan" id="kobo.664.1">Let’s take a look at the relationship between these structures when a process issues an </span><span class="No-Break"><span class="koboSpan" id="kobo.665.1">I/O request:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.666.1">When an application writes data</span><a id="_idIndexMarker179"/><span class="koboSpan" id="kobo.667.1"> in a buffer in its address space, the block layer </span><a id="_idIndexMarker180"/><span class="koboSpan" id="kobo.668.1">creates a </span><strong class="source-inline"><span class="koboSpan" id="kobo.669.1">buffer_head</span></strong><span class="koboSpan" id="kobo.670.1"> structure to represent </span><span class="No-Break"><span class="koboSpan" id="kobo.671.1">this data.</span></span></li>
<li><span class="koboSpan" id="kobo.672.1">The block layer constructs a </span><strong class="source-inline"><span class="koboSpan" id="kobo.673.1">bio</span></strong><span class="koboSpan" id="kobo.674.1"> structure to represent the block I/O request and maps the </span><strong class="source-inline"><span class="koboSpan" id="kobo.675.1">buffer_head</span></strong><span class="koboSpan" id="kobo.676.1"> structure to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.677.1">bio_vec</span></strong><span class="koboSpan" id="kobo.678.1"> structure. </span><span class="koboSpan" id="kobo.678.2">For each </span><strong class="source-inline"><span class="koboSpan" id="kobo.679.1">bio</span></strong><span class="koboSpan" id="kobo.680.1">, the block layer creates one or more </span><strong class="source-inline"><span class="koboSpan" id="kobo.681.1">bio_vec</span></strong><span class="koboSpan" id="kobo.682.1"> structures to represent the data being read from or </span><span class="No-Break"><span class="koboSpan" id="kobo.683.1">written to.</span></span></li>
<li><span class="koboSpan" id="kobo.684.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.685.1">bio</span></strong><span class="koboSpan" id="kobo.686.1"> structure is then added to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">request_queue</span></strong><span class="koboSpan" id="kobo.688.1"> structure for the intended block device through the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.689.1">request</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.690.1"> structure.</span></span></li>
<li><span class="koboSpan" id="kobo.691.1">The device driver for that device, which is registered through </span><strong class="source-inline"><span class="koboSpan" id="kobo.692.1">register_blkdev</span></strong><span class="koboSpan" id="kobo.693.1">, dequeues the </span><strong class="source-inline"><span class="koboSpan" id="kobo.694.1">bio</span></strong><span class="koboSpan" id="kobo.695.1"> structure and schedules it </span><span class="No-Break"><span class="koboSpan" id="kobo.696.1">for processing.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.697.1">bio</span></strong><span class="koboSpan" id="kobo.698.1"> is then split into one or more </span><strong class="source-inline"><span class="koboSpan" id="kobo.699.1">request</span></strong><span class="koboSpan" id="kobo.700.1"> structures based on the block size of </span><span class="No-Break"><span class="koboSpan" id="kobo.701.1">the device.</span></span></li>
<li><span class="koboSpan" id="kobo.702.1">Each </span><strong class="source-inline"><span class="koboSpan" id="kobo.703.1">request</span></strong><span class="koboSpan" id="kobo.704.1"> object is then added to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.705.1">request_queue</span></strong><span class="koboSpan" id="kobo.706.1"> structure of the corresponding device driver </span><span class="No-Break"><span class="koboSpan" id="kobo.707.1">for processing.</span></span></li>
<li><span class="koboSpan" id="kobo.708.1">After processing the request, the device driver writes the data to the </span><span class="No-Break"><span class="koboSpan" id="kobo.709.1">physical storage.</span></span></li>
<li><span class="koboSpan" id="kobo.710.1">Once the I/O request has been completed, the device driver notifies the </span><span class="No-Break"><span class="koboSpan" id="kobo.711.1">block layer.</span></span></li>
<li><span class="koboSpan" id="kobo.712.1">The block layer then updates the buffer cache and the associated data structures. </span><span class="koboSpan" id="kobo.712.2">It marks the request structure as completed and notifies any waiting processes that the I/O operation has </span><span class="No-Break"><span class="koboSpan" id="kobo.713.1">been completed.</span></span></li>
<li><span class="koboSpan" id="kobo.714.1">The corresponding </span><strong class="source-inline"><span class="koboSpan" id="kobo.715.1">buffer_head</span></strong><span class="koboSpan" id="kobo.716.1"> structures are updated to reflect the current state of the data on the </span><span class="No-Break"><span class="koboSpan" id="kobo.717.1">block device.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.718.1">The block layer, with its intricate design, makes use of some complex structures to work with block devices. </span><span class="koboSpan" id="kobo.718.2">We covered some major structures to help you understand how things work under the hood. </span><span class="koboSpan" id="kobo.718.3">Each structure defines a ton of fields in its definition; we’ve tried to highlight some to get a gist </span><span class="No-Break"><span class="koboSpan" id="kobo.719.1">of things.</span></span></p>
<p><span class="koboSpan" id="kobo.720.1">It's important to note that the request</span><a id="_idIndexMarker181"/><span class="koboSpan" id="kobo.721.1"> queues in older kernels were single-threaded</span><a id="_idIndexMarker182"/><span class="koboSpan" id="kobo.722.1"> and were not able to exploit the capabilities of modern hardware. </span><span class="koboSpan" id="kobo.722.2">The Linux kernel added multi-queue support in version </span><strong class="source-inline"><span class="koboSpan" id="kobo.723.1">3.13</span></strong><span class="koboSpan" id="kobo.724.1">. </span><span class="koboSpan" id="kobo.724.2">The framework for implementing multi-queue support is known as </span><strong class="source-inline"><span class="koboSpan" id="kobo.725.1">blk-mq</span></strong><span class="koboSpan" id="kobo.726.1">. </span><span class="koboSpan" id="kobo.726.2">We’re going to cover the multi-queue framework in the </span><span class="No-Break"><span class="koboSpan" id="kobo.727.1">next chapter.</span></span></p>
<h1 id="_idParaDest-85"><a id="_idTextAnchor089"/><span class="koboSpan" id="kobo.728.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.729.1">The first part of this book, which included </span><em class="italic"><span class="koboSpan" id="kobo.730.1">Chapters 1</span></em><span class="koboSpan" id="kobo.731.1">, </span><em class="italic"><span class="koboSpan" id="kobo.732.1">2</span></em><span class="koboSpan" id="kobo.733.1">, and </span><em class="italic"><span class="koboSpan" id="kobo.734.1">3</span></em><span class="koboSpan" id="kobo.735.1">, dealt with VFS and filesystems. </span><span class="koboSpan" id="kobo.735.2">The second part of this book, which constitutes </span><em class="italic"><span class="koboSpan" id="kobo.736.1">Chapters 4</span></em><span class="koboSpan" id="kobo.737.1">, </span><em class="italic"><span class="koboSpan" id="kobo.738.1">5</span></em><span class="koboSpan" id="kobo.739.1">, and </span><em class="italic"><span class="koboSpan" id="kobo.740.1">6</span></em><span class="koboSpan" id="kobo.741.1">, is all about the block layer. </span><span class="koboSpan" id="kobo.741.2">This chapter introduced the role of the block layer in the Linux kernel. </span><span class="koboSpan" id="kobo.741.3">The </span><strong class="bold"><span class="koboSpan" id="kobo.742.1">block layer</span></strong><span class="koboSpan" id="kobo.743.1"> is the kernel subsystem and is in charge of managing I/O operations performed on </span><strong class="bold"><span class="koboSpan" id="kobo.744.1">block</span></strong><span class="koboSpan" id="kobo.745.1"> devices. </span><span class="koboSpan" id="kobo.745.2">The kernel’s block device interface is central to managing persistent storage on Linux. </span><span class="koboSpan" id="kobo.745.3">The user-space applications can access the block devices through block special devices in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.746.1">/dev</span></strong><span class="koboSpan" id="kobo.747.1"> directory. </span><span class="koboSpan" id="kobo.747.2">Working with block devices is far more complicated than working with character devices, which can only work sequentially. </span><span class="koboSpan" id="kobo.747.3">Character devices have a single current position. </span><span class="koboSpan" id="kobo.747.4">Managing block devices is a far more complex task for the kernel as block devices must be able to move to any position to provide random access to data. </span><span class="koboSpan" id="kobo.747.5">Because of this, performance is a major concern when working with block devices. </span><span class="koboSpan" id="kobo.747.6">The Linux kernel provides a complex ecosystem of structures in the block layer for working with </span><span class="No-Break"><span class="koboSpan" id="kobo.748.1">block devices.</span></span></p>
<p><span class="koboSpan" id="kobo.749.1">In the next chapter, we will build on our understanding and see how an I/O request is served in the block layer. </span><span class="koboSpan" id="kobo.749.2">We’ll also cover the device mapper and multi-queue frameworks in </span><span class="No-Break"><span class="koboSpan" id="kobo.750.1">the kernel.</span></span></p>
</div>
</body></html>