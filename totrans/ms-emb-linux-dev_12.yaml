- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a Storage Strategy
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The mass storage options for embedded devices have a great impact on the rest
    of the system in terms of the robustness, speed, and methods used for in-field
    updates. Most devices employ flash memory in some form or another. Flash memory
    has become much less expensive over the past few years as storage capacities have
    increased from tens of megabytes to tens of gigabytes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will begin with a detailed look at the technology behind
    flash memory as well as how different memory organization strategies affect the
    low-level driver software that has to manage it, including the Linux **memory
    technology device** (**MTD**) layer.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: For each flash technology, there are different choices when it comes to the
    filesystem. I will describe those most commonly found on embedded devices and
    complete the survey by providing a summary of choices for each type of flash memory.
    Finally, we will consider some techniques that make the best use of flash memory
    and draw everything together into a coherent storage strategy.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Storage options
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing flash memory from the bootloader
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing flash memory from Linux
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filesystems for flash memory
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filesystems for NOR and NAND flash memory
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filesystems for managed flash
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read-only compressed filesystems
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Temporary filesystems
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making the root filesystem read-only
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filesystem choices
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow along with the examples, make sure you have the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: A Linux-based host system with `e2fsprogs`, `genext2fs`, `mtd-utils`, `squashfs-tools`,
    and `util-linux` or their equivalents installed
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A microSD card reader and card
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: balenaEtcher for Linux
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The U-Boot source tree from [*Chapter 3*](Chapter_03.xhtml#_idTextAnchor061)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Linux kernel source tree from [*Chapter 4*](Chapter_04.xhtml#_idTextAnchor096)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A USB to TTL serial cable with 3.3V logic-level pins
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A BeaglePlay
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 5V USB-C power supply capable of delivering 3A
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should have already downloaded and built U-Boot for the BeaglePlay back
    in [*Chapter 3*](Chapter_03.xhtml#_idTextAnchor061). You should have obtained
    the Linux kernel source tree from [*Chapter 4*](Chapter_04.xhtml#_idTextAnchor096).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'Ubuntu provides packages for most of the tools needed to create and format
    various filesystems. To install the tools on an Ubuntu 24.04 LTS system, use the
    following command:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `mtd-utils` package includes `mtdinfo`, `mkfs.jffs2`, `sumtool`, `nandwrite`,
    and the UBI command-line tools.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Storage options
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Embedded devices need storage that takes little power and is physically compact,
    robust, and reliable over a lifetime of perhaps tens of years. In almost all cases,
    this means solid-state storage. Solid-state storage was introduced many years
    ago with **read-only memory** (**ROM**), but for the past 20 years, it has been
    flash memory of some kind. There have been several generations of flash memory
    in that time, progressing from NOR to NAND to managed flash such as eMMC.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: NOR flash is expensive but reliable and can be mapped into the CPU address space,
    allowing you to execute code directly from flash. NOR flash chips are low capacity,
    ranging from a few megabytes to a gigabyte or so.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: NOR 闪存价格昂贵，但可靠，可以映射到 CPU 地址空间，从而允许你直接从闪存中执行代码。NOR 闪存芯片的容量较小，通常从几兆字节到大约一吉字节。
- en: NAND flash memory is much cheaper than NOR and is available in higher capacities
    from tens of megabytes to tens of gigabytes. However, it needs a lot of hardware
    and software support to turn it into a useful storage medium.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: NAND 闪存比 NOR 闪存便宜得多，并且具有从数十兆字节到数十吉字节不等的更高容量。然而，它需要大量的硬件和软件支持才能将其转化为有用的存储介质。
- en: Managed flash memory consists of one or more NAND flash chips packaged with
    a controller that handles the complexities of flash memory and presents a hardware
    interface similar to that of a hard disk. The attraction is that it removes complexity
    from the driver software and insulates the system designer from the frequent changes
    in flash technology.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 管理型闪存由一个或多个 NAND 闪存芯片组成，配备了一个控制器，该控制器处理闪存的复杂性，并提供类似硬盘的硬件接口。其吸引力在于，它将复杂性从驱动程序软件中移除，并使系统设计师免于应对闪存技术的频繁变化。
- en: SD cards, eMMC chips, and USB flash drives fit into this category. Almost all
    the current generations of smartphones and tablets have eMMC storage and this
    trend is likely to progress with other categories of embedded devices.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: SD 卡、eMMC 芯片和 USB 闪存驱动器都属于这一类别。几乎所有当前一代的智能手机和平板电脑都配备了 eMMC 存储，这一趋势可能会扩展到其他类型的嵌入式设备。
- en: Hard drives are seldom found in embedded systems. One exception is digital video
    recording in set-top boxes and smart TVs where a large amount of storage is needed
    with fast write times.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式系统中很少使用硬盘驱动器。一个例外是机顶盒和智能电视中的数字视频录制，它们需要大量存储并具有快速写入时间。
- en: 'In all cases, robustness is of prime importance: you want the device to boot
    and reach a functional state despite power failures and unexpected resets. You
    should choose filesystems that behave well under such circumstances. Your choice
    of storage device technology limits your choice of filesystems.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有情况下，可靠性至关重要：你希望设备能够在电力故障和意外重启的情况下启动并进入功能状态。你应该选择在此类情况下表现良好的文件系统。你的存储设备技术选择将限制你对文件系统的选择。
- en: In this section, we will learn the difference between NOR and NAND flash and
    consider our options when choosing a managed flash technology.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将学习 NOR 闪存和 NAND 闪存之间的差异，并在选择管理型闪存技术时考虑我们的选择。
- en: NOR flash
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NOR 闪存
- en: The memory cells in NOR flash chips are arranged into erase blocks of, for example,
    128 KB. Erasing a block sets all the bits to 1\. It can be programmed one word
    at a time (8, 16, or 32 bits depending on the data bus width). Each erase cycle
    damages the memory cells slightly and after a number of cycles, the erase block
    becomes unreliable and cannot be used anymore. The maximum number of erase cycles
    should be given in the data sheet for the chip but is usually in the range of
    1 K to 1 M.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: NOR 闪存芯片中的存储单元被排列成擦除块，例如 128 KB。擦除一个块会将所有位设置为 1。它可以一次编程一个字（根据数据总线宽度，8、16 或 32
    位）。每个擦除周期都会轻微损坏存储单元，经过一定次数的周期后，擦除块将变得不可靠，无法再使用。芯片的数据表中应提供最大擦除周期数，但通常在 1 K 到 1
    M 之间。
- en: The data can be read word by word. The chip is usually mapped into the CPU address
    space, meaning that you can execute code directly from NOR flash. This makes it
    a convenient place to put the bootloader code as it needs no initialization beyond
    hardwiring the address mapping. SoCs that support NOR flash in this way have configurations
    that provide a default memory mapping so that it encompasses the reset vector
    of the CPU.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 数据可以逐字读取。芯片通常被映射到 CPU 地址空间，这意味着你可以直接从 NOR 闪存中执行代码。这使得它成为放置引导加载程序代码的一个方便位置，因为它只需要硬接地址映射，不需要额外的初始化。因此，支持这种
    NOR 闪存的 SoC 通常会提供默认的内存映射，使其涵盖 CPU 的重置向量。
- en: The kernel, and even the root filesystem, can also be located in flash memory,
    avoiding the need for copying them into RAM and thus creating devices with small
    memory footprints. This technique is known as **Execute-in-Place** or **XIP**.
    It is very specialized, and I will not examine it further here. I have included
    some references at the end of this chapter in the *Further study* section.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 内核，甚至根文件系统，也可以位于闪存中，这样就避免了将它们复制到 RAM 中，从而创建了具有小内存占用的设备。这种技术被称为**就地执行**或**XIP**。它非常专业，我在这里不会进一步讨论。章节末尾的*进一步学习*部分包含了一些参考资料。
- en: There is a standard register-level interface for NOR flash chips called the
    **Common Flash Interface** or **CFI**, which all modern chips support. The CFI
    is described in standard JESD68, which you can get from [https://www.jedec.org/](https://www.jedec.org/).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned what NOR flash is, let’s look at NAND flash.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: NAND flash
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: NAND flash is much cheaper than NOR flash and has a higher capacity. First-generation
    NAND chips stored one bit per memory cell in what is now known as a **single-level
    cell** (**SLC**) organization. Later generations moved on to two bits per cell
    in **multi-level cell** (**MLC**) chips and now to three bits per cell in **tri-level
    cell** (**TLC**) chips. As the number of bits per cell increased, the reliability
    of the storage decreased, requiring more complex controller hardware and software
    to compensate for this. Where reliability is a concern, you should make sure you
    are using SLC NAND flash chips.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: As with NOR flash, NAND flash is organized into erase blocks ranging in size
    from 16 KB to 512 KB and, once again, erasing a block sets all the bits to 1\.
    However, the number of erase cycles is lower before the block becomes unreliable.
    There are typically as few as 1 K cycles for TLC chips and up to 100 K for SLC.
    NAND flash can only be read and written in pages (usually of 2 or 4 KB). Since
    they cannot be accessed byte by byte, they cannot be mapped into the address space,
    so code and data have to be copied into RAM before they can be accessed.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Data transfers to and from the chip are prone to bit flips, which can be detected
    and corrected using **error-correction codes** (**ECC**s). SLC chips generally
    use a simple **hamming code**, which can be implemented efficiently in software
    and can correct a single-bit error in a page read. MLC and TLC chips need more
    sophisticated codes such as **Bose-Chaudhuri-Hocquenghem** (**BCH**), which can
    correct up to 8-bit errors per page. Correcting that many errors requires hardware
    support inside the flash controller.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'The ECCs need to be stored somewhere, so there is an extra area of memory per
    page known as the **out-of-band** (**OOB**) area or the spare area. SLC designs
    usually have 1 byte of OOB per 32 bytes of main storage. So, for a 2 KB page device,
    the OOB is 64 bytes per page, and for a 4 KB page, it is 128 bytes. MLC and TLC
    chips have proportionally larger OOB areas to accommodate more complex ECCs. The
    following diagram shows the organization of a chip with a 128 KB erase block and
    2 KB pages:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – OOB area](img/B18466_09_01.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – OOB area
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: During production, the manufacturer tests all the blocks and marks any that
    fail by setting a flag in the OOB area of each page in the block. It is not uncommon
    to find that brand-new chips have up to 2% of their blocks marked bad in this
    way. Saving OOB information for analysis before erasing the area can be useful
    when there is a problem. Furthermore, it is within the specification for a similar
    proportion of blocks to give errors on erase before the erase cycle limit is reached.
    The NAND flash driver should detect this and mark it as bad.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产过程中，制造商会测试所有的块，并通过在每个块的页面的OOB区域中设置标志来标记任何失败的块。发现全新芯片中有多达2%的块以这种方式标记为坏是很常见的。在擦除区域之前保存OOB信息以进行分析在出现问题时是有用的。此外，在达到擦除周期限制之前，类似比例的块给出擦除错误是符合规范的。NAND闪存驱动程序应检测到并标记其为坏块。
- en: 'Once space has been made in the OOB area for a bad block flag and ECC bytes,
    there are still some bytes left. Some flash filesystems make use of these free
    bytes to store filesystem metadata. Consequently, many parts of the system are
    interested in the layout of the OOB area: the SoC ROM boot code, the bootloader,
    the kernel MTD driver, the filesystem code, and the tools to create filesystem
    images. There is not much standardization, so it is easy to get into a situation
    in which the bootloader writes data using an OOB format that cannot be read by
    the kernel MTD driver. It is up to you to make sure that they all agree.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在OOB区域为坏块标志和ECC字节留出空间后，仍然有一些字节剩余。一些闪存文件系统利用这些空闲字节来存储文件系统元数据。因此，系统的许多部分对OOB区域的布局感兴趣：SoC
    ROM引导代码、引导加载程序、内核MTD驱动程序、文件系统代码以及创建文件系统映像的工具。由于标准化程度不高，因此很容易出现引导加载程序使用无法被内核MTD驱动程序读取的OOB格式的情况。您需要确保它们彼此一致。
- en: Access to NAND flash chips requires a NAND flash controller, which is usually
    part of the SoC. You will need the corresponding driver in the bootloader and
    kernel. The NAND flash controller handles the hardware interface for the chip
    transferring data to and from pages and may include hardware for error correction.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 访问NAND闪存芯片需要一个NAND闪存控制器，通常是SoC的一部分。您需要引导加载程序和内核中对应的驱动程序。NAND闪存控制器处理芯片的硬件接口，传输页面的数据，可能包括用于错误校正的硬件。
- en: There is a standard register-level interface for NAND flash chips known as the
    **Open NAND Flash Interface** or **ONFI**, which most modern chips adhere to.
    See [https://onfi.org/](https://onfi.org/) for more information.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: NAND闪存芯片有一个称为**开放NAND闪存接口**（Open NAND Flash Interface，ONFI）的标准寄存器级接口，大多数现代芯片都遵循这一标准。有关更多信息，请参阅[https://onfi.org/](https://onfi.org/)。
- en: Modern NAND flash technology is complicated. Pairing NAND flash memory with
    a controller is no longer enough. We also need an interface to the hardware that
    abstracts most of the technical details such as error correction away.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现代NAND闪存技术非常复杂。仅仅将NAND闪存存储器与控制器配对已不再足够。我们还需要一个接口来抽象掉大部分技术细节，例如错误校正。
- en: Managed flash
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理型闪存
- en: The burden of supporting flash memory in the operating system – NAND in particular
    – becomes smaller if there is a well-defined hardware interface and a standard
    flash controller that hides the complexities of the memory. This is managed flash
    memory, and it is becoming more and more common. In essence, it means combining
    one or more flash chips with a microcontroller that offers an ideal storage device
    with a small sector size and that is compatible with conventional filesystems.
    The most important types of chips for embedded systems are **Secure Digital**
    (**SD**) cards and the embedded variant known as eMMC.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作系统中支持闪存存储器的负担变小了，特别是对于NAND闪存而言，如果有一个明确定义的硬件接口和一个隐藏存储器复杂性的标准闪存控制器。这就是管理型闪存存储器，它越来越普遍。实质上，它意味着将一个或多个闪存芯片与提供理想存储设备的微控制器结合起来，具有小的扇区大小，并且与传统文件系统兼容。嵌入式系统中最重要的芯片类型是**安全数字**（Secure
    Digital，SD）卡及其嵌入式变体称为eMMC。
- en: The MultiMediaCard and Secure Digital cards
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多媒体卡（MultiMediaCard）和安全数字卡（Secure Digital cards）
- en: 'The **MultiMediaCard** (**MMC**) was introduced in 1997 by SanDisk and Siemens
    as a form of packaged storage using flash memory. Shortly after, in 1999, SanDisk,
    Matsushita, and Toshiba created the SD card, which is based on MMC but adds encryption
    and **Digital Rights Management** (**DRM**), hence the “secure” part of the name.
    Both were intended for consumer electronics such as digital cameras, music players,
    and similar devices. Currently, SD cards are the dominant form of managed flash
    for consumer and embedded electronics even though the encryption features are
    seldom used. Newer versions of the SD specification allow smaller packaging (miniSD
    and microSD) and larger capacities: high capacity SDHC up to 32 GB and extended
    capacity SDXC up to 2 TB.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**多媒体卡**（**MMC**）由SanDisk和西门子于1997年推出，是一种使用闪存的封装存储形式。随后，在1999年，SanDisk、松下和东芝共同创建了SD卡，它基于MMC，但增加了加密和**数字版权管理**（**DRM**）功能，因此才有了“安全”这一名称部分。这两种卡都是为了消费类电子产品，如数码相机、音乐播放器和类似设备而设计的。目前，SD卡是消费类和嵌入式电子产品中占主导地位的管理型闪存，尽管加密功能很少被使用。SD规范的新版本允许更小的封装（miniSD和microSD）和更大的容量：高容量的SDHC最高可达32GB，扩展容量的SDXC可达2TB。'
- en: The hardware interface for MMC and SD cards is very similar. It is possible
    to use full-sized MMC cards in full-sized SD card slots (but not the other way
    around). Early incarnations used a 1-bit **Serial Peripheral Interface** (**SPI**).
    More recent cards use a 4-bit interface.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: MMC和SD卡的硬件接口非常相似。可以在全尺寸的SD卡插槽中使用全尺寸的MMC卡（但反过来不可行）。早期的版本使用了1位的**串行外设接口**（**SPI**）。更近期的卡片使用了4位接口。
- en: 'There is a command set for reading and writing memory in sectors of 512 bytes.
    Inside the package is a microcontroller and one or more NAND flash chips, as shown
    in the following diagram:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令集用于读取和写入512字节的扇区内存。封装内部包含一个微控制器和一个或多个NAND闪存芯片，具体如下图所示：
- en: '![Figure 9.2 – SD card package](img/B18466_09_02.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – SD卡封装](img/B18466_09_02.png)'
- en: Figure 9.2 – SD card package
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – SD卡封装
- en: 'The microcontroller implements the command set and manages the flash memory,
    performing the function of a flash translation layer, as described later in this
    chapter. They are preformatted with a FAT filesystem: FAT16 on SDSC cards, FAT32
    on SDHC, and exFAT on SDXC. The quality of the NAND flash chips and the software
    on the microcontroller varies greatly between cards. It is questionable whether
    any of them are sufficiently reliable for deep embedded use. Certainly not with
    a FAT filesystem, which is prone to file corruption. Remember that the prime use
    case for MMC and SD cards is for removable storage on cameras, tablets, and phones.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 微控制器实现了指令集并管理闪存，执行闪存翻译层的功能，如本章后续所述。它们已经预格式化为FAT文件系统：SDSC卡使用FAT16，SDHC卡使用FAT32，SDXC卡使用exFAT。NAND闪存芯片的质量以及微控制器上的软件在不同卡片之间差异很大。是否有卡片足够可靠以供深度嵌入使用仍存疑，尤其是使用FAT文件系统时，它容易导致文件损坏。请记住，MMC和SD卡的主要使用场景是作为数码相机、平板电脑和手机的可移动存储。
- en: eMMC
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: eMMC
- en: '**Embedded MMC** or **eMMC** is simply MMC memory that’s been packaged so that
    it can be soldered onto the motherboard using a 4- or 8-bit interface for data
    transfer. However, they are intended to be used as storage for an operating system,
    so the components are capable of performing that task. The chips are usually not
    preformatted with any filesystem.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**嵌入式MMC**或**eMMC**实际上是将MMC存储芯片封装成可以通过4位或8位接口焊接到主板上的存储器。它们通常用作操作系统的存储，因此这些组件能够执行该任务。芯片通常没有预格式化任何文件系统。'
- en: Other types of managed flash
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他类型的管理型闪存
- en: One of the first managed flash technologies was **CompactFlash** (**CF**), which
    uses a subset of the **Personal Computer Memory Card International Association**
    (**PCMCIA**) hardware interface. CF exposes memory through a **Parallel Advanced
    Technology Attachment** (**PATA**) interface and appears to the operating system
    as a standard hard disk. They were common in x86-based single-board computers
    and professional video and camera equipment.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个管理型闪存技术之一是**紧凑型闪存**（**CF**），它使用了**个人计算机内存卡国际协会**（**PCMCIA**）硬件接口的一个子集。CF通过**并行先进技术附件**（**PATA**）接口暴露内存，并且在操作系统中表现为标准硬盘。它们曾广泛应用于基于x86的单板计算机和专业视频及摄影设备中。
- en: One other format that we use every day is the **USB flash drive**. In this case,
    memory is accessed through a USB interface and the controller implements the USB
    mass storage specification as well as the flash translation layer and interface
    to the flash chip or chips. The USB mass storage protocol is based on the SCSI
    disk command set. As with MMC and SD cards, they are usually preformatted with
    a FAT filesystem. Their main use case in embedded systems is to exchange data
    with PCs.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们每天使用的另一种格式是**USB闪存驱动器**。在这种情况下，内存是通过USB接口访问的，控制器实现了USB大容量存储规范以及闪存转换层和与闪存芯片的接口。USB大容量存储协议基于SCSI磁盘命令集。与MMC和SD卡一样，它们通常预格式化为FAT文件系统。它们在嵌入式系统中的主要用例是与PC交换数据。
- en: A recent addition to the list of options for managed flash storage is **Universal
    Flash Storage** (**UFS**). Like eMMC, it is packaged in a chip that is mounted
    on the motherboard. It has a high-speed serial interface and can achieve data
    rates greater than eMMC. It supports an SCSI disk command set.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，作为一种新的管理型闪存存储选项，**通用闪存存储**（**UFS**）被加入到列表中。与eMMC类似，它是一个封装在芯片中的存储单元，安装在主板上。它具有高速串行接口，并且可以实现比eMMC更高的传输速率。它支持SCSI磁盘命令集。
- en: Now that we know what types of flash are available, let’s learn how U-Boot loads
    a kernel image from each of them.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了可用的闪存类型，让我们学习一下U-Boot如何从每种闪存中加载内核镜像。
- en: Accessing flash memory from the bootloader
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从引导加载程序访问闪存内存
- en: In [*Chapter 3*](Chapter_03.xhtml#_idTextAnchor061) I mentioned the need for
    the bootloader to load kernel binaries and other images from various flash devices
    and to perform system maintenance tasks such as erasing and reprogramming flash
    memory. It follows that the bootloader must have the drivers and infrastructure
    needed to support read, erase, and write operations on the type of memory you
    have, whether it be NOR, NAND, or managed. I will use U-Boot in the following
    examples. Other bootloaders follow a similar pattern.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第3章*](Chapter_03.xhtml#_idTextAnchor061)中，我提到了引导加载程序需要从各种闪存设备中加载内核二进制文件和其他镜像，并执行系统维护任务，如擦除和重新编程闪存内存。因此，引导加载程序必须具备支持读取、擦除和写入操作的驱动程序和基础设施，无论你使用的是NOR、NAND还是管理型内存。接下来的示例中我将使用U-Boot。其他引导加载程序遵循类似的模式。
- en: U-Boot and NOR flash
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: U-Boot和NOR闪存
- en: 'U-Boot has drivers for NOR CFI chips in `drivers/mtd` and utilizes various
    `erase` commands to erase memory and `cp.b` to copy data byte by byte onto the
    flash cells. Suppose that you have NOR flash memory mapped from `0x40000000` to
    `0x48000000`, of which 4 MB, starting at `0x40040000`, is a kernel image. Here,
    you would load a new kernel into flash using these U-Boot commands:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: U-Boot在`drivers/mtd`中有NOR CFI芯片的驱动程序，并使用各种`erase`命令擦除内存，通过`cp.b`命令逐字节将数据复制到闪存单元。如果你的NOR闪存内存从`0x40000000`映射到`0x48000000`，其中4MB的内存从`0x40040000`开始用于存储内核镜像。此时，你可以使用这些U-Boot命令将新的内核加载到闪存中：
- en: '[PRE1]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `filesize` variable in the preceding example is set by the `tftpboot` command
    to the size of the file just downloaded.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例中的`filesize`变量由`tftpboot`命令设置为刚刚下载的文件的大小。
- en: U-Boot and NAND flash
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: U-Boot和NAND闪存
- en: For NAND flash, you need a driver for the NAND flash controller on your SoC,
    which you can find in the U-Boot source code in the `drivers/mtd/nand` directory.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于NAND闪存，你需要一个NAND闪存控制器的驱动程序，通常可以在U-Boot源代码中的`drivers/mtd/nand`目录找到。
- en: 'You can use the `nand` command to manage memory using its `erase`, `write`,
    and `read` sub-commands. This example shows a kernel image being loaded into RAM
    at `0x82000000` and then placed into flash starting at the `0x280000` offset:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`nand`命令来管理内存，使用它的`erase`、`write`和`read`子命令。这个例子展示了一个内核镜像被加载到`0x82000000`的RAM中，然后再从`0x280000`偏移位置开始写入到闪存中：
- en: '[PRE2]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: U-Boot can also read files stored in the JFFS2, YAFFS2, and UBIFS filesystems.
    `nand write` will skip blocks that are marked as bad.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: U-Boot还可以读取存储在JFFS2、YAFFS2和UBIFS文件系统中的文件。`nand write`会跳过标记为坏的块。
- en: '**Important note**'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: If the data you’re writing is for a filesystem, make sure that the filesystem
    also skips bad blocks.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在写入的数据属于文件系统，请确保文件系统也会跳过坏块。
- en: U-Boot and MMC, SD, and eMMC
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: U-Boot和MMC、SD以及eMMC
- en: U-Boot has drivers for several MMC controllers in `drivers/mmc`. You can access
    raw data using `mmc read` and `mmc write` at the user interface level, allowing
    you to handle raw kernel and filesystem images.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: U-Boot在`drivers/mmc`中有多个MMC控制器的驱动程序。你可以通过用户界面级别使用`mmc read`和`mmc write`访问原始数据，从而处理原始内核和文件系统镜像。
- en: U-Boot can also read files from the FAT32 and ext4 filesystems on MMC storage.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: U-Boot还可以从MMC存储上的FAT32和ext4文件系统中读取文件。
- en: U-Boot needs drivers to access NOR, NAND, and managed flash. Which driver you
    should use depends on your choice of NOR chip or the flash controller on your
    SoC. Accessing raw NOR and NAND flash from Linux involves additional layers of
    software.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: U-Boot 需要驱动程序来访问 NOR、NAND 和管理闪存。你应使用哪个驱动程序取决于你选择的 NOR 芯片或 SoC 上的闪存控制器。从 Linux
    访问原始 NOR 和 NAND 闪存涉及额外的软件层。
- en: Accessing flash memory from Linux
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 Linux 访问闪存
- en: Raw NOR and NAND flash memory is handled by the **Memory Technology Device**
    (**MTD**) subsystem, which provides you with basic interfaces to read, erase,
    and write blocks of flash memory. In the case of NAND flash, there are also functions
    that handle the OOB area and are used to identify bad blocks.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的 NOR 和 NAND 闪存由**内存技术设备**（**MTD**）子系统处理，该子系统为你提供了基本接口来读取、擦除和写入闪存块。对于 NAND
    闪存，还有处理 OOB 区域的功能，用于识别坏块。
- en: For managed flash, you need drivers to handle a particular hardware interface.
    MMC/SD cards and eMMC use the `mmcblk` driver. While CompactFlash and hard drives
    use the `sd` SCSI disk driver. USB flash drives use the `usb_storage` driver together
    with the `sd` driver.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于管理闪存，你需要驱动程序来处理特定的硬件接口。MMC/SD 卡和 eMMC 使用 `mmcblk` 驱动程序。而 CompactFlash 和硬盘则使用
    `sd` SCSI 磁盘驱动程序。USB 闪存驱动器使用 `usb_storage` 驱动程序，并与 `sd` 驱动程序一起使用。
- en: Memory technology devices
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存技术设备
- en: 'The MTD subsystem was started by David Woodhouse in 1999 and has been extensively
    developed over the intervening years. In this section, I will concentrate on the
    way it handles the two main technologies, NOR and NAND flash.MTD consists of three
    layers: a core set of functions, a set of drivers for various types of chips,
    and user-level drivers that present the flash memory as a character device or
    a block device:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: MTD 子系统由 David Woodhouse 于 1999 年启动，并在这期间得到了广泛的发展。在本节中，我将重点介绍它如何处理两种主要技术，NOR
    和 NAND 闪存。MTD 包含三层：一组核心功能、用于各种类型芯片的驱动程序集合以及以字符设备或块设备形式呈现闪存的用户级驱动程序：
- en: '![Figure 9.3 – MTD layers](img/B18466_09_03.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.3 – MTD 层](img/B18466_09_03.png)'
- en: Figure 9.3 – MTD layers
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 – MTD 层
- en: The chip drivers are at the lowest level and interface with flash chips. Only
    a small number of drivers are needed for NOR flash chips, enough to cover the
    CFI standard and variations, plus a few non-compliant chips, which are now mostly
    obsolete. For NAND flash, you will need a driver for the NAND flash controller
    you are using. This is usually supplied as part of the board support package.
    There are drivers for about 40 of them in the current mainline kernel in the `drivers/mtd/nand`
    directory.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 芯片驱动程序处于最低层，与闪存芯片进行接口。NOR 闪存芯片只需要少数几个驱动程序，足以涵盖 CFI 标准和变种，以及一些不符合标准的芯片，这些芯片现在大多已过时。对于
    NAND 闪存，你需要一个用于你所使用的 NAND 闪存控制器的驱动程序。这个驱动程序通常作为板级支持包的一部分提供。目前主线内核的 `drivers/mtd/nand`
    目录中大约有 40 个相关驱动程序。
- en: MTD partitions
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MTD 分区
- en: 'In most cases, you will want to partition the flash memory into a number of
    areas, for example, to provide space for a bootloader, a kernel image, or a root
    filesystem. In MTD, there are several ways to specify the size and location of
    partitions, with the main ones being as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，你可能希望将闪存分区成多个区域，例如，提供引导加载程序、内核镜像或根文件系统的空间。在 MTD 中，有几种方法可以指定分区的大小和位置，主要的几种方法如下：
- en: Through the kernel command line using `CONFIG_MTD_CMDLINE_PARTS`
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过内核命令行使用 `CONFIG_MTD_CMDLINE_PARTS`
- en: Via the device tree using `CONFIG_MTD_OF_PARTS`
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过设备树使用 `CONFIG_MTD_OF_PARTS`
- en: With a platform-mapping driver
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用平台映射驱动程序
- en: 'In the case of the first option, the kernel command-line option to use is `mtdparts`,
    which is defined within the Linux source code inside `drivers/mtd/parsers/cmdlinepart.c`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个选项中，内核命令行选项为 `mtdparts`，该选项在 Linux 源代码中的 `drivers/mtd/parsers/cmdlinepart.c`
    文件内定义：
- en: '[PRE3]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Perhaps an example will help. Imagine that you have one flash chip of 128 MB
    that is to be divided into five partitions. A typical command line would be this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 或许一个例子能帮助理解。假设你有一个128 MB的闪存芯片，需要将其分成五个分区。一个典型的命令行如下：
- en: '[PRE4]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first element before the colon is `mtd-id`, which identifies the flash chip
    either by number or by the name assigned by the board support package. If there
    is only one chip, as is the case here, it can be left empty. If there is more
    than one chip, the information for each is separated by a semicolon. Then, for
    each chip, there is a comma-separated list of partitions each with a size in bytes,
    KB (`k`) or MB (`m`), and a name in parentheses. The `ro` suffix makes the partition
    read-only to MTD and is often used to prevent accidental overwriting of the bootloader.
    The size of the last partition for the chip may be replaced by a dash (`-`) indicating
    that it should take up all the remaining space.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see a summary of the configuration at runtime by reading `/proc/mtd`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There is more detailed information for each partition in `/sys/class/mtd`,
    including the erase block size and the page size. It is nicely summarized using
    `mtdinfo`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Another way of specifying MTD partitions is through the device tree. Here is
    an example that creates the same partitions as the command-line example:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'A third alternative is to code the partition information as platform data in
    an `mtd_partition` structure as shown in this example taken from `arch/arm/mach-omap2/board-omap3beagle.c`
    (`NAND_BLOCK_SIZE` is defined elsewhere as 128 KB):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Platform data is deprecated: you will only find it used in BSPs for old SoCs
    that have not been updated to use a device tree.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: MTD device drivers
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The upper level of the MTD subsystem contains a pair of device drivers:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'A character device with a major number of `90`. There are two device nodes
    per MTD partition number, N: `/dev/mtdN` (minor number=N*2) and `/dev/mtdNro`
    (minor number=(N*2 + 1)). The latter is just a read-only version of the former.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A block device with a major number of `31` and a minor number of N. The device
    nodes are in the form `/dev/mtdblockN`.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s look at the character device first since it is the most commonly used
    of the two. Character devices behave much like files on storage in the sense that
    you can easily read text from and write text to them.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: The MTD character device, mtd
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The character devices are the most important: they allow you to access the
    underlying flash memory as an array of bytes so that you can read and write (program)
    the flash. It also implements a number of `ioctl` functions that allow you to
    erase blocks and manage the OOB area on NAND chips. The following list has been
    taken from `include/uapi/mtd/mtd-abi.h`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '`MEMGETINFO`: Gets basic MTD characteristic information.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MEMERASE`: Erases blocks in the MTD partition.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MEMWRITEOOB`: Writes out-of-band data for the page.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MEMREADOOB`: Reads out-of-band data for the page.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MEMLOCK`: Locks the chip (if supported).'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MEMUNLOCK`: Unlocks the chip (if supported).'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MEMGETREGIONCOUNT`: Gets the number of erase regions: non-zero if there are
    erase blocks of differing sizes in the partition, which is common for NOR flash
    but rare on NAND.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MEMGETREGIONINFO`: Can be used to get the offset, size, and block count of
    each region if `MEMGETREGIONCOUNT` is non-zero.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MEMGETOOBSEL`: Deprecated.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MEMGETBADBLOCK`: Gets the bad block flag.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MEMSETBADBLOCK`: Sets the bad block flag.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OTPSELECT`: Sets OTP (one-time programmable) mode if the chip supports it.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OTPGETREGIONCOUNT`: Gets the number of OTP regions.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OTPGETREGIONINFO`: Gets information about an OTP region.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ECCGETLAYOUT`: Deprecated.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is a set of utility programs known as `mtd-utils` for manipulating flash
    memory that makes use of these `ioctl` functions. The source can be found at `git://git.infradead.org/mtd-utils.git`
    and is available as a package in The Yocto Project and Buildroot. The essential
    tools are shown in the following list. The package also contains utilities for
    the JFFS2 and UBI/UBIFS filesystems, which I will cover later. For each of these
    tools, the MTD character device is one of the following parameters:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '`flash_erase`: Erases a range of blocks.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flash_lock`: Locks a range of blocks.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flash_unlock`: Unlocks a range of blocks.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nanddump:` Dumps memory from NAND flash, optionally, including the OOB area.
    Skips bad blocks.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nandtest`: Tests and performs diagnostics for NAND flash.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nandwrite`: Writes (programs) data from a file into NAND flash, skipping bad
    blocks.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tip**'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You must always erase flash memory before writing new content to it.
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`flash_erase` is the command that does this.'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To program NOR flash, you simply copy bytes to the MTD device node using a file
    copy command such as cp.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, this doesn’t work with NAND memory as the copy will fail at the
    first bad block. Instead, use `nandwrite`, which skips over any bad blocks. To
    read back NAND memory, you should use `nanddump`, which also skips bad blocks.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: The MTD block device, mtdblock
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `mtdblock` driver isn’t used often. Its purpose is to present flash memory
    as a block device you can use to format and mount a filesystem. However, it has
    severe limitations because it does not handle bad blocks in NAND flash, it does
    not do wear leveling, and it does not handle the mismatch in size between filesystem
    blocks and flash erase blocks. In other words, it does not have a flash translation
    layer, which is essential for reliable file storage. The only case where the `mtdblock`
    device is useful is for mounting read-only file systems such as SquashFS on top
    of reliable flash memory such as NOR.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip**'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: If you want a read-only filesystem on NAND flash, you should use the UBI driver
    as described later in this chapter.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Logging kernel oops to MTD
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A kernel error or oops is normally logged via the `klogd` and `syslogd` daemons
    to a circular memory buffer or a file. After a reboot, the log will be lost in
    the case of a ring buffer. Even in the case of a file, it may not have been properly
    written to before the system crashed. A more reliable method is to write oops
    and kernel panics to an MTD partition as a circular log buffer. You can enable
    it with `CONFIG_MTD_OOPS` and add `console=ttyMTDN` to the kernel command line
    with `N` being the MTD device number to write the messages to.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Simulating NAND memory
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The NAND simulator emulates a NAND chip using system RAM. Its main use is to
    test code that has to be NAND-aware without access to physical NAND memory. The
    ability to simulate bad blocks, bit flips, and other errors allows you to test
    code paths that are difficult to exercise using real flash memory. For more information,
    the best place to look is in the code itself, which provides a comprehensive description
    of the ways you can configure the driver. The code is in `drivers/mtd/nand/nandsim.c`.
    Enable it with the `CONFIG_MTD_NAND_NANDSIM` kernel configuration.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: The MMC block driver
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MMC/SD cards and eMMC chips are accessed using the `mmcblk` block driver. You
    need a host controller to match the MMC adapter you are using, which is part of
    the board support package. The drivers are in the Linux source code under `drivers/mmc/host`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: MMC storage is partitioned using a partition table in exactly the same way you
    would for hard disks. That is, by using `fdisk` or a similar utility.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: We now know how Linux accesses each type of flash. Next, we will look at the
    problems intrinsic to flash memory and how Linux deals with them, either by way
    of the filesystem or the block device driver.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Filesystems for flash memory
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several challenges when it comes to making efficient use of flash
    memory for mass storage: the mismatch between the size of an erase block and a
    disk sector, the limited number of erase cycles per erase block, and the need
    for bad block handling on NAND chips. These differences are resolved by a **flash
    translation layer** (**FTL**).'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Flash translation layers
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A flash translation layer has the following features:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '**Sub allocation**: Filesystems work best with a small allocation unit, traditionally
    a 512-byte sector. This is much smaller than a flash erase block of 128 KB or
    more. Therefore, erase blocks need to be subdivided into smaller units to avoid
    wasting large amounts of space.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Garbage collection**: A consequence of sub allocation is that an erase block
    will contain a mixture of good data and stale data once the filesystem has been
    in use for a while. Since we can only free up whole erase blocks, the only way
    to reclaim this free space is to coalesce the good data into one place and then
    return the now empty erase block to the free list. This is known as garbage collection,
    and it is usually implemented as a background thread.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Wear leveling**: There is a limit on the number of erase cycles for each
    block. To maximize the lifespan of a chip, it is important to move data around
    so that each block is erased roughly the same number of times.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bad block handling**: On NAND flash chips, you must avoid using any block
    marked bad and also mark good blocks as bad if they cannot be erased.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Robustness**: Embedded devices may be powered off or reset without warning.
    Any filesystem should be able to cope without corruption, usually by incorporating
    a journal or a log of transactions.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are several ways to deploy the flash translation layer:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '**In the filesystem**: As with JFFS2, YAFFS2, and UBIFS.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**In the block device driver**: The UBI driver, which UBIFS depends on implements
    some aspects of a flash translation layer.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**In the device controller**: As with managed flash devices.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the flash translation layer is in the filesystem or the block driver, the
    code is part of the kernel so we can see how it works and expect that it will
    be improved over time. On the other hand, if the FTL is inside a managed flash
    device, it is hidden from view, and we cannot verify whether it works as we want.
    Not only that but putting the FTL into the disk controller means that it misses
    out on useful information that is held at the filesystem layer, like which sectors
    belong to files that have been deleted. The latter problem is solved by adding
    commands that pass this information between the filesystem and the device. I will
    describe how this works later, in the section on the `TRIM` command. However,
    the question of code visibility remains. If you are using managed flash, you just
    have to choose a manufacturer you can trust.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know the motivation behind filesystems, let’s look at which filesystems
    are best suited for which types of flash.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Filesystems for NOR and NAND flash memory
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To use raw flash chips for mass storage, you have to use a filesystem that
    understands the peculiarities of the underlying technology. There are three such
    filesystems:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '**JFFS2** (**Journaling Flash File System 2**): This was the first flash filesystem
    for Linux and is still in use today. It works for NOR and NAND memory but is notoriously
    slow during mount.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**YAFFS2** (**Yet Another Flash File System 2**): This is like JFFS2 but specifically
    for NAND flash memory. It was adopted by Google as the preferred raw flash filesystem
    on Android devices.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UBIFS** (**Unsorted Block Image File System**): This works in conjunction
    with the UBI block driver to create a reliable flash filesystem. It works well
    with both NOR and NAND memory. Since it generally offers better performance than
    JFFS2 or YAFFS2 it should be the preferred solution for new designs.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these use MTD as the common interface to flash memory.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: JFFS2
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Journaling Flash File System** had its beginnings in the software for
    the Axis 2100 network camera back in 1999\. For many years, it was the only flash
    filesystem for Linux and has been deployed on many different types of devices.
    Today, it is not the best choice, but I will cover it first because it shows the
    beginning of the evolutionary path.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: JFFS2 is a log-structured filesystem that uses MTD to access flash memory. In
    a log-structured filesystem, changes are written sequentially as nodes to flash
    memory. A node may contain changes to a directory, such as the names of files
    created and deleted, or it may contain changes to file data. After a while, a
    node may be superseded by information contained in subsequent nodes and become
    an obsolete node. Both NOR and NAND flash are organized as erase blocks. Erasing
    a block sets all its bits to 1.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'JFFS2 categorizes erase blocks into three types:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '**Free**: Contains no nodes at all.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clean**: Only contains valid nodes.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dirty**: Contains at least one obsolete node.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At any one time, there is one block receiving updates, which is called the open
    block. If power is lost or the system is reset, the only data that can be lost
    is the last write to the open block. In addition, nodes are compressed as they
    are written, increasing the effective storage capacity of the flash chip, which
    is important if you are using expensive NOR flash memory.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: When the number of free blocks falls below a certain threshold, a garbage collector
    kernel thread is started, which scans for dirty blocks, copies the valid nodes
    into the open block, and then frees up the dirty block.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, the garbage collector provides a crude form of wear leveling
    because it cycles valid data from one block to another. The way that the open
    block is chosen means that each block is erased roughly the same number of times
    as long as it contains data that changes from time to time. Sometimes, a clean
    block is chosen for garbage collection to make sure that blocks containing static
    data that is seldom written are also wear-leveled.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'JFFS2 filesystems have a write-through cache, meaning that writes are written
    to the flash memory synchronously as if they have been mounted with the `-o` sync
    option. While improving reliability, this approach increases the time to write
    data. There is a further problem with small writes: if the length of a write is
    comparable to the size of the node header (40 bytes), the overhead becomes high.
    A well-known corner case is log files like those produced by `syslogd`.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Summary nodes
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is one overriding disadvantage to JFFS2: since there is no on-chip index,
    the directory’s structure has to be deduced at mount time by reading the log from
    start to finish. At the end of the scan, you have a complete picture of the directory
    structure of the valid nodes, but the mount time taken is proportional to the
    size of the partition. It is not uncommon to see mount times of the order of one
    second per megabyte, leading to total mount times of tens or hundreds of seconds.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Summary nodes became an option in Linux 2.6.15 for reducing the time to scan
    during a mount. A summary node is written at the end of the open erase block,
    just before it is closed. The summary node contains all of the information needed
    for the mount-time scan, thereby reducing the amount of data to process during
    the scan. Summary nodes can reduce mount times by a factor of between two and
    five at the expense of an overhead of about 5% of the storage space. They are
    enabled with the `CONFIG_JFFS2_SUMMARY` kernel configuration.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Clean markers
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An erased block with all its bits set to 1 is indistinguishable from a block
    that has been written with 1s, but the latter has not had its memory cells refreshed
    and cannot be programmed again until it is erased. JFFS2 uses a mechanism called
    **clean markers** to distinguish between these two situations. After a successful
    block erase, a clean marker is written either to the beginning of the block or
    to the OOB area of the first page of the block. If the clean marker exists, then
    it must be a clean block.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Creating a JFFS2 filesystem
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Creating an empty JFFS2 filesystem at runtime is as simple as erasing an MTD
    partition with clean markers and then mounting it. There is no formatting step
    because a blank JFFS2 filesystem consists entirely of free blocks. For example,
    to format MTD partition 6, you would enter these commands on the device:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `-j` option to `flash_erase` adds the clean markers and mounting with the
    `jffs2` type presents the partition as an empty filesystem. Note that the device
    to be mounted is given as `mtd6`, not `/dev/mtd6`. Alternatively, you can give
    the block the `/dev/mtdblock6` device node. This is just a peculiarity of JFFS2\.
    Once mounted, you can treat it like any other filesystem.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: You can create a filesystem image directly from the staging area of your development
    system using `mkfs.jffs2` to write out the files in JFFS2 format and `sumtool`
    to add the summary nodes. Both of these are part of the `mtd-utils` package.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, to create an image of the files in `rootfs` for a NAND flash
    device with an erase block size of 128 KB (`0x20000`) and with summary nodes,
    you would use these two commands:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `-p` option adds padding at the end of the image file to make it a whole
    number of erase blocks. The `-n` option suppresses the creation of clean markers
    in the image, which is normal for NAND devices as the clean marker is in the OOB
    area. For NOR devices, you would leave out the `-n` option. You can use a device
    table with `mkfs.jffs2` to set the permissions and the ownership of files by adding
    `-D <device table>`. Of course, Buildroot and The Yocto Project will do all this
    for you.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'You can program the image into flash memory from your bootloader. For example,
    if you have loaded a filesystem image into RAM at address `0x82000000` and you
    want to load it into a flash partition that begins at `0x163000` bytes from the
    start of the flash chip and is `0x7a9d000` bytes long, the U-Boot commands for
    this would be:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can do the same thing from Linux using the `mtd` driver like this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To boot with a JFFS2 root filesystem, you need to pass the `mtdblock` device
    on the kernel command line for the partition and a `rootfstype` since JFFS2 cannot
    be auto-detected:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Shortly after JFFS2 was introduced, another log-structured filesystem appeared.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: YAFFS2
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The YAFFS filesystem was written by Charles Manning starting in 2001 to handle
    NAND flash chips at a time when JFFS2 did not. Subsequent changes to handle larger
    (2 KB) page sizes resulted in YAFFS2\. The website for YAFFS is [https://yaffs.net/](https://yaffs.net/).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: YAFFS is also a log-structured filesystem that follows the same design principles
    as JFFS2\. The different design decisions mean that it has a faster mount-time
    scan, simpler and faster garbage collection, and no compression, which speeds
    up reads and writes at the expense of less efficient use of storage.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'YAFFS is not limited to Linux. It has been ported to a wide range of operating
    systems. It has a dual license: GPLv2 (compatible with Linux) and a commercial
    license for other operating systems. Unfortunately, the YAFFS code has never been
    merged into mainline Linux so you will have to patch your kernel.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'To get YAFFS2 and patch a kernel, do the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Then, you can configure the kernel with `CONFIG_YAFFS_YAFFS2`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Creating a YAFFS2 filesystem
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As with JFFS2, to create a YAFFS2 filesystem at runtime, you only need to erase
    the partition and mount it, but note that in this case, you do not enable clean
    markers:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To create a filesystem image, the simplest thing to do is use the `mkyaffs2`
    tool from [https://code.google.com/archive/p/yaffs2utils/](https://code.google.com/archive/p/yaffs2utils/):'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, `-c` is the page size and `-s` is the OOB size. There is a tool named
    `mkyaffs2image` that is part of the YAFFS code, but it has a couple of drawbacks.
    Firstly, the page and OOB size are hard coded in the source, so you will have
    to edit and recompile if you have memory that does not match the defaults of 2,048
    and 64\. Secondly, the OOB layout is incompatible with MTD, which uses the first
    two bytes as a bad block marker, whereas `mkyaffs2image` uses those bytes to store
    part of the YAFFS metadata.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'To copy the image to the MTD partition from a Linux shell prompt on the target,
    follow these steps:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To boot with a YAFFS2 root filesystem, add the following to the kernel command
    line:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: While we are on the topic of filesystems for raw NOR and NAND flash, let’s look
    at one of the more modern options. This filesystem runs on top of the UBI driver.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: UBI and UBIFS
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Unsorted Block Image** (**UBI**) driver is a volume manager for flash
    memory that takes care of bad block handling and wear leveling. It was implemented
    by Artem Bityutskiy and first appeared in Linux 2.6.22\. In parallel with that,
    engineers at Nokia were working on a filesystem that would take advantage of the
    features of UBI, which they called UBIFS. It appeared in Linux 2.6.27\. Splitting
    the flash translation layer in this way makes the code more modular and also allows
    other filesystems to take advantage of the UBI driver, as we shall see later on.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: UBI
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: UBI provides an idealized, reliable view of a flash chip by mapping **physical
    erase blocks** (**PEBs**) to **logical erase blocks** (**LEBs**). Bad blocks are
    not mapped to LEBs and so are never used. If a block cannot be erased, it is marked
    as bad and dropped from the mapping. UBI keeps a count of the number of times
    each PEB has been erased in the header of the LEB and then changes the mapping
    to ensure that each PEB is erased the same number of times.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'UBI accesses the flash memory through the MTD layer. As an extra feature, it
    can divide an MTD partition into several UBI volumes, which improves wear leveling
    as follows. Imagine that you have two filesystems: one containing fairly static
    data, such as a root filesystem, and the other containing data that is constantly
    changing.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'If they are stored in separate MTD partitions, the wear leveling only impacts
    the second one. Whereas if you choose to store them in two UBI volumes in a single
    MTD partition, the wear leveling takes place over both areas of the storage, and
    the lifetime of the flash memory is increased. The following diagram illustrates
    this situation:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – UBI volumes](img/B18466_09_04.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – UBI volumes
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'In this way, UBI fulfills two of the requirements of a flash translation layer:
    wear leveling and bad-block handling.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'To prepare an MTD partition for UBI, you don’t use `flash_erase` as with JFFS2
    and YAFFS2\. Instead, you use the `ubiformat` utility, which preserves the erase
    counts that are stored in the PEB headers. `ubiformat` needs to know the minimum
    unit of I/O, which for most NAND flash chips is the page size, but some chips
    allow reading and writing in subpages that are a half or a quarter of the page
    size. Consult the chip data sheet for details and, if in doubt, use the page size.
    This example prepares `mtd6` using a page size of 2048 bytes:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, you can use the `ubiattach` command to load the UBI driver on an MTD
    partition that has been prepared in this way:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This creates the `/dev/ubi0` device node through which you can access the UBI
    volumes. You can use `ubiattach` on several MTD partitions, in which case they
    can be accessed through `/dev/ubi1`, `/dev/ubi2`, and so on. Note that since each
    LEB has a header containing the meta information used by UBI, the LEB is smaller
    than the PEB by two pages. For example, a chip with a PEB size of 128 KB and 2
    KB pages would have an LEB of 124 KB. This is important information that you will
    need when creating a UBIFS image.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: The PEB-to-LEB mapping is loaded into memory during the attach phase, a process
    that takes time proportional to the number of PEBs, typically a few seconds. A
    new feature was added in Linux 3.7, called the UBI fastmap, which checkpoints
    the mapping to flash from time to time and so reduces the attach time. The kernel
    configuration option for this is `CONFIG_MTD_UBI_FASTMAP`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'The first time you attach to an MTD partition after a `ubiformat`, there will
    be no volumes. You can create volumes using `ubimkvol`. For example, suppose you
    have a 128 MB MTD partition, and you want to split it into two volumes. The first
    is to be 32 MB in size and the second will take up the remaining space:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, you have a device with two nodes: `/dev/ubi0_0` and `/dev/ubi0_1`. You
    can confirm this using `ubinfo`:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: At this point, you have a 128 MB MTD partition containing two UBI volumes of
    sizes 32 MB and 88.8 MB. The total storage available is 32 MB plus 88.8 MB, which
    equals 120.8 MB. The remaining space, 7.2 MB, is taken up by the UBI headers at
    the start of each PEB, and space is reserved for mapping out blocks that go bad
    during the lifetime of the chip.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: UBIFS
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: UBIFS uses a UBI volume to create a robust filesystem. It adds sub-allocation
    and garbage collection to create a complete flash translation layer. Unlike JFFS2
    and YAFFS2, it stores index information on-chip, so mounting is fast, although
    don’t forget that attaching the UBI volume beforehand may take a significant amount
    of time. It also allows write-back caching as in a normal disk filesystem, so
    writes are much faster, but data that has not been flushed to flash memory is
    lost in the event of power down. You can resolve this problem by making careful
    use of the `fsync(2)` and `fdatasync(2)` functions to force a flush of file data
    at crucial points.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: UBIFS has a journal for fast recovery in the event of power down. The minimum
    size of the journal is 4 MB so UBIFS is not suitable for very small flash devices.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have created the UBI volumes, you can mount them using the device
    node for the volume, such as `/dev/ubi0_0`, or by using the device node for the
    whole partition plus the volume name, as shown here:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Creating a filesystem image for UBIFS is a two-stage process. First, you create
    a UBIFS image using `mkfs.ubifs`, and then embed it into a UBI volume using `ubinize`.
    For the first stage, `mkfs.ubifs` needs to be informed of the page size with `-m`,
    the size of the UBI LEB with `-e`, and the maximum number of erase blocks in the
    volume with `-c`. If the first volume is 32 MB and an erase block is 128 KB, then
    the number of erase blocks is 256\. So, to take the contents of the `rootfs` directory
    and create a UBIFS image named `rootfs.ubi`, type the following:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The second stage requires you to create a configuration file for `ubinize`
    that describes the characteristics of each volume in the image. The help page
    (`ubinize -h`) provides details about the format. This example creates two volumes
    (`vol_1` and `vol_2`):'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The second volume has an auto-resize flag and so will expand to fill the remaining
    space on the MTD partition. Only one volume can have this flag. From this information,
    `ubinize` will create an image file named by the `-o` parameter, with the PEB
    size as `-p`, the page size as `-m`, and the sub-page size as `-s`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To install this image on the target, you would enter these commands on the
    target:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If you want to boot with a UBIFS root filesystem, you will need to provide
    these kernel command-line parameters:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: UBIFS completes our survey of filesystems for raw NOR and NAND flash memory.
    Next, we’ll look at filesystems for managed flash.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Filesystems for managed flash
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the trend toward managed flash technologies continues, particularly eMMC,
    we need to consider how to use them effectively. While they appear to have the
    same characteristics as hard disk drives, the underlying NAND flash chips have
    the limitations of large erase blocks with limited erase cycles and bad block
    handling. We also need robustness in the event of power loss.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to use any of the normal disk filesystems, but we should try
    to choose one that reduces disk writes and has a fast restart after an unscheduled
    shutdown.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Flashbench
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make optimum use of the underlying flash memory, you need to know the erase
    block size and page size. Manufacturers do not publish these numbers as a rule,
    but it is possible to deduce them by observing the behavior of the chip or card.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Flashbench is one such tool. It was initially written by Arnd Bergman as described
    in the LWN article available at [https://lwn.net/Articles/428584](https://lwn.net/Articles/428584).
    You can get the code from [https://github.com/bradfa/flashbench](https://github.com/bradfa/flashbench).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a typical run on a SanDisk 4 GB SDHC card:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this case, `flashbench` reads blocks of 1,024 bytes just before and just
    after various power-of-two boundaries. As you cross a page or erase a block boundary,
    the reads after the boundary take longer. The rightmost column shows the difference
    and is the one that is most interesting. Reading from the bottom, there is a big
    jump at 4 KB, which is the most likely size of a page. There is a second jump
    from 52.4µs to 349µs at 8 KB. This is fairly common and indicates that the card
    can use multi-plane access to read two 4 KB pages at the same time. Beyond that,
    the differences are less well marked, but there is a clear jump from 485µs to
    805µs at 512 KB, which is probably the erase block’s size. Given that the card
    being tested is quite old, these are the sort of numbers you would expect.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Discard and TRIM
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Usually, when you delete a file, only the modified directory node is written
    to storage while the sectors containing the file’s contents remain unchanged.
    When the flash translation layer is in the disk controller, as with managed flash,
    it does not know that this group of disk sectors no longer contains useful data
    and so it ends up copying stale data.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: In the last few years, the addition of transactions that pass information about
    deleted sectors down to the disk controller has improved this situation. The SCSI
    and SATA specifications have a `TRIM` command, and MMC has a similar command named
    `ERASE`. In Linux, this feature is known as **discard**.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: To make use of discard, you need a storage device that supports it – most current
    eMMC chips do – and a Linux device driver to match. You can check this by looking
    at the block system queue parameters in `/sys/block/<block device>/queue/`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: 'The ones of interest are as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '`discard_granularity`: The size of the internal allocation unit of the device.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`discard_max_bytes`: The maximum number of bytes that can be discarded in one
    go.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`discard_zeroes_data`: If this is set to `1`, discarded data will be set to
    0.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the device or the device driver does not support discard, these values will
    all be set to `0`. As an example, these are the parameters you will see from the
    2 GB eMMC chip on my BeagleBone Black:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: More information can be found in the `Documentation/block/queue-sysfs.txt` kernel
    documentation file.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: You can enable discard when mounting a filesystem by adding the `-o` discard
    option to the mount command. Both ext4 and F2FS support it.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip**'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that the storage device supports discard before using the `-o` discard
    mount option as data loss can occur.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to force discard from the command line independently of
    how the partition is mounted using the `fstrim` command, which is part of the
    `util-linux` package. Typically, you would run this command periodically to free
    up unused space. `fstrim` operates on a mounted filesystem so to trim the root
    filesystem, you would type the following:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The preceding example uses the `-v` verbose option so that it prints out the
    number of bytes that have been potentially freed up. In this case, 2,061,000,704
    is the approximate amount of free space in the filesystem, so it is the maximum
    amount of storage that could have been trimmed.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Ext4
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **extended filesystem** (**ext**) has been the main filesystem for Linux
    desktops since 1992\. The current version (**ext4**) is very stable, well-tested,
    and has a journal that makes recovering from an unscheduled shutdown fast and
    mostly painless. It is a good choice for managed flash devices, and you will find
    that it is the preferred filesystem for Android devices that have eMMC storage.
    If the device supports discard, you can mount an ext4 filesystem on it with the
    `-o` discard option.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: 'To format and create an ext4 filesystem at runtime, type the following:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To create a filesystem image at build time, you can use the `genext2fs` utility
    available from [https://github.com/bestouff/genext2fs](https://github.com/bestouff/genext2fs).
    In this example, I have specified the block size with `-B` and the number of blocks
    in the image with `-b`:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`genext2fs` can make use of a device table to set the file permissions and
    ownership as described in [*Chapter 5*](Chapter_05.xhtml#_idTextAnchor138) with
    `-D <file table>`.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: 'As the name implies, this will generate an image in ext2 format. You can upgrade
    to ext4 using tune2fs as follows (details of the command’s options can be found
    on the `tune2fs(8)` manual page):'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Both The Yocto Project and Buildroot use exactly these steps when creating images
    in ext4 format.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: While a journal is an asset for devices that may power down without warning,
    it does add extra write cycles to each write transaction, wearing out the flash
    memory. If the device is battery-powered, especially if the battery is not removable,
    the chances of an unscheduled power down are small, so you may want to leave the
    journal out.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Even with journaling, filesystem corruption can occur on unexpected power loss.
    In many devices, holding down the power button, unplugging the power cord, or
    pulling out the battery can result in immediate shutdown.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Due to the nature of buffered I/O, data being written out to flash may be lost
    if the power goes out before the write is done flushing to storage. For these
    reasons, it is good to run `fsck` non-interactively on a user partition to check
    for and repair any filesystem corruption before mounting. Otherwise, the corruption
    can compound over time until it becomes a serious issue.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: F2FS
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Flash-Friendly File System** (**F2FS**) is a log-structured filesystem
    designed for managed flash devices, especially eMMC chips and SD cards. It was
    written by Samsung and was merged into mainline Linux in 3.8\. It is marked as
    experimental, indicating that it has not been extensively deployed yet, but it
    seems that some Android devices are using it.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: F2FS takes into account the page and erase block sizes and then tries to align
    data on these boundaries. The log format provides resilience in the face of power
    down and also provides good write performance. In some tests, F2FS shows a twofold
    improvement over ext4\. There is a good description of the design of F2FS in the
    `Documentation/filesystems/f2fs.txt` kernel documentation file and there are references
    at the end of this chapter in the *Further study* section.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: 'The `mkfs.f2fs` utility creates an empty F2FS filesystem with the `-l` label:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: There isn’t a tool you can use to create F2FS filesystem images offline yet.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: FAT16/32
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The old Microsoft filesystems (FAT16 and FAT32) continue to be important as
    a common format understood by most operating systems. When you buy an SD card
    or USB flash drive, it is almost certain to be formatted as FAT32, and, in some
    cases, the on-card microcontroller is optimized for FAT32 access patterns. Also,
    some boot ROMs require a FAT partition for the second-stage bootloader. However,
    FAT formats are definitely not suitable for storing critical files because they
    are prone to corruption and make poor use of the storage space.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: 'Linux supports FAT16 through both the `msdos` and `vfat` filesystems, but FAT32
    is only supported through the `vfat` filesystem. To mount a device, say an SD
    card, on the second MMC hardware adapter, type this:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '**Important note**'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: In the past, there have been licensing issues with the `vfat` driver, which
    may (or may not) infringe a patent held by Microsoft.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: FAT32 has a limitation of 32 GB on the device’s size. Devices of a larger capacity
    may be formatted using the Microsoft exFAT format and it is a requirement for
    SDXC cards. There is no kernel driver for exFAT, but it can be supported by means
    of a user space FUSE driver. Since exFAT is proprietary to Microsoft, there are
    bound to be licensing implications if you support this format on your device.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 'That does it for read-write filesystems geared toward managed flash. What about
    space-saving read-only filesystems? The choice is simple: SquashFS.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: Read-only compressed filesystems
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Compressing data is useful if you don’t have quite enough storage to fit everything
    in. Both JFFS2 and UBIFS do on-the-fly data compression by default. However, if
    the files are never going to be written, as is usually the case with the root
    filesystem, you can achieve better compression ratios by using a read-only compressed
    filesystem. Linux supports several of these: `romfs`, `cramfs`, and `squashfs`.
    The first two are obsolete now, so I will only describe SquashFS.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: SquashFS
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The SquashFS filesystem was written by Phillip Lougher in 2002 as a replacement
    for `cramfs`. It existed as a kernel patch for a long time, eventually being merged
    into mainline Linux in version 2.6.29 in 2009\. It is very easy to use. You create
    a filesystem image using `mksquashfs` and install it to the flash memory:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The resulting filesystem is read-only so there is no mechanism for modifying
    any of the files at runtime. The only way to update a SquashFS filesystem is to
    erase the whole partition and program in a new image.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: 'SquashFS is not bad-block aware so it must be used with reliable flash memory
    such as NOR flash. However, it can be used on NAND flash as long as you use UBI
    to create an emulated, reliable MTD. You have to enable the `CONFIG_MTD_UBI_BLOCK`
    kernel configuration, which will create a read-only MTD block device for each
    UBI volume. The following diagram shows two MTD partitions, each with accompanying
    `mtdblock` devices. The second partition is also used to create a UBI volume that
    is exposed as a third, reliable `mtdblock` device, which you can use for any read-only
    filesystem that is not bad-block aware:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – UBI volume](img/B18466_09_05.png)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – UBI volume
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: A read-only filesystem is great for immutable contents, but what about temporary
    files that don’t need to persist across reboots? This is where a RAM disk comes
    in handy.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Temporary filesystems
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are always some files that have a short lifetime or have no significance
    after a reboot. Many such files are put into `/tmp`, so it makes sense to keep
    these files from reaching permanent storage.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: 'The temporary filesystem (`tmpfs`) is ideal for this purpose. You can create
    a temporary RAM-based filesystem by simply mounting `tmpfs`:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As with `procfs` and `sysfs`, there is no device node associated with `tmpfs`,
    so you have to supply a placekeeper string, which is `tmp_files` in the preceding
    example.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: 'The amount of memory used will grow and shrink as files are created and deleted.
    The default maximum size is half the physical RAM. In most cases, it would be
    a disaster if `tmpfs` grew to be that large, so it is a very good idea to cap
    it with the `-o` size parameter. The parameter can be given in bytes, KB (k),
    MB (m), or GB (g) like this for example:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In addition to `/tmp`, some subdirectories of `/var` contain volatile data
    and it is good practice to use `tmpfs` for them as well, either by creating a
    separate filesystem for each or, more economically, using symbolic links. Buildroot
    does this like so:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In The Yocto Project, `/run` and `/var/volatile` are `tmpfs` mounts with symbolic
    links pointing to them as shown:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: It is not uncommon to load the root filesystem into RAM on embedded Linux systems.
    That way, any damage to its contents that may occur at runtime is not permanent.
    The root filesystem does not need to reside on SquashFS or `tmpfs` to be protected.
    You just need to make sure the root filesystem is read-only.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Making the root filesystem read-only
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You need to make your target device able to survive unexpected events, including
    file corruption, and still be able to boot and achieve at least a minimum level
    of functionality. Making the root filesystem read-only is a key part of achieving
    this ambition because it eliminates accidental overwrites. Making it read-only
    is easy. Replace `rw` with `ro` on the kernel command line or use an inherently
    read-only filesystem such as SquashFS. However, you will find that there are a
    few files and directories that are traditionally writable:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '`/etc/resolv.conf`: This file is written by network configuration scripts to
    record the addresses of DNS name servers. The information is volatile so you simply
    have to make it a symlink to a temporary directory like `/etc/resolv.conf -> /var/run/resolv.conf`.'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/etc/passwd`: This file, along with `/etc/group`, `/etc/shadow`, and `/etc/gshadow`,
    stores user and group names and passwords. They need to be symbolically linked
    to an area of persistent storage.'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/var/lib`: Many applications expect to be able to write to this directory
    and to keep permanent data here as well. One solution is to copy a base set of
    files to a `tmpfs` filesystem at boot time and then bind mount `/var/lib` to the
    new location. You can do this by putting a sequence of commands such as these
    into one of the boot scripts:'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`/var/log`: This is the place where `syslogd` and other daemons keep their
    logs. Generally, logging to flash memory is not desirable because of the many
    small write cycles it generates. A simple solution is to mount `/var/log` using
    `tmpfs` making all log messages volatile. In the case of `syslogd`, BusyBox has
    a version that can log to a circular ring buffer.'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are using The Yocto Project, you can create a read-only root filesystem
    by adding `IMAGE_FEATURES = "read-only-rootfs"` to `conf/local.conf` or to your
    image recipe.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: Filesystem choices
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have looked at the technology behind solid-state memory and at the
    many types of filesystems. Now it is time to summarize the options that are available.
    In most cases, you will be able to divide your storage requirements into these
    three categories:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '**Permanent, read-write data**: Runtime configuration, network parameters,
    passwords, data logs, and user data'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Permanent, read-only data**: Programs, libraries, and configurations files
    that are constant; for example, the root filesystem'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Volatile data**: Temporary storage; for example, `/tmp`'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The choices for read-write storage are as follows:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '**NOR**: UBIFS or JFFS2'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NAND**: UBIFS, JFFS2, or YAFFS2'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**eMMC**: ext4 or F2FS'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For read-only storage, you can use any of these mounted with the `ro` attribute.
    Additionally, if you want to save space, you could use SquashFS. Finally, for
    volatile storage, there is only one choice: `tmpfs`.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flash memory has been the storage technology of choice for embedded Linux from
    the beginning. Over the years, Linux has gained very good flash memory support
    from low-level drivers up to flash-aware filesystems, with the latest being UBIFS.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: As the rate at which new flash technologies are introduced increases, it is
    becoming harder to keep pace with the changes at the top end. System designers
    are increasingly turning to managed flash in the form of eMMC to provide a stable
    hardware and software interface that is independent of the memory chips inside.
    Embedded Linux developers are beginning to get to grips with these new chips.
    Support for `TRIM` in ext4 and F2FS is well-established, and it is slowly finding
    its way into the chips themselves. Also, the appearance of new filesystems that
    have been optimized to manage flash, such as F2FS, is a welcome step forward.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: However, the fact remains that flash memory is not the same as a hard disk drive.
    You have to be careful when you’re minimizing the number of filesystem writes
    – especially as the higher density TLC chips may be able to support as few as
    1,000 erase cycles.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue with the theme of storage options as we
    consider different ways to keep software up to date on devices that may be deployed
    to remote locations.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: Further study
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*XIP: The past, the present... the future?*, by Vitaly Wool – [https://archive.fosdem.org/2007/slides/devrooms/embedded/Vitaly_Wool_XIP.pdf](https://archive.fosdem.org/2007/slides/devrooms/embedded/Vitaly_Wool_XIP.pdf)'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Optimizing Linux with cheap flash drives*, by Arnd Bergmann – [https://lwn.net/Articles/428584/](https://lwn.net/Articles/428584/)'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*eMMC/SSD File System Tuning Methodology*, Cogent Embedded, Inc. – [https://elinux.org/images/b/b6/EMMC-SSD_File_System_Tuning_Methodology_v1.0.pdf](https://elinux.org/images/b/b6/EMMC-SSD_File_System_Tuning_Methodology_v1.0.pdf)'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Flash-Friendly File System (F2FS)*, by Joo-Young Hwang – [https://elinux.org/images/1/12/Elc2013_Hwang.pdf](https://elinux.org/images/1/12/Elc2013_Hwang.pdf)'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*An F2FS teardown*, by Neil Brown – [https://lwn.net/Articles/518988/](https://lwn.net/Articles/518988/)'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
