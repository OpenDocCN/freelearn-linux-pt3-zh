<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div id="_idContainer040" class="Basic-Text-Frame">
    <h1 class="chapterNumber"><a id="_idTextAnchor061"/>3</h1>
    <h1 id="_idParaDest-56" class="chapterTitle"><a id="_idTextAnchor062"/>All about Bootloaders</h1>
    <p class="normal">The bootloader is the second element of embedded Linux. It is the part that starts the system and loads the operating system kernel. In this chapter, we will look at the role of the bootloader and how it <a id="_idIndexMarker164"/>passes control from itself to the kernel using a data structure called a <strong class="keyWord">device tree</strong>, also known as a <strong class="keyWord">flattened device tree</strong> or <strong class="keyWord">FDT</strong>.</p>
    <p class="normal">I will cover the basics of device trees so <a id="_idIndexMarker165"/>that you will be able to follow the connections described in a device tree and relate them to real hardware. I will focus on a popular open source bootloader known as U-Boot and show you how to use it to boot a target device. I will also show you how to customize U-Boot to run on a new device using BeaglePlay as an example.</p>
    <p class="normal">In this chapter, we will cover the following topics:</p>
    <ul>
      <li class="bulletList">What does a bootloader do?</li>
      <li class="bulletList">Boot sequence</li>
      <li class="bulletList">Moving from the bootloader to the kernel</li>
      <li class="bulletList">Introducing device trees</li>
      <li class="bulletList">U-Boot</li>
    </ul>
    <h1 id="_idParaDest-57" class="heading-1"><a id="_idTextAnchor063"/>Technical requirements</h1>
    <p class="normal">To work through the examples, make sure you have the following:</p>
    <ul>
      <li class="bulletList">An Ubuntu 24.04 or later LTS host system with <code class="inlineCode">device-tree-compiler</code>, <code class="inlineCode">git</code>, <code class="inlineCode">make</code>, <code class="inlineCode">patch</code>, and <code class="inlineCode">u-boot-tools</code> installed</li>
      <li class="bulletList">A Bootlin toolchain for BeaglePlay from <a href="Chapter_01.xhtml#_idTextAnchor028"><em class="italic">Chapter 2</em></a></li>
      <li class="bulletList">A microSD card reader and card</li>
      <li class="bulletList">A USB-to-TTL serial cable with a 3.3 V logic level</li>
      <li class="bulletList">BeaglePlay</li>
      <li class="bulletList">A 5 V USB-C power supply capable of delivering 3 A</li>
    </ul>
    <p class="normal">All of the code for this chapter can be found in the <code class="inlineCode">Chapter03</code> folder from the book’s GitHub repository: <a href="https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter03"><span class="url">https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter03</span></a>.</p>
    <h1 id="_idParaDest-58" class="heading-1"><a id="_idTextAnchor064"/>What does a bootloader do?</h1>
    <p class="normal">In an embedded Linux system, the bootloader has two main jobs: initializing the system to a basic level and loading the kernel. In fact, the first job is somewhat subsidiary to the second in that it is only necessary to get as <a id="_idIndexMarker166"/>much of the system working as is needed to load the kernel.</p>
    <p class="normal">When the first lines of the bootloader code are executed, following a power-on or reset, the system is in a very minimal state. The <strong class="keyWord">Dynamic Random Access Memory</strong> (<strong class="keyWord">DRAM</strong>) controller is not set up, so the main memory is not accessible. Likewise, other interfaces are not configured, so storage that’s accessed via <strong class="keyWord">NAND </strong>(<strong class="keyWord">NOT AND</strong>)<strong class="keyWord"> flash</strong> controllers, <strong class="keyWord">MultiMediaCard</strong> (<strong class="keyWord">MMC</strong>) controllers, and so on is unavailable. Typically, the only resources that are operational at the beginning are a single CPU core, some on-chip <strong class="keyWord">Static Random Access Memory</strong> (<strong class="keyWord">SRAM</strong>), and the boot <strong class="keyWord">Read-Only Memory</strong> (<strong class="keyWord">ROM</strong>).</p>
    <p class="normal">A system bootstrap consists of several phases of code, each bringing more of the system into operation. The final act of the bootloader is to load the kernel into RAM and create an execution environment for it. The details of the interface between the bootloader and the kernel are architecture-specific, but in each case, it has to do two things. First, the bootloader has to pass a pointer to a structure containing information about the hardware configuration. Second, it has to pass a pointer to the kernel command line.</p>
    <p class="normal">The kernel command line is a text string that controls the behavior of Linux. Once the kernel has begun executing, the bootloader is no longer needed and all the memory it was using can be reclaimed.</p>
    <p class="normal">A subsidiary job of the bootloader is to provide a maintenance mode for updating boot configurations, loading new boot images into memory, and maybe running diagnostics. This is usually controlled by a simple command-line user interface, commonly over a serial console.</p>
    <h1 id="_idParaDest-59" class="heading-1"><a id="_idTextAnchor065"/>Boot sequence</h1>
    <p class="normal">Some years ago, we only needed to place the<a id="_idIndexMarker167"/> bootloader in non-volatile memory at the reset vector of the processor. <strong class="keyWord">NOR </strong>(<strong class="keyWord">NOT OR</strong>)<strong class="keyWord"> flash</strong> memory was common at that time and, since it can be mapped directly into the address space, it was the ideal method of storage. The following diagram shows such a configuration with the <strong class="keyWord">reset vector</strong> at <code class="inlineCode">0xfffffffc</code> at the top end of an area of flash memory:</p>
    <figure class="mediaobject"><img src="../Images/B18466_03_01.png" alt="Figure 3.1 – NOR flash" width="946" height="1034"/></figure>
    <p class="packt_figref">Figure 3.1 – NOR flash</p>
    <p class="normal">The bootloader is linked so that there is a jump instruction at that location that points to the start of the bootloader code. From that point on, the bootloader code running in NOR flash memory can initialize the <a id="_idIndexMarker168"/>DRAM controller so that the main memory – the <strong class="keyWord">DRAM</strong> – becomes available, and then it copies itself into the DRAM. Once fully operational, the bootloader can load the kernel from flash memory into DRAM and transfer control to it.</p>
    <p class="normal">However, once you move away from a simple linearly addressable storage medium such as NOR flash, the boot sequence becomes a complex, multi-stage procedure. The details are very specific to each SoC, but they generally go through the following phases.</p>
    <h2 id="_idParaDest-60" class="heading-2"><a id="_idTextAnchor066"/>Phase 1 – ROM code</h2>
    <p class="normal">In the absence of reliable external <a id="_idIndexMarker169"/>memory, the code that runs immediately after a reset or power-on is stored on-chip in the SoC. This is known as <strong class="keyWord">ROM code</strong>. It is loaded into the chip when it is manufactured, and hence the ROM code is proprietary and cannot be replaced by an open source equivalent.</p>
    <p class="normal">ROM code does not include code to initialize the memory controller because DRAM configurations are highly device-specific, and so it can only use SRAM, which does not require a memory controller. Most embedded SoC designs have a small amount of SRAM on chip, varying in size from as little as 4 KB to several hundred KB.</p>
    <figure class="mediaobject"><img src="../Images/B18466_03_02.png" alt="Figure 3.2 – Phase 1 – ROM code" width="576" height="463"/></figure>
    <p class="packt_figref">Figure 3.2 – Phase 1 – ROM code</p>
    <p class="normal">The ROM code can load a small chunk of code from one of several pre-programmed locations into SRAM. As an example, TI Sitara chips try to load code from the first few pages of NAND flash memory, or from flash memory <a id="_idIndexMarker170"/>connected through a <strong class="keyWord">Serial Peripheral Interface</strong> (<strong class="keyWord">SPI</strong>). They also try to load code from the first sectors of an MMC device like an eMMC chip or SD card, or from a file named<strong class="keyWord"> MLO</strong> (<strong class="keyWord">Memory Loader</strong>) on the first partition of an MMC device. If reading from all these<a id="_idIndexMarker171"/> memory devices fails, then it tries reading a byte stream from Ethernet, USB, or UART. The latter is provided mainly as a way to load code into flash memory at production rather than for use in normal operation.</p>
    <p class="normal">Most embedded SoCs have<a id="_idIndexMarker172"/> ROM code that works in a similar way. In SoCs where the SRAM is not large enough to load a full bootloader such as U-Boot, there needs to be an intermediate <a id="_idIndexMarker173"/>loader called the <strong class="keyWord">Secondary Program Loader</strong> (<strong class="keyWord">SPL</strong>). At the end of the ROM code phase, the SPL is present in the SRAM and the ROM code jumps to the beginning of that code.</p>
    <h2 id="_idParaDest-61" class="heading-2"><a id="_idTextAnchor067"/>Phase 2 – Secondary Program Loader</h2>
    <p class="normal">The SPL must set up the memory controller and other essential parts of the system in preparation for <a id="_idIndexMarker174"/>loading the <strong class="keyWord">Tertiary Program Loader</strong> (<strong class="keyWord">TPL</strong>) into DRAM. The functionality of the SPL is limited by the size<a id="_idIndexMarker175"/> of the SRAM. It can read a program from a list of storage devices, as can the ROM code, once again using pre-programmed offsets from the start of a flash device.</p>
    <p class="normal">If the SPL has filesystem drivers built into it, it can read well-known filenames such as <code class="inlineCode">u-boot.img</code> from a disk partition. The SPL usually doesn’t allow any user interaction, but it may print version information and progress messages that you can see on the console. The following diagram displays the phase 2 architecture:</p>
    <figure class="mediaobject"><img src="../Images/B18466_03_03.png" alt="Figure 3.3 – Phase 2 – SPL" width="737" height="1076"/></figure>
    <p class="packt_figref">Figure 3.3 – Phase 2 – SPL</p>
    <p class="normal">The preceding diagram shows the jump from ROM code to SPL. As the SPL executes within SRAM, it loads the TPL into<a id="_idIndexMarker176"/> DRAM. At the end of the second phase, the TPL is present in DRAM and the SPL can make a jump to that area.</p>
    <p class="normal">The SPL may be open source, as is the case with Atmel AT91Bootstrap, but it is quite common for it to contain proprietary code that is supplied by the manufacturer as a binary blob.</p>
    <h2 id="_idParaDest-62" class="heading-2"><a id="_idTextAnchor068"/>Phase 3 – Tertiary Program Loader</h2>
    <p class="normal">At this point, we are running a full bootloader, such as U-Boot, which we will learn about a bit later in this chapter. Usually, there is a <a id="_idIndexMarker177"/>simple command-line user interface that lets you perform maintenance tasks such as loading new boot and kernel images into flash storage, as well as a way to load the kernel automatically without user intervention. The following diagram explains the phase 3 architecture:</p>
    <figure class="mediaobject"><img src="../Images/B18466_03_04.png" alt="Figure 3.4 – Phase 3 – TPL" width="878" height="1165"/></figure>
    <p class="packt_figref">Figure 3.4 – Phase 3 – TPL</p>
    <p class="normal">The preceding diagram shows the jump from SPL in SRAM to TPL in DRAM. As the TPL executes, it loads the kernel into DRAM. We also have the choice of appending an FDT and/or initial RAM disk to the image in DRAM if we want. Either way, at the end of the third phase, there is a kernel in memory waiting to be started.</p>
    <p class="normal">Embedded bootloaders <a id="_idIndexMarker178"/>usually disappear from memory once the kernel is running and have no further part in the operation of the system. Before that happens, the TPL needs to hand off control of the boot process to the kernel.</p>
    <h1 id="_idParaDest-63" class="heading-1"><a id="_idTextAnchor069"/>Moving from the bootloader to the kernel</h1>
    <p class="normal">When the bootloader <a id="_idIndexMarker179"/>passes control to the kernel, it has to pass some basic information, which includes the following:</p>
    <ul>
      <li class="bulletList">The machine number, which is used on PowerPC and Arm platforms without support for a device tree, to identify the type of the SoC</li>
      <li class="bulletList">Basic details of the hardware that’s been detected so far, including (at the very least) the size and location of the physical RAM and the CPU’s clock speed</li>
      <li class="bulletList">The kernel command line</li>
      <li class="bulletList">Optionally, the location and size of a device tree binary</li>
      <li class="bulletList">Optionally, the location and size of an initial <a id="_idIndexMarker180"/>RAM disk, called the <strong class="keyWord">initial RAM file system</strong> (<strong class="keyWord">initramfs</strong>)</li>
    </ul>
    <p class="normal">The kernel command line is a plain ASCII string that controls the behavior of Linux by giving it, for example, the name of the device that contains the root filesystem. We will look at the kernel command line in detail in the next chapter. It is common to provide the root filesystem as a RAM disk, in which <a id="_idIndexMarker181"/>case it is the responsibility of the bootloader to load the RAM disk image into memory. We will cover how to create initial RAM disks in <a href="Chapter_05.xhtml#_idTextAnchor138"><em class="italic">Chapter 5</em></a>.</p>
    <p class="normal">The way this information is passed is dependent on the architecture and has changed in recent years. For instance, with PowerPC, the bootloader simply used to pass a pointer to a board information structure, whereas with Arm, it passed a pointer to a list of A tags. There is a good description of the format of A tags in the kernel source tree at <code class="inlineCode">Documentation/arch/arm/booting.rst</code>. Browse the kernel source tree at <a href="https://github.com/torvalds/linux"><span class="url">https://github.com/torvalds/linux</span></a>.</p>
    <p class="normal">In both cases, the amount of information being passed is very limited, leaving the bulk to be discovered at runtime or hard-coded into the kernel as <strong class="keyWord">platform data</strong>. The widespread use of platform data meant that each board had to have a kernel configured and modified for that platform. A better way was needed, and that way is the device tree.</p>
    <p class="normal">In the Arm world, the move away from A tags began in earnest in February 2013 with the release of Linux 3.8. Today, almost all Arm systems use device trees to gather information about the specifics of the hardware platform. This allows a single kernel binary to run on a wide range of Arm platforms.</p>
    <p class="normal">Now that we’ve learned what a bootloader does, what the stages of the boot sequence are, and how it passes control to the kernel, let’s learn how to configure a bootloader so that it runs on popular embedded SoCs.</p>
    <h1 id="_idParaDest-64" class="heading-1"><a id="_idTextAnchor070"/>Introducing device trees</h1>
    <p class="normal">If you are working with Arm or PowerPC SoCs, you are almost certainly going to encounter device trees at some point. This section <a id="_idIndexMarker182"/>aims to give you a quick overview of what they are and how they work. We will revisit the topic of device trees repeatedly throughout the course of this book.</p>
    <p class="normal">A device tree is a flexible way of defining the hardware components of a computer system. Bear in mind that a device tree is just static data, not executable code. Usually, the device tree is loaded by the bootloader and passed to the kernel, although it is possible to bundle the device tree with the kernel image itself to cater to bootloaders that are not capable of loading them separately.</p>
    <p class="normal">The format is derived from a Sun Microsystems bootloader known as <strong class="keyWord">OpenBoot</strong>, which was formalized as the Open Firmware specification (IEEE standard IEEE1275-1994). It was used in PowerPC-based Macintosh computers and so was a logical choice for the PowerPC Linux port. Since then, it has been adopted at a large scale by the many Arm Linux implementations and, to a lesser extent, by MIPS, MicroBlaze, ARC, and other architectures.</p>
    <p class="normal">I recommend visiting <a href="https://www.devicetree.org"><span class="url">https://www.devicetree.org</span></a> for more information.</p>
    <h2 id="_idParaDest-65" class="heading-2"><a id="_idTextAnchor071"/>Device tree basics</h2>
    <p class="normal">The Linux kernel contains a large number of device tree source files in <code class="inlineCode">arch/$ARCH/boot/dts</code>, and this is a good starting <a id="_idIndexMarker183"/>point for learning about device trees. Additionally, the U-Boot source code contains a smaller number of sources in <code class="inlineCode">arch/$ARCH/dts</code>. If you acquired your hardware from a third party, the <code class="inlineCode">dts</code> file forms part of the board support package, so you should expect to receive one along with the other source files.</p>
    <p class="normal">The device tree represents a computer system as a collection of components joined together in a hierarchy. Every device tree begins with a root node represented by a forward slash, <code class="inlineCode">/</code>, which contains subsequent child nodes describing the hardware of the system. Each node has a name and contains several properties in the form <code class="inlineCode">name = "value"</code>. Here is a simple example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">/dts-v1/</span><span class="hljs-punctuation">;</span>
<span class="hljs-title">/</span><span class="hljs-punctuation">{</span>
    <span class="hljs-attr">model</span> <span class="hljs-operator">=</span> <span class="hljs-string">"TI AM335x BeagleBone"</span><span class="hljs-punctuation">;</span>
    <span class="hljs-attr">compatible</span> <span class="hljs-operator">=</span> <span class="hljs-string">"ti,am33xx"</span><span class="hljs-punctuation">;</span>
    <span class="hljs-meta">#address-cells = &lt;1&gt;;</span>
    <span class="hljs-meta">#size-cells = &lt;1&gt;;</span>
    <span class="hljs-title">cpus</span> <span class="hljs-punctuation">{</span>
        <span class="hljs-meta">#address-cells = &lt;1&gt;;</span>
        <span class="hljs-meta">#size-cells = &lt;0&gt;;</span>
        <span class="hljs-title">cpu@0</span> <span class="hljs-punctuation">{</span>
            <span class="hljs-attr">compatible</span> <span class="hljs-operator">=</span> <span class="hljs-string">"arm,cortex-a8"</span><span class="hljs-punctuation">;</span>
            device_<span class="hljs-attr">type</span> <span class="hljs-operator">=</span> <span class="hljs-string">"cpu"</span><span class="hljs-punctuation">;</span>
            <span class="hljs-attr">reg</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;</span><span class="hljs-number">0</span><span class="hljs-params">&gt;</span><span class="hljs-punctuation">;</span>
        <span class="hljs-punctuation">};</span>
    <span class="hljs-punctuation">};</span>
    <span class="hljs-title">memory@80000000</span> <span class="hljs-punctuation">{</span>
        device_<span class="hljs-attr">type</span> <span class="hljs-operator">=</span> <span class="hljs-string">"memory"</span><span class="hljs-punctuation">;</span>
        <span class="hljs-attr">reg</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;</span><span class="hljs-number">0x80000000</span><span class="hljs-params"> </span><span class="hljs-number">0x20000000</span><span class="hljs-params">&gt;</span><span class="hljs-punctuation">;</span> <span class="hljs-comment">/* 512 MB */</span>
    <span class="hljs-punctuation">};</span>
<span class="hljs-punctuation">};</span>
</code></pre>
    <p class="normal">Here, we have a root node that contains a <code class="inlineCode">cpus</code> node and a <code class="inlineCode">memory</code> node. The <code class="inlineCode">cpus</code> node contains a single CPU node named <code class="inlineCode">cpu@0</code>. The names of these nodes often include an <code class="inlineCode">@</code> followed by an address that distinguishes the node from other nodes of the same type. <code class="inlineCode">@</code> is required if the node has a <code class="inlineCode">reg</code> property.</p>
    <p class="normal">Both the root and CPU nodes have a <code class="inlineCode">compatible</code> property. The Linux kernel uses this property to find a matching device driver by <a id="_idIndexMarker184"/>comparing it with the strings that are exported by each device driver in an <code class="inlineCode">of_device_id</code> structure (more on this in <a href="Chapter_11.xhtml#_idTextAnchor373"><em class="italic">Chapter 11</em></a>).</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">IMPORTANT NOTE</strong></p>
      <p class="normal">It is a convention that the value of the <code class="inlineCode">compatible</code> property is composed of a manufacturer name and a component name to reduce confusion between similar devices made by different manufacturers, hence <code class="inlineCode">ti,am33xx</code> and <code class="inlineCode">arm,cortex-a8</code>. It is also quite common to have more than one value for the <code class="inlineCode">compatible</code> property when there is more than one driver that can handle this device. They are listed with the most suitable mentioned first.</p>
    </div>
    <p class="normal">The CPU node and the memory node have a <code class="inlineCode">device_type</code> property that describes the class of the device. The node name is often derived from <code class="inlineCode">device_type</code>.</p>
    <h2 id="_idParaDest-66" class="heading-2"><a id="_idTextAnchor072"/>reg property</h2>
    <p class="normal">The <code class="inlineCode">memory</code> and <code class="inlineCode">cpu</code> nodes shown earlier have a <code class="inlineCode">reg</code> property, which refers to a range of units in a register space. A <code class="inlineCode">reg</code> property<a id="_idIndexMarker185"/> consists of two values representing the real physical address and the size (length) of the range. Both are written as zero or more 32-bit integers called cells. Hence, the previous <code class="inlineCode">memory</code> node refers to a single bank of memory that begins at <code class="inlineCode">0x80000000</code> and is <code class="inlineCode">0x20000000</code> bytes long.</p>
    <p class="normal">Understanding <code class="inlineCode">reg</code> properties becomes more complex when the address or size values cannot be represented in 32 bits. For example, on a device with 64-bit addressing, you need two cells for each:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-title">/</span><span class="hljs-punctuation">{</span>
    <span class="hljs-meta">#address-cells = &lt;2&gt;;</span>
    <span class="hljs-meta">#size-cells = &lt;2&gt;;</span>
    <span class="hljs-title">memory@80000000</span> <span class="hljs-punctuation">{</span>
        device_<span class="hljs-attr">type</span> <span class="hljs-operator">=</span> <span class="hljs-string">"memory"</span><span class="hljs-punctuation">;</span>
        <span class="hljs-attr">reg</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;</span><span class="hljs-number">0x00000000</span><span class="hljs-params"> </span><span class="hljs-number">0x80000000</span><span class="hljs-params"> </span><span class="hljs-number">0</span><span class="hljs-params"> </span><span class="hljs-number">0x80000000</span><span class="hljs-params">&gt;</span><span class="hljs-punctuation">;</span>
    <span class="hljs-punctuation">};</span>
<span class="hljs-punctuation">};</span>
</code></pre>
    <p class="normal">The information about the number of cells required is held in the <code class="inlineCode">#address-cells</code> and <code class="inlineCode">#size_cells</code> properties in an ancestor node. In other words, to understand a <code class="inlineCode">reg</code> property, you have to look backward down the node hierarchy until you find <code class="inlineCode">#address-cells</code> and <code class="inlineCode">#size_cells</code>. If there are none, the default values are <code class="inlineCode">1</code> for each – but it is bad practice for device tree writers to depend on defaults. Default values may or may not be obvious, so being explicit prevents any misunderstandings.</p>
    <p class="normal">Now, let’s return to the <code class="inlineCode">cpu</code> and <code class="inlineCode">cpus</code> nodes. CPUs have addresses as well. In a quadcore device, they might be addressed as <code class="inlineCode">0</code>, <code class="inlineCode">1</code>, <code class="inlineCode">2</code>, and <code class="inlineCode">3</code>. That can be thought of as a one-dimensional array without any depth, so the size is zero. Therefore, you can see that we have <code class="inlineCode">#address-cells = &lt;1&gt;</code> and <code class="inlineCode">#size-cells = &lt;0&gt;</code> in the <code class="inlineCode">cpus</code> node. And in the child node, <code class="inlineCode">cpu@0</code>, we assign a single value to the <code class="inlineCode">reg</code> property with <code class="inlineCode">reg = &lt;0&gt;</code>.</p>
    <h2 id="_idParaDest-67" class="heading-2"><a id="_idTextAnchor073"/>Labels and interrupts</h2>
    <p class="normal">The structure of the device tree described so far assumes that there is a single hierarchy of components when there are, in fact, several. Besides the obvious data connection between a component and other parts of the<a id="_idIndexMarker186"/> system, a node might also be connected to an interrupt controller, to a clock source, and to a voltage regulator. </p>
    <p class="normal">To express these connections, we can add a label to a node and reference the label from other nodes. These labels are sometimes referred <a id="_idIndexMarker187"/>to as <strong class="keyWord">phandles</strong> because when the device tree is compiled, nodes with a reference from another node are assigned a unique numerical value in a property called <code class="inlineCode">phandle</code>.</p>
    <p class="normal">You can see phandles if you decompile the device tree binary. Take as an example a system containing an LCD controller that can generate <code class="inlineCode">interrupts</code> and an <code class="inlineCode">interrupt-controller</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">/dts-v1/</span><span class="hljs-punctuation">;</span>
<span class="hljs-punctuation">{</span>
<span class="hljs-symbol">    intc:</span> <span class="hljs-title">interrupt-controller@48200000</span> <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">compatible</span> <span class="hljs-operator">=</span> <span class="hljs-string">"ti,am33xx-intc"</span><span class="hljs-punctuation">;</span>
        <span class="hljs-attr">interrupt-controller</span><span class="hljs-punctuation">;</span>
        <span class="hljs-meta">#interrupt-cells = &lt;1&gt;;</span>
        <span class="hljs-attr">reg</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;</span><span class="hljs-number">0x48200000</span><span class="hljs-params"> </span><span class="hljs-number">0x1000</span><span class="hljs-params">&gt;</span><span class="hljs-punctuation">;</span>
    <span class="hljs-punctuation">};</span>
<span class="hljs-symbol">    lcdc:</span> <span class="hljs-title">lcdc@4830e000</span> <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">compatible</span> <span class="hljs-operator">=</span> <span class="hljs-string">"ti,am33xx-tilcdc"</span><span class="hljs-punctuation">;</span>
        <span class="hljs-attr">reg</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;</span><span class="hljs-number">0x4830e000</span><span class="hljs-params"> </span><span class="hljs-number">0x1000</span><span class="hljs-params">&gt;</span><span class="hljs-punctuation">;</span>
        <span class="hljs-attr">interrupt-parent</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;</span><span class="hljs-variable">&amp;intc</span><span class="hljs-params">&gt;</span><span class="hljs-punctuation">;</span>
        <span class="hljs-attr">interrupts</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;</span><span class="hljs-number">36</span><span class="hljs-params">&gt;</span><span class="hljs-punctuation">;</span>
        <span class="hljs-attr">ti,hwmods</span> <span class="hljs-operator">=</span> <span class="hljs-string">"lcdc"</span><span class="hljs-punctuation">;</span>
        <span class="hljs-attr">status</span> <span class="hljs-operator">=</span> <span class="hljs-string">"disabled"</span><span class="hljs-punctuation">;</span>
    <span class="hljs-punctuation">};</span>
<span class="hljs-punctuation">};</span>
</code></pre>
    <p class="normal">Here, we have the <code class="inlineCode">interrupt-controller@48200000</code> node with a label of <code class="inlineCode">intc</code>. The <code class="inlineCode">interrupt-controller</code> property identifies it as an interrupt controller. Like all interrupt controllers, it has an <code class="inlineCode">#interrupt-cells</code> property, which tells us how many cells are needed to represent an interrupt source. In this case, there<a id="_idIndexMarker188"/> is only one that represents the <strong class="keyWord">Interrupt Request</strong> (<strong class="keyWord">IRQ</strong>) number.</p>
    <p class="normal">Other interrupt controllers may use additional cells to characterize the interrupt, for example, to indicate whether it is edge or level triggered. The number of interrupt cells and their meanings are described in the bindings for each interrupt controller. The device tree bindings can be found in the Linux kernel source in the <code class="inlineCode">Documentation/devicetree/bindings</code> directory.</p>
    <p class="normal">Looking at the <code class="inlineCode">lcdc@4830e000</code> node, it has an <code class="inlineCode">interrupt-parent</code> property, which references the interrupt controller it is connected to using the label. It also has an <code class="inlineCode">interrupts</code> property, which is <code class="inlineCode">36</code> in this<a id="_idIndexMarker189"/> case. Note that this node has its own label, <code class="inlineCode">lcdc</code>, which is used elsewhere. Any node can have a label.</p>
    <h2 id="_idParaDest-68" class="heading-2"><a id="_idTextAnchor074"/>Device tree include files</h2>
    <p class="normal">A lot of hardware is common between SoCs of the same family and between boards using the same SoC. This is reflected in the <a id="_idIndexMarker190"/>device tree by splitting out common sections into <code class="inlineCode">include</code> files, usually with the <code class="inlineCode">.dtsi</code> extension. The Open Firmware standard defines <code class="inlineCode">/include/</code> as the mechanism to be used, as in this snippet from <code class="inlineCode">vexpress-v2p-ca9.dts</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">/include/</span> <span class="hljs-string">"vexpress-v2m.dtsi"</span>
</code></pre>
    <p class="normal">Look through the <code class="inlineCode">.dts</code> files in the kernel and you will find an alternative <code class="inlineCode">include</code> statement that is borrowed from C; for example, this is in <code class="inlineCode">am335x-boneblack.dts</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">#</span><span class="hljs-keyword">include</span><span class="hljs-meta"> </span><span class="hljs-string">"am33xx.dtsi"</span>
<span class="hljs-meta">#</span><span class="hljs-keyword">include</span><span class="hljs-meta"> </span><span class="hljs-string">"am335x-bone-common.dtsi"</span>
</code></pre>
    <p class="normal">Here is another example from <code class="inlineCode">am33xx.dtsi</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">#</span><span class="hljs-keyword">include</span><span class="hljs-meta"> </span><span class="hljs-string">&lt;dt-bindings/gpio/gpio.h&gt;</span>
<span class="hljs-meta">#</span><span class="hljs-keyword">include</span><span class="hljs-meta"> </span><span class="hljs-string">&lt;dt-bindings/pinctrl/am33xx.h&gt;</span>
<span class="hljs-meta">#</span><span class="hljs-keyword">include</span><span class="hljs-meta"> </span><span class="hljs-string">&lt;dt-bindings/clock/am3.h&gt;</span>
</code></pre>
    <p class="normal">Lastly, <code class="inlineCode">include/dt-bindings/pinctrl/am33xx.h</code> contains normal C macros:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">#</span><span class="hljs-keyword">define</span><span class="hljs-meta"> PULL_DISABLE       (1 &lt;&lt; 3)</span>
<span class="hljs-meta">#</span><span class="hljs-keyword">define</span><span class="hljs-meta"> INPUT_EN           (1 &lt;&lt; 5)</span>
<span class="hljs-meta">#</span><span class="hljs-keyword">define</span><span class="hljs-meta"> SLEWCTRL_SLOW      (1 &lt;&lt; 6)</span>
<span class="hljs-meta">#</span><span class="hljs-keyword">define</span><span class="hljs-meta"> SLEWCTRL_FAST             0</span>
</code></pre>
    <p class="normal">All of this is resolved if the device tree sources are built using the Kbuild system, which runs them through the C preprocessor, CPP. CPP processes the <code class="inlineCode">#include</code> and <code class="inlineCode">#define</code> statements into text that is suitable for the device tree compiler. The motivation is illustrated by the previous example. It means that the device tree sources can use the same definitions of constants as the kernel code.</p>
    <p class="normal">When we include files using either syntax, the nodes are overlaid on top of one another to create a composite tree in which the outer layers extend or modify the inner ones. For example, <code class="inlineCode">am33xx.dtsi</code>, which is general to all <code class="inlineCode">am33xx</code> SoCs, defines the first MMC controller interface like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-symbol">mmc1:</span> <span class="hljs-title">mmc@48060000</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">compatible</span> <span class="hljs-operator">=</span> <span class="hljs-string">"ti,omap4-hsmmc"</span><span class="hljs-punctuation">;</span>
    <span class="hljs-attr">ti,hwmods</span> <span class="hljs-operator">=</span> <span class="hljs-string">"mmc1"</span><span class="hljs-punctuation">;</span>
    <span class="hljs-attr">ti,dual-volt</span><span class="hljs-punctuation">;</span>
    <span class="hljs-attr">ti,needs-special-reset</span><span class="hljs-punctuation">;</span>
    <span class="hljs-attr">ti,needs-special-hs-handling</span><span class="hljs-punctuation">;</span>
    <span class="hljs-attr">dmas</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;</span><span class="hljs-variable">&amp;edma_xbar</span><span class="hljs-params"> </span><span class="hljs-number">24</span><span class="hljs-params"> </span><span class="hljs-number">0</span><span class="hljs-params"> </span><span class="hljs-number">0</span>
<span class="hljs-params">            </span><span class="hljs-variable">&amp;edma_xbar</span><span class="hljs-params"> </span><span class="hljs-number">25</span><span class="hljs-params"> </span><span class="hljs-number">0</span><span class="hljs-params"> </span><span class="hljs-number">0</span><span class="hljs-params">&gt;</span><span class="hljs-punctuation">;</span>
    <span class="hljs-attr">dma-names</span> <span class="hljs-operator">=</span> <span class="hljs-string">"tx"</span>, <span class="hljs-string">"rx"</span><span class="hljs-punctuation">;</span>
    <span class="hljs-attr">interrupts</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;</span><span class="hljs-number">64</span><span class="hljs-params">&gt;</span><span class="hljs-punctuation">;</span>
    <span class="hljs-attr">reg</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;</span><span class="hljs-number">0x48060000</span><span class="hljs-params"> </span><span class="hljs-number">0x1000</span><span class="hljs-params">&gt;</span><span class="hljs-punctuation">;</span>
    <span class="hljs-attr">status</span> <span class="hljs-operator">=</span> <span class="hljs-string">"disabled"</span><span class="hljs-punctuation">;</span>
<span class="hljs-punctuation">};</span>
</code></pre>
    <p class="normal">Note that <code class="inlineCode">status</code> is <code class="inlineCode">disabled</code>, meaning that no device driver should be bound to it, and that it has a label of <code class="inlineCode">mmc1</code>.</p>
    <p class="normal">Both BeagleBone and BeagleBone Black have<a id="_idIndexMarker191"/> a microSD card interface attached to <code class="inlineCode">mmc1</code>. This is why, in <code class="inlineCode">am335x-bone-common.dtsi</code>, the same node is referenced by an ampersand and its label, <code class="inlineCode">&amp;mmc1</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-variable">&amp;mmc1</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">status</span> <span class="hljs-operator">=</span> <span class="hljs-string">"okay"</span><span class="hljs-punctuation">;</span>
    <span class="hljs-attr">bus-width</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;</span><span class="hljs-number">0x4</span><span class="hljs-params">&gt;</span><span class="hljs-punctuation">;</span>
    <span class="hljs-attr">pinctrl-names</span> <span class="hljs-operator">=</span> <span class="hljs-string">"default"</span><span class="hljs-punctuation">;</span>
    pinctrl<span class="hljs-number">-0</span> = <span class="hljs-params">&lt;</span><span class="hljs-variable">&amp;mmc1_pins</span><span class="hljs-params">&gt;</span><span class="hljs-punctuation">;</span>
    <span class="hljs-attr">cd-gpios</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;</span><span class="hljs-variable">&amp;gpio0</span><span class="hljs-params"> </span><span class="hljs-number">6</span><span class="hljs-params"> GPIO_ACTIVE_LOW&gt;</span><span class="hljs-punctuation">;</span>
<span class="hljs-punctuation">};</span>
</code></pre>
    <p class="normal">Referencing a node by an ampersand and its label lets us overwrite properties from previous <code class="inlineCode">mmc1</code> entries. Here, the <code class="inlineCode">status</code> property is set to <code class="inlineCode">okay</code>, which causes the MMC device driver to bind with this interface at runtime on both variants of BeagleBone. Also, a reference to a label is added to the pin control configuration, <code class="inlineCode">mmc1_pins</code>. Alas, there is not sufficient space here to describe pin control and pin multiplexing. The Linux kernel source contains some information in the <code class="inlineCode">Documentation/devicetree/bindings/pinctrl</code> directory.</p>
    <p class="normal">However, the <code class="inlineCode">mmc1</code> interface is connected to a different voltage regulator on BeagleBone Black. This is expressed in <code class="inlineCode">am335x-boneblack.dts</code>, where you will see another reference to <code class="inlineCode">mmc1</code>, which associates it with the voltage regulator via the <code class="inlineCode">vmmcsd_fixed</code> label:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-variable">&amp;mmc1</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">vmmc-supply</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;</span><span class="hljs-variable">&amp;vmmcsd_fixed</span><span class="hljs-params">&gt;</span><span class="hljs-punctuation">;</span>
<span class="hljs-punctuation">};</span>
</code></pre>
    <p class="normal">So, layering the device tree source files like this gives us flexibility and reduces the need for duplicated code.</p>
    <h2 id="_idParaDest-69" class="heading-2"><a id="_idTextAnchor075"/>Compiling a device tree</h2>
    <p class="normal">The bootloader and kernel require a binary representation of the device tree, so it has to be compiled using the device tree <a id="_idIndexMarker192"/>compiler, that is, <code class="inlineCode">dtc</code>. The result is a file ending with <code class="inlineCode">.dtb</code>, which is referred to as a device tree binary or a device tree blob.</p>
    <p class="normal">There is a copy of <code class="inlineCode">dtc</code> in the Linux source in <code class="inlineCode">scripts/dtc/dtc</code>, and it is also available as a package on many Linux distributions. You can use it to compile a simple device tree (one that does not use <code class="inlineCode">#include</code>) like this:</p>
    <pre class="programlisting con"><code class="hljs-con">$ dtc simpledts-1.dts -o simpledts-1.dtb
DTC: dts-&gt;dts on file "simpledts-1.dts"
</code></pre>
    <p class="normal">Be wary of the fact that <code class="inlineCode">dtc</code> does not give helpful error messages and makes no checks other than on the basic syntax of the language. This means that debugging a typing error in a device tree source file can be a lengthy process.</p>
    <p class="normal">To build more complex examples, you will have to use the Kbuild kernel as shown in <a href="Chapter_04.xhtml#_idTextAnchor096"><em class="italic">Chapter 4</em></a>.</p>
    <p class="normal">Like the kernel, the bootloader can use a device tree to initialize an embedded SoC and its peripherals. This device tree is critical when you’re loading the kernel from a mass storage device such as a QSPI flash. While embedded Linux offers a choice of bootloaders, we will only cover one. Let’s dig deep into that bootloader next.</p>
    <h1 id="_idParaDest-70" class="heading-1"><a id="_idTextAnchor076"/>U-Boot</h1>
    <p class="normal">We are going to focus on U-Boot exclusively because it supports a good number of processor architectures and most individual <a id="_idIndexMarker193"/>boards and devices. U-Boot, or to give its full name, <strong class="keyWord">Das U-Boot</strong>, began life as an open source bootloader for embedded PowerPC boards. Then, it was ported to Arm-based <a id="_idIndexMarker194"/>boards and later to other architectures, including <strong class="keyWord">Microprocessor without Interlocked Pipeline Stages</strong> (<strong class="keyWord">MIPS</strong>) and <strong class="keyWord">SuperH</strong> (<strong class="keyWord">SH</strong>).</p>
    <p class="normal">U-Boot has been around for a long<a id="_idIndexMarker195"/> time and has a good community. The project is hosted and maintained by DENX Software Engineering. There is plenty of information available on it, and a good place to start is <a href="https://u-boot.readthedocs.io"><span class="url">https://u-boot.readthedocs.io</span></a>. There is also a mailing list at <a href="https://u-boot@lists.denx.de"><span class="url">u-boot@lists.denx.de</span></a> that you can subscribe to by filling out and submitting the form provided at <a href="https://lists.denx.de/listinfo/u-boot"><span class="url">https://lists.denx.de/listinfo/u-boot</span></a>.</p>
    <h2 id="_idParaDest-71" class="heading-2"><a id="_idTextAnchor077"/>Building U-Boot</h2>
    <p class="normal">Begin by getting the<a id="_idIndexMarker196"/> source code. As with most projects, the recommended way is to clone the Git repository and check out the tag you intend to use:</p>
    <pre class="programlisting con"><code class="hljs-con">$ git clone git://git.denx.de/u-boot.git u-boot-mainline
$ cd u-boot-mainline
$ git checkout v2024.04
</code></pre>
    <p class="normal">Alternatively, you can download a tarball from <a href="https://ftp.denx.de/pub/u-boot/"><span class="url">https://ftp.denx.de/pub/u-boot/</span></a>.</p>
    <p class="normal">There are more than 1,000 configuration files for common development boards and devices in the <code class="inlineCode">configs</code> directory. In most cases, you can take a good guess regarding which to use based on the filename. But you can get more detailed information by looking through the <code class="inlineCode">.rst</code> files in the <code class="inlineCode">doc/board</code> directory. Or <a id="_idIndexMarker197"/>you can find information in an appropriate web tutorial or forum.</p>
    <p class="normal">Taking BeaglePlay as an example, we will find that there is a configuration file named <code class="inlineCode">am62x_evm_a53_defconfig</code> in the <code class="inlineCode">configs</code> directory. In that same directory, there is another configuration file named <code class="inlineCode">am62x_evm_r5_defconfig</code> that is for BeaglePlay’s Arm Cortex-R5F microcontroller. The ROM code runs on the Arm Cortex-R5F microcontroller and the TPL runs on the main Arm Cortex-A53 CPU. There are two U-Boot SPLs: one that runs on the R5 and another that runs on the main CPU. There is a sequence diagram explaining BeaglePlay’s unique boot flow in detail inside <code class="inlineCode">doc/board/beagle/am62x_beagleplay.rst</code>. Take a close look at this sequence diagram and make sure you understand it. As you progress through the remainder of this chapter, refer to this diagram for clarification.</p>
    <p class="normal">Building U-Boot for <a id="_idIndexMarker198"/>BeaglePlay is a multi-stage process. The Arm Cortex-M4F and Cortex-R5F in BeaglePlay’s <code class="inlineCode">am62x</code> SoC are 32-bit processors, so they require a 32-bit toolchain. A software <a id="_idIndexMarker199"/>component called <strong class="keyWord">TI Foundational Security</strong> (<strong class="keyWord">TIFS</strong>) runs on the M4. TIFS starts the R5 and asks it to load a firmware image to the TIFS core. That means we need to bundle a TIFS binary firmware image for the M4 together with a U-Boot SPL when generating a bootloader image for the R5. Next, we need to build <strong class="keyWord">Trusted Firmware-A</strong> (<strong class="keyWord">TF-A</strong>) for the<a id="_idIndexMarker200"/> main A53 CPU using a 64-bit toolchain. Lastly, we configure and build a U-Boot SPL and TPL for the main CPU.</p>
    <h3 id="_idParaDest-72" class="heading-3"><a id="_idTextAnchor078"/>Obtaining a 32-bit toolchain</h3>
    <p class="normal">Point your web browser at <a href="https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads"><span class="url">https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads</span></a>. Search for <strong class="screenText">Downloads: 13.2.Rel1</strong> and click <a id="_idIndexMarker201"/>on the plus sign in front to expand that section. Then click on the <code class="inlineCode">arm-gnu-toolchain-13.2.rel1-x86_64-arm-none-eabi.tar.xz</code> file under x86_64 Linux hosted cross toolchains <strong class="keyWord">AArch32 bare-metal target</strong><em class="italic"> </em>(<strong class="keyWord">arm-none-eabi</strong>) to download the toolchain. </p>
    <p class="normal">The following R5 exercises were successfully performed with that version of the Arm GNU toolchain. I recommend downloading the same version from that web page (if it is still available) to prevent any problems.</p>
    <p class="normal">Install the 32-bit toolchain in your home directory:</p>
    <pre class="programlisting con"><code class="hljs-con">$ cd ~
$ tar -xvf ~/Downloads/arm-gnu-toolchain-13.2.rel1-x86_64-arm-none-eabi.tar.xz
</code></pre>
    <p class="normal">Add the 32-bit toolchain to your <code class="inlineCode">PATH</code> environment variable:</p>
    <pre class="programlisting con"><code class="hljs-con">$ export PATH=${HOME}/arm-gnu-toolchain-13.2.Rel1-x86_64-arm-none-eabi/bin/:$PATH
</code></pre>
    <p class="normal">You are now ready to build U-Boot for the R5. Make sure to replace <code class="inlineCode">13.2.rel1</code> and <code class="inlineCode">13.2.Rel1</code> in the preceding commands with the<a id="_idIndexMarker202"/> actual version of the 32-bit toolchain you downloaded.</p>
    <h3 id="_idParaDest-73" class="heading-3"><a id="_idTextAnchor079"/>Building U-Boot SPL for R5</h3>
    <p class="normal">Support for BeaglePlay in mainline U-Boot was very new back in November 2023 when I wrote this. For this reason, I have<a id="_idIndexMarker203"/> instead opted to use BeagleBoard.org’s U-Boot fork for BeaglePlay. I suggest building the U-Boot source from the same Git repo (if it is still available) to<a id="_idIndexMarker204"/> prevent any problems.</p>
    <p class="normal">Clone the U-Boot fork to your home directory and check out a stable commit:</p>
    <pre class="programlisting con"><code class="hljs-con">$ git clone https://github.com/beagleboard/u-boot u-boot-beagleplay
$ cd u-boot-beagleplay
$ git checkout f036fb
</code></pre>
    <p class="normal">Install the packages needed to build U-Boot for BeaglePlay:</p>
    <pre class="programlisting con"><code class="hljs-con">$ sudo apt install bison device-tree-compiler flex libncurses-dev libssl-dev python3-dev python3-setuptools swig
</code></pre>
    <p class="normal">Configure and build U-Boot for the R5:</p>
    <ol>
      <li class="numberedList" value="1">First, create a build directory for the R5 one level up to share build artifacts across builds:
        <pre class="programlisting con"><code class="hljs-con">$ mkdir -p ../build_uboot/r5
</code></pre>
      </li>
      <li class="numberedList">Next, set the <code class="inlineCode">ARCH</code> and <code class="inlineCode">CROSS_COMPILE</code> environment variables for 32-bit Arm:
        <pre class="programlisting con"><code class="hljs-con">$ export ARCH=arm
$ export CROSS_COMPILE=arm-none-eabi-
</code></pre>
      </li>
      <li class="numberedList">Select <code class="inlineCode">am62x_evm_r5_defconfig</code> for building:
        <pre class="programlisting con"><code class="hljs-con">$ make am62x_evm_r5_defconfig O=../build_uboot/r5
</code></pre>
      </li>
      <li class="numberedList">Run <code class="inlineCode">make menuconfig</code> to configure U-Boot further for building:
        <pre class="programlisting con"><code class="hljs-con">$ make menuconfig O=../build_uboot/r5
</code></pre>
        <ul>
          <li class="bulletList">Drill down into the <strong class="screenText">Environment</strong> submenu.</li>
          <li class="bulletList">Select <strong class="screenText">Environment is in a EXT4 filesystem</strong>.</li>
        </ul>
      </li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18466_03_05.png" alt="Figure 3.5 – Selecting Environment is in a EXT4 fileystem" width="1463" height="1398"/></figure>
    <p class="packt_figref">Figure 3.5 – Selecting Environment is in a EXT4 fileystem</p>
    <ol>
      <li class="numberedList" value="5">Deselect any <a id="_idIndexMarker205"/>other options (e.g., MMC, NAND, and SPI) for environment storage <a id="_idIndexMarker206"/>on that menu page.</li>
      <li class="numberedList">Enter <code class="inlineCode">mmc</code> in the <strong class="screenText">Name of the block device for the environment</strong> text field.</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18466_03_06.png" alt="Figure 3.6 – Name of the block device for the environment" width="1518" height="583"/></figure>
    <p class="packt_figref">Figure 3.6 – Name of the block device for the environment</p>
    <ol>
      <li class="numberedList" value="7">Enter <code class="inlineCode">1:2</code> in<a id="_idIndexMarker207"/> the <strong class="screenText">Device and partition for where to store the environment in EXT4</strong> text field.</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18466_03_07.png" alt="Figure 3.7 – Device and partition for where to store the environment in EXT4" width="1518" height="583"/></figure>
    <p class="packt_figref">Figure 3.7 – Device and partition for where to store the environment in EXT4</p>
    <ol>
      <li class="numberedList" value="8">Ensure <code class="inlineCode">/uboot.env</code> is <a id="_idIndexMarker208"/>the <strong class="screenText">Name of the EXT4 file to use for the environment</strong> text field.</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18466_03_08.png" alt="Figure 3.8 – Environment" width="1517" height="1453"/></figure>
    <p class="packt_figref">Figure 3.8 – Environment</p>
    <ol>
      <li class="numberedList" value="9">Back out <a id="_idIndexMarker209"/>of the <strong class="screenText">Environment</strong> submenu.</li>
      <li class="numberedList">Drill down<a id="_idIndexMarker210"/> into the <strong class="screenText">SPL/TPL</strong> submenu.</li>
      <li class="numberedList">Select <strong class="screenText">Support EXT filesystems</strong>.</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18466_03_09.png" alt="Figure 3.9 – Select Support EXT4 filesystems" width="1517" height="1441"/></figure>
    <p class="packt_figref">Figure 3.9 – Select Support EXT4 filesystems</p>
    <ol>
      <li class="numberedList" value="12">Back out <a id="_idIndexMarker211"/>of the <strong class="screenText">SPL/TPL</strong> submenu.</li>
      <li class="numberedList">Drill down into<a id="_idIndexMarker212"/> the <strong class="screenText">Boot Options</strong> submenu.</li>
      <li class="numberedList">Select <strong class="screenText">Enable a default value for bootcmd</strong>.</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18466_03_10.png" alt="Figure 3.10 – Select Enable a default value for bootcmd" width="1518" height="643"/></figure>
    <p class="packt_figref">Figure 3.10 – Select Enable a default value for bootcmd</p>
    <ol>
      <li class="numberedList" value="15">Enter<a id="_idIndexMarker213"/> <code class="inlineCode">echo 'no bootcmd yet'</code> in<a id="_idIndexMarker214"/> the <strong class="screenText">bootcmd value</strong> text field.</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18466_03_11.png" alt="Figure 3.11 – bootcmd value" width="1518" height="492"/></figure>
    <p class="packt_figref">Figure 3.11 – bootcmd value</p>
    <figure class="mediaobject"><img src="../Images/B18466_03_12.png" alt="Figure 3.12 – Boot options" width="1518" height="650"/></figure>
    <p class="packt_figref">Figure 3.12 – Boot options</p>
    <ol>
      <li class="numberedList" value="16">Exit out of <code class="inlineCode">menuconfig</code> and choose <strong class="screenText">Yes</strong> when asked to save your new configuration.</li>
      <li class="numberedList">Lastly, build<a id="_idIndexMarker215"/> the U-Boot for the R5:
        <pre class="programlisting con"><code class="hljs-con">$ make O=../build_uboot/r5
</code></pre>
      </li>
    </ol>
    <p class="normal">When U-Boot is done<a id="_idIndexMarker216"/> building, there should be an SPL binary for the R5 in <code class="inlineCode">../build_uboot/r5/spl</code>.</p>
    <div class="note">
      <p class="normal">Refer to the boot flow sequence diagram in <code class="inlineCode">doc/board/beagle/am62x_beagleplay.rst</code>.</p>
    </div>
    <h3 id="_idParaDest-74" class="heading-3"><a id="_idTextAnchor080"/>Generating an image for the R5</h3>
    <p class="normal">Recall that the TIFS firmware<a id="_idIndexMarker217"/> image that gets loaded into the M4 needs to be <a id="_idIndexMarker218"/>bundled together with the U-Boot SPL for the R5. We obtain the binary TIFS firmware image directly from TI.</p>
    <p class="normal">Clone the TI firmware repo to your home directory:</p>
    <pre class="programlisting con"><code class="hljs-con">$ cd ~
$ git clone https://github.com/TexasInstruments-Sandbox/ti-linux-firmware.git
$ cd ti-linux-firmware
$ git checkout c126d386
</code></pre>
    <p class="normal">Bundling the TIFS firmware image for the M4 together with the U-Boot SPL for the R5 requires a tool named <code class="inlineCode">k3-image-gen</code>.</p>
    <p class="normal">Clone the <code class="inlineCode">k3-image-gen</code> repo to your home directory:</p>
    <pre class="programlisting con"><code class="hljs-con">$ cd ~
$ git clone git://git.ti.com/k3-image-gen/k3-image-gen.git
$ cd k3-image-gen
$ git checkout 150f195
</code></pre>
    <p class="normal">Generate the combined image for the R5 by running <code class="inlineCode">make</code> in the <code class="inlineCode">k3-image-gen</code> directory with paths to the U-Boot SPL and TIFS firmware image passed in as arguments:</p>
    <pre class="programlisting con"><code class="hljs-con">$ make SOC=am62x SBL=../build_uboot/r5/spl/u-boot-spl.bin SYSFW_PATH=../ti-linux-firmware/ti-sysfw/ti-fs-firmware-am62x-gp.bin
</code></pre>
    <p class="normal">There should now <a id="_idIndexMarker219"/>be a <code class="inlineCode">tiboot3.bin</code> file in the <code class="inlineCode">k3-image-gen</code> directory.</p>
    <div class="note">
      <p class="normal">Refer to the boot flow sequence <a id="_idIndexMarker220"/>diagram in <code class="inlineCode">doc/board/beagle/am62x_beagleplay.rst</code>. </p>
    </div>
    <h3 id="_idParaDest-75" class="heading-3"><a id="_idTextAnchor081"/>Building TF-A for the main A53 CPU</h3>
    <p class="normal">The A53 in BeaglePlay’s <code class="inlineCode">am62x</code> SoC is a 64-bit CPU, so we must switch to a 64-bit toolchain to cross-compile source code for it. We will <a id="_idIndexMarker221"/>use the same 64-bit Bootlin toolchain from <a href="Chapter_01.xhtml#_idTextAnchor028"><em class="italic">Chapter 2</em></a> that you installed in your home directory.</p>
    <p class="normal">Add that 64-bit Bootlin toolchain to your <code class="inlineCode">PATH</code> environment variable:</p>
    <pre class="programlisting con"><code class="hljs-con">$ export PATH=${HOME}/aarch64--glibc--stable-2024.02-1/bin/:$PATH
</code></pre>
    <p class="normal">Make sure to replace <code class="inlineCode">2024.02-1</code> in the preceding commands with the actual version of the 64-bit toolchain you downloaded.</p>
    <p class="normal">Clone the TF-A source code to your home directory and check out a stable release tag:</p>
    <pre class="programlisting con"><code class="hljs-con">$ cd ~
$ git clone https://github.com/ARM-software/arm-trusted-firmware.git
$ cd arm-trusted-firmware
$ git checkout v2.9
</code></pre>
    <p class="normal">Configure and build TF-A for the A53:</p>
    <ol>
      <li class="numberedList" value="1">Set the <code class="inlineCode">ARCH</code> and <code class="inlineCode">CROSS_COMPILE</code> environment variables for 64-bit Arm:
        <pre class="programlisting con"><code class="hljs-con">$ export ARCH=aarch64
$ export CROSS_COMPILE=aarch64-buildroot-linux-gnu-
</code></pre>
      </li>
      <li class="numberedList">Build TF-A for the A53 specifying <code class="inlineCode">k3</code> as the platform and <code class="inlineCode">lite</code> as the target board:
        <pre class="programlisting con"><code class="hljs-con">$ make PLAT=k3 TARGET_BOARD=lite
</code></pre>
      </li>
    </ol>
    <p class="normal">When TF-A is done building, there should be a <code class="inlineCode">bl31.bin</code> for the A53 in <code class="inlineCode">./build/k3/lite/release</code>.</p>
    <div class="note">
      <p class="normal">Refer to the boot flow <a id="_idIndexMarker222"/>sequence diagram in <code class="inlineCode">doc/board/beagle/am62x_beagleplay.rst</code>.</p>
    </div>
    <h3 id="_idParaDest-76" class="heading-3"><a id="_idTextAnchor082"/>Building U-Boot for the main A53 CPU</h3>
    <p class="normal">All the build steps performed up until now are unique to the <code class="inlineCode">am62x</code> SoC in BeaglePlay. Building U-Boot for most targets <a id="_idIndexMarker223"/>only requires compiling an SPL and TPL for the main CPU. We will use the same 64-bit Bootlin toolchain from <a href="Chapter_01.xhtml#_idTextAnchor028"><em class="italic">Chapter 2</em></a><em class="italic"> </em>that you installed in your home directory.</p>
    <p class="normal">Add that 64-bit Bootlin toolchain to your <code class="inlineCode">PATH</code> environment variable:</p>
    <pre class="programlisting con"><code class="hljs-con">$ export PATH=${HOME}/aarch64--glibc--stable-2024.02-1/bin/:$PATH
</code></pre>
    <p class="normal">Make sure to replace <code class="inlineCode">2024.02-1</code> in the preceding commands with the actual version of the 64-bit toolchain you downloaded.</p>
    <p class="normal">Configure and build U-Boot for the A53:</p>
    <ol>
      <li class="numberedList" value="1">First, navigate back to the <code class="inlineCode">u-boot</code> source tree for BeaglePlay:
        <pre class="programlisting con"><code class="hljs-con">$ cd ~
$ cd u-boot-beagleplay
</code></pre>
      </li>
      <li class="numberedList">Next, create a build directory for the A53 one level up:
        <pre class="programlisting con"><code class="hljs-con">$ mkdir -p ../build_uboot/a53
</code></pre>
      </li>
      <li class="numberedList">Set the <code class="inlineCode">ARCH</code> and <code class="inlineCode">CROSS_COMPILE</code> environment variables for 64-bit Arm:
        <pre class="programlisting con"><code class="hljs-con">$ export ARCH=aarch64
$ export CROSS_COMPILE=aarch64-buildroot-linux-gnu-
</code></pre>
      </li>
      <li class="numberedList">Select <code class="inlineCode">am62x_evm_a53_defconfig</code> for building:
        <pre class="programlisting con"><code class="hljs-con">$ make am62x_evm_a53_defconfig O=../build_uboot/a53
</code></pre>
      </li>
      <li class="numberedList">Run <code class="inlineCode">make menuconfig</code> to configure U-Boot further for building:
        <pre class="programlisting con"><code class="hljs-con">$ make menuconfig O=../build_uboot/a53
</code></pre>
      </li>
      <li class="numberedList">Drill down into the <strong class="screenText">Environment</strong> submenu.</li>
      <li class="numberedList">Select <strong class="screenText">Environment is in a EXT4 filesystem</strong>.</li>
      <li class="numberedList">Deselect any other options (e.g., MMC, NAND, and SPI) for environment storage on that menu page.</li>
      <li class="numberedList">Enter <code class="inlineCode">mmc</code> in the <strong class="screenText">Name of the block device for the environment</strong> text field.</li>
      <li class="numberedList">Enter <code class="inlineCode">1:2</code> in the <strong class="screenText">Device and partition for where to store the environment in EXT4</strong> text field.</li>
      <li class="numberedList">Ensure <code class="inlineCode">/uboot.env</code> is entered in the <strong class="screenText">Name of the EXT4 file to use for the environment</strong> text field.</li>
      <li class="numberedList">Back out of the <strong class="screenText">Environment</strong> submenu.</li>
      <li class="numberedList">Drill down into the <strong class="screenText">SPL/TPL</strong> submenu.</li>
      <li class="numberedList">Select <strong class="screenText">Support EXT filesystems</strong>.</li>
      <li class="numberedList">Back out of the <strong class="screenText">SPL/TPL</strong> submenu.</li>
      <li class="numberedList">Drill down into the <strong class="screenText">Boot Options</strong> submenu.</li>
      <li class="numberedList">Select <strong class="screenText">Enable a default value for bootcmd</strong>.</li>
      <li class="numberedList">Enter <code class="inlineCode">echo 'no bootcmd yet'</code> in the <strong class="screenText">bootcmd value</strong> text field.</li>
      <li class="numberedList">Exit out of <code class="inlineCode">menuconfig</code> and choose <strong class="screenText">Yes</strong> when asked to save your new configuration.</li>
      <li class="numberedList">Lastly, build U-Boot for<a id="_idIndexMarker224"/> the A53 passing paths to TI’s TF-A and DM firmware as arguments to <code class="inlineCode">make</code>:
        <pre class="programlisting con"><code class="hljs-con">$ make ATF=$HOME/arm-trusted-firmware/build/k3/lite/release/bl31.bin DM=$HOME/ti-linux-firmware/ti-dm/am62xx/ipc_echo_testb_mcu1_0_release_strip.xer5f O=../build_uboot/a53
</code></pre>
        <div class="note">
          <p class="normal"><strong class="keyWord">IMPORTANT NOTE</strong></p>
          <p class="normal">Always use absolute paths as opposed to relative <code class="inlineCode">./</code> paths to point to the <code class="inlineCode">ATF</code> and <code class="inlineCode">DM</code> firmware in your <code class="inlineCode">make</code> command. Otherwise, the resulting SPL and U-Boot binaries will be incorrect in size and content.</p>
        </div>
      </li>
    </ol>
    <p class="normal">The results of the compilation are as follows:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">u-boot</code>: U-Boot in ELF format, suitable for use with a debugger</li>
      <li class="bulletList"><code class="inlineCode">u-boot.map</code>: The symbol table</li>
      <li class="bulletList"><code class="inlineCode">u-boot.bin</code>: U-Boot in raw binary format, suitable for running on your device</li>
      <li class="bulletList"><code class="inlineCode">u-boot.img</code>: <code class="inlineCode">u-boot.bin</code> with a U-Boot header added, suitable for uploading to a running copy of U-Boot</li>
      <li class="bulletList"><code class="inlineCode">u-boot.srec</code>: U-Boot in Motorola S-record (<strong class="keyWord">SRECORD</strong> or <strong class="keyWord">SRE</strong>) format, suitable for transferring over a serial connection</li>
    </ul>
    <p class="normal">BeaglePlay also requires an SPL, as described earlier. This is built at the same time and is named <code class="inlineCode">tispl.bin</code> (the boot flow sequence diagram in <code class="inlineCode">doc/board/beagle/am62x_beagleplay.rst</code>):</p>
    <pre class="programlisting con"><code class="hljs-con">$ cd ~
$ cd build_uboot/a53
$ ls -l tispl.bin
-rw-rw-r-- 1 frank frank 549508 Jun 29 20:31 tispl.bin
$ ls -l u-boot*
-rwxrwxr-x 1 frank frank 6779128 Jun 29 20:31 u-boot
-rw-rw-r-- 1 frank frank 1098236 Jun 29 20:31 u-boot.bin
-rw-rw-r-- 1 frank frank   18246 Jun 29 20:30 u-boot.cfg
-rw-rw-r-- 1 frank frank   11563 Jun 29 20:31 u-boot.cfg.configs
-rw-rw-r-- 1 frank frank   37485 Jun 29 20:31 u-boot.dtb
-rw-rw-r-- 1 frank frank 1060788 Jun 29 20:31 u-boot-dtb.img
-rw-rw-r-- 1 frank frank 1098236 Jun 29 20:31 u-boot-fit-dtb.bin
-rw-rw-r-- 1 frank frank 1060788 Jun 29 20:31 u-boot.img
-rw-rw-r-- 1 frank frank 1060788 Jun 29 20:31 u-boot.img_HS
-rw-rw-r-- 1 frank frank    1348 Jun 29 20:31 u-boot.lds
-rw-rw-r-- 1 frank frank  765615 Jun 29 20:31 u-boot.map
-rwxrwxr-x 1 frank frank  993104 Jun 29 20:31 u-boot-nodtb.bin
-rwxrwxr-x 1 frank frank  993104 Jun 29 20:31 u-boot-nodtb.bin_HS
-rw-rw-r-- 1 frank frank    1836 Jun 29 20:31 u-boot-spl-k3_HS.its
-rwxrwxr-x 1 frank frank 2979442 Jun 29 20:31 u-boot.srec
-rw-rw-r-- 1 frank frank  342412 Jun 29 20:31 u-boot.sym
</code></pre>
    <p class="normal">The procedure is similar<a id="_idIndexMarker225"/> for other targets.</p>
    <h2 id="_idParaDest-77" class="heading-2"><a id="_idTextAnchor083"/>Installing U-Boot</h2>
    <p class="normal">Installing a bootloader on a board for the first time requires some manual intervention. If the board has a hardware debug<a id="_idIndexMarker226"/> interface, such as a<strong class="keyWord"> Joint Test Action Group </strong>(<strong class="keyWord">JTAG</strong>), it is usually possible to load a copy<a id="_idIndexMarker227"/> of U-Boot directly into RAM and get it running. From that point, you can use U-Boot commands so that it copies itself into flash memory. The details are very board-specific and outside the scope of this book.</p>
    <p class="normal">Many SoC designs have a boot ROM built in that can be used to read boot code from various external sources, such as SD cards, serial interfaces, or USB mass storage. This is the case with the <code class="inlineCode">am62x</code> chip in the Beagle, which makes it easy to try out new software.</p>
    <p class="normal">You will need a microSD card reader to write the images to a card. There are two types: external readers that plug into a USB port and the internal SD readers that are present on many laptops. A device name is assigned by Linux when a card is plugged into the reader. The <code class="inlineCode">lsblk</code> command is a useful tool for finding out which device has been allocated. For example, this is what I see when I plug a nominal 32 GB microSD card into my card reader:</p>
    <pre class="programlisting con"><code class="hljs-con">$ lsblk
NAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT
sda           8:0    1  29.8G  0 disk
└─sda1        8:1    1  29.8G  0 part /media/frank/6662-6262
nvme0n1     259:0    0 465.8G  0 disk
├─nvme0n1p1 259:1    0   512M  0 part /boot/efi
├─nvme0n1p2 259:2    0    16M  0 part
├─nvme0n1p3 259:3    0 232.9G  0 part
└─nvme0n1p4 259:4    0 232.4G  0 part /
</code></pre>
    <p class="normal">In this case, <code class="inlineCode">nvme0n1</code> is my 512 GB hard drive and <code class="inlineCode">sda</code> is the microSD card. It has a single partition, <code class="inlineCode">sda1</code>, which is <a id="_idIndexMarker228"/>mounted as the <code class="inlineCode">/media/frank/6662-6262</code> directory.</p>
    <p class="normal">If I use the built-in SD card slot, I see this:</p>
    <pre class="programlisting con"><code class="hljs-con">$ lsblk
NAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT
mmcblk0     179:0    1  29.8G  0 disk
└─mmcblk0p1 179:1    1  29.8G  0 part /media/frank/6662-6262
nvme0n1     259:0    0 465.8G  0 disk
├─nvme0n1p1 259:1    0   512M  0 part /boot/efi
├─nvme0n1p2 259:2    0    16M  0 part
├─nvme0n1p3 259:3    0 232.9G  0 part
└─nvme0n1p4 259:4    0 232.4G  0 part /
</code></pre>
    <p class="normal">In this case, the microSD card appears as <code class="inlineCode">mmcblk0</code>, and the partition is <code class="inlineCode">mmcblk0p1</code>. Note that the microSD card you use may have been formatted differently than this one, so you may see a different number of partitions with different mount points. When formatting an SD card, it is very important to be sure of its device name. You really don’t want to mistake your hard drive for an SD card and format that instead.</p>
    <p class="normal">This has happened to me more than once. So, I have provided a shell script in this book’s code repo named <code class="inlineCode">MELD/format-sdcard.sh</code>, which has a reasonable number of checks to prevent you (and me) from using the wrong device name. The parameter is the device name of the microSD card, which would be <code class="inlineCode">sda</code> in the first example and <code class="inlineCode">mmcblk0</code> in the second. Here is an example of its use:</p>
    <pre class="programlisting con"><code class="hljs-con">$ MELD/format-sdcard.sh mmcblk0
</code></pre>
    <p class="normal">The script creates two partitions. The first is 128 MB and formatted as FAT32, and it will contain the bootloader, while the second is 1 GB and formatted as ext4, which you will use in <a href="Chapter_05.xhtml#_idTextAnchor138"><em class="italic">Chapter 5</em></a>. The script aborts when it’s applied to any drive greater than 128 GB so be prepared to modify it if you are using larger microSD cards.</p>
    <p class="normal">Once you have formatted the microSD card, remove it from the card reader and then reinsert it. Roll over and click on one of the USB stick icons that appears to the left of the Ubuntu desktop so that a window opens for the <code class="inlineCode">boot</code> partition. On current versions of Ubuntu, the two partitions are mounted as <code class="inlineCode">/media/&lt;user&gt;/boot</code> and <code class="inlineCode">/media/&lt;user&gt;/rootfs</code>.</p>
    <p class="normal">Copy <code class="inlineCode">tiboot3.bin</code>, <code class="inlineCode">tispl.bin</code> and <code class="inlineCode">u-boot.img</code> to the <code class="inlineCode">boot</code> partition like this:</p>
    <pre class="programlisting con"><code class="hljs-con">$ cd ~
$ cd k3-image-gen
$ cp tiboot3.bin /media/$USER/boot/.
$ cd ~
$ cd build_uboot/a53
$ cp tispl.bin u-boot.img /media/$USER/boot/.
</code></pre>
    <p class="normal">Right-click on either of the two USB stick icons and select <strong class="screenText">Eject</strong> to unmount the microSD card. Lastly, remove the microSD<a id="_idIndexMarker229"/> card from your host machine’s card reader.</p>
    <p class="normal">To boot BeaglePlay from your newly prepared microSD card:</p>
    <ol>
      <li class="numberedList" value="1">With no power on BeaglePlay, insert the microSD card into BeaglePlay’s reader.</li>
      <li class="numberedList">Plug the USB side of your USB-to-TTL serial cable into your host machine. Make sure your cable has a 3.3 V logic level.</li>
      <li class="numberedList">The three-pin UART connector is right next to the USB-C connector on BeaglePlay. Do not connect a fourth red wire from your cable. A red wire typically indicates power, which is unnecessary in this instance and could damage the board.</li>
      <li class="numberedList">Connect the TX wire from the cable to the RX pin on BeaglePlay.</li>
      <li class="numberedList">Connect the RX wire from the cable to the TX pin on BeaglePlay.</li>
      <li class="numberedList">Connect the GND (black) wire from the cable to the GND pin on BeaglePlay.</li>
      <li class="numberedList">A serial port should appear on your PC as <code class="inlineCode">/dev/ttyUSB0</code>.</li>
      <li class="numberedList">Start a suitable terminal program, like <code class="inlineCode">gtkterm</code>, <code class="inlineCode">minicom</code>, or <code class="inlineCode">picocom</code>, and attach it to the port at 115,200 <strong class="keyWord">bits per second</strong> (<strong class="keyWord">bps</strong>) with no flow control. <code class="inlineCode">gtkterm</code> is probably the easiest to set up and use:
        <pre class="programlisting con"><code class="hljs-con">$ gtkterm -p /dev/ttyUSB0 -s 115200
</code></pre>
      </li>
      <li class="numberedList">If you get a permissions error, then you may need to add yourself to the <code class="inlineCode">dialout</code> group to use this port or launch <code class="inlineCode">gtkterm</code> with <code class="inlineCode">sudo</code>. If garbled or no output appears on the serial console, then swap the wires connected to the RX and TX pins on BeaglePlay.</li>
      <li class="numberedList">Press and hold the USR button on BeaglePlay.</li>
      <li class="numberedList">Power up the board using USB-C.</li>
      <li class="numberedList">Release the button after about 5 seconds.</li>
    </ol>
    <p class="normal">You should see some output followed by a U-Boot prompt on the serial console:</p>
    <pre class="programlisting con"><code class="hljs-con">U-Boot SPL 2021.01-gf036fbdc25 (Jun 29 2024 - 18:54:55 -0700)
SYSFW ABI: 3.1 (firmware rev 0x0009 '9.0.4--v09.00.04 (Kool Koala)')
SPL initial stack usage: 13384 bytes
Trying to boot from MMC2
spl_load_fit_image: Skip load 'tee': image size is 0!
Loading Environment from EXT4... ** File not found /uboot.env **
** Unable to read "/uboot.env" from mmc1:2 **
Starting ATF on ARM64 core...
NOTICE:  BL31: v2.9(release):v2.9.0
NOTICE:  BL31: Built : 19:01:43, Jun 29 2024
U-Boot SPL 2021.01-gf036fbdc25 (Jun 29 2024 - 20:30:20 -0700)
SYSFW ABI: 3.1 (firmware rev 0x0009 '9.0.4--v09.00.04 (Kool Koala)')
Trying to boot from MMC2
U-Boot 2021.01-gf036fbdc25 (Jun 29 2024 - 20:30:20 -0700)
SoC:   AM62X SR1.0 GP
Model: BeagleBoard.org BeaglePlay
Board: BEAGLEPLAY-A0- rev 02
DRAM:  2 GiB
MMC:   mmc@fa10000: 0, mmc@fa00000: 1, mmc@fa20000: 2
Loading Environment from EXT4... ** File not found /uboot.env **
** Unable to read "/uboot.env" from mmc1:2 **
In:    serial@2800000
Out:   serial@2800000
Err:   serial@2800000
Error: Can't set serial# to SSSS
Net:   Could not get PHY for ethernet@8000000port@1: addr 0
am65_cpsw_nuss_port ethernet@8000000port@1: phy_connect() failed
No ethernet found.
Press SPACE to abort autoboot in 2 seconds
no bootcmd yet
=&gt;
</code></pre>
    <p class="normal">Hit any key on your <a id="_idIndexMarker230"/>keyboard to stop U-Boot from autobooting with the default environment. Now that we have a U-Boot prompt in front of us, let’s put U-Boot through its paces.</p>
    <h2 id="_idParaDest-78" class="heading-2"><a id="_idTextAnchor084"/>Using U-Boot</h2>
    <p class="normal">In this section, I describe some of the common tasks that can be performed with U-Boot.</p>
    <p class="normal">U-Boot provides a command-line interface over a serial port. It provides a command prompt that is customized for <a id="_idIndexMarker231"/>each board. In these examples, I use <code class="inlineCode">=&gt;</code> for the command prompt. Typing <code class="inlineCode">help</code> prints out all the commands that have been configured in this version of U-Boot. Typing <code class="inlineCode">help &lt;command&gt;</code> prints out more information about a particular command.</p>
    <p class="normal">The default command interpreter for BeaglePlay is quite simple. You cannot do command-line editing by pressing the left or right keys. There is no command completion by pressing the <em class="italic">Tab</em> key, and there is no command history by pressing the up arrow key. Pressing any of these keys will disrupt the command you are currently trying to type, and you will have to type <em class="italic">Ctrl + C</em> and start all over again. The only line editing key you can safely use is the backspace.</p>
    <p class="normal">As an option, you can configure a different <a id="_idIndexMarker232"/>command shell called <strong class="keyWord">Hush</strong>, which has more sophisticated interactive support, including command-line editing.</p>
    <p class="normal">The default number format is hexadecimal. Consider the following command:</p>
    <pre class="programlisting con"><code class="hljs-con">=&gt; nand read 82000000 400000 200000
</code></pre>
    <p class="normal">This will read <code class="inlineCode">0x200000</code> bytes from offset <code class="inlineCode">0x400000</code> from the start of the NAND flash memory into RAM address <code class="inlineCode">0x82000000</code>.</p>
    <h3 id="_idParaDest-79" class="heading-3"><a id="_idTextAnchor085"/>Environment variables</h3>
    <p class="normal">U-Boot uses environment variables extensively to store and pass information between functions and even to create <a id="_idIndexMarker233"/>scripts. Environment variables are simple <code class="inlineCode">name=value</code> pairs that are stored in an area of memory. The initial population of variables may be coded in the board configuration header file like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">#</span><span class="hljs-keyword">define</span><span class="hljs-meta"> CONFIG_EXTRA_ENV_SETTINGS</span>
<span class="hljs-string">"myvar1=value1"</span>
<span class="hljs-string">"myvar2=value2"</span>
</code></pre>
    <p class="normal">You can create and modify variables from the U-Boot command line using <code class="inlineCode">setenv</code>. For example, <code class="inlineCode">setenv foo bar</code> creates the <code class="inlineCode">foo</code> variable with the <code class="inlineCode">bar</code> value. Note that there is no <code class="inlineCode">=</code> sign between the variable name and the value. You can delete a variable by setting it to a null string using <code class="inlineCode">setenv foo</code>. You can print all the variables to the console using <code class="inlineCode">printenv</code>, or you can print a single variable using <code class="inlineCode">printenv foo</code>.</p>
    <p class="normal">If U-Boot has been configured with space to store the environment, you can use the <code class="inlineCode">saveenv</code> command to save it. If there is raw NAND or NOR flash, then an erase block can be reserved for this purpose, often with another erase block being used as a redundant copy to guard against corruption. If there is eMMC or SD card storage, it can be stored in a reserved array of sectors, or in a file named <code class="inlineCode">uboot.env</code> in a partition of the disk. Other options include storing it in serial <strong class="keyWord">Electrical Erasable Programmable Read Only Memory </strong>(<strong class="keyWord">EEPROM</strong>) connected via an I2C or SPI interface or<a id="_idIndexMarker234"/> non-volatile RAM.</p>
    <h3 id="_idParaDest-80" class="heading-3"><a id="_idTextAnchor086"/>Boot image format</h3>
    <p class="normal">U-Boot doesn’t have a filesystem. Instead, it tags blocks of information with a 64-byte header so that it can track the contents. We <a id="_idIndexMarker235"/>prepare files for U-Boot using the <code class="inlineCode">mkimage</code> command-line tool, which comes bundled with the <code class="inlineCode">u-boot-tools</code> package on Ubuntu. You can also get <code class="inlineCode">mkimage</code> by running <code class="inlineCode">make tools</code> from within the U-Boot source tree and then invoke it as <code class="inlineCode">tools/mkimage</code>. Here is a summary of the command’s usage:</p>
    <pre class="programlisting con"><code class="hljs-con">$ mkimage
Error: Missing output filename
Usage: mkimage -l image
          -l ==&gt; list image header information
       mkimage [-x] -A arch -O os -T type -C comp -a addr -e ep -n name -d data_file[:data_file...] image
          -A ==&gt; set architecture to 'arch'
          -O ==&gt; set operating system to 'os'
          -T ==&gt; set image type to 'type'
          -C ==&gt; set compression type 'comp'
          -a ==&gt; set load address to 'addr' (hex)
          -e ==&gt; set entry point to 'ep' (hex)
          -n ==&gt; set image name to 'name'
          -d ==&gt; use image data from 'datafile'
          -x ==&gt; set XIP (execute in place)
       mkimage [-D dtc_options] [-f fit-image.its|-f auto|-F] [-b &lt;dtb&gt; [-b &lt;dtb&gt;]] [-E] [-B size] [-i &lt;ramdisk.cpio.gz&gt;] fit-image
           &lt;dtb&gt; file is used with -f auto, it may occur multiple times.
          -D =&gt; set all options for device tree compiler
          -f =&gt; input filename for FIT source
          -i =&gt; input filename for ramdisk file
          -E =&gt; place data outside of the FIT structure
          -B =&gt; align size in hex for FIT structure and header
Signing / verified boot options: [-k keydir] [-K dtb] [ -c &lt;comment&gt;] [-p addr] [-r] [-N engine]
          -k =&gt; set directory containing private keys
          -K =&gt; write public keys to this .dtb file
          -G =&gt; use this signing key (in lieu of -k)
          -c =&gt; add comment in signature node
          -F =&gt; re-sign existing FIT image
          -p =&gt; place external data at a static position
          -r =&gt; mark keys used as 'required' in dtb
          -N =&gt; openssl engine to use for signing
       mkimage -V ==&gt; print version information and exit
Use '-T list' to see a list of available image types
</code></pre>
    <p class="normal">For example, to prepare a kernel image for a 32-bit Arm processor, you can use the following command:</p>
    <pre class="programlisting con"><code class="hljs-con">$ mkimage -A arm -O linux -T kernel -C gzip -a 0x80008000 -e 0x80008000 -n 'Linux' -d zImage uImage
</code></pre>
    <p class="normal">In this instance, the architecture is <code class="inlineCode">arm</code>, the operating system is <code class="inlineCode">linux</code>, and the image type is <code class="inlineCode">kernel</code>. Additionally, the <a id="_idIndexMarker236"/>compression scheme is <code class="inlineCode">gzip</code>, the load address is <code class="inlineCode">0x80008000</code>, and the entry point is the same as the load address. Lastly, the image name is <code class="inlineCode">Linux</code>, the image datafile is named <code class="inlineCode">zImage</code>, and the image being generated is named <code class="inlineCode">uImage</code>.</p>
    <h3 id="_idParaDest-81" class="heading-3"><a id="_idTextAnchor087"/>Loading images</h3>
    <p class="normal">Usually, you load images from<a id="_idIndexMarker237"/> removable storage such as an SD card or over a network. SD cards are handled in U-Boot by the MMC driver. Here is an example of loading a file from a microSD card into memory:</p>
    <pre class="programlisting con"><code class="hljs-con">=&gt; mmc rescan
=&gt; mmc list
mmc@fa10000: 0 (eMMC)
mmc@fa00000: 1 (SD)
mmc@fa20000: 2
=&gt; fatload mmc 1:1 80000000 tiboot3.bin
329021 bytes read in 19 ms (16.5 MiB/s)
</code></pre>
    <p class="normal">The <code class="inlineCode">mmc rescan</code> command re-initializes the MMC driver, perhaps to detect that an SD card has recently been inserted. Next, <code class="inlineCode">fatload</code> is used to read a file from a FAT-formatted partition on the SD card. Note that <code class="inlineCode">tiboot3.bin</code> is the firmware image for the R5, not a Linux kernel image, so it cannot be executed at this point in the boot sequence. The format for the <code class="inlineCode">fatload</code> command is as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">fatload &lt;interface&gt; [&lt;dev[:part]&gt; [&lt;addr&gt; [&lt;filename&gt; [bytes [pos]]]]]
</code></pre>
    <p class="normal">If <code class="inlineCode">&lt;interface&gt;</code> is <code class="inlineCode">mmc</code>, as in our case, then <code class="inlineCode">&lt;dev:part&gt;</code> is the device number of the MMC interface counting from zero and the partition number counting from one. Hence, <code class="inlineCode">&lt;1:1&gt;</code> is the first partition on the second device, which is <code class="inlineCode">mmc 1</code> for the microSD card on BeaglePlay (the onboard eMMC is <code class="inlineCode">mmc 0</code>). The chosen memory location of <code class="inlineCode">0x80000000</code> is in an area of RAM that is not being used at this moment.</p>
    <p class="normal">To load kernel image files over a network, you must<a id="_idIndexMarker238"/> use the <strong class="keyWord">Trivial File Transfer Protocol</strong> (<strong class="keyWord">TFTP</strong>). This requires you to install <code class="inlineCode">tftpd</code> (a TFTP daemon) on your development system and start running it. You must also configure any firewalls between your PC and the target board to allow the TFTP protocol on UDP port <code class="inlineCode">69</code> to pass through.</p>
    <p class="normal">The default configuration of TFTP only allows access to the <code class="inlineCode">/var/lib/tftpboot</code> directory. The next step is to copy the files you want to transfer to the target into that directory. Then, assuming that you are using <a id="_idIndexMarker239"/>a pair of static IP addresses, which removes the need for further network administration, the sequence of commands to load a kernel image file looks like this:</p>
    <pre class="programlisting con"><code class="hljs-con">=&gt; setenv ipaddr 192.168.159.42
=&gt; setenv serverip 192.168.159.99
=&gt; tftp 82000000 uImage
link up on port 0, speed 100, full duplex
Using cpsw device
TFTP from server 192.168.159.99; our IP address is 192.168.159.42
Filename 'uImage'.
Load address: 0x82000000
Loading:
######################################################################################################################################################################################################################################################################################################################
3 MiB/s
done
Bytes transferred = 4605000 (464448 hex)
</code></pre>
    <p class="normal">Finally, let’s look at how to program images into NAND flash memory and read them back. This is handled by the <code class="inlineCode">nand</code> command. This example loads a kernel image via TFTP and programs it into flash:</p>
    <pre class="programlisting con"><code class="hljs-con">=&gt; tftpboot 82000000 uImage
=&gt; nandecc hw
=&gt; nand erase 280000 400000
NAND erase: device 0 offset 0x280000, size 0x400000
Erasing at 0x660000 -- 100% complete.
OK
=&gt; nand write 82000000 280000 400000
NAND write: device 0 offset 0x280000, size 0x400000
4194304 bytes written: OK
</code></pre>
    <p class="normal">Now, you can load the kernel from flash memory using the <code class="inlineCode">nand read</code> command:</p>
    <pre class="programlisting con"><code class="hljs-con">=&gt; nand read 82000000 280000 400000
</code></pre>
    <p class="normal">Once the kernel has been loaded into RAM, we can boot it.</p>
    <h2 id="_idParaDest-82" class="heading-2"><a id="_idTextAnchor088"/>Booting Linux</h2>
    <p class="normal">The <code class="inlineCode">bootm</code> command starts a kernel image running. The syntax is as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">bootm &lt;address of kernel&gt; &lt;address of ramdisk&gt; &lt;address of dtb&gt;
</code></pre>
    <p class="normal">The address of the kernel image is <a id="_idIndexMarker240"/>necessary, but the addresses of the <code class="inlineCode">ramdisk</code> and <code class="inlineCode">dtb</code> can be omitted if the kernel configuration does not need them. If there is a <code class="inlineCode">dtb</code> but no <code class="inlineCode">initramfs</code>, then the second address can be replaced with a dash. That would look like this:</p>
    <pre class="programlisting con"><code class="hljs-con">=&gt; bootm 82000000 – 83000000
</code></pre>
    <p class="normal">Typing a long series of commands to boot your board each time it is powered up is clearly not acceptable. Let’s look at how to automate the boot process.</p>
    <h3 id="_idParaDest-83" class="heading-3"><a id="_idTextAnchor089"/>Automating the boot with U-Boot scripts</h3>
    <p class="normal">U-Boot stores a sequence of commands in environment variables. If a special variable named <code class="inlineCode">bootcmd</code> contains a script, then it is <a id="_idIndexMarker241"/>run at power-up after a delay of <code class="inlineCode">bootdelay</code> seconds. If you watch this on the serial console, you will see the delay counting down to zero. You can press any key during this period to terminate the countdown and enter an interactive session with U-Boot.</p>
    <p class="normal">The way that you create scripts is simple, though it’s not easy to read. You simply append commands separated by semicolons, which must be preceded by a <em class="italic">\</em> escape character. For example, to load a kernel image from an offset in flash memory and boot it, you might use the following command:</p>
    <pre class="programlisting con"><code class="hljs-con">setenv bootcmd nand read 82000000 400000 200000\;bootm 82000000
</code></pre>
    <p class="normal">We now know how to boot a kernel on BeaglePlay using U-Boot. But how do we port U-Boot to a new board that has no BSP? We’ll cover that in the remainder of this chapter.</p>
    <h2 id="_idParaDest-84" class="heading-2"><a id="_idTextAnchor090"/>Porting U-Boot to a new board</h2>
    <p class="normal">Let’s assume that your <a id="_idIndexMarker242"/>hardware department has created a new board called <strong class="keyWord">Nova</strong> that is based on BeaglePlay and that <a id="_idIndexMarker243"/>you need to port U-Boot to it. You will need to understand the layout of the U-Boot code and how the board configuration mechanism works. In this section, I will show you how to create a variant of an existing board – BeaglePlay – which you could go on to use as the basis for further customizations.</p>
    <p class="normal">There are quite a few files that need to be changed. I have put them together into a patch file at <code class="inlineCode">MELD/Chapter03/0001-BSP-for-Nova.patch</code> in the book’s code repo. You can simply apply that patch to a clean copy of the U-Boot fork for BeaglePlay and rebuild it like this:</p>
    <pre class="programlisting con"><code class="hljs-con">$ cd ~
$ cd u-boot-beagleplay
$ patch -p1 &lt; ~/MELD/Chapter03/0001-BSP-for-Nova.patch
$ rm -rf ../build_uboot/a53
$ mkdir ../build_uboot/a53
$ export PATH=${HOME}/aarch64--glibc--stable-2024.02-1/bin/:$PATH
$ export ARCH=aarch64
$ export CROSS_COMPILE=aarch64-buildroot-linux-gnu-
$ make nova_defconfig O=../build_uboot/a53
$ make ATF=$HOME/arm-trusted-firmware/build/k3/lite/release/bl31.bin DM=$HOME/ti-linux-firmware/ti-dm/am62xx/ipc_echo_testb_mcu1_0_release_strip.xer5f O=../build_uboot/a53
</code></pre>
    <p class="normal">If you want to use a different version of U-Boot, you will have to regenerate the patch yourself for it to apply cleanly. The remainder of this section describes how the patch was created. To skip these details, run the preceding commands and jump to the end of the <em class="italic">Building and testing</em> portion of this section. To follow <a id="_idIndexMarker244"/>along step by step, you will need a clean copy of the U-Boot fork for BeaglePlay without the Nova BSP patch applied. The main directories we will be dealing with are as follows:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">arch</code>: Contains code that’s specific to each supported architecture in the <code class="inlineCode">arm</code>, <code class="inlineCode">mips</code>, and <code class="inlineCode">powerpc</code> directories. Within each architecture, there is a subdirectory for each member of the family. For example, in <code class="inlineCode">arch/arm/cpu</code> there are directories for the various architecture variants, including <code class="inlineCode">arm926ejs</code>, <code class="inlineCode">armv7</code>, and <code class="inlineCode">armv8</code>.</li>
      <li class="bulletList"><code class="inlineCode">board</code>: Contains code that’s specific to a board. Where there are several boards from the same vendor, they are collected into a subdirectory. Hence, the code for the <code class="inlineCode">am62x</code> EVM board, which BeaglePlay is based on, is in <code class="inlineCode">board/ti/am62x</code>.</li>
      <li class="bulletList"><code class="inlineCode">common</code>: Contains core functions including the command shells and the commands that can be called from them each in a file named <code class="inlineCode">cmd_&lt;command name&gt;.c</code>.</li>
      <li class="bulletList"><code class="inlineCode">doc</code>: Contains several <code class="inlineCode">.rst</code> files describing various aspects of U-Boot. If you are wondering how to proceed with your U-Boot port, this is a good place to start.</li>
      <li class="bulletList"><code class="inlineCode">include</code>: In addition to many shared header files, this contains the important <code class="inlineCode">include/configs</code> subdirectory, where you will find the majority of the board configuration settings.</li>
    </ul>
    <p class="normal">The way that <code class="inlineCode">Kconfig</code> extracts configuration information from <code class="inlineCode">Kconfig</code> files and stores the total system configuration in a file named <code class="inlineCode">.config</code> will be described in some detail in <a href="Chapter_04.xhtml#_idTextAnchor096"><em class="italic">Chapter 4</em></a>. Each board has a default configuration stored in <code class="inlineCode">configs/&lt;board name&gt;_defconfig</code>. For the Nova board, we can begin by making a copy of the configuration for the EVM:</p>
    <pre class="programlisting con"><code class="hljs-con">$ cp configs/am62x_evm_a53_defconfig configs/nova_defconfig
</code></pre>
    <p class="normal">Now, edit <code class="inlineCode">configs/nova_defconfig</code> and replace <code class="inlineCode">CONFIG_TARGET_AM625_A53_EVM=y</code> with <code class="inlineCode">CONFIG_TARGET_NOVA=y</code> as shown here:</p>
    <pre class="programlisting code"><code class="hljs-code">CONFIG_ARM=y
CONFIG_ARCH_K3=y
CONFIG_TI_SECURE_DEVICE=y
CONFIG_TI_COMMON_CMD_OPTIONS=y
CONFIG_SPL_GPIO_SUPPORT=y
CONFIG_SPL_LIBCOMMON_SUPPORT=y
CONFIG_SPL_LIBGENERIC_SUPPORT=y
CONFIG_SYS_MALLOC_F_LEN=0x8000
CONFIG_NR_DRAM_BANKS=2
CONFIG_SOC_K3_AM625=y
CONFIG_K3_ATF_LOAD_ADDR=0x9e780000
CONFIG_TARGET_NOVA=y
CONFIG_ENV_SIZE=0x20000
&lt;…&gt;
</code></pre>
    <p class="normal">Note that <code class="inlineCode">CONFIG_ARM=y</code> causes<a id="_idIndexMarker245"/> the contents of <code class="inlineCode">arch/arm/Kconfig</code> to be included.</p>
    <p class="normal">We are now done modifying <code class="inlineCode">configs/nova_defconfig</code>.</p>
    <h3 id="_idParaDest-85" class="heading-3"><a id="_idTextAnchor091"/>Board-specific files</h3>
    <p class="normal">Each board has a subdirectory named <code class="inlineCode">board/&lt;board name&gt;</code> or <code class="inlineCode">board/&lt;vendor&gt;/&lt;board name&gt;</code> that should <a id="_idIndexMarker246"/>contain the following:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">Kconfig</code>: Contains the configuration options for the board.</li>
      <li class="bulletList"><code class="inlineCode">MAINTAINERS</code>: Contains a record of whether the board is currently maintained and, if so, by whom.</li>
      <li class="bulletList"><code class="inlineCode">Makefile</code>: Used to build the board-specific code.</li>
    </ul>
    <p class="normal">In addition, there may be source files for board-specific functions.</p>
    <p class="normal">Our Nova board is based on BeaglePlay, which in turn is based on a TI <code class="inlineCode">am62x</code> EVM. So, we should make copies of the <code class="inlineCode">am62x</code> board files:</p>
    <pre class="programlisting con"><code class="hljs-con">$ mkdir board/ti/nova
$ cp -a board/ti/am62x/* board/ti/nova
$ cd board/ti/nova
$ mv evm.c nova.c
</code></pre>
    <p class="normal">First, modify <code class="inlineCode">board/ti/nova/Makefile</code> so that <code class="inlineCode">nova.c</code> is compiled instead of <code class="inlineCode">evm.c</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">&lt;…&gt;
obj-y   += nova.o
</code></pre>
    <p class="normal">Duplicating <code class="inlineCode">evm.c</code> as <code class="inlineCode">nova.c</code> lets you change how U-Boot interacts with your custom board.</p>
    <p class="normal">Next, edit <code class="inlineCode">board/ti/nova/Kconfig</code>:</p>
    <ul>
      <li class="bulletList">Change the <code class="inlineCode">"TI K3 AM62x based boards"</code> string under <code class="inlineCode">prompt</code> to say <code class="inlineCode">"TI K3 AM62x based Nova! board"</code>.</li>
      <li class="bulletList">Rename <code class="inlineCode">TARGET_AM625_A53_EVM</code> to <code class="inlineCode">TARGET_NOVA</code>.</li>
      <li class="bulletList">Delete <code class="inlineCode">TARGET_AM625_R5_EVM</code> along with all its items.</li>
      <li class="bulletList">Set <code class="inlineCode">SYS_BOARD</code> to <code class="inlineCode">"nova"</code> so that it will build the<a id="_idIndexMarker247"/> files in <code class="inlineCode">board/ti/nova</code>.</li>
      <li class="bulletList">Set <code class="inlineCode">SYS_CONFIG_NAME</code> to <code class="inlineCode">"nova"</code> so that it will use <code class="inlineCode">include/configs/nova.h</code> as the configuration file.</li>
    </ul>
    <p class="normal">The modified <code class="inlineCode">board/ti/nova/Konfig</code> should look as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">&lt;…&gt;
if TARGET_NOVA
config SYS_BOARD
       default "nova"
config SYS_VENDOR
       default "ti"
config SYS_CONFIG_NAME
       default "nova"
source "board/ti/common/Kconfig"
endif
&lt;…&gt;
</code></pre>
    <p class="normal">Now we need to link the <code class="inlineCode">Kconfig</code> file for Nova into the chain of <code class="inlineCode">Kconfig</code> files. First, edit <code class="inlineCode">arch/arm/Kconfig</code> and insert <code class="inlineCode">source "board/ti/nova/Kconfig"</code> after <code class="inlineCode">source "board/tcl/sl50/Kconfig"</code>, as shown here:</p>
    <pre class="programlisting code"><code class="hljs-code">&lt;…&gt;
source "board/st/stv0991/Kconfig"
source "board/tcl/sl50/Kconfig"
source "board/ti/nova/Kconfig"
source "board/toradex/colibri_pxa270/Kconfig"
source "board/variscite/dart_6ul/Kconfig"
&lt;…&gt;
</code></pre>
    <p class="normal">Now that we have copied and modified the board-specific files for our Nova board, let’s move on to the header files.</p>
    <h3 id="_idParaDest-86" class="heading-3"><a id="_idTextAnchor092"/>Configuring header files</h3>
    <p class="normal">Each board has a header file in <code class="inlineCode">include/configs</code> that contains most of the configuration information. The file is named by the <code class="inlineCode">SYS_CONFIG_NAME</code> identifier in the board’s <code class="inlineCode">Kconfig</code> file. The format of this file is<a id="_idIndexMarker248"/> described in detail in the <code class="inlineCode">README</code> file at the top level of the U-Boot source tree. For the purposes of our Nova board, simply copy <code class="inlineCode">include/configs/am62x_evm.h</code> into <code class="inlineCode">include/configs/nova.h</code> and make a few changes, as shown here:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-params">&lt;…&gt;</span>
<span class="hljs-meta">#</span><span class="hljs-keyword">ifndef</span><span class="hljs-meta"> __CONFIG_NOVA_H</span>
<span class="hljs-meta">#</span><span class="hljs-keyword">define</span><span class="hljs-meta"> __CONFIG_NOVA_H</span>
<span class="hljs-meta">#</span><span class="hljs-keyword">include</span><span class="hljs-meta"> </span><span class="hljs-string">&lt;linux/sizes.h&gt;</span>
<span class="hljs-meta">#</span><span class="hljs-keyword">include</span><span class="hljs-meta"> </span><span class="hljs-string">&lt;config_distro_bootcmd.h&gt;</span>
<span class="hljs-meta">#</span><span class="hljs-keyword">include</span><span class="hljs-meta"> </span><span class="hljs-string">&lt;environment/ti/mmc.h&gt;</span>
<span class="hljs-meta">#</span><span class="hljs-keyword">include</span><span class="hljs-meta"> </span><span class="hljs-string">&lt;environment/ti/k3_dfu.h&gt;</span>
<span class="hljs-meta">#</span><span class="hljs-keyword">undef</span><span class="hljs-meta"> CONFIG_SYS_PROMPT</span>
<span class="hljs-meta">#</span><span class="hljs-keyword">define</span><span class="hljs-meta"> CONFIG_SYS_PROMPT        </span><span class="hljs-string">"nova!&gt; "</span>
<span class="hljs-comment">/* DDR Configuration */</span>
<span class="hljs-meta">#</span><span class="hljs-keyword">define</span><span class="hljs-meta"> CONFIG_SYS_SDRAM_BASE1          0x880000000</span>
<span class="hljs-meta">#</span><span class="hljs-keyword">define</span><span class="hljs-meta"> CONFIG_SYS_BOOTM_LEN            SZ_64M</span>
<span class="hljs-meta">#</span><span class="hljs-keyword">ifdef</span><span class="hljs-meta"> CONFIG_SYS_K3_SPL_ATF</span>
<span class="hljs-meta">#</span><span class="hljs-keyword">define</span><span class="hljs-meta"> CONFIG_SPL_FS_LOAD_PAYLOAD_NAME </span><span class="hljs-string">"tispl.bin"</span>
<span class="hljs-meta">#</span><span class="hljs-keyword">endif</span>
<span class="hljs-meta">#</span><span class="hljs-keyword">if</span><span class="hljs-meta"> defined(CONFIG_TARGET_NOVA)</span>
<span class="hljs-meta">#</span><span class="hljs-keyword">define</span><span class="hljs-meta"> CONFIG_SPL_MAX_SIZE             SZ_1M</span>
<span class="hljs-meta">#</span><span class="hljs-keyword">define</span><span class="hljs-meta"> CONFIG_SYS_INIT_SP_ADDR         (CONFIG_SPL_TEXT_BASE + SZ_4M)</span>
<span class="hljs-meta">#</span><span class="hljs-keyword">else</span>
<span class="hljs-params">&lt;…&gt;</span>
<span class="hljs-meta">#</span><span class="hljs-keyword">endif</span><span class="hljs-meta"> </span><span class="hljs-comment">/* __CONFIG_NOVA_H */</span>
</code></pre>
    <p class="normal">First, replace <code class="inlineCode">__CONFIG_AM625_EVM_H</code> with <code class="inlineCode">__CONFIG_NOVA_H</code>. Next, redefine <code class="inlineCode">CONFIG_SYS_PROMPT</code> so that we can identify this bootloader at runtime. Lastly, replace <code class="inlineCode">CONFIG_TARGET_AM625_A53_EVM</code> with <code class="inlineCode">CONFIG_TARGET_NOVA</code> so that <code class="inlineCode">CONFIG_SPL_MAX_SIZE</code> and <code class="inlineCode">CONFIG_SYS_INIT_SP_ADDR</code> are defined correctly.</p>
    <p class="normal">With the source tree fully modified, we<a id="_idIndexMarker249"/> are now ready to build U-Boot for our custom board.</p>
    <h3 id="_idParaDest-87" class="heading-3"><a id="_idTextAnchor093"/>Building and testing</h3>
    <p class="normal">To build U-Boot for the<a id="_idIndexMarker250"/> Nova board:</p>
    <ol>
      <li class="numberedList" value="1">First, navigate back to the U-Boot source tree for BeaglePlay:
        <pre class="programlisting con"><code class="hljs-con">$ cd ~
$ cd u-boot-beagleplay
</code></pre>
      </li>
      <li class="numberedList">Next, set the <code class="inlineCode">ARCH</code> and <code class="inlineCode">CROSS_COMPILE</code> environment variables for 64-bit Arm:
        <pre class="programlisting con"><code class="hljs-con">$ export ARCH=aarch64
$ export CROSS_COMPILE=aarch64-buildroot-linux-gnu-
</code></pre>
      </li>
      <li class="numberedList">Clean out any previous build artifacts:
        <pre class="programlisting con"><code class="hljs-con">$ rm -rf ../build_uboot/a53
$ mkdir ../build_uboot/a53
</code></pre>
      </li>
      <li class="numberedList">Select <code class="inlineCode">nova_defconfig</code> for building:
        <pre class="programlisting con"><code class="hljs-con">$ make nova_defconfig O=../build_uboot/a53
</code></pre>
      </li>
      <li class="numberedList">Run <code class="inlineCode">make menuconfig</code> to configure U-Boot further for building:
        <pre class="programlisting con"><code class="hljs-con">$ make menuconfig O=../build_uboot/a53
</code></pre>
      </li>
      <li class="numberedList">Drill down into the <strong class="screenText">Environment</strong> submenu.</li>
      <li class="numberedList">Select <strong class="screenText">Environment is in a EXT4 filesystem</strong>.</li>
      <li class="numberedList">Deselect any <a id="_idIndexMarker251"/>other options (e.g., MMC, NAND, and SPI) for environment storage on that menu page.</li>
      <li class="numberedList">Enter <code class="inlineCode">mmc</code> in the <strong class="screenText">Name of the block device for the environment</strong> text field.</li>
      <li class="numberedList">Enter <code class="inlineCode">1:2</code> in the <strong class="screenText">Device and partition for where to store the environment in EXT4</strong> text field.</li>
      <li class="numberedList">Ensure <code class="inlineCode">/uboot.env</code> is entered in the <strong class="screenText">Name of the EXT4 file to use for the environment</strong> text field.</li>
      <li class="numberedList">Back out of the <strong class="screenText">Environment</strong> submenu.</li>
      <li class="numberedList">Drill down into the <strong class="screenText">SPL/TPL</strong> submenu.</li>
      <li class="numberedList">Select <strong class="screenText">Support EXT filesystems</strong>.</li>
      <li class="numberedList">Back out of the <strong class="screenText">SPL/TPL</strong> submenu.</li>
      <li class="numberedList">Drill down into the <strong class="screenText">Boot Options</strong> submenu.</li>
      <li class="numberedList">Select <strong class="screenText">Enable a default value for bootcmd</strong>.</li>
      <li class="numberedList">Enter <code class="inlineCode">echo 'no bootcmd yet'</code> in the <strong class="screenText">bootcmd value</strong> text field.</li>
      <li class="numberedList">Exit out of <code class="inlineCode">menuconfig</code> and choose <strong class="screenText">Yes</strong> when asked to save your new configuration.</li>
      <li class="numberedList">Save the modified <code class="inlineCode">defconfig</code>:
        <pre class="programlisting con"><code class="hljs-con">$ make savedefconfig O=../build_uboot/a53
</code></pre>
      </li>
      <li class="numberedList">Update <code class="inlineCode">nova_defconfig</code> with your changes:
        <pre class="programlisting con"><code class="hljs-con">$ cp ../build_uboot/a53/defconfig configs/nova_defconfig
</code></pre>
      </li>
      <li class="numberedList">Lastly, build U-Boot<a id="_idIndexMarker252"/> for the A53, passing paths to TI’s TF-A and DM firmware as arguments to <code class="inlineCode">make</code>:
        <pre class="programlisting con"><code class="hljs-con">$ make ATF=$HOME/arm-trusted-firmware/build/k3/lite/release/bl31.bin DM=$HOME/ti-linux-firmware/ti-dm/am62xx/ipc_echo_testb_mcu1_0_release_strip.xer5f O=../build_uboot/a53
</code></pre>
      </li>
      <li class="numberedList">Copy <code class="inlineCode">tispl.bin</code> and <code class="inlineCode">u-boot.img</code> to the <code class="inlineCode">boot</code> partition of the microSD card you created earlier:
        <pre class="programlisting con"><code class="hljs-con">$ cd ~
$ cd build_uboot/a53
$ cp tispl.bin u-boot.img /media/$USER/boot/.
</code></pre>
      </li>
    </ol>
    <p class="normal">Reinsert the microSD card into BeaglePlay and reapply power while holding down the USR button. You should see output like this (note the custom command prompt) on the serial console:</p>
    <pre class="programlisting con"><code class="hljs-con">&lt;…&gt;
U-Boot SPL 2021.01-gf036fbdc25-dirty (Jun 30 2024 - 18:37:39 -0700)
SYSFW ABI: 3.1 (firmware rev 0x0009 '9.0.4--v09.00.04 (Kool Koala)')
Trying to boot from MMC2
U-Boot 2021.01-gf036fbdc25-dirty (Jun 30 2024 - 18:37:39 -0700)
SoC:   AM62X SR1.0 GP
Model: BeagleBoard.org BeaglePlay
Board: BEAGLEPLAY-A0- rev 02
DRAM:  2 GiB
MMC:   mmc@fa10000: 0, mmc@fa00000: 1, mmc@fa20000: 2
Loading Environment from EXT4... ** File not found /uboot.env **
** Unable to read "/uboot.env" from mmc1:2 **
In:    serial@2800000
Out:   serial@2800000
Err:   serial@2800000
Error: Can't set serial# to SSSS
Net:   Could not get PHY for ethernet@8000000port@1: addr 0
am65_cpsw_nuss_port ethernet@8000000port@1: phy_connect() failed
No ethernet found.
Press SPACE to abort autoboot in 2 seconds
no bootcmd yet
nova!&gt;
</code></pre>
    <p class="normal">You can create a patch for all these <a id="_idIndexMarker253"/>changes by checking them into Git and using the <code class="inlineCode">git format-patch</code> command:</p>
    <pre class="programlisting con"><code class="hljs-con">$ git add .
$ git commit -m "BSP for Nova"
&lt;…&gt;
$ git format-patch -1
0001-BSP-for-Nova.patch
</code></pre>
    <p class="normal">Generating this patch concludes our coverage of U-Boot as a TPL. U-Boot can also be configured to bypass the TPL stage of the boot process altogether. Next, let’s examine this alternate approach to booting Linux.</p>
    <h2 id="_idParaDest-88" class="heading-2"><a id="_idTextAnchor094"/>Falcon mode</h2>
    <p class="normal">We are used to the idea that booting<a id="_idIndexMarker254"/> a modern embedded processor involves the boot ROM loading an SPL, which loads <code class="inlineCode">u-boot.bin</code>, which then loads a Linux kernel. You may be <a id="_idIndexMarker255"/>wondering if there is a way to reduce the number of steps, thereby simplifying and speeding up the boot process. The answer is U-Boot Falcon mode.</p>
    <p class="normal">The idea is simple: have the SPL load a kernel image directly skipping over <code class="inlineCode">u-boot.bin</code>. There is no user interaction and there are no scripts. It just loads a kernel from a known location in flash memory or eMMC into memory, passes it a pre-prepared parameter block, and starts running it. The details of configuring Falcon mode are beyond the scope of this book.</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">IMPORTANT NOTE</strong></p>
      <p class="normal">Falcon mode is named after the peregrine falcon, which is the fastest bird of all, capable of reaching speeds of more than 200 miles per hour in a dive.</p>
    </div>
    <h1 id="_idParaDest-89" class="heading-1"><a id="_idTextAnchor095"/>Summary</h1>
    <p class="normal">Every system needs a bootloader to bring the hardware to life and to load a kernel. U-Boot has found favor with many developers because it supports a useful range of hardware, and it is fairly easy to port to a new device.</p>
    <p class="normal">In this chapter, we learned how to inspect and drive U-Boot interactively from the command line over a serial console. These command-line exercises included loading a kernel over a network using TFTP for rapid iteration. Lastly, we learned how to port U-Boot to a new device by generating a patch for our Nova board.</p>
    <p class="normal">Over the last few years, the complexity and ever-increasing variety of embedded hardware has led to the introduction of the device tree as a way of describing hardware. The device tree is simply a textual representation of a system that is compiled into a device tree binary, which is passed to the kernel when it loads. It is up to the kernel to interpret the device tree and to load and initialize drivers for the devices it finds there.</p>
    <p class="normal">U-Boot is very flexible, allowing images to be loaded from mass storage, flash memory, or a network and then booted. Having covered some of the intricacies of booting Linux, in the next chapter, we will cover the next stage of the process. This is the third element of your embedded project – the kernel.</p>
  </div>
</div></div></body></html>