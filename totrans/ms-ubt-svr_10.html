<html><head></head><body>
<div id="sbo-rt-content"><div class="Basic-Text-Frame" id="_idContainer135">
<h1 class="chapterNumber">10</h1>
<h1 class="chapterTitle" id="_idParaDest-143">Connecting to Networks</h1>
<p class="normal">Linux networks took the IT industry by storm. Many organizations use Linux in their data centers, on both physical servers and in the cloud. Ubuntu Server is among the most popular choices for running mission-critical applications, but without a stable network to connect the individual components of your infrastructure together, even the most powerful server hardware will be ineffective.</p>
<p class="normal">So far in this book, we’ve worked with a single Ubuntu Server instance. Here, we begin a two-part look at networking in Linux. In this chapter, we’ll discuss topics related to initial network connectivity and remote management. We’ll continue learning additional networking topics in <em class="chapterRef">Chapter 11</em>, <em class="italic">Setting Up Network Services</em>, where we’ll work on building and configuring additional components that will enable your servers to communicate more effectively, which will result in a strong foundational network that will serve your needs for years to come.</p>
<p class="normal">In this episode of our Ubuntu adventure, we will cover:</p>
<ul>
<li class="bulletList">Setting the hostname</li>
<li class="bulletList">Managing network interfaces</li>
<li class="bulletList">Assigning static IP addresses</li>
<li class="bulletList">Understanding Linux name resolution</li>
<li class="bulletList">Getting started with OpenSSH</li>
<li class="bulletList">Getting started with SSH key management</li>
<li class="bulletList">Simplifying SSH connections with a config file</li>
</ul>
<p class="normal">To get started in our exploration of networking, we should first give each of our Ubuntu servers its own identity; basically, we should give them a name to help distinguish each from the others.</p>
<h1 class="heading-1" id="_idParaDest-144">Setting the hostname</h1>
<p class="normal">During installation, you <a id="_idIndexMarker512"/>were asked to create a hostname for your server. Specifically, the field was labeled <code class="inlineCode">Your server's name</code> during the initial setup process. At that time, our goal was to simply get an Ubuntu Server installation set up for working through the examples in this book. At this point, you may consider changing the hostname of your server. </p>
<p class="normal">When we utilize OpenSSH to remotely manage our servers (as we’ll do later on in this chapter), the hostname is shown on the command line. That can be very confusing if all servers have the same name. More importantly, the hostname of a server gives it an identity. When it comes to real production deployments of Ubuntu Server, each individual server should have its own designated purpose, and be named accordingly. Often, organizations will have their own naming scheme. Perhaps web servers in a company are named similar to <code class="inlineCode">webserver-01</code>, or with a fully qualified domain name, such as <code class="inlineCode">webserver-01.example.com</code>.</p>
<p class="normal">In this book, I won’t assume any particular naming scheme, so when we do work through changing the hostname, feel free to adjust the name as you see fit. If you don’t have a naming scheme (but would like to create one) feel free to get creative. I’ve seen quite a few variations, from naming servers after cartoon characters (who wouldn’t want a server named <code class="inlineCode">daffy-duck</code>?), to Greek gods or goddesses. Some companies choose to be a bit boring and come up with naming schemes consisting of a series of characters separated by hyphens, with codes representing which rack the server is in, as well as its purpose. You can create your own naming convention if you haven’t already, and no matter what you come up with, I won’t judge you.</p>
<p class="normal">As I mentioned, the hostname of your server is its identity. It identifies your server to the rest of the network. While a simple hostname, such as <code class="inlineCode">ubuntu</code>, is fine if you have just one host, it would get confusing really quickly if you kept the default on every Ubuntu Server within your network. Giving each server a descriptive name helps you tell them apart from each other. But there’s more to a server’s name than its hostname, which we’ll get into in <em class="chapterRef">Chapter 11</em>, <em class="italic">Setting Up Network Services</em>, when we discuss DNS. But for now, we’ll work through viewing and configuring the hostname, so you’ll be ready to make your hostname official with a DNS assignment, when we come to it.</p>
<p class="normal">So, how do you view your hostname? One way is to simply look at your shell prompt; you’ve probably already noticed that your hostname is included there. While you can customize your shell prompt in many different ways, the default shows your current hostname. However, depending on what you’ve named your server, it may or may not show the entire name. Basically, the <a id="_idIndexMarker513"/>default prompt (known as a <strong class="keyWord">PS1 prompt</strong>, in case you were wondering) shows the hostname only until it reaches the first period. For example, if your hostname is <code class="inlineCode">dev.mycompany.org</code>, your prompt will only show <code class="inlineCode">dev</code>. To view the entire <a id="_idIndexMarker514"/>hostname, simply enter the <code class="inlineCode">hostname</code> command:</p>
<figure class="mediaobject"><img alt="Graphical user interface, application  Description automatically generated" height="166" src="../Images/B18425_10_01.png" width="601"/></figure>
<p class="packt_figref">Figure 10.1: Output from the hostname command</p>
<p class="normal">Changing the hostname is fairly simple. To do this, we can use the <code class="inlineCode">hostnamectl</code> command as <code class="inlineCode">root</code> or with <code class="inlineCode">sudo</code>. If, for example, I’d like to change my hostname from <code class="inlineCode">dev.mynetwork.org</code> to <code class="inlineCode">dev2.mynetwork.org</code>, I would execute the following command:</p>
<pre class="programlisting con"><code class="hljs-con">sudo hostnamectl set-hostname dev2.mynetwork.org 
</code></pre>
<p class="normal">Simple enough, but what does that command actually do? Well, I’d love to give you a fancy outline, but all it really does is change the contents of a text file (specifically, <code class="inlineCode">/etc/hostname</code>). To see this for yourself, feel free to use the <code class="inlineCode">cat</code> command to view the contents of this file before and after making the change with <code class="inlineCode">hostnamectl</code>:</p>
<pre class="programlisting con"><code class="hljs-con">cat /etc/hostname 
</code></pre>
<p class="normal">You’ll see that this file contains only your hostname.</p>
<p class="normal">Once you change your hostname, you may start seeing an error message similar to the following after executing some commands:</p>
<pre class="programlisting con"><code class="hljs-con">unable to resolve host dev.mynetwork.org 
</code></pre>
<p class="normal">This error means that the computer is no longer able to resolve your local hostname. This is due to the fact that the <code class="inlineCode">/etc/hostname</code> file is not the only file where your hostname is located; it’s also referenced in <code class="inlineCode">/etc/hosts</code>. Unfortunately, the <code class="inlineCode">hostnamectl</code> command doesn’t update <code class="inlineCode">/etc/hosts</code> for you, so you’ll need to edit that file yourself to make the<a id="_idIndexMarker515"/> error go away. Here’s what an <code class="inlineCode">/etc/hosts</code> file looks like on an example server:</p>
<figure class="mediaobject"><img alt="Text  Description automatically generated" height="363" src="../Images/B18425_10_02.png" width="818"/></figure>
<p class="packt_figref">Figure 10.2: Sample contents from an /etc/hosts file</p>
<p class="normal">The first two entries, in this example, refer to the local machine itself. Localhost addresses, also <a id="_idIndexMarker516"/>known as <strong class="keyWord">loopback addresses</strong>, allow the machine to essentially reach itself. If you were to use the <code class="inlineCode">ping</code> command against the <code class="inlineCode">127.0.0.1</code> address, the reply would come from the machine that executed the command, not from another host on the network. On the first line, we have the following:</p>
<pre class="programlisting con"><code class="hljs-con">127.0.0.1 localhost
</code></pre>
<p class="normal">If you were to use any networking command to attempt to communicate with the local server, such as pinging <code class="inlineCode">127.0.0.1</code> or <code class="inlineCode">localhost</code>, the <code class="inlineCode">/etc/hosts</code> file on this line declares that this communication is directed toward the underlying server itself.</p>
<p class="normal">With the second line in the example screenshot, we have the following:</p>
<pre class="programlisting con"><code class="hljs-con">127.0.1.1 dev.mynetwork.org dev
</code></pre>
<p class="normal">Depending on your configuration, such as whether you are using a physical server, a virtualization platform, or a cloud server provider, that line may or may not be present. You can add that line if it’s missing, but we’ll talk about that more in a moment.</p>
<p class="normal">Essentially, that particular line identifies that the local server can also be reached at the IP address <code class="inlineCode">127.0.1.1</code>, the fully qualified domain name of <code class="inlineCode">dev.mynetwork.org</code>, as well as the simplified form of <code class="inlineCode">dev</code>. A fully qualified domain name consists of the name of the server (<code class="inlineCode">dev</code> in this case) as well as the domain name for the organization (<code class="inlineCode">mynetwork.org</code> in this example). This enables you to ping your local server directly from that server by using the name <code class="inlineCode">dev.mynetwork.org</code> or the simplified form of <code class="inlineCode">dev</code>.</p>
<p class="normal">If you don’t<a id="_idIndexMarker517"/> have a domain name to use with your servers, you can leave the fully qualified domain name out of the <code class="inlineCode">/etc/hosts</code> file. So in our example, that line would look like the following if there was no domain:</p>
<pre class="programlisting con"><code class="hljs-con">127.0.1.1 dev
</code></pre>
<p class="normal">Going back to our example of changing a hostname on a server, I mentioned that you can use the <code class="inlineCode">hostnamectl</code> command to do that, but that command doesn’t update the <code class="inlineCode">/etc/hosts</code> file for you, it only updates the <code class="inlineCode">/etc/hostname</code> file. It’s a best practice to also update the <code class="inlineCode">/etc/hosts</code> file to match. You can avoid using the <code class="inlineCode">hostnamectl</code> command altogether and manually edit the <code class="inlineCode">/etc/hosts</code> and <code class="inlineCode">/etc/hostname</code> files, which is actually my preferred method. If I have to manually edit a text file, regardless of whether or not I use the <code class="inlineCode">hostnamectl</code> command, I figure that I may as well use a text editor for both.</p>
<p class="normal">The main takeaway, though, is to give your servers an identity that makes sense and matches the role that the server will fill within your network. At a typical organization, you’ll have web servers, file servers, database servers, and more. A consistent and logical naming scheme will just make everything that much easier.</p>
<p class="normal">Now that we have learned how to give our servers an identity, we can learn how to manage network interfaces.</p>
<h1 class="heading-1" id="_idParaDest-145">Managing network interfaces</h1>
<p class="normal">Networking<a id="_idIndexMarker518"/> is critical for server infrastructure. Without a network, servers cannot communicate with one another, and users will be unable to access them. In order for a server to connect to a network, it needs to have a network interface installed. Most servers will have a standard wired Ethernet adapter installed, allowing you to plug in a network cable to connect it to a switch. Assuming our server’s hardware has been properly detected by Ubuntu, this is handled pretty much automatically. However, the automatic configuration is not always ideal. Perhaps we want to customize the IP address or settings related to the connection.</p>
<p class="normal">First, we need <a id="_idIndexMarker519"/>to understand how to view the current connection parameters that the network card of our server currently has in effect. That’s the main goal of this section. We can do so using two basic commands: <code class="inlineCode">ip</code> (which is recommended) and <code class="inlineCode">ifconfig</code> (which was the previous method in older versions of Ubuntu, and its usage is no longer recommended).</p>
<p class="normal">We can review information regarding our network interfaces and manage them with the <code class="inlineCode">ip</code> command. For example, we can use <code class="inlineCode">ip addr show</code> to view our currently assigned IP address:</p>
<pre class="programlisting con"><code class="hljs-con">ip addr show
</code></pre>
<p class="normal">This will produce an output similar to that shown in the following screenshot:</p>
<figure class="mediaobject"><img alt="Text  Description automatically generated" height="335" src="../Images/B18425_10_03.png" width="875"/></figure>
<p class="packt_figref">Figure 10.3: Viewing IP information with the ip addr show command</p>
<p class="normal">Once you enter that command, you should see output that pertains to the network interfaces that you have available and their current status. Also, you can abbreviate the command all the way down to simply <code class="inlineCode">ip a</code> (the output will be the same in either case). From the output, we can see several useful tidbits, such as the IP address for each device (if it has one), as well as its MAC address.</p>
<p class="normal">Using the <code class="inlineCode">ip</code> command, we can also manage the state of an interface. We can bring a device down (prevent it from connecting to networks), and then back up again:</p>
<pre class="programlisting con"><code class="hljs-con">sudo ip link set enp0s3 down 
sudo ip link set enp0s3 up 
</code></pre>
<p class="normal">In that example, I’m simply toggling the state for interface <code class="inlineCode">enp0s3</code>. First, I’m bringing it down, and then I’m bringing it back up again.</p>
<p class="normal">Bringing <a id="_idIndexMarker520"/>interfaces up and down is all well and good, but what’s up with that naming convention? The convention used in Ubuntu 22.04 may seem a bit strange for those of you that have grown accustomed to the scheme used in earlier versions, which utilized network interface names such as <code class="inlineCode">eth0</code>, <code class="inlineCode">wlan0</code>, and so on. Since Ubuntu is based on Debian, it has adopted the new naming convention that was introduced starting with Debian 9.0.</p>
<p class="normal">The new naming convention has been put in place in order to make interface naming more predictable. While you may argue that names such as <code class="inlineCode">eth0</code> may be easier to memorize than something like <code class="inlineCode">enp0s3</code>, the change helps the name stay persistent between boots. When you add new network interfaces to a Linux system, there’s always the possibility that other interface names may change as well.</p>
<p class="normal">For example, if you have an older Linux installation on a server with a single network card (<code class="inlineCode">eth0</code>) and you add a second (which is given the name <code class="inlineCode">eth1</code>), your configuration may break if the names were to get switched during the next boot. Imagine for a moment that one interface is connected to the internet and another connected to a switch (basically, you have an internet gateway). If the interfaces came up in the wrong order, internet access would be disrupted for your entire office, due to the fact that the firewall rules you’ve written are being applied to the wrong interfaces. Definitely not a pleasant experience!</p>
<p class="normal">In the past, previous versions of Ubuntu (as well as Debian, and even CentOS) have opted to use <code class="inlineCode">udev</code> to make the names stick in order to work around this issue. This is no longer necessary nowadays, but I figured I’d mention it here just in case you end up working on a server with an older installation. These older servers would achieve stickiness with interface names from configuration stored in the following file:</p>
<pre class="programlisting con"><code class="hljs-con">/etc/udev/rules.d/70-persistent-net-rules 
</code></pre>
<p class="normal">This file existed on older versions of some popular Linux distributions (including Ubuntu), as a workaround to this problem. This file contains some information that identifies specific qualities of the network interface, so that with each boot, it will always come up with the same name. Therefore, the card you recognize as <code class="inlineCode">eth0</code> will always be <code class="inlineCode">eth0</code>. If you have an older version of Ubuntu Server in use, you should be able to see this file for yourself. Here’s some sample output of this file on an older installation:</p>
<pre class="programlisting con"><code class="hljs-con">SUBSYSTEM=="net", ACTION=="add", DRIVERS=="?*", 
TTR{address}=="01:22:4e:a5:f2:ec", ATTR{dev_id}=="0x0", ATTR{type}=="1", KERNEL=="eth*", NAME="eth0" 
</code></pre>
<p class="normal">As you<a id="_idIndexMarker521"/> can see, it’s using the MAC address of the card to identify it with <code class="inlineCode">eth0</code>. But this becomes a small problem if I want to take an image of this machine and re-deploy it onto another server. This is a common practice—we administrators rarely start over from scratch if we don’t have to, and if another server is similar enough to a new server’s desired purpose, cloning it will be an option. However, when we restore the image onto another server, the <code class="inlineCode">/etc/udev/rules.d/70-persistent-net-rules</code> file will come along for the ride. We’ll more than likely find that the new server’s first network interface will have a designation of <code class="inlineCode">eth1</code>, even if we only have one interface.</p>
<p class="normal">This is because the file already designated a device as <code class="inlineCode">eth0</code> (it’s referencing a device that’s not present in the system), so we would need to correct this file ourselves in order to reclaim <code class="inlineCode">eth0</code>. We would do that by editing the <code class="inlineCode">rules</code> file, deleting the line that contains the card that’s not on the system, and then changing the device designation on the remaining line back to <code class="inlineCode">eth0</code>.</p>
<p class="normal">The new naming scheme is effective as of <code class="inlineCode">systemd v197</code> and later (in case you didn’t already know from earlier topics in this book, <code class="inlineCode">systemd</code> is the underlying framework utilized in Ubuntu for managing processes and various resources). For the most part, the new naming convention references the physical location of the network card on your system’s bus. </p>
<p class="normal">Therefore, the name it receives cannot change unless you were to actually remove the network card and place it in a different slot on the system’s board, or change the position of the virtual network device in your hypervisor.</p>
<p class="normal">As a quick overview of how the network names break down, <code class="inlineCode">en</code> is for Ethernet, and <code class="inlineCode">wl</code> is for wireless. Therefore, we know that the example interface I mentioned earlier (<code class="inlineCode">enp0s3</code>) references a wired card. The <code class="inlineCode">p</code> references which bus is being used, so <code class="inlineCode">p0</code> refers to the system’s first PCI bus (the numbering starts at 0). Next, we have <code class="inlineCode">s3</code>, which references PCI slot 3. Putting it together, <code class="inlineCode">enp0s3</code> references a wired network interface card on the system’s first bus, placed in PCI slot 3. The exact details of the new naming specification could even be a chapter of its own, but hopefully this gives you a general idea of how the new naming convention breaks down. There’s much more documentation online if you’re interested in the nitty-gritty details (see the <em class="italic">Further reading</em> section). The important point here is that since the new naming scheme is based on where the card is physically located, it’s much less likely to change abruptly. In fact, it can’t change, as long as you don’t physically switch the positions of your network cards inside the case.</p>
<p class="normal">Getting back to <a id="_idIndexMarker522"/>managing our interfaces, another command worth discussion is <code class="inlineCode">ifconfig</code>.</p>
<p class="normal">The <code class="inlineCode">ifconfig</code> command is part of the <code class="inlineCode">net-tools</code> suite of utilities, which has been deprecated (for the most part). Its replacement is the <code class="inlineCode">iproute2</code> suite of utilities, which includes the <code class="inlineCode">ip</code> command we’ve already discussed. In summary, this basically means you should be using commands from the <code class="inlineCode">iproute2</code> suite, instead of commands such as <code class="inlineCode">ifconfig</code>. The problem, though, is that most administrators nowadays still use <code class="inlineCode">ifconfig</code>, with no sign of it slowing down. In fact, the <code class="inlineCode">net-tools</code> suite has been recommended for deprecation for years now, and many Linux distributions shipping today still have this suite installed by default. Those that don’t have it installed offer it as an additional package that you can install. In the case of Ubuntu Server 22.04, the <code class="inlineCode">net-tools</code> package is no longer installed by default, but it’s still available if you want to manually install it. I don’t recommend installing it though, since it’s deprecated and shouldn’t be used anymore.</p>
<p class="normal">The reason commands such as <code class="inlineCode">ifconfig</code> have a tendency to stick around so long after they’ve been deprecated usually comes down to the <em class="italic">change is hard</em> mentality, but quite a few scripts and programs out there are still using <code class="inlineCode">ifconfig</code>, and therefore it’s worth discussing here. Even if you immediately stop using <code class="inlineCode">ifconfig</code>, and move to <code class="inlineCode">ip</code> from now on, you’ll still encounter this command on your travels, so you may as well know a few examples. Knowing the older commands will also help you if you find yourself on an older server.</p>
<p class="normal">First, when executed by itself with no options, <code class="inlineCode">ifconfig</code> will print information regarding your interfaces like we did with <code class="inlineCode">ip addr show</code> earlier. That seems pretty simple.</p>
<p class="normal">If you are unable to use <code class="inlineCode">ifconfig</code> to view interface information using a normal user, try using the fully qualified command (include the full path):</p>
<pre class="programlisting con"><code class="hljs-con">/usr/sbin/ifconfig
</code></pre>
<p class="normal">The <code class="inlineCode">/usr/sbin</code> directory may or may not be in your <code class="inlineCode">$PATH</code> (a set of directories your shell looks within for commands), so if your system doesn’t recognize <code class="inlineCode">ifconfig</code>, using the fully qualified command should produce the desired output, as follows:</p>
<figure class="mediaobject"><img alt="Text  Description automatically generated" height="764" src="../Images/B18425_10_04.png" width="883"/></figure>
<p class="packt_figref">Figure 10.4: Viewing interface information with the ifconfig command</p>
<p class="normal">Secondly, just <a id="_idIndexMarker523"/>like with the <code class="inlineCode">ip</code> commands we practiced earlier, we can also bring an interface down or up with <code class="inlineCode">ifconfig</code> as well:</p>
<pre class="programlisting con"><code class="hljs-con">sudo ifconfig enp0s3 down 
sudo ifconfig enp0s3 up 
</code></pre>
<p class="normal">There are, of course, other options and variations of <code class="inlineCode">ip</code> and <code class="inlineCode">ifconfig</code>, so feel free to look up the man pages for either if you want more information. For the purposes of this section, the <a id="_idIndexMarker524"/>main thing is to remember how to view your current IP assignments, as well as how to bring an interface up or down.</p>
<p class="normal">As useful as our network interfaces can be, they’re useless without an IP address assigned to them. While a network will often use DHCP to take care of this, in the next section we’ll take a look at how to assign a static IP address.</p>
<h1 class="heading-1" id="_idParaDest-146">Assigning static IP addresses</h1>
<p class="normal">With <a id="_idIndexMarker525"/>servers, it’s very important that your IP addresses remain fixed and do not change for any reason. If an IP address does change (such as a dynamic lease with no reservation), your users will experience an outage, services will fail, or entire sites may become unavailable. When you install Ubuntu Server, it will grab a dynamically assigned lease from your DHCP server, but after you configure the server the way you want it, it’s important to set a permanent IP address right away before it’s considered production-ready. One exception to this rule is an Ubuntu-based VPS. Cloud providers that bill you for these servers will have an automatic system in place to declare an IP address for your new VPS, and will already have it configured to remain in place. But in the case of virtual or physical servers you manage yourself, you’ll start off with a dynamic address, unless you’ve already configured a static IP address during installation.</p>
<p class="normal">In most cases, you’ll have an IP address scheme in place at your office or organization, which will outline a range of IP addresses that are available for use with static assignments. If you don’t have such a scheme, it’s important to create one, so you will have less work to do later when you bring more servers online. We’ll talk about setting up a DHCP server and IP address scheme in <em class="chapterRef">Chapter 11</em>, <em class="italic">Setting Up Network Services</em>, but for now, I’ll give you a few quick tips. Your DHCP server will typically have a range of IP addresses that will be automatically assigned to any host that requests an assignment. When setting up a static IP on a server, you’ll want to make sure that the IP address that you choose is outside of the range that your DHCP server assigns so you don’t end up with a duplicate IP on your network. For example, if your DHCP server assigns IPs ranging from <code class="inlineCode">10.10.10.100</code> through <code class="inlineCode">10.10.10.150</code>, you’ll want to use an IP address <em class="italic">not</em> included within that range for your servers.</p>
<p class="normal">There are two ways of assigning a fixed address to a network host, including your servers. The first is by using a static IP assignment, as I’ve already mentioned. With that method, you’ll arbitrarily grab an IP address that’s not being used by anything, and then configure your Ubuntu Server to use that address. In that case, your server is never requesting an IP address from your network’s DHCP server. It simply uses whatever you assign it. This is the method I’ll be going over in this section.</p>
<p class="normal">The other way of assigning a fixed address to a server is by using a static lease. This is also known<a id="_idIndexMarker526"/> as a <strong class="keyWord">DHCP reservation</strong>, but I prefer to use the former term. With this method, you configure your DHCP server to assign a specific IP address to specific hosts. In other words, your server will request an IP address from your local DHCP server, and your DHCP server is instructed to give a specific address to your server each time it asks for one. This is the method I prefer, because it makes your DHCP server the single source of truth for the IP addresses that are assigned on your network. I’ll go over it in more detail in <em class="chapterRef">Chapter 11</em>, <em class="italic">Setting Up Network Services</em>.</p>
<p class="normal">However, you <a id="_idIndexMarker527"/>don’t always have a choice. As a Linux administrator, you may or may not be in charge of the DHCP server. It’s often the case at many organizations that administrators that manage servers are not the same individuals that also manage the network. </p>
<p class="normal">If you don’t have authority over the design of the network, you’d use an IP address that would be provided to you by your network administrator, and then you’ll proceed to configure your Ubuntu Server to use it by applying the parameters they give you.</p>
<p class="normal">Within the last several years, the method that we utilize to customize the IP address of our servers has changed from the way it was handled in the past. Since Ubuntu 17.10, which was released back in 2017, configuring your IP address settings is now done via Netplan. In the past, we would configure networking via NetworkManager, but that’s installed only by default in Ubuntu Desktop. With Netplan, configuration files for your network interfaces now reside in the <code class="inlineCode">/etc/netplan</code> directory, in YAML format. Explaining the YAML format itself is beyond the scope of this book, but the syntax is very easy to follow so you don’t really need to thoroughly understand this format in order to configure your network interfaces. If you list the contents of the <code class="inlineCode">/etc/netplan</code> directory, you should see at least one file there, often named <code class="inlineCode">00-installer-config.yaml</code> or <code class="inlineCode">50-cloud-init.yaml</code>. It’s possible the file could be saved with a different name, so check the contents of the <code class="inlineCode">/etc/netplan</code> directory to see what the file is named on your end. On one of my servers, I see the following contents in the <code class="inlineCode">/etc/netplan/00-installer-config.yaml</code> file:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># This is the network config written by 'subiquity'</span>
<span class="hljs-attr">network:</span>
  <span class="hljs-attr">ethernets:</span>
    <span class="hljs-attr">enp0s3:</span>
      <span class="hljs-attr">dhcp4:</span> <span class="hljs-literal">true</span>
  <span class="hljs-attr">version:</span> <span class="hljs-number">2</span>
</code></pre>
<p class="normal">We can already glean some obvious information from this default file. First, the comment at the beginning mentions <code class="inlineCode">subiquity</code>, which is the official name of the Ubuntu Server installer, used when you install the distribution from boot media created from the ISO file.</p>
<p class="normal">More importantly, we <a id="_idIndexMarker528"/>can see that this particular server is configured to utilize DHCP in order to grab an IP address, which we can tell from the following line:</p>
<pre class="programlisting code"><code class="hljs-code">      <span class="hljs-attr">dhcp4:</span> <span class="hljs-literal">true</span>
</code></pre>
<p class="normal">We can also tell that this configuration file pertains to interface <code class="inlineCode">enp0s3</code>. Putting it all together, this file is telling us that interface <code class="inlineCode">enp0s3</code> is configured to automatically obtain an IP address via DHCP. If we’d like to convert this configuration to a static IP address instead, we should first back up the file:</p>
<pre class="programlisting con"><code class="hljs-con">sudo cp /etc/netplan/00-installer-config.yaml /etc/netplan/00-installer-config.yaml.bak
</code></pre>
<p class="normal">This way, if we make a mistake, we can easily restore the original file by renaming the backup file to the original name. This is a good practice to get into, regardless of the file we’re editing. Being able to restore a previous configuration is a best practice for just about any change we might be making. The first change we need to make is to remove the following line (or just change it to <code class="inlineCode">false</code>):</p>
<pre class="programlisting code"><code class="hljs-code">      <span class="hljs-attr">dhcp4:</span> <span class="hljs-literal">true</span>
</code></pre>
<p class="normal">Essentially, to set up a static IP we will replace that line with the details specific to our configuration. Here’s an example of the file, configured for a static IP address:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># This is the network config written by 'subiquity'</span>
<span class="hljs-attr">network:</span>
  <span class="hljs-attr">ethernets:</span>
    <span class="hljs-attr">enp0s3:</span>
      <span class="code-highlight"><strong class="hljs-attr-slc">addresses:</strong><strong class="hljs-slc"> [</strong><strong class="hljs-number-slc">192.168.100.50</strong><strong class="hljs-string-slc">/24</strong><strong class="hljs-slc">]</strong></span>
      <span class="code-highlight"><strong class="hljs-attr-slc">gateway4:</strong><strong class="hljs-slc"> </strong><strong class="hljs-number-slc">192.168.100.1</strong></span>
      <span class="code-highlight"><strong class="hljs-attr-slc">nameservers:</strong></span>
        <span class="code-highlight"><strong class="hljs-attr-slc">addresses:</strong><strong class="hljs-slc"> [</strong><strong class="hljs-number-slc">192.168.100.1</strong><strong class="hljs-slc">, </strong><strong class="hljs-number-slc">192.168.100.2</strong><strong class="hljs-slc">]</strong></span>
  <span class="hljs-attr">version:</span> <span class="hljs-number">2</span>
</code></pre>
<p class="normal">In the example, I’ve bolded four lines, which were added in place of the <code class="inlineCode">dhcp4: true</code> line. First, we set the actual IP address:</p>
<pre class="programlisting code"><code class="hljs-code">      <span class="hljs-attr">addresses:</span> [<span class="hljs-number">192.168.100.50</span><span class="hljs-string">/24</span>]
</code></pre>
<p class="normal">There, I’ve used <a id="_idIndexMarker529"/>an example IP address of <code class="inlineCode">192.168.100.50/24</code>. On your end, you would make sure that the IP address you choose is within the scope of the network you’d like your server to be a part of. As I mentioned earlier, the IP address you choose should <em class="italic">not</em> be within the DHCP scope that automatically assigned IP addresses are chosen from. The preceding IP address would be fine if the example scope of the DHCP server on your network ranged from <code class="inlineCode">192.168.100.100</code> to <code class="inlineCode">192.168.100.150</code>. The IP chosen here of <code class="inlineCode">192.168.100.50</code> is outside of that, so we don’t have to worry about another device being assigned that address.</p>
<p class="normal">We also include <code class="inlineCode">/24</code> to declare that the IP address is part <a id="_idIndexMarker530"/>of a 24-bit <strong class="keyWord">subnet</strong>, which is fairly standard unless your network administrator has set up a larger scope. An <code class="inlineCode">/24</code> network is the same as a Class C network, in case that’s more familiar to you. This also takes care of the subnet mask, which we don’t need here since <code class="inlineCode">/24</code> implies the same subnet mask as <code class="inlineCode">255.255.255.0</code> (if you’re more familiar with the classful style, which shows the subnet mask in the same format as an IP address). We will discuss subnets in <em class="chapterRef">Chapter 11</em>, <em class="italic">Setting Up Network Services</em>; however, a full walk-through of subnetting and the TCP/IP protocol would be more fitting for a book dedicated to networking concepts, so we won’t go anymore into detail than necessary.</p>
<p class="normal">Moving on, we also set up the gateway:</p>
<pre class="programlisting code"><code class="hljs-code">      <span class="hljs-attr">gateway4:</span> <span class="hljs-number">192.168.100.1</span>
</code></pre>
<p class="normal">When it comes to networking, the gateway refers to the device your outbound connections are routed through, which will often be a router or firewall, depending on how your network is set up. This value will need to match the actual default gateway address on your network, which is quite often the same as the IP address with the last portion being <code class="inlineCode">.1</code>. If in doubt, you can check the IP address assignment of another device on the same network you’re joining the Ubuntu server to, which would be the same.</p>
<p class="normal">The last section allows us to configure the DNS server that our server will use to look up external domain names:</p>
<pre class="programlisting code"><code class="hljs-code">      <span class="hljs-attr">nameservers:</span>
        <span class="hljs-attr">addresses:</span> [<span class="hljs-number">192.168.100.1</span>, <span class="hljs-number">192.168.100.2</span>]
</code></pre>
<p class="normal">The example configuration is just that, an example—all the values must match whatever is appropriate for your network. Often, the DNS server IP address will be the same as the gateway address, but that’s not always true. Sometimes a network administrator will have a custom IP scheme for DNS servers. I also added a secondary DNS server in the example, <code class="inlineCode">192.168.100.2</code>, but you can remove the second IP address if that’s not necessary.</p>
<p class="normal">Once you’ve <a id="_idIndexMarker531"/>ensured that the values in the file are appropriate, we’ll need to apply and test these changes:</p>
<ul>
<li class="bulletList">If you are using a virtual machine, you may want to make the changes from the virtual machine console</li>
<li class="bulletList">If you’re updating a physical machine, you may want to have a display and keyboard attached</li>
<li class="bulletList">Although we discuss OpenSSH later in this chapter, if you’re already aware of how to connect to a server via OpenSSH, you probably won’t want to change network configuration over OpenSSH, since as soon as you activate these changes your connection will drop</li>
</ul>
<p class="normal">Just take your time and double-check everything to ensure you didn’t mistype anything, so you won’t find yourself with a server that cannot connect.</p>
<p class="normal">To actually make these changes take effect, you can run the following command:</p>
<pre class="programlisting con"><code class="hljs-con">sudo netplan apply
</code></pre>
<p class="normal">When you run the previous command, it will let you know if there are any errors in the file or apply the changes if not. The new IP address will take effect immediately.</p>
<p class="normal">In the case of utilizing remote connections such as OpenSSH while configuring networking, you can work around the issue of being disconnected and having networking not restart properly by using <code class="inlineCode">tmux</code>, a popular terminal multiplexer. A full run-through of <code class="inlineCode">tmux</code> is beyond the scope of this book, but it is helpful to us in this scenario because it keeps commands running in the background, even if our connection to the server gets dropped. To use it, first install the package:</p>
<pre class="programlisting con"><code class="hljs-con">sudo apt install tmux 
</code></pre>
<p class="normal">Then, activate <code class="inlineCode">tmux</code> by simply typing <code class="inlineCode">tmux</code> in your shell prompt.</p>
<p class="normal">From this point on, <code class="inlineCode">tmux</code> is now responsible for your session. If you run a command within <code class="inlineCode">tmux</code>, it will continue to run, regardless of whether or not you’re attached to it. To see this in action, first enter <code class="inlineCode">tmux</code> and then execute the <code class="inlineCode">top</code> command. While <code class="inlineCode">top</code> is running, disconnect from <code class="inlineCode">tmux</code>. To do that, press <em class="keystroke">Ctrl</em> + <em class="keystroke">b</em> on your keyboard, release, and then press <em class="keystroke">d</em>. You’ll exit <code class="inlineCode">tmux</code>, but if you enter the <code class="inlineCode">tmux a</code> command to reattach your session, you’ll see that <code class="inlineCode">top</code> was still running even though you disconnected. Following this same logic, you can activate <code class="inlineCode">tmux</code> prior to executing the <code class="inlineCode">sudo netplan apply</code> command. </p>
<p class="normal">Most likely, you’ll still get dropped from your shell, since the process of activating network changes brings the network interface down and then back up again, but with <code class="inlineCode">tmux</code> the command will complete in the background. You can then reconnect to the server and run <code class="inlineCode">tmux a</code> to rejoin your <code class="inlineCode">tmux</code> session.</p>
<p class="normal">The <code class="inlineCode">tmux</code> utility is<a id="_idIndexMarker532"/> extremely powerful, and when harnessed can really enhance your workflow when using the Linux shell. Although a complete tutorial is outside the scope of this book, I highly recommend looking into using it, which you can do here: <a href="https://www.packtpub.com/hardware-and-creative/getting-started-tmux"><span class="url">https://www.packtpub.com/hardware-and-creative/getting-started-tmux</span></a>. If you need some guidance with it, check out the video guide on LearnLinuxTV that<a id="_idIndexMarker533"/> will be linked at the end of this chapter.</p>
<p class="normal">With networking restarted, you should be able to immediately reconnect to the server and see that the new IP assignment has taken place by executing <code class="inlineCode">ip a</code>. If, for some reason, you cannot reconnect to the server, you may have made a mistake while editing the configuration file for Netplan. Double-check that file for any errors. But as long as you’ve followed along and typed in the proper values for your interface and network, you should be up and running with a static IP assignment.</p>
<p class="normal">Now, we have an actual network—we’ve named our server(s) and configured our network interfaces. We should also understand how name resolution works in Ubuntu, which is the process in which servers are able to find other servers by their name.</p>
<h1 class="heading-1" id="_idParaDest-147">Understanding Linux name resolution</h1>
<p class="normal">In <em class="chapterRef">Chapter 11</em>, <em class="italic">Setting Up Network Services</em>, we’ll have a discussion on setting up a DNS server for<a id="_idIndexMarker534"/> local name resolution for your network. But before we get to that, it’s also important to understand how Linux resolves names in the first place. Most of you are probably aware of the concept of a <strong class="keyWord">Domain Name System</strong> (<strong class="keyWord">DNS</strong>), which <a id="_idIndexMarker535"/>matches human-understandable domain names to IP addresses. This makes browsing your network (as well as the internet) much easier. However, a DNS isn’t always the first thing that your Linux server will use when resolving names.</p>
<p class="normal">For more information on the order in which Ubuntu Server checks resources to resolve names, feel free to take a look at the <code class="inlineCode">/etc/nsswitch.conf</code> file. There’s a line in this file that begins with the word <code class="inlineCode">hosts</code>. Here is the output of the relevant line from the file on my server:</p>
<pre class="programlisting con"><code class="hljs-con">hosts:          files mdns4_minimal [NOTFOUND=return] dns mymachines
</code></pre>
<p class="normal">In this case, the server is configured to first check local files, and then the DNS if the request isn’t found. This is the default order, and I see little reason to make any changes here (but you certainly can). Specifically, the file the server will check is <code class="inlineCode">/etc/hosts</code>. If it doesn’t find what it needs there, it will move on to the DNS (basically, it will check the DNS server we configured earlier with Netplan, or the default server provided by DHCP).</p>
<p class="normal">There are many <a id="_idIndexMarker536"/>other lines in the <code class="inlineCode">nsswitch.conf</code> file, but I won’t discuss them here as they are out of scope of the topic of this section.</p>
<p class="normal">The <code class="inlineCode">/etc/hosts</code> file, which we briefly discussed while working with our hostname, tells our server how to resolve itself (it has a hostname mapping to the localhost IP of <code class="inlineCode">127.0.0.1</code>), but you are also able to create additional names to IP mappings here as well. </p>
<p class="normal">For example, if I had a server (<code class="inlineCode">myserver.mydomain.org</code>) at IP <code class="inlineCode">10.10.96.124</code>, I could add the following line to <code class="inlineCode">/etc/hosts</code> to make my machine resolve the server to that IP each time, without it needing to consult a DNS server at all:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-number">10.10.96.124</span> <span class="hljs-string">myserver.mydomain.org</span> 
</code></pre>
<p class="normal">In practice though, this is usually not a very convenient method by which to configure name resolution. Don’t get me wrong, you can certainly list your servers in this file along with their IP addresses, and your server would be able to resolve those names just fine. The problem stems from the fact that this method is difficult to maintain. The name mappings apply only to the server you’ve made the <code class="inlineCode">/etc/hosts</code> changes on; other servers wouldn’t benefit since they would only check their own <code class="inlineCode">/etc/hosts</code> file. You could add a list of servers to the <code class="inlineCode">hosts</code> file on each of your servers, but that would be a pain to manage. This is the main reason why having a central DNS server is a benefit to any network, especially for resolving the names of local resources.</p>
<p class="normal">However, the <code class="inlineCode">/etc/hosts</code> file is used every now and again in the enterprise as a quick one-off workaround, and you’ll probably eventually end up needing to use this method for one reason or another. One very common reason to use such a manual method of resolving names is in the case where you’re testing a replacement server. In that case, you can configure the <code class="inlineCode">/etc/hosts</code> file to have the same name as the original server, but with the IP address of the new server. Once you finish testing and confirm that the new server is operating properly, you can then replace the network-wide DNS name to point to the new IP address.</p>
<p class="normal">On legacy <a id="_idIndexMarker537"/>Ubuntu servers, the <code class="inlineCode">/etc/resolv.conf</code> file included the IP addresses for DNS servers the system would use to resolve names. If you wanted to override the DNS servers for your server, you would alter that file. Although this file still exists in Ubuntu 22.04, it only exists to redirect lookups to <code class="inlineCode">systemd-resolved</code>, which is a systemd unit that runs in the background and applies DNS settings based on what the system receives via DHCP or what you may have configured in Netplan. For the sake of completeness though, here is a brief overview of the syntax of this file in older releases, in case you end up working on such a server. An example of this file is as follows:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-string">nameserver</span> <span class="hljs-number">10.10.96.1</span> 
<span class="hljs-string">nameserver</span> <span class="hljs-number">10.10.96.2</span> 
</code></pre>
<p class="normal">In this example, the <code class="inlineCode">/etc/resolv.conf</code> output is utilizing servers <code class="inlineCode">10.10.96.1</code> and <code class="inlineCode">10.10.96.2</code>. Therefore, the server will first check <code class="inlineCode">/etc/hosts</code> for a match of the resource you’re looking up, and if it doesn’t find it, it will then check <code class="inlineCode">/etc/resolv.conf</code> in order to find out which server to check next. In this case, the server will check <code class="inlineCode">10.10.96.1</code>.</p>
<p class="normal">The <code class="inlineCode">/etc/resolv.conf</code> file on legacy servers is typically not one that you’d make actual changes to, since it’s automatically generated by NetworkManager. NetworkManager is a service that helps you manage your network interfaces; however, it’s not used anymore with Ubuntu Server for a handful of releases now. Even though you don’t typically manually edit the <code class="inlineCode">/etc/resolv.conf</code> file, it may be worth looking at on legacy servers to see which DNS servers were assigned, in case you’re troubleshooting some sort of networking issue.</p>
<p class="normal">Nowadays, modern Ubuntu servers utilize <code class="inlineCode">systemd-resolved</code> to handle name resolution. If you’d like to see which DNS servers were assigned on a newer Ubuntu Server installation, you can simply look at the configuration file for Netplan that we worked through earlier in the case of a static IP assignment, but if DHCP is being used, the <code class="inlineCode">resolvectl</code> command will let you know what DNS nameservers your server is currently pointing to. This will provide an output similar to that shown in the following screenshot:</p>
<figure class="mediaobject"><img alt="" height="469" src="../Images/B18425_10_05.png" width="876"/></figure>
<p class="packt_figref">Figure 10.5: Viewing a server’s current DNS assignment</p>
<p class="normal">In a typical <a id="_idIndexMarker538"/>enterprise Linux network, you’ll set up a local DNS server to resolve your internal resources, which will then forward requests to a public DNS server in case you’re attempting to reach something that’s not internal. We’ll get to that in <em class="chapterRef">Chapter 11</em>, <em class="italic">Setting Up Network Services</em>, but you should now understand how the name resolution process works on your Ubuntu Server.</p>
<p class="normal">As Linux administrators, we will likely manage a large number of servers, and often the server we’re managing may not even be in the same physical location as us. OpenSSH is a powerful tool for remote management, and it’s what we’ll explore next.</p>
<h1 class="heading-1" id="_idParaDest-148">Getting started with OpenSSH</h1>
<p class="normal"><strong class="keyWord">OpenSSH</strong> is<a id="_idIndexMarker539"/> quite possibly the most useful tool in existence for managing Linux servers. Of all the countless utilities available, this is the one I recommend that everyone starts practicing as soon as they can. Technically, I could probably better fit a section for setting up OpenSSH in <em class="chapterRef">Chapter 11</em>, <em class="italic">Setting Up Network Services</em>, but this utility is very handy, and we should start using it as soon as possible.</p>
<p class="normal">OpenSSH allows you to open a command shell on other Linux servers, enabling you to run commands as if you were there in front of the server. For Linux administrators like us, this is extremely convenient. We could be tasked with managing dozens, hundreds, or even thousands of servers. </p>
<p class="normal">With OpenSSH, we can manage our entire server architecture without even getting out of our chairs. In this section, I’ll give you some information on OpenSSH and how to install it, and then I’ll finish up the section with a few examples of actually using it.</p>
<h2 class="heading-2" id="_idParaDest-149">Installing OpenSSH</h2>
<p class="normal">OpenSSH <a id="_idIndexMarker540"/>consists of two components, the server daemon that runs in the background that accepts SSH connections, and the client that runs on a laptop, workstation, or another server that gives you the ability to connect to an SSH server and run commands. All operating systems nowadays give you access to an OpenSSH client that you can use to make the connection to the server, so that requirement is probably already met. When it comes to Linux, most distributions give you the OpenSSH client already. You can verify that by running <code class="inlineCode">which ssh</code> at your shell prompt. If you have the client installed, your output should read <code class="inlineCode">/usr/bin/ssh</code>.</p>
<p class="normal">If, for some reason, you don’t have this package installed and you’ve received no output from the previous command (which would be rare), you can install the OpenSSH client with the following command:</p>
<pre class="programlisting con"><code class="hljs-con">sudo apt install openssh-client 
</code></pre>
<p class="normal">Depending on the choices you’ve made during installation, your Ubuntu Server likely has the OpenSSH server installed already. If you don’t remember whether or not you opted to have this included during our initial installation, you can run the <code class="inlineCode">which sshd</code> command at your shell prompt and you should see the output of <code class="inlineCode">/usr/sbin/sshd</code>. You can also execute <code class="inlineCode">systemctl status ssh</code> as well, and if the server component is present and running, then your server is ready to accept SSH connections:</p>
<figure class="mediaobject"><img alt="Text  Description automatically generated" height="333" src="../Images/B18425_10_06.png" width="877"/></figure>
<p class="packt_figref">Figure 10.6: Verifying that the OpenSSH service is running on a server</p>
<p class="normal">In the case <a id="_idIndexMarker541"/>that you don’t have the OpenSSH server component installed on your server, you can install it with the following command:</p>
<pre class="programlisting con"><code class="hljs-con">sudo apt install openssh-server 
</code></pre>
<p class="normal">With great power comes great responsibility, though. As great as OpenSSH is, any service that listens for connections has the potential of being abused. An outside intruder finding a weakness or exploit that allows them to take control over your server is a really bad situation. Therefore, like any service that runs on your server, you should only have it running if you need to use it. Since OpenSSH is incredibly helpful (and it’s the standard method of remote management) it’s very hard to <em class="italic">not</em> use it.</p>
<p class="normal">There are many methods you can utilize to secure such a service and help protect it. One method is covered in the next section, and we’ll talk about security pertaining to OpenSSH again before the book comes to a close. Specifically, in <em class="chapterRef">Chapter 21</em>, <em class="italic">Securing Your Server</em>, I will walk you through various configuration changes you can make to help minimize the threat of miscreants breaking into your server from the outside and wreaking havoc.</p>
<p class="normal">Securing OpenSSH is actually not hard at all, and would probably only take a few minutes of your time. Therefore, feel free to make a detour to that chapter to read the section there that talks about securing OpenSSH, and then come back here when you’re done. For now, make sure that you have secure, randomly generated passwords on the server at the very least. If OpenSSH is reachable via the public internet, and any of your users have weak <a id="_idIndexMarker542"/>passwords, it definitely won’t be a fun situation.</p>
<p class="normal">With all of that out of the way, we can get started with actually using OpenSSH.</p>
<h2 class="heading-2" id="_idParaDest-150">Issuing commands with OpenSSH</h2>
<p class="normal">After you’ve <a id="_idIndexMarker543"/>installed the <code class="inlineCode">openssh-server</code> package on <a id="_idIndexMarker544"/>your target machine (the one you want to control remotely), you’ll need to start it if it hasn’t been already. By default, Ubuntu’s <code class="inlineCode">openssh-server</code> package is automatically configured to start and become enabled once installed. Just as we’ve done earlier, you can verify that the required service is running with the following command:</p>
<pre class="programlisting con"><code class="hljs-con">systemctl status ssh 
</code></pre>
<p class="normal">If OpenSSH is running as a daemon on your server, you should see output that tells you that it’s <code class="inlineCode">active (running)</code>. If not, you can start it with the following command:</p>
<pre class="programlisting con"><code class="hljs-con">sudo systemctl start ssh 
</code></pre>
<p class="normal">If the output of the <code class="inlineCode">systemctl status ssh</code> command shows that the daemon is disabled (meaning it doesn’t start up automatically when the server boots), you can enable it with the following command:</p>
<pre class="programlisting con"><code class="hljs-con">sudo systemctl enable ssh 
</code></pre>
<p class="normal">With the OpenSSH server started and running, your server should now be listening for connections. To verify this, use the following command to list listening ports, restricting the output to SSH:</p>
<pre class="programlisting con"><code class="hljs-con">sudo ss -tunlp |grep ssh 
</code></pre>
<p class="normal">The <code class="inlineCode">ss</code> command allows us to view a list of processes running on our server that are listening for connections. It will also display which port a process is listening on. </p>
<p class="normal">We’ll explore this command in more detail in <em class="chapterRef">Chapter 21</em>, <em class="italic">Securing Your Server</em>. But for now, this command should produce an output similar to the following:</p>
<figure class="mediaobject"><img alt="Graphical user interface, text  Description automatically generated" height="111" src="../Images/B18425_10_07.png" width="876"/></figure>
<p class="packt_figref">Figure 10.7: Checking if the required port for SSH is listening</p>
<p class="normal">If, for some <a id="_idIndexMarker545"/>reason, your server doesn’t show that it has an<a id="_idIndexMarker546"/> SSH server listening, double-check that you’ve started the daemon. By default, the SSH server listens for connections on port <code class="inlineCode">22</code>. This can be changed by modifying the port declaration in the <code class="inlineCode">/etc/ssh/sshd_config</code> file, but that’s a story for a later chapter. While I won’t be going over the editing of this file just yet, just take note that it’s the default configuration file for the daemon. OpenSSH reads this file for configuration values each time it’s started or restarted.</p>
<p class="normal">To connect to a server using SSH, simply execute the <code class="inlineCode">ssh</code> command followed by the name or IP address of the server you’d like to connect to:</p>
<pre class="programlisting con"><code class="hljs-con">ssh 192.168.1.120 
</code></pre>
<p class="normal">By default, the <code class="inlineCode">ssh</code> command will use the username you’re currently logged in with for the connection. If you’d like to use a different username, specify it with the <code class="inlineCode">ssh</code> command by including your username followed by the <code class="inlineCode">@</code> symbol just before the IP address or hostname:</p>
<pre class="programlisting con"><code class="hljs-con">ssh fmulder@192.168.1.120
</code></pre>
<p class="normal">Unless you tell it otherwise, the <code class="inlineCode">ssh</code> command assumes that your target is listening on port <code class="inlineCode">22</code>. If it isn’t, you can give the command a different port with the <code class="inlineCode">-p</code> option followed by a port number:</p>
<pre class="programlisting con"><code class="hljs-con">ssh -p 2242 fmulder@192.168.1.120
</code></pre>
<p class="normal">Once you’re connected to the target machine, you’ll be able to run shell commands and administer the system as if you were right in front of it. You’ll have all the same permissions as the user you’ve logged in with, and you’ll also be able to use <code class="inlineCode">sudo</code> to run administrative commands if you normally have access to do so on that server.</p>
<p class="normal">Basically, anything you’re able to do if you were standing right in front of the server, you’ll be able to do via SSH. When you’re finished with your session, simply type <code class="inlineCode">exit</code> at the shell prompt, or press <em class="keystroke">Ctrl</em> + <em class="keystroke">d</em> on your keyboard.</p>
<p class="normal">When you <a id="_idIndexMarker547"/>exit an OpenSSH connection, any processes you <a id="_idIndexMarker548"/>may have had running in the background will be killed. Be sure you resume any background processes you may have running and finish working with them before you exit your connection. We took a look at how to run processes in the background back in <em class="chapterRef">Chapter 7</em>, <em class="italic">Controlling and Monitoring Processes</em>.</p>
<p class="normal">As you can see, OpenSSH is a miraculous tool that will benefit you by allowing you to remotely manage your servers from anywhere you allow SSH access from. Make sure to read the relevant section in <em class="chapterRef">Chapter 11</em>, <em class="italic">Setting Up Network Services</em>, with regard to securing it, though. In the next section, we’ll discuss SSH key management, which brings the benefit of convenience, but also allows you to increase security as well.</p>
<h1 class="heading-1" id="_idParaDest-151">Getting started with SSH key management</h1>
<p class="normal">When you <a id="_idIndexMarker549"/>connect to a host via SSH, you’ll be asked for your password, and after you authenticate you’ll be connected. Instead of using your password, though, you can authenticate via public key authentication instead. The core benefit to this method is added security, as your system password is never transmitted during the process of connecting to the server. When you create an SSH key pair, you are generating two files, a <em class="italic">public key</em> and a <em class="italic">private key</em>. These two files are mathematically linked, so if you connect to a server that has your public key, it will know it’s you because you (and only you) have the private key that matches it. This method is far more secure than password authentication, and I highly recommend that you use it. To get the most out of the security benefit of authentication via keys, you can actually disable password-based authentication on your server so that your SSH key is your only way in. By disabling password-based authentication and using only keys, you’re increasing your server’s security by a sizeable margin. We’ll go over that in <em class="chapterRef">Chapter 21</em>, <em class="italic">Securing Your Server</em>.</p>
<h2 class="heading-2" id="_idParaDest-152">Generating public and private keys</h2>
<p class="normal">To <a id="_idIndexMarker550"/>get <a id="_idIndexMarker551"/>started, you’ll <a id="_idIndexMarker552"/>first need to generate <a id="_idIndexMarker553"/>your key. To do so, on your workstation or laptop (the device you’re using to connect to the server), use the <code class="inlineCode">ssh-keygen</code> command <a id="_idIndexMarker554"/>as your normal user account. The following screenshot shows what this process<a id="_idIndexMarker555"/> generally looks like:</p>
<figure class="mediaobject"><img alt="Text  Description automatically generated" height="640" src="../Images/B18425_10_08.png" width="876"/></figure>
<p class="packt_figref">Figure 10.8: Generating an SSH key pair</p>
<p class="normal">First, you’ll be <a id="_idIndexMarker556"/>asked for the directory in which <a id="_idIndexMarker557"/>to save your key files, defaulting to <code class="inlineCode">/home/&lt;user&gt;/.ssh</code>. You’ll next be asked for a passphrase, which is optional. Although it does add an additional step to authenticating via keys, I recommend that you give it a passphrase (which should be different than your system password) since it greatly enhances security (the key would be unusable without the passphrase, if you gave it one). You can press <em class="keystroke">Enter</em> for the passphrase without entering one if you do not want this.</p>
<p class="normal">What this command does is create a directory named <code class="inlineCode">.ssh</code> in your <code class="inlineCode">home</code> directory, if it doesn’t already exist. Inside that directory, it will create two files, <code class="inlineCode">id_rsa</code> and <code class="inlineCode">id_rsa.pub</code>. The <code class="inlineCode">id_rsa</code> file is your private key. It should never leave your machine, be given to another user, or <a id="_idIndexMarker558"/>be stored on any external media. If your private key leaks out, your keys can no<a id="_idIndexMarker559"/> longer be trusted. By default, the <a id="_idIndexMarker560"/>private key is owned by the user that created it, with <code class="inlineCode">rw</code> permissions given only to its owner.</p>
<p class="normal">The <a id="_idIndexMarker561"/>public key, on the other hand, can leave your computer and doesn’t need to be secured as much. Its permissions are more lenient, being readable by everyone and writeable by the owner. You can see this yourself by executing <code class="inlineCode">ls -l /home/&lt;user&gt;/.ssh</code>:</p>
<figure class="mediaobject"><img alt="A screenshot of a computer  Description automatically generated with medium confidence" height="211" src="../Images/B18425_10_09.png" width="638"/></figure>
<p class="packt_figref">Figure 10.9: Listing the contents of the .ssh directory, showing the permissions of the newly created keys</p>
<p class="normal">The public key is the key that actually gets copied to other servers to facilitate your being able to log in via such a key pair. When you log in to a server that has your key, it checks that it’s a mathematical match to your private key, and if it is, it will let you log in. You’ll also be asked for your passphrase, if you chose to set one when you first created it. But before we can actually use our key, we need to copy it over to the server we intend to connect to.</p>
<h2 class="heading-2" id="_idParaDest-153">Copying your public key to a remote server</h2>
<p class="normal">To<a id="_idIndexMarker562"/> actually transmit your public key to a target server, we can use the <code class="inlineCode">ssh-copy-id</code> command, as I’m doing in the following example command:</p>
<pre class="programlisting con"><code class="hljs-con">ssh-copy-id -i ~/.ssh/id_rsa.pub 192.168.1.150
</code></pre>
<p class="normal">With that <a id="_idIndexMarker563"/>command, replace the IP address with the actual IP address, or with the <em class="italic">hostname</em> of the target server. You’ll be asked to log in via your password first, and then your key will be copied over. From that point on, you’ll log in via your key, falling back to being asked for your password if, for some reason, your key relationship is broken. Here’s an example of what this process looks like, if I were to work through the process of copying my key to a server named <code class="inlineCode">myserver.mycompany.org</code>:</p>
<figure class="mediaobject"><img alt="Text  Description automatically generated" height="300" src="../Images/B18425_10_10.png" width="875"/></figure>
<p class="packt_figref">Figure 10.10: Using the ssh-copy-id command to copy a public key to a server</p>
<p class="normal">So, what exactly did the <code class="inlineCode">ssh-copy-id</code> command do? Where is your public key copied to, exactly? What happens with this command is that on the target server, a <code class="inlineCode">.ssh</code> directory is created in your <code class="inlineCode">home</code> directory on the target server if it didn’t already exist. Inside that directory, a file named <code class="inlineCode">authorized_keys</code> is created if it wasn’t already present. The contents of <code class="inlineCode">~/.ssh/id_rsa.pub</code> on your machine are copied into the <code class="inlineCode">~/.ssh/authorized_keys</code> file on the target server. With each additional key you add (for example, you connect to that server from multiple machines), the key is added to the end of the <code class="inlineCode">authorized_keys</code> file, one per line.</p>
<p class="normal">Using the <code class="inlineCode">ssh-copy-id</code> command is merely a matter of convenience; there’s nothing stopping you from copying the contents of your <code class="inlineCode">id_rsa.pub</code> file and manually pasting it into the <code class="inlineCode">authorized_keys</code> file of the target server. That method will actually work just fine as well.</p>
<p class="normal">When <a id="_idIndexMarker564"/>you <a id="_idIndexMarker565"/>connect to a server that you have set up a key relationship with by adding your public key, SSH checks the contents of the <code class="inlineCode">~/.ssh/authorized_keys</code> file on that server, looking for a key that mathematically matches the private key (<code class="inlineCode">~/.ssh/id_rsa</code>) on your machine. If the two keys are an appropriate match, you are allowed access. If you set up a passphrase, you’ll be asked to enter it in order to open your public key.</p>
<p class="normal">If you decided not to create a passphrase with your key, you’re essentially setting up authentication without a password, meaning you won’t be asked to enter anything when authenticating.</p>
<h2 class="heading-2" id="_idParaDest-154">Utilizing an SSH agent</h2>
<p class="normal">When <a id="_idIndexMarker566"/>we created our SSH key earlier, it was mentioned that having a passphrase is optional but is a good idea. Using passphrases with OpenSSH key pairs boosts their security. If an OpenSSH key falls into the wrong hands, it will be useless if the person attempting to utilize it doesn’t know the passphrase. However, we lose a bit of convenience because we need to enter the passphrase<a id="_idIndexMarker567"/> for a key each time we want to use it. An OpenSSH key without a passphrase will allow us to connect to a server and be logged in without entering anything at all. With an <em class="italic">SSH agent</em>, you can actually cache your passphrase the first time you use it, so you won’t be asked for it with every connection. This essentially allows you to benefit from the added security of a passphrase, and still maintain at least some convenience. Best of all, if your laptop or desktop is able to utilize the OpenSSH client for connecting to remote systems, you should have an SSH agent on your system already. If we’re using a flavor of Linux or macOS on our workstation or laptop, for example, we will have the <code class="inlineCode">ssh-agent</code> command available to us.</p>
<p class="normal">The <code class="inlineCode">ssh-agent</code> is used by starting it in the background in our terminal. We can then “unlock” our keys with our passphrase, and then the unlocked key will be stored in memory and will be automatically used when we attempt to connect to a server we’ve copied our public key to. To start it, enter the following command as your normal user account on the machine you’re starting your connections from (that is, your workstation):</p>
<pre class="programlisting con"><code class="hljs-con">eval $(ssh-agent) 
</code></pre>
<p class="normal">This <a id="_idIndexMarker568"/>command will start an SSH agent, which will continue to run in the background of your shell. But it’s not adding any value to us yet—so <a id="_idIndexMarker569"/>we will need to add an SSH key to the now-running agent. The <code class="inlineCode">ssh-add</code> command allows us to add an SSH key to our running <code class="inlineCode">ssh-agent</code>. To do so, we can give the <code class="inlineCode">ssh-add</code> command the path to our public key as an argument:</p>
<pre class="programlisting con"><code class="hljs-con">ssh-add ~/.ssh/id_rsa 
</code></pre>
<p class="normal">At this point, you’ll be asked for your passphrase. As long as you enter it properly, your key will remain open and you won’t need to enter it again for future connections, until you close that shell or log out. Now that you have the <code class="inlineCode">ssh-agent</code> running in the background with your unlocked key, utilizing a key with a passphrase becomes much easier and you’ll end up typing a lot less.</p>
<h2 class="heading-2" id="_idParaDest-155">Changing the passphrase of an OpenSSH key</h2>
<p class="normal">At some point, you<a id="_idIndexMarker570"/> may want to<a id="_idIndexMarker571"/> change the passphrase associated with a key. If you’d like to do that, you can use the <code class="inlineCode">-p</code> argument with the <code class="inlineCode">ssh-keygen</code> command. That <a id="_idIndexMarker572"/>same argument can also be used if you didn’t choose to add a passphrase when you initially created the key. That’s all there is to it. The command you’d enter to add or change a passphrase is as simple as the following:</p>
<pre class="programlisting con"><code class="hljs-con">ssh-keygen -p 
</code></pre>
<p class="normal">Once you enter that command, press <em class="keystroke">Enter</em> to accept the default file (<code class="inlineCode">id_rsa</code>) unless the key you want to alter is under a different name, in which case you can type the path to, and the name of, that key. Then, you’ll be asked for your current passphrase (leave it blank if you don’t have one yet) followed by your new passphrase twice. The process looks like this:</p>
<figure class="mediaobject"><img alt="A screenshot of a computer  Description automatically generated with medium confidence" height="243" src="../Images/B18425_10_11.png" width="761"/></figure>
<p class="packt_figref">Figure 10.11: Changing an SSH passphrase</p>
<p class="normal">These <a id="_idIndexMarker573"/>concepts may take a bit of<a id="_idIndexMarker574"/> practice if you’ve never used SSH before. The <a id="_idIndexMarker575"/>best way to practice is to set up multiple Ubuntu Server installations (perhaps several virtual machines), and practice using SSH to connect to them, as well as deploying your key to each machine via the <code class="inlineCode">ssh-copy-id</code> command. It’s actually quite easy once you get the hang of it.</p>
<h1 class="heading-1" id="_idParaDest-156">Simplifying SSH connections with a config file</h1>
<p class="normal">Before we<a id="_idIndexMarker576"/> leave the topic of OpenSSH, there’s another trick that has the benefit of convenience, and that is the creation of a<a id="_idIndexMarker577"/> local configuration file for SSH. This file must be stored in the <code class="inlineCode">.ssh</code> directory of your home directory, and be named <code class="inlineCode">config</code>. The full path for this file in my case looks like this:</p>
<pre class="programlisting con"><code class="hljs-con">/home/jay/.ssh/config
</code></pre>
<p class="normal">This file doesn’t exist by default, but if it’s found, SSH will parse it whenever you use the client and you’ll be able to benefit from it. Go ahead and open this file in your text editor, such as <code class="inlineCode">nano</code>:</p>
<pre class="programlisting con"><code class="hljs-con">nano /home/your_username/.ssh/config
</code></pre>
<p class="normal">This <code class="inlineCode">config</code> file allows you to type configuration for servers that you connect to often, which can simplify the <code class="inlineCode">ssh</code> command automatically. The following are example contents from such a file that <a id="_idIndexMarker578"/>will help me illustrate what it does:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-string">host</span> <span class="hljs-string">myserver</span> 
    <span class="hljs-string">Hostname</span> <span class="hljs-number">192.168.1.23</span> 
    <span class="hljs-string">Port</span> <span class="hljs-number">22</span> 
    <span class="hljs-string">User</span> <span class="hljs-string">jdoe</span> 
<span class="hljs-string">Host</span> <span class="hljs-string">nagios</span> 
    <span class="hljs-string">Hostname</span> <span class="hljs-string">nagios.mynetwork.org</span> 
    <span class="hljs-string">Port</span> <span class="hljs-number">2222</span> 
    <span class="hljs-string">User</span> <span class="hljs-string">nagiosuser</span> 
</code></pre>
<p class="normal">In the <a id="_idIndexMarker579"/>example contents, I have two hosts outlined, <code class="inlineCode">myserver</code> and <code class="inlineCode">nagios</code>. For each, I’ve identified a way to reach it by name or IP address (the <code class="inlineCode">Hostname</code> line), as well as the <code class="inlineCode">Port</code> and <code class="inlineCode">User</code> account to use for the connection. If I use <code class="inlineCode">ssh</code> to connect to either <code class="inlineCode">Host</code> by the name I outlined in this file, it will use the values I have stored there, for example:</p>
<pre class="programlisting con"><code class="hljs-con">ssh nagios 
</code></pre>
<p class="normal">That command is a lot shorter than if I set all the options manually. Considering I have a <code class="inlineCode">config</code> file for SSH, that command is essentially the same as if I identified the connection details manually, which would’ve been the following:</p>
<pre class="programlisting con"><code class="hljs-con">ssh -p 2222 nagiosuser@nagios.mynetwork.org 
</code></pre>
<p class="normal">I’m sure you can see how much simpler it is to type the first command than the second. With the <code class="inlineCode">config</code> file for SSH, I can have some of those details automatically applied. Since I’ve outlined that my <code class="inlineCode">nagios</code> server is located at <code class="inlineCode">nagios.mynetwork.org</code>, its SSH user is <code class="inlineCode">nagiosuser</code>, and it’s listening on port <code class="inlineCode">2222</code>, it will automatically use those values even though I only typed <code class="inlineCode">ssh nagios</code>. Furthermore, you can also override this entry as well. If you provide a different username when you use the <code class="inlineCode">ssh</code> command, it will use that instead of what you have written in the <code class="inlineCode">config</code> file.</p>
<p class="normal">In the first example (for the <code class="inlineCode">myserver</code> server), I’m providing an IP address for the connection, rather than a hostname. This is useful in a situation where you may not have a DNS entry for your target server. With this example, I don’t have to remember that the IP address for <code class="inlineCode">myserver</code> is <code class="inlineCode">192.168.1.23</code>. I simply execute <code class="inlineCode">ssh myserver</code> and it’s taken care of for me.</p>
<p class="normal">The names of <a id="_idIndexMarker580"/>each server within the <code class="inlineCode">config</code> file are arbitrary and don’t have to match the target server’s hostname. I could’ve named the first server <code class="inlineCode">potato</code> and it would still have routed me to <code class="inlineCode">192.168.1.23</code>, so I can create any sort of named shortcut I want, whatever I <a id="_idIndexMarker581"/>find is most convenient for me and easiest to remember. As you can see, maintaining a <code class="inlineCode">config</code> file in your home directory containing your most commonly used SSH connections will certainly help keep you organized and allow you to connect more easily.</p>
<h1 class="heading-1" id="_idParaDest-157">Summary</h1>
<p class="normal">In this chapter, we worked through several examples of connecting to other networks. We started off by configuring our hostname, managing network interfaces, assigning static IP addresses, as well as looking at how name resolution works in Linux. A decent portion of this chapter was dedicated to topics regarding OpenSSH, which is an extremely useful utility that allows you to remotely manage your servers. We’ll revisit OpenSSH in <em class="chapterRef">Chapter 21</em>, <em class="italic">Securing Your Server</em>, with a look at boosting its security. Overall, we’ve only begun to scratch the surface of this tool. Entire books have been written about SSH, but the examples in this chapter should be enough to make you productive with it. The name of the game is to practice, practice, practice!</p>
<p class="normal">In the next chapter, we’ll talk about managing software packages. We’ll work through adding and removing them, adding additional repositories, and more!</p>
<h1 class="heading-1" id="_idParaDest-158">Relevant videos</h1>
<ul>
<li class="bulletList">OpenSSH Guide (LearnLinuxTV): <a href="https://linux.video/ssh-guide"><span class="url">https://linux.video/ssh-guide</span></a></li>
<li class="bulletList">tmux Guide (LearnLinuxTV): <a href="https://linux.video/tmux-guide"><span class="url">https://linux.video/tmux-guide</span></a></li>
<li class="bulletList">The OpenSSH Client Config File (LearnLinuxTV): <a href="https://linux.video/ssh-config-file"><span class="url">https://linux.video/ssh-config-file</span></a></li>
<li class="bulletList">Getting Started with OpenSSH Key Management (LearnLinuxTV): <a href="https://linux.video/ssh-key-mgmt"><span class="url">https://linux.video/ssh-key-mgmt</span></a></li>
</ul>
<h1 class="heading-1" id="_idParaDest-159">Further reading</h1>
<ul>
<li class="bulletList">Netplan FAQ: <a href="https://learnlinux.link/npf"><span class="url">https://learnlinux.link/npf</span></a></li>
<li class="bulletList">Ubuntu SSH key documentation: <a href="https://learnlinux.link/u-ssh-keys"><span class="url">https://learnlinux.link/u-ssh-keys</span></a></li>
<li class="bulletList">NetworkInterfaceNames (from Debian’s wiki): <a href="https://learnlinux.link/net-int-nam"><span class="url">https://learnlinux.link/net-int-nam</span></a></li>
</ul>
<h1 class="heading-1">Join our community on Discord</h1>
<p class="normal">Join our community’s Discord space for discussions with the author and other readers: </p>
<p class="normal"><a href="https://packt.link/LWaZ0"><span class="url">https://packt.link/LWaZ0</span></a></p>
<p class="normal"><img alt="" height="177" src="../Images/QR_Code50046724-1955875156.png" width="177"/></p>
</div>
</div></body></html>