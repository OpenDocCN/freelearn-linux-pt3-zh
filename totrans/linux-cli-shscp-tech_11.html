<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer237">
			<h1 id="_idParaDest-250"><em class="italic"><a id="_idTextAnchor256"/>Chapter 11</em>: Working with Variables</h1>
			<p><strong class="bold">Variables</strong> are <a id="_idIndexMarker817"/>one of the most important things in programming. Being able to store and then use values in our code is as important as being able to make decisions in our scripts using <strong class="source-inline">if</strong> statements. </p>
			<p>We will cover the following recipes in this chapter: </p>
			<ul>
				<li>Using shell variables</li>
				<li>Using variables in shell scripting</li>
				<li>Quoting in the shell</li>
				<li>Performing operations on variables</li>
				<li>Variables via external commands</li>
			</ul>
			<p>We are going to cover the most important things you need to know about variables, but as with almost everything else, this chapter will require you to practice. </p>
			<h1 id="_idParaDest-251"><a id="_idTextAnchor257"/>Technical requirements </h1>
			<p>The machine you can use for these recipes is the same as in the previous chapters on scripting—basically, anything that can run bash is going to work. In our case, we are using a <strong class="bold">virtual machine</strong> (<strong class="bold">VM</strong>) with Linux and Ubuntu 20.10 installed. </p>
			<p>So, start your VM, and let's get cracking!</p>
			<h1 id="_idParaDest-252"><a id="_idTextAnchor258"/>Using shell variables </h1>
			<p>Variables are <a id="_idIndexMarker818"/>something that you probably understand, even if only conceptually. We are not talking about programming here; our everyday life is full of variables. Basically, a variable is something that holds a value and that can provide us with that value once we need it. </p>
			<h2 id="_idParaDest-253"><a id="_idTextAnchor259"/>Getting ready</h2>
			<p>In everyday language, we could say an activity such as driving is full of variables. This means that the weather temperature, the amount of ambient light, the quality of the road surface, and many other things are going to change as you move along. Even though they are changing all the time, it is important that at any given point, we are able to see what the actual <em class="italic">value</em> of the weather is, what is the actual value of the temperature, how much light we have, and how the road behaves or how it is structured. </p>
			<p>This is what we <a id="_idIndexMarker819"/>mean by variables and looking variables up. </p>
			<p>As soon as we establish what the weather is actually like, it stops being a variable since it has an actual value. Variables work the same way when we're talking about programming. What we do is we give a name to a space that we are going to use to store some value. In our code, we refer to this space to store and read values from it. Depending on the language, this <em class="italic">space</em> can <em class="italic">hold</em> different things, but right now, we just refer to the variable as something that can hold a value. </p>
			<p>In <strong class="source-inline">bash</strong>, variables are a lot simpler than in many other languages, and they can basically hold two different types of values. One is a string; it can be any sequence of numbers and letters, and it can include special characters. </p>
			<p>Another one is a number, and the only reason that there is a difference between those two types of variables is that some operators and some operations are different when we are dealing with strings or dealing with numbers. </p>
			<h2 id="_idParaDest-254"><a id="_idTextAnchor260"/>How to do it…</h2>
			<p>When you start to work with variables, there are two things that you need to learn. </p>
			<p>First, you need to know how to assign a value to a variable. This is usually called <em class="italic">assigning</em> a variable or <em class="italic">instancing</em> a variable. A variable has a name and a value. In <strong class="source-inline">bash</strong>, when we want to create a variable, we are simply going to choose a name and assign a value to it. After that, our shell knows that this is a variable, and it keeps track of the value or values we assign to it. Before we assign a value, a variable simply does not exist, and any reference to it will be invalid.</p>
			<p>So, how do you choose a name for a variable? </p>
			<p>Every variable has its own name, which is used to reference a variable inside the script or inside your working environment in the shell. The choice of name is completely up to you. The name should be something that you can easily remember and something that you will not confuse with other variables. A good choice is usually either something that identifies what purpose the variable has or a completely abstract name that will hint at what the meaning is of the variable. </p>
			<p>One thing that you<a id="_idIndexMarker820"/> should always avoid using when naming variables are keywords, especially those that already have a meaning in <strong class="source-inline">bash</strong>. For example, we cannot use <strong class="source-inline">continue</strong> as a variable name since this is the name of a command. This will inevitably generate an error since the shell is going to get confused about what to do with the variable itself. </p>
			<p>We mentioned<a id="_idIndexMarker821"/> environment variables. In an interactive shell, there are quite a few variables that are used to store information about your environment. This information describes different things that are required by different applications—things such as the username, your shell, and so on. </p>
			<p>Let's do a few quick examples. We assign a variable exactly as we mentioned, by giving a value to a name. In our case, we are going to assign a <strong class="source-inline">value</strong> string value to a variable called <strong class="source-inline">VAR1</strong>: </p>
			<p class="source-code">demo@cli1:~$ VAR1=value</p>
			<p>That was easy. Now, let's read from the variable we just created:</p>
			<p class="source-code">demo@cli1:~$ echo $VAR1</p>
			<p class="source-code">value</p>
			<p>As we can see, in order to read the variable, we need to prefix the variable name with the <strong class="source-inline">$</strong> character. Also, we need to use the same case in the variable name that we used when creating the variable itself, as names are case-sensitive. </p>
			<p>If we don't do that, we are not going to get any useful value out of our <strong class="source-inline">echo</strong> command, but be very aware that neither of these examples gave us any errors: </p>
			<p class="source-code">demo@cli1:~$ echo var1</p>
			<p class="source-code">Var1</p>
			<p class="source-code">demo@cli1:~$ echo $var1</p>
			<p class="source-code">demo@cli1:~$ echo VAR1</p>
			<p class="source-code">VAR1</p>
			<p>We made these errors on purpose to make a few small points. When using an <strong class="source-inline">echo</strong> command, we tell it to display a string. If the string contains a variable name, it has to be prefixed; otherwise, the <strong class="source-inline">echo</strong> command is just going to output it directly as it was written, without the variable value. </p>
			<p>As we said, names are<a id="_idIndexMarker822"/> case-sensitive, but if we make a mistake, there won't be any errors displayed—we will simply get an empty line. This can be changed, and we will deal with this behavior later when we start using variables in scripts. </p>
			<p>Let's now do something else—we'll try to use our variable in a script. Remember that we assigned a variable in the shell, but now, we are going to reference it in a script. </p>
			<p>The script is going to be the simplest possible—create a file, name it <strong class="source-inline">referencing.sh</strong>, and enter the following code: </p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code">#referencing variable VAR1</p>
			<p class="source-code">echo $VAR1</p>
			<p>What happens when we run it? Let's have a look: </p>
			<p class="source-code">demo@cli1:~$ bash referencing.sh</p>
			<p class="source-code">demo@cli1:~$ echo $VAR1</p>
			<p class="source-code">value</p>
			<p>We see we have a problem. When we are reading the variable from the command line, everything is fine, but this variable does not exist inside our scripts. The reason is not as simple as it seems, though. We mentioned contexts and environment variables before. Each variable exists in the current environment and is not implicitly inherited by any command. When we start a script, we are actually creating a new environment and a new context that inherits all the variables that are marked as inheritable. Since we just assigned a value to our variable and didn't do anything else to it, this variable will remain visible only to our shell, and not to any commands or scripts that we run from it. </p>
			<p>To fix this, we will need to <em class="italic">export</em> a variable. Exporting means flagging our variable to tell the environment that we want the value of the variable to be available to the commands and scripts that are running as its child processes. To do that, we need to use a command called <strong class="source-inline">export</strong>. The syntax couldn't be simpler: </p>
			<p class="source-code">demo@cli1:~$ export VAR1</p>
			<p class="source-code">demo@cli1:~$ bash referencing.sh</p>
			<p class="source-code">value</p>
			<p class="source-code">demo@cli1:~$</p>
			<p>As we can see, our script now knows the value of our variable, and it got inherited from the <strong class="source-inline">bash</strong> shell. </p>
			<p>If we just type in <strong class="source-inline">export</strong>, we will see <a id="_idIndexMarker823"/>a list of all the variables that are exported and available to our scripts: </p>
			<div>
				<div id="_idContainer233" class="IMG---Figure">
					<img src="Images/Figure_11.1_B16269.jpg" alt="Figure 11.1 – Different exported variables exist for every user&#13;&#10;" width="1219" height="797"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.1 – Different exported variables exist for every user</p>
			<p>Notice one important thing: every line starts with the <strong class="source-inline">declare -x</strong> command, followed by a variable name and value. This points us to another extremely useful command: <strong class="source-inline">declare</strong>. </p>
			<p>When we are <a id="_idIndexMarker824"/>creating a variable and giving it a value, we are using only part of what can be done with variables in <strong class="source-inline">bash</strong>. Remember how we exported the variable? Variables have attributes that are additional information about how the variable should behave. Having a variable being exported is one of the attributes, but we can also make a variable read-only, change the variable name case, and even change the type of information that the variable holds. For all that, we use <strong class="source-inline">declare</strong>. </p>
			<h2 id="_idParaDest-255"><a id="_idTextAnchor261"/>How it works…</h2>
			<p>The only thing left to do is to give you more information about<a id="_idIndexMarker825"/> environment variables. </p>
			<p>The environment can be, depending on your system and its configuration, huge. It contains a lot of things, and it is different from system to system because variables in the environment and their values are dependent on different programs and options installed on your particular system. For example, if you use a shell other than <strong class="source-inline">bash</strong>, you may have different<a id="_idIndexMarker826"/> variables specific to that shell. If you use <strong class="bold">GNU Network Model Object Environment</strong> (<strong class="bold">GNOME</strong>) or <strong class="bold">K Desktop Environment</strong> (<strong class="bold">KDE</strong>) as your <strong class="bold">graphical user interface</strong> (<strong class="bold">GU</strong>I), there <a id="_idIndexMarker827"/>are different variables that each have a specific meaning. To see what your environment <a id="_idIndexMarker828"/>looks like, you can use either <strong class="source-inline">declare -p</strong> or <strong class="source-inline">env</strong>. </p>
			<p>The difference between those two is very important. The <strong class="source-inline">declare</strong> statement is a <strong class="source-inline">bash</strong> built-in command. It will read every variable there is in the environment and show you all of them. <strong class="source-inline">env</strong>, on the other hand, is an application. It will run, create its own environment to run in, and then show you all the variables in that environment:</p>
			<div>
				<div id="_idContainer234" class="IMG---Figure">
					<img src="Images/Figure_11.2_B16269.jpg" alt="Figure 11.2 – The environment can be checked at least two ways, but we usually use the env command&#13;&#10;" width="1216" height="796"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.2 – The environment can be checked at least two ways, but we usually use the env command</p>
			<p>We are going to<a id="_idIndexMarker829"/> mention some of those most important: </p>
			<ul>
				<li><strong class="source-inline">USER</strong>—Holds the <a id="_idIndexMarker830"/>username of the current user. This is extremely important if you need to check under which user the script is running. An alternative to this is to run the <strong class="source-inline">whoami</strong> command. </li>
				<li><strong class="source-inline">PWD</strong>—Holds the<a id="_idIndexMarker831"/> absolute path to the current directory. This is also important to any script since it can help you find which running directory the script was called from. An alternative to this command is <strong class="source-inline">pwd</strong>. </li>
				<li><strong class="source-inline">LOGNAME</strong>—Provides <a id="_idIndexMarker832"/>the same information as <strong class="source-inline">USER</strong>, specifically the username of the logged-on user, hence the name. </li>
				<li><strong class="source-inline">SHELL</strong>—Contains the<a id="_idIndexMarker833"/> entire path to the current user's login shell. This is not the same as the running shell; we can run any shell and work from it, and this variable returns what our login shell is set to. This value comes from the <strong class="source-inline">/etc/passwd</strong> file.</li>
				<li><strong class="source-inline">SHLVL</strong>—When you run <a id="_idIndexMarker834"/>your shell initially, you are one level into your environment. What this means is that there is nothing else running <em class="italic">above</em> your shell—or, to be more precise, your shell was started by your system directly. As you work, you can run other shells, scripts, and even shells inside shells. Each time you run a shell inside your shell, you increase your <strong class="source-inline">SHLVL</strong>. This is useful when trying to find out whether your script was run from another shell or directly by the system. </li>
				<li><strong class="source-inline">PATH</strong>—<strong class="source-inline">PATH</strong> contains<a id="_idIndexMarker835"/> a list of directories that your shell is going to look in when trying to find any command that you try to execute. Since almost everything on Linux is a command, this piece of information is crucial—if a certain path is not in the <strong class="source-inline">PATH</strong> variable, it won't be searched, and commands from it can only be executed if you reference them directly. This is useful if you don't want to reference commands directly all the time, or you have some<a id="_idIndexMarker836"/> reasons to prefer a command in one directory over another. </li>
			</ul>
			<p>Before we go on to the next recipe, there is another way to get variables listed, and that is by using <strong class="source-inline">set</strong> without any parameter: </p>
			<div>
				<div id="_idContainer235" class="IMG---Figure">
					<img src="Images/Figure_11.3_B16269.jpg" alt="Figure 11.3 – set not only shows you variables but is also capable of configuring the shell&#13;&#10;" width="1216" height="797"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.3 – set not only shows you variables but is also capable of configuring the shell</p>
			<p>Of course, since <a id="_idIndexMarker837"/>there is a lot of variables active at any given time, it is much better to use some sort of filtering: </p>
			<div>
				<div id="_idContainer236" class="IMG---Figure">
					<img src="Images/Figure_11.4_B16269.jpg" alt="Figure 11.4 – The only way to quickly find things is to use grep&#13;&#10;" width="1217" height="563"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.4 – The only way to quickly find things is to use grep</p>
			<h2 id="_idParaDest-256"><a id="_idTextAnchor262"/>See also</h2>
			<p>We are going to give<a id="_idIndexMarker838"/> you just the place to start since this topic is massive:</p>
			<ul>
				<li><a href="https://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-5.html">https://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-5.html</a></li>
				<li><a href="https://ryanstutorials.net/bash-scripting-tutorial/bash-variables.php">https://ryanstutorials.net/bash-scripting-tutorial/bash-variables.php</a></li>
			</ul>
			<h1 id="_idParaDest-257"><a id="_idTextAnchor263"/>Using variables in shell scripting </h1>
			<p>Variables <a id="_idIndexMarker839"/>sometimes look simple enough—they are there to <a id="_idIndexMarker840"/>enable you to put a changing value in your code. The problem is that in this simplicity, there are a couple of things you should know about where you actually place a variable—in something called a context. We are going to deal with that in this chapter. </p>
			<h2 id="_idParaDest-258"><a id="_idTextAnchor264"/>Getting ready</h2>
			<p>When we're talking about scripting, things are a little different than they are when we are working in an interactive environment. Every environment variable that is available to you when you use the interactive shell is also available to you in the script. There is, however, one important thing you must always remember. As we said earlier, your script is running in a certain context. This context is defined by the user that has run the script. In a previous chapter, we wanted you to make sure that you have appropriate permissions to do tasks that you need in the script. </p>
			<p>In this recipe, we are going to make sure you understand this also applies to variables. Unless we have explicitly set the variable in our script, we need to make sure that the one we got from the environment is something that we expect. Also, a lot of times, we will simply check if the variable is there in the first place since it may not be exported from the shell and will hence be invisible to us.</p>
			<p>There is also a special <a id="_idIndexMarker841"/>class of variables that are set right at the moment the script is run and contain a certain amount of information very important to successfully running a script. </p>
			<p>What we are going<a id="_idIndexMarker842"/> to do is to start with how the script interacts with the shell using variables. </p>
			<h2 id="_idParaDest-259"><a id="_idTextAnchor265"/>How to do it…</h2>
			<p>We are, as always, going to start simple. First, we are going to do the most basic thing we can do—<strong class="source-inline">Hello World</strong>, but with variables: </p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code"># define a variable</p>
			<p class="source-code">STRING="Hello World!"</p>
			<p class="source-code"># output the variable</p>
			<p class="source-code">echo $STRING</p>
			<p>This is basically what we mentioned before but in a script. We have created a variable, assigned it a value, and then used that value to output text. </p>
			<p>Now, let's try something more useful. When writing scripts, there are things that we need to calculate or prepare in some way so that we can use them in different parts of the script. Variables are a good way to do this clearly so that they can be reused in the code. </p>
			<p>For example, we<a id="_idIndexMarker843"/> can create a string that will contain today's date. We<a id="_idIndexMarker844"/> can then use a variable instead of running the appropriate command every time to create a date in a given format over and over again:</p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code"># we are using variable TodaysDate to store date</p>
			<p class="source-code">TodaysDate=$(date +%Y%m%d)</p>
			<p class="source-code"># now lets create an archive that will have todays date in \</p>
			<p class="source-code">the name. </p>
			<p class="source-code">tar cfz Backup-$TodaysDate.tgz .</p>
			<p>After we run this one, the output is going to be interesting: </p>
			<p class="source-code">demo@cli1:~/variables$ bash varinname.sh </p>
			<p class="source-code">tar: .: file changed as we read it</p>
			<p class="source-code">demo@cli1:~/variables$ ls </p>
			<p class="source-code">Backup-20210920.tgz  varinname.sh</p>
			<p>We can see that the file was created correctly and that our date looks OK. What we didn't expect was the error. The reason for the error is simple—<strong class="source-inline">tar</strong> starts creating files by first creating an output file and then reading the directory it must archive. If the archive file is created in the directory it is trying to archive, this means that the <strong class="source-inline">tar</strong> command will try to run on the archive itself, creating this error. This is normal in these circumstances but try to avoid doing this archive loop. The solution is to archive to a place outside of the directory we are archiving. </p>
			<p>Now for the fun part—passing arguments to your scripts. Up to this point, we have made scripts that were completely unaware of their surroundings. We need to change that since we need to be able to both pass information to our script and make our script report back what has happened.  </p>
			<p>Any script, regardless of the way it was executed, can have arguments. This is so common that we usually don't even think about it. Arguments are basically strings that come after the script name when we execute the script. </p>
			<p>This is precisely <a id="_idIndexMarker845"/>how arguments work in scripts—the shell takes<a id="_idIndexMarker846"/> whatever is in the command line that started the script and passes it along using a variable that has a number as the name. Here's an example: </p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code"># we are going to read first three parameters</p>
			<p class="source-code"># and just echo them</p>
			<p class="source-code">echo $1 $2 $3</p>
			<p class="source-code"># we will also use $# to echo number of arguments</p>
			<p class="source-code">echo Number of arguments passed: $#</p>
			<p>Now, here's how we can run it in a few different ways: </p>
			<p class="source-code">demo@cli1:~/variables$ bash parameters.sh </p>
			<p class="source-code">Number of arguments passed: 0</p>
			<p>If we don't give it any parameters, everything works as well as if we give it three parameters we expect:</p>
			<p class="source-code">demo@cli1:~/variables$ bash parameters.sh one two 3</p>
			<p class="source-code">one two 3</p>
			<p class="source-code">Number of arguments passed: 3</p>
			<p>But let's try to use more than three: </p>
			<p class="source-code">demo@cli1:~/variables$ bash parameters.sh one two 3 four</p>
			<p class="source-code">one two 3</p>
			<p class="source-code">Number of arguments passed: 4</p>
			<p class="source-code">demo@cli1:~/variables$ bash parameters.sh one two 3 four five</p>
			<p class="source-code">one two 3</p>
			<p class="source-code">Number of arguments passed: 5</p>
			<p>We see a problem here. Variables that hold the parameter value are <em class="italic">positional</em>, and it is up to us to correctly reference everything in the parameter line. The way to do it is to read the number of <strong class="source-inline">arguments</strong> variable, and then create a loop of some kind to read the arguments. </p>
			<p>You may be wondering: <em class="italic">What about $0?</em> Programmers tend to count from zero, not from one, and this is no exception—there is a variable called <strong class="source-inline">$0</strong> and it contains the name of the script itself. This is extremely convenient for scripting. We are creating a script called <strong class="source-inline">parameters1.sh</strong> and running it: </p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code"># reading the script name</p>
			<p class="source-code"># and just echo</p>
			<p class="source-code">echo $0</p>
			<p>As we can see, this <a id="_idIndexMarker847"/>script could not be simpler. But in this simplicity is<a id="_idIndexMarker848"/> one neat trick: </p>
			<p class="source-code">demo@cli1:~/variables$ bash parameters1.sh<strong class="source-inline"> </strong></p>
			<p class="source-code">parameters1.sh</p>
			<p class="source-code">demo@cli1:~/variables$ cd ..</p>
			<p class="source-code">demo@cli1:~$ bash variables/parameters1.sh </p>
			<p class="source-code">Variables/parameters1.sh</p>
			<p class="source-code">demo@cli1:~$ bash /home/demo/variables/parameters1.sh </p>
			<p class="source-code">/home/demo/variables/parameters1.sh</p>
			<p class="source-code">demo@cli1:~$</p>
			<p>The point we are trying to make here is that the variable holds a value that contains not only the name of the script but also the entire path that was used to run the script. This can be used to determine how the script was run if we are running from <strong class="source-inline">crontab</strong> or another script. </p>
			<p>To continue, we need to learn about a new concept—the <strong class="source-inline">shift</strong> statement. </p>
			<p>There are two ways to parse arguments to a script—one is by using a loop that is going to run for <strong class="source-inline">$#</strong> iterations, which means that we are going to run for each argument that the script has once. This is a completely valid way, but there is also another, rather more elegant way to deal with this problem. <strong class="source-inline">shift</strong> is an in-built statement that enables you to parse your<a id="_idIndexMarker849"/> arguments one at a time without knowing how many of <a id="_idIndexMarker850"/>them there are.</p>
			<h2 id="_idParaDest-260"><a id="_idTextAnchor266"/>How it works…</h2>
			<p>The way shifting works is completely intuitive once you understand what it does. Let's quote from the <strong class="source-inline">help</strong> page: </p>
			<p class="source-code">demo@cli1:~/variables$ help shift</p>
			<p class="source-code">shift: shift [n]</p>
			<p class="source-code">    Shift positional parameters.</p>
			<p class="source-code">    Rename the positional parameters $N+1,$N+2 ... to $1,$2 ...  If N is</p>
			<p class="source-code">    not given, it is assumed to be 1.</p>
			<p class="source-code">        Exit Status:</p>
			<p class="source-code">    Returns success unless N is negative or greater than $#.</p>
			<p>Basically, we only need to read the <strong class="source-inline">$1</strong> parameter and then invoke <strong class="source-inline">shift</strong>. The command is going to delete this parameter and shift all of them to the left, making the next one <strong class="source-inline">$1</strong>, and so on. </p>
			<p>This enables us to do these kinds of things: </p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code">while [ "$1" != "" ]; do</p>
			<p class="source-code">    case $1 in</p>
			<p class="source-code">        -n | --name )</p>
			<p class="source-code">            shift</p>
			<p class="source-code">            echo Parameter is Name: $1</p>
			<p class="source-code">        ;;</p>
			<p class="source-code">        -s | --surname )</p>
			<p class="source-code">            shift</p>
			<p class="source-code">            echo Parameter is Surname: $1,</p>
			<p class="source-code">       ;;</p>
			<p class="source-code">        -h | --help )    echo usage is -n or -s followed by a \</p>
			<p class="source-code">string</p>
			<p class="source-code">            exit</p>
			<p class="source-code">        ;;</p>
			<p class="source-code">        * )              echo usage is -n or -s followed by a \</p>
			<p class="source-code">string</p>
			<p class="source-code">            exit 1</p>
			<p class="source-code">    esac</p>
			<p class="source-code">    shift</p>
			<p class="source-code">done</p>
			<p>We need to <a id="_idIndexMarker851"/>explain a few things here. The reason we are using <strong class="source-inline">shift</strong> instead of a f<strong class="source-inline">or</strong> loop is that we are parsing arguments that can be different options. Our <a id="_idIndexMarker852"/>script has three possible switches: <strong class="source-inline">-n</strong> that can be written down as <strong class="source-inline">—name</strong>, <strong class="source-inline">-s</strong> that can also be used as <strong class="source-inline">-surname</strong>, and <strong class="source-inline">-h</strong> or <strong class="source-inline">—help</strong>. After the first two arguments, our script expects to have some string. If none of the arguments is used or we choose <strong class="source-inline">-h</strong>, our script is going to write a small reminder on the usage parameters. </p>
			<p>If you tried to do this in a <strong class="source-inline">for</strong> loop, you would have a problem—we would need to read the option, store it somewhere, read the <strong class="source-inline">option</strong> parameters in the next loop, and then loop again, trying to decide if what follows is an option or an argument. </p>
			<p>By using <strong class="source-inline">shift</strong>, things are much simpler—we read an argument, and if we find any option we shift it; the parameters then become stored in <strong class="source-inline">$1</strong> and we can print and use them. </p>
			<p>If we don't find <a id="_idIndexMarker853"/>an option, we simply ignore what is inside the<a id="_idIndexMarker854"/> variable. </p>
			<h2 id="_idParaDest-261"><a id="_idTextAnchor267"/>See also</h2>
			<p>The topic of using arguments is very complicated and is needed in almost every script. So, there are <a id="_idIndexMarker855"/>open source solutions for that, such as these: </p>
			<ul>
				<li><a href="https://dev.to/unfor19/parsing-command-line-arguments-in-bash-3b51">https://dev.to/unfor19/parsing-command-line-arguments-in-bash-3b51</a></li>
				<li><a href="https://www.baeldung.com/linux/use-command-line-arguments-in-bash-script">https://www.baeldung.com/linux/use-command-line-arguments-in-bash-script</a></li>
			</ul>
			<h1 id="_idParaDest-262"><a id="_idTextAnchor268"/>Quoting in the shell </h1>
			<p>Quotes<a id="_idIndexMarker856"/> are something that we take for granted, not only in Linux but also in a lot of other applications. In this recipe, we are going to deal with how quotes work, which quotes to use, and how to make sure that your quoted part of the script behaves as you intended. </p>
			<h2 id="_idParaDest-263"><a id="_idTextAnchor269"/>Getting ready</h2>
			<p>Using quotes is<a id="_idIndexMarker857"/> incredibly important in Linux, not only in shell scripts but also in any other application that uses text. In this context, quotes behave pretty much the same way as brackets do in mathematical expressions—they offer us the way to change how an expression is evaluated. Almost all command-line tools use a space as a delimiter that tells the tool where one string ends and another one begins. You probably ran into this when you tried to use a file or a directory that has a space in its name. Usually, we solve this problem by using an escape character (<strong class="source-inline">\</strong>), but it makes it much easier to read if we apply quotes. </p>
			<p>This is not the only reason we use quotes, so we are going to pay much more attention to them right now. </p>
			<p>First, we must define<a id="_idIndexMarker858"/> different quotation symbols that we can use and outline what they mean: </p>
			<ul>
				<li>Double quotation marks: <strong class="source-inline">""""</strong></li>
			</ul>
			<p>Used to quote strings and stop a shell from using a space as a delimiter. This quotation style will use shell expansion characters such as <strong class="source-inline">$</strong>, <strong class="source-inline">`</strong>, <strong class="source-inline">\</strong>, and <strong class="source-inline">!</strong> as expansion characters, not quoting them but instead replacing them in the normal way. You will use this quotation style all the time. </p>
			<ul>
				<li>Single quotation marks: <strong class="source-inline">'</strong></li>
			</ul>
			<p>These behave almost exactly the same as double quotes, but with an important twist. Everything inside single quotation marks is treated <em class="italic">as is</em> and will not be changed in any way. Even if you use special characters, this will have no influence—they are going to be used as part of a string. </p>
			<ul>
				<li>Backticks: <strong class="source-inline">"`"</strong></li>
			</ul>
			<p>The backtick character is sometimes considered a quote and often mistaken for a single quote.Note that this is a completely separate character—on a standard <strong class="bold">United States</strong> (<strong class="bold">US</strong>) keyboard, you can find it in the upper row, on the key left of the number <em class="italic">1</em> key, furthest to the left. The difference is in the slope of the character, so the name <em class="italic">backtick</em> really means that it is oriented differently than the quote character. In the shell, it is used to run a command—or, to be more precise, to run a command and then use its output in its place.</p>
			<p>Even though backticks are not strictly quotes, in most learning materials you may find them mentioned as such. This is either because they look like quotes, or because they are the most probable character to get changed automatically to a quote in any text editor.</p>
			<h2 id="_idParaDest-264"><a id="_idTextAnchor270"/>How to do it…</h2>
			<p>To understand quotes, we are <a id="_idIndexMarker859"/>going to make a few script examples, starting with a simple <strong class="source-inline">if</strong> statement, just to remind you what it looks like. We are going to create a file called <strong class="source-inline">quotes1.sh</strong> using this code: </p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code">directory="scripting"</p>
			<p class="source-code"># does the directory exist? </p>
			<p class="source-code">If [ -d $directory ]; then</p>
			<p class="source-code">             echo "Directory $directory exists!"</p>
			<p class="source-code">else </p>
			<p class="source-code">              echo "Directory $directory does not exist!"</p>
			<p class="source-code">fi</p>
			<p>Once we run this, the results are as we expected: </p>
			<p class="source-code">demo@cli1:~/variables$ bash quotes1.sh </p>
			<p class="source-code">Directory scripting does not exist!</p>
			<p>Now, let's just make one small change in <strong class="source-inline">quotes1.sh</strong> and save it as <strong class="source-inline">quotes2.sh</strong>:</p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code">directory='scripting'</p>
			<p class="source-code"># does the directory exist? </p>
			<p class="source-code">if [ -d $directory ]; then</p>
			<p class="source-code">             echo 'Directory $directory exists!'</p>
			<p class="source-code">else </p>
			<p class="source-code">             echo 'Directory $directory does not exist!'</p>
			<p class="source-code">fi</p>
			<p>In this case, when we run the command, the result is going to be quite different. Since we used single quotes, the shell is not displaying our variable, and instead, we are seeing our actual variable name with its prefix:</p>
			<p class="source-code">demo@cli1:~/variables$ bash quotes2.sh </p>
			<p class="source-code">Directory $directory does not exist!</p>
			<p>There is also a special case that we need to mention, and that is when we use double quotes inside single quotes and the other way around. In the case of double quotes being outside, they will negate the single quotes, so we get the usual expansion of variables. This time, create a <a id="_idIndexMarker860"/>file called <strong class="source-inline">undeterdouble.sh</strong> and get this code typed into it: </p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code">directory='scripting'</p>
			<p class="source-code"># does the directory exist? </p>
			<p class="source-code">echo "'Directory $directory is undetermined since we have no \</p>
			<p class="source-code">logic in this script'"</p>
			<p>When we run it, we get this: </p>
			<p class="source-code">demo@cli1:~/variables$ bash undeterdouble.sh </p>
			<p class="source-code">'Directory 'scripting' is undetermined since we have no logic in this script'</p>
			<p>Notice that the shell inserted another set of quotes to separate the variable value and the rest of the string. </p>
			<p>If we turn it the other way around, we are going to end up with everything being quoted, since the single quotes mean just that:</p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code">directory='scripting'</p>
			<p class="source-code"># does the directory exist? </p>
			<p class="source-code">echo '"Directory $directory is undetermined since we have no \</p>
			<p class="source-code">logic in this script"'</p>
			<p>Notice there are no additional quotes in the string: </p>
			<p class="source-code">demo@cli1:~/variables$ bash undetersingle.sh </p>
			<p class="source-code">"Directory $directory is undetermined since we have no logic in this script"</p>
			<h2 id="_idParaDest-265"><a id="_idTextAnchor271"/>How it works…</h2>
			<p>The shell needs to know<a id="_idIndexMarker861"/> when to expand variables and when not to do this. Spaces are also a big problem in scripting—more often than not, your script is going to completely miss some part of the string because it will cut it up into single words divided by spaces. </p>
			<p>Both quotes have their uses, but you are going to be using double quotes most of the time. The reason is that you will usually have a string with spaces but also with different variables in it. By using double quotes, you will have your variables expanded while keeping the text. </p>
			<h2 id="_idParaDest-266"><a id="_idTextAnchor272"/>See also</h2>
			<p>When it comes to <a id="_idIndexMarker862"/>single and double quotes, there are only a couple of resources since they are straightforward: </p>
			<ul>
				<li><a href="https://bash.cyberciti.biz/guide/Quoting">https://bash.cyberciti.biz/guide/Quoting</a></li>
				<li><a href="https://www.gnu.org/software/bash/manual/html_node/Quoting.html">https://www.gnu.org/software/bash/manual/html_node/Quoting.html</a></li>
			</ul>
			<h1 id="_idParaDest-267"><a id="_idTextAnchor273"/>Performing operations on variables </h1>
			<p>Variables are <a id="_idIndexMarker863"/>great since they can hold any value that we <a id="_idIndexMarker864"/>can think of. Often, we need more than just holding a value inside a variable. In this recipe, we are going to deal with a lot of different things that we can do to a variable, sometimes changing it and sometimes completely replacing it. </p>
			<h2 id="_idParaDest-268"><a id="_idTextAnchor274"/>Getting ready</h2>
			<p>In order to be able to change variables, you will need to understand one simple concept. <strong class="source-inline">bash</strong> cannot change the variable itself; we are going to mention this a little later, but if you need to change something in a variable, you will have to reassign it. </p>
			<h2 id="_idParaDest-269"><a id="_idTextAnchor275"/>How to do it…</h2>
			<p>There is a lot of things that can be done to a variable. Sometimes, we want to know more about what it contains; sometimes, we need to change something in order to use it later; or, we may simply want to know if the variable even has a value. </p>
			<p>In this recipe, we are going to use the command line a lot since it makes explaining things much easier. </p>
			<p>Before we begin, we are going to introduce one thing we haven't mentioned yet: arrays. </p>
			<p>An array is a variable that holds separate strings divided by spaces. You could say it's a string itself, but for a lot of reasons to do with flexibility, <strong class="source-inline">bash</strong> is able to address different parts of the array individually, keeping the values in one variable. </p>
			<p>We are going to define an array that will have four strings in it. The way to define a variable is by using brackets and enclosing strings inside them: </p>
			<p class="source-code">demo@cli1:~/variables$ TestArray=(first second third fourth)</p>
			<p>Now, we can see how<a id="_idIndexMarker865"/> many elements there are in our array. This is <a id="_idIndexMarker866"/>where things get a little strange. Remember when we said that counting in <strong class="source-inline">bash</strong> starts at zero? </p>
			<p class="source-code">demo@cli1:~/variables$ echo ${#TestArray[@]}</p>
			<p class="source-code">4</p>
			<p>We see that we got the right information—our array has exactly four elements. The way we got this was by using curly brackets together with some special characters. Our expression starts with <strong class="source-inline">$ {</strong>, which tells <strong class="source-inline">bash</strong> that we are going to do something with an array. Then comes the <strong class="source-inline">#</strong> sign, which means that we are expecting a count of something, either the length or number of elements. After that, we have our array name followed by square brackets and the <strong class="source-inline">@</strong> sign inside brackets. In shell syntax, this tells <strong class="source-inline">bash</strong> that we want all elements in the array. </p>
			<p>Translated into plain English, this command says: show me the count of how many elements there are in the <strong class="source-inline">TestArray</strong> array.</p>
			<p>But beware—things are extremely sensitive when it comes to syntax. For example, if you omit the <strong class="source-inline">[@]</strong> part, this is a completely valid command, but it gives you also completely different information: </p>
			<p class="source-code">demo@cli1:~/variables$ echo ${#TestArray}</p>
			<p class="source-code">5</p>
			<p>The number we get is actually the length of the first string in the array, not the array itself. This is because if we try to just use the array name, we are going to get only the first string as a result: </p>
			<p class="source-code">demo@cli1:~/variables$ echo ${TestArray}</p>
			<p class="source-code">first</p>
			<p>To avoid this, we should<a id="_idIndexMarker867"/> always use square brackets and a number <a id="_idIndexMarker868"/>inside them. This is the right way of referencing the positions of strings in our array. Have in mind that the first string has an index of <strong class="source-inline">0</strong>:</p>
			<p class="source-code">demo@cli1:~/variables$ echo ${TestArray[2]}</p>
			<p class="source-code">third</p>
			<p class="source-code">demo@cli1:~/variables$ echo ${TestArray[0]}</p>
			<p class="source-code">first</p>
			<p class="source-code">demo@cli1:~/variables$ echo ${TestArray[1]}</p>
			<p class="source-code">second</p>
			<p class="source-code">demo@cli1:~/variables$ echo ${TestArray[@]}</p>
			<p class="source-code">first second third fourth</p>
			<p>Now that we have seen how to reference arrays and their parts, let's see if a variable even exists and what is the way to check its length. We already know how to do that—we just need to use <strong class="source-inline">${#variablename}</strong> to have the shell output the length:</p>
			<p class="source-code">demo@cli1:~/variables$ TestVar="Very Long Variable Contains \</p>
			<p class="source-code">Lots Of Characters"</p>
			<p class="source-code">demo@cli1:~/variables$ echo $TestVar </p>
			<p class="source-code">Very Long Variable Contains Lots Of Characters</p>
			<p class="source-code">demo@cli1:~/variables$ echo ${#TestVar} </p>
			<p class="source-code">46</p>
			<p>As we can see, since we put a string in the quotes, our variable contains all the spaces and characters in a single string. The length is then correctly calculated. </p>
			<p>What about checking if a variable exists by looking at its length? </p>
			<p class="source-code">demo@cli1:~/variables$ echo $VariableThatDoesNotExist</p>
			<p class="source-code">demo@cli1:~/variables$ echo ${#VariableThatDoesNotExist}</p>
			<p class="source-code">0</p>
			<p>The length is in this particular case <strong class="source-inline">0</strong>. If you are not used to this kind of calculation, you will probably expect not to get a valid number but to have the shell report that the variable is not defined, but <strong class="source-inline">bash</strong> does it differently. </p>
			<p>The next thing we can do is do substitutions of variables. An extremely useful thing is being able to check if a variable has a value, and if it doesn't have a value, just substitute another value in its place. In<a id="_idIndexMarker869"/> other words, before you use a variable, always <a id="_idIndexMarker870"/>make sure it has a value since <strong class="source-inline">bash</strong> is by default going to return an empty result if the variable is not defined. Here's an example: </p>
			<p class="source-code">demo@cli1:~/variables$ echo ${TEST:-empty}</p>
			<p class="source-code">empty</p>
			<p class="source-code">demo@cli1:~/variables$ echo $TEST</p>
			<p class="source-code">demo@cli1:~/variables$ TEST=full</p>
			<p class="source-code">demo@cli1:~/variables$ echo $TEST</p>
			<p class="source-code">full</p>
			<p class="source-code">demo@cli1:~/variables$ echo ${TEST:-empty}</p>
			<p class="source-code">full</p>
			<p>What we are doing here is testing if the <strong class="source-inline">TEST</strong> variable has a value. If not, we are going to output <strong class="source-inline">empty</strong> as a string. As soon as our variable is set, the output is going to revert to the value of the variable. </p>
			<h2 id="_idParaDest-270"><a id="_idTextAnchor276"/>How it works…</h2>
			<p>The things we have mentioned up to now were simple substitutions of a whole variable. What is much more common is having to change something inside a variable. This can be done using a special syntax. What we can do is extract strings from our variable. This is not going to change the variable itself; instead, we need to save this string into another variable if we need it for something later. The syntax we are going to use is shown here: </p>
			<p class="source-code">${VAR:OFFSET:LENGTH}</p>
			<p><strong class="source-inline">VAR</strong> is the variable name. <strong class="source-inline">OFFSET</strong> and <strong class="source-inline">LENGTH</strong> are self-explanatory—they basically mean <em class="italic">take this many characters starting from this exact position</em>. The easiest way to explain this functionality is<a id="_idIndexMarker871"/> to show you a couple of <a id="_idIndexMarker872"/>examples: </p>
			<p class="source-code">demo@cli1:~/variables$ echo $TestVar </p>
			<p class="source-code">Very Long Variable Contains Lots Of Characters</p>
			<p class="source-code">demo@cli1:~/variables$ echo ${TestVar:5:4}</p>
			<p class="source-code">Long</p>
			<p class="source-code">demo@cli1:~/variables$ echo ${TestVar:5:13}</p>
			<p class="source-code">Long Variable</p>
			<p class="source-code">demo@cli1:~/variables$ echo ${TestVar:5}</p>
			<p class="source-code">Long Variable Containg Lots Of Characters</p>
			<p class="source-code">demo@cli1:~/variables$ echo ${TestVar:5:}</p>
			<p class="source-code">demo@cli1:~/variables$ echo ${TestVar:5:-4}</p>
			<p class="source-code">Long Variable ContainsLots Of Charac</p>
			<p class="source-code">demo@cli1:~/variables$ echo ${TestVar:5:-10}</p>
			<p class="source-code">Long Variable Contains Lots Of</p>
			<p>Notice that we can also use negative numbers. If we do that, we are going to get the part of the string from the given offset up to the last <em class="italic">X</em> characters, <em class="italic">X</em> being the negative number we used. </p>
			<p>The last thing we wanted to show you is replacing patterns in variables. For that, we use this syntax: </p>
			<p class="source-code">${VAR/PATTERN/STRING}</p>
			<p>The same things apply as when we talked about extracting parts of the variable—we are not changing<a id="_idIndexMarker873"/> the variable <a id="_idIndexMarker874"/>itself, we are just modifying the output: </p>
			<p class="source-code">demo@cli1:~/variables$ echo ${TestVar/Variable/String}</p>
			<p class="source-code">Very Long String Contains Lots Of Characters</p>
			<p class="source-code">demo@cli1:~/variables$ echo $TestVar </p>
			<p class="source-code">Very Long Variable Contains Lots Of Characters</p>
			<h2 id="_idParaDest-271"><a id="_idTextAnchor277"/>See also</h2>
			<p>Variable operations contain a lot <a id="_idIndexMarker875"/>more possibilities. Check them out here: </p>
			<ul>
				<li><a href="https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_10_03.html">https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_10_03.html</a></li>
				<li><a href="https://opensource.com/article/18/5/you-dont-know-bash-intro-bash-arrays">https://opensource.com/article/18/5/you-dont-know-bash-intro-bash-arrays</a></li>
			</ul>
			<h1 id="_idParaDest-272"><a id="_idTextAnchor278"/>Variables via external commands </h1>
			<p>Sometimes, while<a id="_idIndexMarker876"/> writing a script, you will have to run a certain command and then use its output to do something in your script. A complicated way to do that is by using redirection. We say <em class="italic">complicated</em> because once you have to use redirection, you are unable to use it for other things. You could redirect to different file descriptors, but that is going to complicate things even more. </p>
			<h2 id="_idParaDest-273"><a id="_idTextAnchor279"/>Getting ready</h2>
			<p>You will soon notice that it is hard to separate different things related to shell commands and functions. The reason for this is that there are a few fundamental rules that then get repeated in a different way. We are going to mention some of them a few times through this book, not because we like redundancy but because you need to completely understand those rules to be able to write good scripts. </p>
			<p>This is why shell expansion exists, and there are two ways to put it into action to accomplish our task. </p>
			<h2 id="_idParaDest-274"><a id="_idTextAnchor280"/>How to do it…</h2>
			<p>There are two syntaxes we can use for this. One is by enclosing the command with all its parameters into backticks, like this: <strong class="source-inline">command</strong>. Another is by using <strong class="source-inline">$(command)</strong>. Both have the same result—whatever is the output of the command is going to get translated into a group of strings and used instead of the original command: </p>
			<p class="source-code">demo@cli1:~/variables$ ls</p>
			<p class="source-code">Backup-20210920.tgz  parameters.sh  quotes2.sh        undetersingle.sh</p>
			<p class="source-code">parameters1.sh       quotes1.sh     undeterdouble.sh  varinname.sh</p>
			<p class="source-code">demo@cli1:~/variables$ echo $(ls)</p>
			<p class="source-code">Backup-20210920.tgz parameters1.sh parameters.sh quotes1.sh quotes2.sh undeterdouble.sh undetersingle.sh varinname.sh</p>
			<p class="source-code">demo@cli1:~/variables$ echo `ls`</p>
			<p class="source-code">Backup-20210920.tgz parameters1.sh parameters.sh quotes1.sh quotes2.sh undeterdouble.sh undetersingle.sh varinname.sh</p>
			<p>This was just to show<a id="_idIndexMarker877"/> you how this sort of expansion behaves. Using a single <strong class="source-inline">echo</strong> command makes no sense; we are going to try with something more complicated: </p>
			<p class="source-code">#!/usr/bin/bash</p>
			<p class="source-code"># testing extension on list of files </p>
			<p class="source-code">for name  in $(ls) ;            do </p>
			<p class="source-code">             for exten in .pdf .txt; do </p>
			<p class="source-code">                          echo "Trying $name$exten"</p>
			<p class="source-code">     done</p>
			<p class="source-code">done</p>
			<p>What we are doing is getting <a id="_idIndexMarker878"/>a list of files from the current directory, and then using this list to try different extensions. This way of working with files is the most common thing you will use in your scripts. When iterating like this, there are going to be either files or lines in the file:</p>
			<p class="source-code">demo@cli1:~/variables$ bash forexpand.sh </p>
			<p class="source-code">Trying Backup-20210920.tgz.pdf</p>
			<p class="source-code">Trying Backup-20210920.tgz.txt</p>
			<p class="source-code">Trying forexpand.sh.pdf</p>
			<p class="source-code">Trying forexpand.sh.txt</p>
			<p class="source-code">Trying parameters1.sh.pdf</p>
			<p class="source-code">Trying parameters1.sh.txt</p>
			<p class="source-code">Trying parameters.sh.pdf</p>
			<p class="source-code">Trying parameters.sh.txt</p>
			<p class="source-code">Trying quotes1.sh.pdf</p>
			<p class="source-code">Trying quotes1.sh.txt</p>
			<p class="source-code">Trying quotes2.sh.pdf</p>
			<p class="source-code">Trying quotes2.sh.txt</p>
			<p class="source-code">Trying undeterdouble.sh.pdf</p>
			<p class="source-code">Trying undeterdouble.sh.txt</p>
			<p class="source-code">Trying undetersingle.sh.pdf</p>
			<p class="source-code">Trying undetersingle.sh.txt</p>
			<p class="source-code">Trying varinname.sh.pdf</p>
			<p class="source-code">Trying varinname.sh.txt</p>
			<p>This shell capability is<a id="_idIndexMarker879"/> amazing but it has its own limitations, the main one being that the output of the command inside brackets has to be <em class="italic">clean</em>. By cleanliness, we mean that it has to contain only the information that can be directly used as parameters. Consider this minuscule change in our script:</p>
			<p class="source-code">demo@cli1:~/variables$ cat forexpand.sh </p>
			<p class="source-code">#!/usr/bin/bash</p>
			<p class="source-code"># testing extension on list of files </p>
			<p class="source-code">for name  in $(ls -l) ;         do </p>
			<p class="source-code">               for exten in .pdf .txt; do </p>
			<p class="source-code">                          echo "Trying $name$exten"</p>
			<p class="source-code">               done</p>
			<p class="source-code">done</p>
			<p>We changed two<a id="_idIndexMarker880"/> characters in the <strong class="source-inline">ls</strong> command by adding <strong class="source-inline">-l</strong> to make it output in a long format. If we now run it, this is not even remotely what we expected: </p>
			<p class="source-code">demo@cli1:~/variables$ bash forexpand.sh </p>
			<p class="source-code">Trying total.pdf</p>
			<p class="source-code">Trying total.txt</p>
			<p class="source-code">Trying 36.pdf</p>
			<p class="source-code">Trying 36.txt</p>
			<p class="source-code">Trying -rw-rw-r--.pdf</p>
			<p class="source-code">Trying -rw-rw-r--.txt</p>
			<p class="source-code">Trying 1.pdf</p>
			<p class="source-code">Trying 1.txt</p>
			<p class="source-code">Trying demo.pdf</p>
			<p class="source-code">Trying demo.txt</p>
			<p class="source-code">Trying demo.pdf</p>
			<p class="source-code">Trying demo.txt</p>
			<p class="source-code">Trying 494.pdf</p>
			<p class="source-code">Trying 494.txt</p>
			<p>We stopped the output here. </p>
			<h2 id="_idParaDest-275"><a id="_idTextAnchor281"/>How it works…</h2>
			<p>This way of <a id="_idIndexMarker881"/>getting information from one command is probably one of the simplest things to understand in entire <strong class="source-inline">bash</strong> scripting. What the shell does is execute the command, get its output, and then behave as if it is a long list of separate strings using a space as a separator. </p>
			<p>This is also the reason why we have to pay special attention to what is going to be the output of the application. The shell is unable to <em class="italic">understand</em> what we want out of it; it simply parses whatever it sees and treats spaces as separators. What will happen then rests entirely on you—the command<a id="_idIndexMarker882"/> that you embedded this expression in can treat the end result completely differently. </p>
			<h2 id="_idParaDest-276"><a id="_idTextAnchor282"/>See also</h2>
			<ul>
				<li><a href="https://tldp.org/HOWTO/Bash-Prompt-HOWTO/x279.html">https://tldp.org/HOWTO/Bash-Prompt-HOWTO/x279.html</a></li>
				<li><a href="http://www.compciv.org/topics/bash/variables-and-substitution/">http://www.compciv.org/topics/bash/variables-and-substitution/</a></li>
			</ul>
		</div>
	</div></body></html>