<html><head></head><body>
<div class="Basic-Text-Frame" id="_idContainer059">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">10</span></h1>
<h1 class="chapterTitle" id="_idParaDest-193"><span class="koboSpan" id="kobo.2.1">Configuring Software</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">Sooner or later, everyone has to configure software on a Linux system. </span><span class="koboSpan" id="kobo.3.2">And while there are many ways to do that, there is thankfully a general pattern that you can follow to get the results you want. </span><span class="koboSpan" id="kobo.3.3">On Linux, this is especially common; because much of the standard tooling in Linux follows the “small, sharp tools” philosophy, the tendency is toward lots of small, powerful programs that provide flexibility by supporting extensive configuration.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4.1">In this chapter, you’ll learn about the configuration hierarchy that well-designed programs tend to use. </span><span class="koboSpan" id="kobo.4.2">Whether you just need to check a manual page to find a command-line argument for a single command or whether you want to set an environment variable that applies to all commands you run in your shell, you’ll see how to do it.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5.1">From there, we’ll show you the general configuration hierarchy that almost all Unix software uses, so that you’ll always know where to check if a program isn’t quite behaving how you expect based on the configuration you’ve given it.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.6.1">Finally, you’ll see how this configuration translates to programs managed through </span><code class="inlineCode"><span class="koboSpan" id="kobo.7.1">systemd</span></code><span class="koboSpan" id="kobo.8.1">, the most popular service management tool on Linux.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.9.1">To summarize, this chapter will cover the following topics:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.10.1">The configuration hierarchy</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.11.1">Command-line arguments</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.12.1">Environment variables</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.13.1">Configuration files</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.14.1">Configuration in Docker</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-194"><span class="koboSpan" id="kobo.15.1">Configuration hierarchy</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.16.1">One of the first things that you’ll</span><a id="_idIndexMarker307"/><span class="koboSpan" id="kobo.17.1"> do when running programs on Linux is to tweak them to your specific needs. </span><span class="koboSpan" id="kobo.17.2">In fact, you’ve already done that: by passing arguments to commands like </span><code class="inlineCode"><span class="koboSpan" id="kobo.18.1">ls</span></code><span class="koboSpan" id="kobo.19.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.20.1">grep</span></code><span class="koboSpan" id="kobo.21.1">, and others, you have changed how these programs behave.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.22.1">You probably have an intuitive feeling about how this should work because you’ve been around software your whole life. </span><span class="koboSpan" id="kobo.22.2">For example, it might seem natural to you that passing command-line arguments would override program defaults: </span><code class="inlineCode"><span class="koboSpan" id="kobo.23.1">ls -l</span></code><span class="koboSpan" id="kobo.24.1"> gives you output that’s different from the default output of </span><code class="inlineCode"><span class="koboSpan" id="kobo.25.1">ls</span></code><span class="koboSpan" id="kobo.26.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.27.1">Let’s now dive into this intuition a bit more rigorously and see if we can map out some heuristics for how configuration </span><em class="italic"><span class="koboSpan" id="kobo.28.1">generally </span></em><span class="koboSpan" id="kobo.29.1">works in a Unix environment. </span><span class="koboSpan" id="kobo.29.2">One of the norms that most standard Unix command-line programs conform to is a specific configuration hierarchy, where earlier values are overridden by later values. </span><span class="koboSpan" id="kobo.29.3">If you’ve written software that takes user configuration, you may have created a priority hierarchy like this before:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.30.1">Set configurable values to built-in defaults.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.31.1">Check for values passed via configuration files, overriding those defaults.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.32.1">Check for environment variables (people may refer to these as </span><code class="inlineCode"><span class="koboSpan" id="kobo.33.1">env vars</span></code><span class="koboSpan" id="kobo.34.1">), overriding configuration files and earlier values.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.35.1">Check for command-line interface arguments (you may hear these referred to as CLI args), and update values as necessary, overriding earlier values.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.36.1">Each successive level is closer to the user running the software at a specific moment, and so each successive level takes priority over the previous one.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.37.1">For example, if your </span><a id="_idIndexMarker308"/><span class="koboSpan" id="kobo.38.1">software detects conflicting values in the config file and the CLI arguments that the program was launched with, it should prefer the value in the command-line arguments. </span><span class="koboSpan" id="kobo.38.2">In other words, </span><strong class="keyWord"><span class="koboSpan" id="kobo.39.1">the values found closer to the program’s invocation </span></strong><span class="koboSpan" id="kobo.40.1">“</span><strong class="keyWord"><span class="koboSpan" id="kobo.41.1">shadow</span></strong><span class="koboSpan" id="kobo.42.1">” (in the sense of obscuring or replacing) </span><strong class="keyWord"><span class="koboSpan" id="kobo.43.1">the values further away from execution</span></strong><span class="koboSpan" id="kobo.44.1">. </span><span class="koboSpan" id="kobo.44.2">The CLI argument value replaces the configuration file value because the configuration file is further away from the point of invocation than the arguments passed to the program when it’s started. </span><span class="koboSpan" id="kobo.44.3">That should make intuitive sense: you can’t depend on software if it ignores your command-line flags in favor of program defaults. </span><code class="inlineCode"><span class="koboSpan" id="kobo.45.1">ls -l</span></code><span class="koboSpan" id="kobo.46.1"> shouldn’t give you the same output as </span><code class="inlineCode"><span class="koboSpan" id="kobo.47.1">ls</span></code><span class="koboSpan" id="kobo.48.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.49.1">Most software on Linux follows this hierarchy when there are multiple ways to configure that software. </span><span class="koboSpan" id="kobo.49.2">Keep in mind that not all software uses all the configuration paths we’ll show as examples here, and not all software respects this configuration order exactly.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.50.1">Let’s look at this hierarchy again, but this time, connecting it to practical, specific examples for the </span><strong class="keyWord"><span class="koboSpan" id="kobo.51.1">nginx</span></strong><span class="koboSpan" id="kobo.52.1"> web server program. </span><span class="koboSpan" id="kobo.52.2">You’ll likely get to work with nginx at some point in your career, since it’s one of the most popular web servers in the world, used to front all kinds of dynamic web applications. </span><span class="koboSpan" id="kobo.52.3">Let’s see how each part of the priority hierarchy we just covered </span><a id="_idIndexMarker309"/><span class="koboSpan" id="kobo.53.1">maps to practical nginx configuration:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><strong class="keyWord"><span class="koboSpan" id="kobo.54.1">Built-in defaults</span></strong><span class="koboSpan" id="kobo.55.1">: The </span><a id="_idIndexMarker310"/><span class="koboSpan" id="kobo.56.1">hardcoded nginx default for the user that it executes as after starting up is </span><code class="inlineCode"><span class="koboSpan" id="kobo.57.1">nobody</span></code><span class="koboSpan" id="kobo.58.1">.</span></li>
<li class="numberedList"><strong class="keyWord"><span class="koboSpan" id="kobo.59.1">Global configuration files</span></strong><span class="koboSpan" id="kobo.60.1"> can change this for all nginx processes, so it’s common to find a global</span><a id="_idIndexMarker311"/><span class="koboSpan" id="kobo.61.1"> nginx configuration file at </span><code class="inlineCode"><span class="koboSpan" id="kobo.62.1">/etc/nginx/nginx.conf</span></code><span class="koboSpan" id="kobo.63.1"> with the value “</span><code class="inlineCode"><span class="koboSpan" id="kobo.64.1">user www;</span></code><span class="koboSpan" id="kobo.65.1">" which instructs nginx to run as the </span><code class="inlineCode"><span class="koboSpan" id="kobo.66.1">www</span></code><span class="koboSpan" id="kobo.67.1"> user instead.</span></li>
<li class="numberedList"><strong class="keyWord"><span class="koboSpan" id="kobo.68.1">User-level configuration files</span></strong><span class="koboSpan" id="kobo.69.1"> are typically “dot-files” (files named with a leading </span><code class="inlineCode"><span class="koboSpan" id="kobo.70.1">.</span></code><span class="koboSpan" id="kobo.71.1"> character, which</span><a id="_idIndexMarker312"/><span class="koboSpan" id="kobo.72.1"> excludes them from regular </span><code class="inlineCode"><span class="koboSpan" id="kobo.73.1">ls</span></code><span class="koboSpan" id="kobo.74.1"> listings) in the User’s </span><code class="inlineCode"><span class="koboSpan" id="kobo.75.1">/home</span></code><span class="koboSpan" id="kobo.76.1"> directory. </span><span class="koboSpan" id="kobo.76.2">For example, </span><code class="inlineCode"><span class="koboSpan" id="kobo.77.1">/home/dave/.bashrc</span></code><span class="koboSpan" id="kobo.78.1"> is a place for user-specific bash configuration. </span><code class="inlineCode"><span class="koboSpan" id="kobo.79.1">nginx</span></code><span class="koboSpan" id="kobo.80.1"> is a long-running process that doesn’t usually run as a regular Linux user, but it does have something like this: individual sites are often configured in their own, separate configuration files at </span><code class="inlineCode"><span class="koboSpan" id="kobo.81.1">/etc/nginx/conf.d/yourwebsite.conf</span></code><span class="koboSpan" id="kobo.82.1">. </span><span class="koboSpan" id="kobo.82.2">These usually inherit values from the global configuration from the previous level.</span></li>
<li class="numberedList"><strong class="keyWord"><span class="koboSpan" id="kobo.83.1">Environment variables</span></strong><span class="koboSpan" id="kobo.84.1">. </span><code class="inlineCode"><span class="koboSpan" id="kobo.85.1">nginx</span></code><span class="koboSpan" id="kobo.86.1"> gets timezone information from an environment</span><a id="_idIndexMarker313"/><span class="koboSpan" id="kobo.87.1"> variable named </span><code class="inlineCode"><span class="koboSpan" id="kobo.88.1">TZ</span></code><span class="koboSpan" id="kobo.89.1">.</span></li>
<li class="numberedList"><strong class="keyWord"><span class="koboSpan" id="kobo.90.1">Command-line arguments</span></strong><span class="koboSpan" id="kobo.91.1"> are specified when software is run, either manually or in an automated way (for example via cron, or unit files). </span><span class="koboSpan" id="kobo.91.2">Make sure to look at </span><a id="_idIndexMarker314"/><span class="koboSpan" id="kobo.92.1">these possible external sources of command-line arguments when debugging a problem – they’re frequent culprits when you see a disparity between program behavior and the configuration files. </span><code class="inlineCode"><span class="koboSpan" id="kobo.93.1">nginx</span></code><span class="koboSpan" id="kobo.94.1"> takes various command-line arguments that modify its behavior: from overriding the configuration files it will use to preventing it from acting as a web server entirely and instead signaling an already-running nginx process to stop or reload.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.95.1">Now that you’ve seen both the theoretical and practical aspects of how this configuration hierarchy interacts with all the programs you run on Linux, and all the programs you might </span><em class="italic"><span class="koboSpan" id="kobo.96.1">write </span></em><span class="koboSpan" id="kobo.97.1">for it, let’s go through the configuration hierarchy step by step to take a closer look at each level. </span><span class="koboSpan" id="kobo.97.2">We’ll start with the most direct and powerful form of configuration, which overrides everything else: passing command-line arguments at the moment in which you invoke a program.</span></p>
<h1 class="heading-1" id="_idParaDest-195"><span class="koboSpan" id="kobo.98.1">Command-line arguments</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.99.1">You’re already familiar with the most common way to configure programs: with command-line arguments. </span><span class="koboSpan" id="kobo.99.2">These configure a program at the moment it’s invoked as a shell command.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.100.1">To find valid command-line arguments</span><a id="_idIndexMarker315"/><span class="koboSpan" id="kobo.101.1"> for a program, start with the man (manual) page for your command. </span><span class="koboSpan" id="kobo.101.2">Except on the most minimal systems, Unix software ships with manual pages that document most programs, explain available flags, and – usually at the end – list other kinds of configuration methods, like configuration files.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.102.1">Let’s look at the beginning of the man page content for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.103.1">find</span></code><span class="koboSpan" id="kobo.104.1"> command:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.105.1">man find
FIND(1)                                                               General Commands Manual                                                              FIND(1)
 
NAME
     find – walk a file hierarchy
 
SYNOPSIS
     find [-H | -L | -P] [-EXdsx] [-f path] path ... </span><span class="koboSpan" id="kobo.105.2">[expression]
     find [-H | -L | -P] [-EXdsx] -f path [path ...] [expression]
 
DESCRIPTION
     The find utility recursively descends the directory tree for each path listed, evaluating an expression (composed of the "primaries" and "operands" listed
     below) in terms of each file in the tree.
 
     </span><span class="koboSpan" id="kobo.105.3">The options are as follows:
 
     -E      Interpret regular expressions followed by -regex and -iregex primaries as extended (modern) regular expressions rather than basic regular expressions
             (BRE's).  </span><span class="koboSpan" id="kobo.105.4">The re_format(7) manual page fully describes both formats.
 
     </span><span class="koboSpan" id="kobo.105.5">-H      Cause the file information and file type (see stat(2)) returned for each symbolic link specified on the command line to be those of the file
             referenced by the link, not the link itself.  </span><span class="koboSpan" id="kobo.105.6">If the referenced file does not exist, the file information and type will be for the link itself.  </span><span class="koboSpan" id="kobo.105.7">File
             information of all symbolic links not on the command line is that of the link itself.
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.106.1">You can see that most of this</span><a id="_idIndexMarker316"/><span class="koboSpan" id="kobo.107.1"> manual page documents the various command-line arguments that are available when running </span><code class="inlineCode"><span class="koboSpan" id="kobo.108.1">find</span></code><span class="koboSpan" id="kobo.109.1">. </span><span class="koboSpan" id="kobo.109.2">You’ve used plenty of command-line arguments since </span><em class="chapterRef"><span class="koboSpan" id="kobo.110.1">Chapter 1</span></em><span class="koboSpan" id="kobo.111.1">, so this should all feel familiar.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.112.1">Let’s look at the next, slightly more distant kind of configuration: environment variables.</span></p>
<h1 class="heading-1" id="_idParaDest-196"><span class="koboSpan" id="kobo.113.1">Environment variables</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.114.1">While a</span><a id="_idIndexMarker317"/><span class="koboSpan" id="kobo.115.1"> command-line argument is powerful, it applies only to the single program invocation that it’s a part of. </span><span class="koboSpan" id="kobo.115.2">When you type </span><code class="inlineCode"><span class="koboSpan" id="kobo.116.1">ls -l</span></code><span class="koboSpan" id="kobo.117.1">, only that one </span><code class="inlineCode"><span class="koboSpan" id="kobo.118.1">ls</span></code><span class="koboSpan" id="kobo.119.1"> command will have the long-form output. </span><span class="koboSpan" id="kobo.119.2">But what if you want a configuration value to persist over multiple invocations of a command? </span><span class="koboSpan" id="kobo.119.3">This is useful if, for example, you’re writing a script that will install packages at a few different points, and you want to set a configuration option </span><em class="italic"><span class="koboSpan" id="kobo.120.1">once </span></em><span class="koboSpan" id="kobo.121.1">instead of having to add it over and over again as a command-line argument every single time you run the package installation command. </span><span class="koboSpan" id="kobo.121.2">That’s where environment variables come in.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.122.1">As a developer writing any kind of software, you are likely aware of environment variables: shell values that are analogous to variables in any other programming language. </span><span class="koboSpan" id="kobo.122.2">These differ from command-line arguments because they operate one level higher. </span><span class="koboSpan" id="kobo.122.3">Environment variables give you more leverage: once you set a configuration variable in the shell, it applies to all program invocations made in that shell session. </span><span class="koboSpan" id="kobo.122.4">Set it once, and a program that looks for the environment variable will respect it every time it’s run, until the variable changes or you end the shell session.</span></p>
<div class="note">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.123.1">Note</span></strong></p>
<p class="normal"><span class="koboSpan" id="kobo.124.1">We’ll dive deeper into environment variables in </span><em class="chapterRef"><span class="koboSpan" id="kobo.125.1">Chapter 12</span></em><span class="koboSpan" id="kobo.126.1">, </span><em class="italic"><span class="koboSpan" id="kobo.127.1">Automating Tasks with Shell Scripts</span></em><span class="koboSpan" id="kobo.128.1">, but this section covers the basics.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.129.1">Most standard Unix environments use environment variables as a means to specify common configurations that are relevant to many different programs, not just one. </span><span class="koboSpan" id="kobo.129.2">For example, environment variables keep track of where the User’s </span><code class="inlineCode"><span class="koboSpan" id="kobo.130.1">/home</span></code><span class="koboSpan" id="kobo.131.1"> directory can be found (</span><code class="inlineCode"><span class="koboSpan" id="kobo.132.1">$HOME</span></code><span class="koboSpan" id="kobo.133.1">), what the current working directory is (</span><code class="inlineCode"><span class="koboSpan" id="kobo.134.1">$PWD</span></code><span class="koboSpan" id="kobo.135.1">), which shell should be used by default (</span><code class="inlineCode"><span class="koboSpan" id="kobo.136.1">$SHELL</span></code><span class="koboSpan" id="kobo.137.1">), where to look for the executable files that correspond to commands received via the CLI (</span><code class="inlineCode"><span class="koboSpan" id="kobo.138.1">$PATH</span></code><span class="koboSpan" id="kobo.139.1">), and so on.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.140.1">Feel free to inspect them right now; you can see the value of a specific environment variable by printing it out with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.141.1">echo</span></code><span class="koboSpan" id="kobo.142.1"> command:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.143.1">$ echo $SHELL
/bin/zsh
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.144.1">Or you can use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.145.1">env</span></code><span class="koboSpan" id="kobo.146.1"> command to see all of the environment variables currently set:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.147.1">$ env
...
</span><span class="koboSpan" id="kobo.147.2"># many lines of output, one for each of your environment variables ...
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.148.1">To set an environment variable in your current shell, simply use </span><code class="inlineCode"><span class="koboSpan" id="kobo.149.1">=</span></code><span class="koboSpan" id="kobo.150.1"> for assignment (ensure that there are no spaces around the equals sign):</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.151.1">MYVAR=fruitloops
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.152.1">You’ve set it for your current shell:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.153.1">$ echo $MYVAR
fruitloops
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.154.1">To persist this variable for any subshells you spawn (for example, when you run a script), use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.155.1">export</span></code><span class="koboSpan" id="kobo.156.1"> builtin:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.157.1">export MYVAR=fruitloops
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.158.1">You’ll learn</span><a id="_idIndexMarker318"/><span class="koboSpan" id="kobo.159.1"> more in </span><em class="chapterRef"><span class="koboSpan" id="kobo.160.1">Chapter 12</span></em><span class="koboSpan" id="kobo.161.1">, </span><em class="italic"><span class="koboSpan" id="kobo.162.1">Automating Tasks with Shell Scripts</span></em><span class="koboSpan" id="kobo.163.1">, but the above command is the extent of what you’ll need to pass environment variable configuration to most programs you interact with.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.164.1">Back to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.165.1">find</span></code><span class="koboSpan" id="kobo.166.1"> example: if you scroll down far enough on the </span><code class="inlineCode"><span class="koboSpan" id="kobo.167.1">find</span></code><span class="koboSpan" id="kobo.168.1"> man page, which we looked at in the previous section, you’ll see a section titled </span><code class="inlineCode"><span class="koboSpan" id="kobo.169.1">ENVIRONMENT</span></code><span class="koboSpan" id="kobo.170.1">:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.171.1">ENVIRONMENT
     The LANG, LC_ALL, LC_COLLATE, LC_CTYPE, LC_MESSAGES and LC_TIME environment variables affect the execution of the find utility as described in environ(7).
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.172.1">This is a different level of configuration – instead of being passed as command arguments at runtime, these are the configuration directives that can be read from shell environment variables.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.173.1">Why should a program treat environment variables differently from arguments? </span><span class="koboSpan" id="kobo.173.2">Let’s think it through: the command-line argument </span><code class="inlineCode"><span class="koboSpan" id="kobo.174.1">–H</span></code><span class="koboSpan" id="kobo.175.1"> is incredibly specific because it is defined at the command invocation level. </span><span class="koboSpan" id="kobo.175.2">As a result, it applies only to the command being run at that instant.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.176.1">On the other</span><a id="_idIndexMarker319"/><span class="koboSpan" id="kobo.177.1"> hand, environment variables are less specific. </span><span class="koboSpan" id="kobo.177.2">They’re defined at the shell level and, therefore, are available to all commands run from that shell.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.178.1">Let’s keep walking up the configuration hierarchy: if a value isn’t set at runtime in a command-line argument, or as an environment variable in the shell session that a program is launched from, where does configuration come from?</span></p>
<h1 class="heading-1" id="_idParaDest-197"><span class="koboSpan" id="kobo.179.1">Configuration files</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.180.1">The next place a program looks for</span><a id="_idIndexMarker320"/><span class="koboSpan" id="kobo.181.1"> configuration is in its configuration files. </span><em class="italic"><span class="koboSpan" id="kobo.182.1">Where </span></em><span class="koboSpan" id="kobo.183.1">a program looks for configuration can vary wildly, but there are a few standard places to look.</span></p>
<h2 class="heading-2" id="_idParaDest-198"><span class="koboSpan" id="kobo.184.1">System-level configuration in /etc/</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.185.1">First, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.186.1">/etc/</span></code><span class="koboSpan" id="kobo.187.1"> directory is a </span><a id="_idIndexMarker321"/><span class="koboSpan" id="kobo.188.1">good place to start. </span><span class="koboSpan" id="kobo.188.2">You’ve seen this directory before, in </span><em class="chapterRef"><span class="koboSpan" id="kobo.189.1">Chapter 5</span></em><span class="koboSpan" id="kobo.190.1">, </span><em class="italic"><span class="koboSpan" id="kobo.191.1">Introducing Files</span></em><span class="koboSpan" id="kobo.192.1">. </span><code class="inlineCode"><span class="koboSpan" id="kobo.193.1">/etc/programname</span></code><span class="koboSpan" id="kobo.194.1"> – where </span><code class="inlineCode"><span class="koboSpan" id="kobo.195.1">programname</span></code><span class="koboSpan" id="kobo.196.1"> is a stand-in for the name of the program you’re interested in configuring – is a common choice of directory for software to keep system-wide configuration. </span><span class="koboSpan" id="kobo.196.2">For many programs, that’s enough. </span><span class="koboSpan" id="kobo.196.3">For example, the nginx web server is a system-level program: different users aren’t commonly running their own instances of web servers on a single machine, so a system-wide configuration is all that’s needed.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.197.1">That said, configuration for large or complex programs can still be broken up inside of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.198.1">/etc/programname</span></code><span class="koboSpan" id="kobo.199.1"> directory. </span><span class="koboSpan" id="kobo.199.2">Nginx is a good example of this; its main configuration file is at </span><code class="inlineCode"><span class="koboSpan" id="kobo.200.1">/etc/nginx.conf</span></code><span class="koboSpan" id="kobo.201.1">, with additional config files being sourced from additional files in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.202.1">/etc/nginx/conf.d/</span></code><span class="koboSpan" id="kobo.203.1"> directory.</span></p>
<h2 class="heading-2" id="_idParaDest-199"><span class="koboSpan" id="kobo.204.1">User-level configuration in ~/.config</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.205.1">For programs that have</span><a id="_idIndexMarker322"/><span class="koboSpan" id="kobo.206.1"> significant per-user configuration – think text editors, development tooling, games, and more – the </span><code class="inlineCode"><span class="koboSpan" id="kobo.207.1">~/.config</span></code><span class="koboSpan" id="kobo.208.1"> directory inside a user’s home directory is used. </span><span class="koboSpan" id="kobo.208.2">Recall from </span><em class="chapterRef"><span class="koboSpan" id="kobo.209.1">Chapter 1</span></em><span class="koboSpan" id="kobo.210.1">, </span><em class="italic"><span class="koboSpan" id="kobo.211.1">How the Command Line Works</span></em><span class="koboSpan" id="kobo.212.1"> that </span><code class="inlineCode"><span class="koboSpan" id="kobo.213.1">~</span></code><span class="koboSpan" id="kobo.214.1"> is a shorthand for “the current user’s home directory,” and that directories whose names start with a period character (“</span><code class="inlineCode"><span class="koboSpan" id="kobo.215.1">.</span></code><span class="koboSpan" id="kobo.216.1">") are omitted from </span><code class="inlineCode"><span class="koboSpan" id="kobo.217.1">ls</span></code><span class="koboSpan" id="kobo.218.1"> output unless you pass the </span><code class="inlineCode"><span class="koboSpan" id="kobo.219.1">-a</span></code><span class="koboSpan" id="kobo.220.1"> flag. </span><span class="koboSpan" id="kobo.220.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.221.1">~/.config</span></code><span class="koboSpan" id="kobo.222.1"> directory is part of the XDG base directory standard, which you can get an overview of here: </span><a href="https://wiki.archlinux.org/title/XDG_Base_Directory"><span class="url"><span class="koboSpan" id="kobo.223.1">https://wiki.archlinux.org/title/XDG_Base_Directory</span></span></a><span class="koboSpan" id="kobo.224.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.225.1">As an example, my </span><code class="inlineCode"><span class="koboSpan" id="kobo.226.1">neovim</span></code><span class="koboSpan" id="kobo.227.1"> configuration is meaningfully different from other developers’ configuration, yet a single neovim binary on a system can support hundreds of developers working on the same machine simultaneously because each developer’s invocation of neovim uses their user-specific configuration files kept in </span><code class="inlineCode"><span class="koboSpan" id="kobo.228.1">~/.config/nvim/</span></code><span class="koboSpan" id="kobo.229.1">. </span><span class="koboSpan" id="kobo.229.2">And that’s good! </span></p>
<p class="normal"><span class="koboSpan" id="kobo.230.1">You can imagine the pandemonium that would ensue if there was only a single system-wide place to configure this program in </span><code class="inlineCode"><span class="koboSpan" id="kobo.231.1">/etc/</span></code><span class="koboSpan" id="kobo.232.1"> – either each developer would have to set countless environment variables before running the neovim editor or invoke the editor command with countless command-line flags.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.233.1">Now that you’ve taken a walk through the classical configuration sources for Unix programs, let’s look at one Linux-specific complication that you should know about: how configuration via environment files and CLI arguments is managed for programs controlled through </span><code class="inlineCode"><span class="koboSpan" id="kobo.234.1">systemd</span></code><span class="koboSpan" id="kobo.235.1">.</span></p>
<h1 class="heading-1" id="_idParaDest-200"><span class="koboSpan" id="kobo.236.1">systemd units</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.237.1">In most Linux distributions – aside</span><a id="_idIndexMarker323"/><span class="koboSpan" id="kobo.238.1"> from Docker containers – </span><code class="inlineCode"><span class="koboSpan" id="kobo.239.1">systemd</span></code><span class="koboSpan" id="kobo.240.1"> runs the show. </span><span class="koboSpan" id="kobo.240.2">We’ve already covered the basics of </span><code class="inlineCode"><span class="koboSpan" id="kobo.241.1">systemd</span></code><span class="koboSpan" id="kobo.242.1"> in this book (see </span><em class="chapterRef"><span class="koboSpan" id="kobo.243.1">Chapter 3</span></em><span class="koboSpan" id="kobo.244.1">, </span><em class="italic"><span class="koboSpan" id="kobo.245.1">Service Management with systemd</span></em><span class="koboSpan" id="kobo.246.1">), and in this section, we’ll take a quick look at how </span><code class="inlineCode"><span class="koboSpan" id="kobo.247.1">systemd</span></code><span class="koboSpan" id="kobo.248.1"> manages configuration for programs.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.249.1">First, a quick review, in case </span><em class="chapterRef"><span class="koboSpan" id="kobo.250.1">Chapter 3</span></em><span class="koboSpan" id="kobo.251.1"> seems awfully distant: in a systemd-managed Linux environment, services are packaged into </span><code class="inlineCode"><span class="koboSpan" id="kobo.252.1">systemd</span></code><span class="koboSpan" id="kobo.253.1"> unit files, which wrap and control the actual executable binary, its arguments, the commands used to launch, restart, and stop the unit, and much more.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.254.1">There are many systemd unit types, as we’ve already covered, but we’re interested in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.255.1">service</span></code><span class="koboSpan" id="kobo.256.1"> unit type here.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.257.1">We’ve already covered the fact that unit files can exist in several different directories, depending on their purpose, but your own custom systemd units will usually live in </span><code class="inlineCode"><span class="koboSpan" id="kobo.258.1">/etc/systemd/system</span></code><span class="koboSpan" id="kobo.259.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.260.1">To understand how a </span><a id="_idIndexMarker324"/><span class="koboSpan" id="kobo.261.1">systemd unit lets you affect the layers of the configuration hierarchy that we’ve covered in this chapter, let’s create a systemd-managed service by writing our own systemd unit for an imaginary program called </span><code class="inlineCode"><span class="koboSpan" id="kobo.262.1">yourprogram</span></code><span class="koboSpan" id="kobo.263.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-201"><span class="koboSpan" id="kobo.264.1">Create your own service</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.265.1">As a developer, you </span><a id="_idIndexMarker325"/><span class="koboSpan" id="kobo.266.1">may need to wrap a program you’re writing into a service, which can be more easily managed than a manually (interactively) invoked program. </span><span class="koboSpan" id="kobo.266.2">That’s perfectly useful on its own, but in this chapter, we’re digging into the extra control that systemd units give you over how and where your program is configured. </span><span class="koboSpan" id="kobo.266.3">Let’s walk through the process of creating a service by wrapping a binary with a </span><code class="inlineCode"><span class="koboSpan" id="kobo.267.1">systemd</span></code><span class="koboSpan" id="kobo.268.1"> unit file.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.269.1">First, ensure that you have an executable file copied to a place that is in the default </span><code class="inlineCode"><span class="koboSpan" id="kobo.270.1">$PATH: /usr/local/bin/yourprogram</span></code><span class="koboSpan" id="kobo.271.1">. </span><span class="koboSpan" id="kobo.271.2">If you want to get the most out of this, use a manually compiled program like the </span><code class="inlineCode"><span class="koboSpan" id="kobo.272.1">htop</span></code><span class="koboSpan" id="kobo.273.1"> binary you created in the previous </span><em class="chapterRef"><span class="koboSpan" id="kobo.274.1">Chapter 9</span></em><span class="koboSpan" id="kobo.275.1">, </span><em class="italic"><span class="koboSpan" id="kobo.276.1">Managing Installed Software</span></em><span class="koboSpan" id="kobo.277.1">, and replace the imaginary </span><code class="inlineCode"><span class="koboSpan" id="kobo.278.1">yourprogram</span></code><span class="koboSpan" id="kobo.279.1"> with </span><code class="inlineCode"><span class="koboSpan" id="kobo.280.1">htop</span></code><span class="koboSpan" id="kobo.281.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.282.1">Now, create the following </span><code class="inlineCode"><span class="koboSpan" id="kobo.283.1">systemd</span></code><span class="koboSpan" id="kobo.284.1"> unit file at </span><code class="inlineCode"><span class="koboSpan" id="kobo.285.1">/etc/systemd/system/yourprogram.service</span></code><span class="koboSpan" id="kobo.286.1">:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.287.1">[Unit]
Description=Your program description.
</span><span class="koboSpan" id="kobo.287.2">After=network-online.target
[Service]
Type=exec
ExecStart=/usr/local/bin/yourprogram -clioption=1 –clioption2
EnvironmentFile=-/etc/yourprogram/prod_defaults
Restart=on-failure
[Install]
WantedBy=multi-user.target
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.288.1">Can you find the two configuration-related lines in this unit file?</span></p>
<p class="normal"><span class="koboSpan" id="kobo.289.1">You can see that the </span><code class="inlineCode"><span class="koboSpan" id="kobo.290.1">ExecStart</span></code><span class="koboSpan" id="kobo.291.1"> line specifies how the program is invoked when someone starts this systemd service. </span><span class="koboSpan" id="kobo.291.2">We’re using the systemd unit file to pass command-line arguments to the program to make sure that anytime someone starts the service, the program is run with exactly the options we want. </span><span class="koboSpan" id="kobo.291.3">Anytime someone runs </span><code class="inlineCode"><span class="koboSpan" id="kobo.292.1">systemctl start yourprogram</span></code><span class="koboSpan" id="kobo.293.1">, we have ensured that </span><code class="inlineCode"><span class="koboSpan" id="kobo.294.1">yourprogram</span></code><span class="koboSpan" id="kobo.295.1"> will be called with </span><code class="inlineCode"><span class="koboSpan" id="kobo.296.1">-clioption=1</span></code><span class="koboSpan" id="kobo.297.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.298.1">-clioption2</span></code><span class="koboSpan" id="kobo.299.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.300.1">Second, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.301.1">EnvironmentFile</span></code><span class="koboSpan" id="kobo.302.1"> line </span><a id="_idIndexMarker326"/><span class="koboSpan" id="kobo.303.1">specifies a file path for </span><code class="inlineCode"><span class="koboSpan" id="kobo.304.1">systemd</span></code><span class="koboSpan" id="kobo.305.1"> to check, where it can expect environment variables relevant to this program to be set. </span><span class="koboSpan" id="kobo.305.2">This file will be parsed by the shell that systemd uses to run the binary; it should contain shell variable assignments like:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.306.1"># yourprogram environment variables
ENV=production
DB_HOST=localhost
DB_PORT=5432
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.307.1">Have systemd re-read its config files to make sure it sees the new service </span><code class="inlineCode"><span class="koboSpan" id="kobo.308.1">Unit</span></code><span class="koboSpan" id="kobo.309.1"> you’ve defined:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.310.1">$ sudo systemd daemon-reload
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.311.1">Now you can manage this like any other </span><code class="inlineCode"><span class="koboSpan" id="kobo.312.1">systemd</span></code><span class="koboSpan" id="kobo.313.1"> service:</span></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.314.1">systemctl start yourprogram</span></code></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.315.1">systemctl status yourprogram</span></code></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.316.1">systemctl stop yourprogram</span></code></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.317.1">systemctl enable yourprogram</span></code></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.318.1">systemctl disable yourprogram</span></code></p>
<p class="normal"><span class="koboSpan" id="kobo.319.1">You know that every time you start this service, your environment file at </span><code class="inlineCode"><span class="koboSpan" id="kobo.320.1">/etc/yourprogram/prod_defaults</span></code><span class="koboSpan" id="kobo.321.1"> will be used to source environment variables, and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.322.1">ExecStart</span></code><span class="koboSpan" id="kobo.323.1"> line will pass the CLI options you’ve specified.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.324.1">We’ve shown you an extremely simple service here, just so you can get your head around how systemd is used to control program configuration, but there are </span><em class="italic"><span class="koboSpan" id="kobo.325.1">many</span></em><span class="koboSpan" id="kobo.326.1"> other configuration directives you can pass here. </span><span class="koboSpan" id="kobo.326.2">Spend some time reading the </span><code class="inlineCode"><span class="koboSpan" id="kobo.327.1">systemd</span></code><span class="koboSpan" id="kobo.328.1"> unit documentation (</span><a href="https://www.freedesktop.org/software/systemd/man/latest/systemd.unit.html#%5BUnit%5D%20Section%20Options"><span class="url"><span class="koboSpan" id="kobo.329.1">https://www.freedesktop.org/software/systemd/man/latest/systemd.unit.html#%5BUnit%5D%20Section%20Options</span></span></a><span class="koboSpan" id="kobo.330.1">) if you have a more complex service on your hands.</span></p>
<h1 class="heading-1" id="_idParaDest-202"><span class="koboSpan" id="kobo.331.1">Quick note: configuration in Docker</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.332.1">Earlier in this chapter, we</span><a id="_idIndexMarker327"/><span class="koboSpan" id="kobo.333.1"> mentioned that Docker is often the exception when it comes to configuration. </span><span class="koboSpan" id="kobo.333.2">Because Docker containers are a much more minimal environment, they don’t have a lot of the extra binaries, services, and configuration files that you’ll find in a traditional Unix system. </span><span class="koboSpan" id="kobo.333.3">But because much of the software that software developers create now runs in containers, as opposed to traditional, full operating system environments, we want to cover some basics here to make sure you’ve got an intuition for how configuration is different in Docker containers. </span><span class="koboSpan" id="kobo.333.4">We’ll dig much deeper into Docker containers in general in </span><em class="chapterRef"><span class="koboSpan" id="kobo.334.1">Chapter 15</span></em><span class="koboSpan" id="kobo.335.1">, </span><em class="italic"><span class="koboSpan" id="kobo.336.1">Containerizing Applications with Docker</span></em><span class="koboSpan" id="kobo.337.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.338.1">In a container environment – whether it’s Docker or another container runtime – you’re dealing with a dramatically smaller environment. </span><span class="koboSpan" id="kobo.338.2">There are very few installed programs and utilities, a dramatically stripped-down </span><code class="inlineCode"><span class="koboSpan" id="kobo.339.1">init</span></code><span class="koboSpan" id="kobo.340.1"> in place of </span><code class="inlineCode"><span class="koboSpan" id="kobo.341.1">systemd</span></code><span class="koboSpan" id="kobo.342.1">, and a much smaller filesystem that doesn’t have many of the directories we’ve mentioned here.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.343.1">The principle of the configuration hierarchy still holds, though. </span><span class="koboSpan" id="kobo.343.2">Most containerized applications expect to get their configuration either from:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.344.1">A config file somewhere on the container filesystem, often dynamically created by a container scheduler just before the container is started</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.345.1">Environment variables, passed in by the container scheduler or the operator launching it</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.346.1">Command-line arguments</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.347.1">Even though this is a simplified version of the configuration hierarchy, you’ll notice that it’s basically identical to the one we explored in full, non-container Linux systems.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.348.1">We’ll dive a bit deeper into containers in </span><em class="chapterRef"><span class="koboSpan" id="kobo.349.1">Chapter 15</span></em><span class="koboSpan" id="kobo.350.1">, </span><em class="italic"><span class="koboSpan" id="kobo.351.1">Containerizing Applications with Docker</span></em><span class="koboSpan" id="kobo.352.1">.</span></p>
<h1 class="heading-1" id="_idParaDest-203"><span class="koboSpan" id="kobo.353.1">Conclusion</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.354.1">This chapter gave you an overview of the Linux configuration hierarchy and how it applies to the programs you’ll use (and write) every day. </span><span class="koboSpan" id="kobo.354.2">You learned about command-line arguments, environment variables, and all the other things that fit into the larger hierarchy that programs pull configuration from.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.355.1">If you followed along, you even created a systemd service that wraps a program and allows you to manage its configuration in a more uniform way.</span></p>
<h1 class="heading-1"><span class="koboSpan" id="kobo.356.1">Learn more on Discord</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.357.1">To join the Discord community for this book – where you can share feedback, ask questions to the author, and learn about new releases – follow the QR code below:</span></p>
<p class="normal"><a href="https://packt.link/SecNet"><span class="url"><span class="koboSpan" id="kobo.358.1">https://packt.link/SecNet</span></span></a></p>
<p class="normal"><span class="koboSpan" id="kobo.359.1"><img alt="" role="presentation" src="../Images/QR_Code1768422420210094187.png"/></span></p>
</div>
</body></html>