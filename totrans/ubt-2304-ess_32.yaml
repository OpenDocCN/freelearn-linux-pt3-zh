- en: 33\. Adding a New Disk Drive to an Ubuntu 23.04 System
  prefs: []
  type: TYPE_NORMAL
- en: One of the first problems users and system administrators encounter is that
    systems need more disk space to store data. Fortunately, disk space is now one
    of the cheapest IT commodities. In this and the next chapter, we will look at
    configuring Ubuntu to use the space provided when a new physical or virtual disk
    drive is installed.
  prefs: []
  type: TYPE_NORMAL
- en: 33.1 Mounted File Systems or Logical Volumes
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways to configure a new disk drive on an Ubuntu system. One straightforward
    method is to create one or more Linux partitions on the new drive, create Linux
    file systems on those partitions and then mount them at specific mount points
    to be accessed. This approach will be covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Another approach is adding new space to an existing volume group or creating
    a new one. When Ubuntu is installed, a volume group named is created. Within this
    volume group are three logical volumes named root, home, and swap, used to store
    the / and /home file systems and swap partitions, respectively. We can increase
    the disk space available to the existing logical volumes by configuring the new
    disk as part of a volume group. For example, using this approach, we can increase
    the size of the /home file system by allocating some or all of the space on the
    new disk to the home volume. This topic will be discussed in detail in [“Adding
    a New Disk to an Ubuntu 23.04 Volume Group and Logical Volume”](Volume_Groups.xhtml#_idTextAnchor506).
  prefs: []
  type: TYPE_NORMAL
- en: 33.2 Finding the New Hard Drive
  prefs: []
  type: TYPE_NORMAL
- en: This tutorial assumes that a new physical or virtual hard drive has been installed
    and is visible to the operating system. Once added, the operating system should
    automatically detect the new drive. Typically, the disk drives in a system are
    assigned device names beginning hd, sd, or nvme, followed by a letter to indicate
    the device number. The first device might be /dev/sda, the second /dev/sdb, etc.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the output from a typical system with only one disk drive
    connected to a SATA controller:'
  prefs: []
  type: TYPE_NORMAL
- en: ls /dev/sd*
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: /dev/sda /dev/sda1 /dev/sda2
  prefs: []
  type: TYPE_NORMAL
- en: This shows that the disk drive represented by /dev/sda is divided into two partitions,
    represented by /dev/sda1 and /dev/sda2\.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following output is from the same system after a second hard disk drive
    has been installed:'
  prefs: []
  type: TYPE_NORMAL
- en: ls /dev/sd*
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: /dev/sda /dev/sda1 /dev/sda2 /dev/sdb
  prefs: []
  type: TYPE_NORMAL
- en: The new hard drive has been assigned to the device file /dev/sdb. The drive
    has no partitions shown (because we have yet to create any).
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we can create partitions and file systems on the new drive and
    mount them for access or add the disk as a physical volume as part of a volume
    group. To perform the former continue with this chapter; otherwise, read [“Adding
    a New Disk to an Ubuntu 23.04 Volume Group and Logical Volume”](Volume_Groups.xhtml#_idTextAnchor506)
    for details on configuring Logical Volumes.
  prefs: []
  type: TYPE_NORMAL
- en: 33.3 Creating Linux Partitions
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to create one or more Linux partitions on the new disk drive.
    This is achieved using the fdisk utility, which takes as a command-line argument
    the device to be partitioned:'
  prefs: []
  type: TYPE_NORMAL
- en: fdisk /dev/sdb
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to fdisk (util-linux 2.37.4).
  prefs: []
  type: TYPE_NORMAL
- en: Changes will remain in memory only, until you decide to write them.
  prefs: []
  type: TYPE_NORMAL
- en: Be careful before using the write command.
  prefs: []
  type: TYPE_NORMAL
- en: Device does not contain a recognized partition table.
  prefs: []
  type: TYPE_NORMAL
- en: Created a new DOS disklabel with disk identifier 0x64d68d00.
  prefs: []
  type: TYPE_NORMAL
- en: 'Command (m for help):'
  prefs: []
  type: TYPE_NORMAL
- en: 'To view the current partitions on the disk, enter the p command:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Command (m for help): p'
  prefs: []
  type: TYPE_NORMAL
- en: 'Disk /dev/sdb: 14.46 GiB, 15525216256 bytes, 30322688 sectors'
  prefs: []
  type: TYPE_NORMAL
- en: 'Disk model: USB 2.0 FD'
  prefs: []
  type: TYPE_NORMAL
- en: 'Units: sectors of 1 * 512 = 512 bytes'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sector size (logical/physical): 512 bytes / 512 bytes'
  prefs: []
  type: TYPE_NORMAL
- en: 'I/O size (minimum/optimal): 512 bytes / 512 bytes'
  prefs: []
  type: TYPE_NORMAL
- en: 'Disklabel type: dos'
  prefs: []
  type: TYPE_NORMAL
- en: 'Disk identifier: 0x64d68d00'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see from the above fdisk output, the disk currently has no partitions
    because it was previously unused. The next step is to create a new partition on
    the disk, a task which is performed by entering n (for a new partition) and p
    (for a primary partition):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Command (m for help): n'
  prefs: []
  type: TYPE_NORMAL
- en: Partition type
  prefs: []
  type: TYPE_NORMAL
- en: p primary (0 primary, 0 extended, 4 free)
  prefs: []
  type: TYPE_NORMAL
- en: e extended (container for logical partitions)
  prefs: []
  type: TYPE_NORMAL
- en: 'Select (default p): p'
  prefs: []
  type: TYPE_NORMAL
- en: 'Partition number (1-4, default 1):'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we only plan to create one partition, which will be partition
    1\. Next, we need to specify where the partition will begin and end. Since this
    is the first partition, we need it to start at the first available sector, and
    since we want to use the entire disk, we specify the last sector as the end. Note
    that if you wish to create multiple partitions, you can specify the size of each
    partition by sectors, bytes, kilobytes, or megabytes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Partition number (1-4, default 1): 1'
  prefs: []
  type: TYPE_NORMAL
- en: 'First sector (2048-30322687, default 2048):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Last sector, +/-sectors or +/-size{K,M,G,T,P} (2048-30322687, default 30322687):'
  prefs: []
  type: TYPE_NORMAL
- en: Created a new partition 1 of type 'Linux' and of size 14.5 GiB.
  prefs: []
  type: TYPE_NORMAL
- en: 'Command (m for help):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have specified the partition, we need to write it to the disk using
    the w command:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Command (m for help): w'
  prefs: []
  type: TYPE_NORMAL
- en: The partition table has been altered.
  prefs: []
  type: TYPE_NORMAL
- en: Calling ioctl() to re-read partition table.
  prefs: []
  type: TYPE_NORMAL
- en: Syncing disks.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we now look at the devices again, we will see that the new partition is
    visible as /dev/sdb1:'
  prefs: []
  type: TYPE_NORMAL
- en: ls /dev/sd*
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: /dev/sda /dev/sda1 /dev/sda2 /dev/sdb /dev/sdb1
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to create a file system on our new partition.
  prefs: []
  type: TYPE_NORMAL
- en: 33.4 Creating a File System on an Ubuntu Disk Partition
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have a new disk installed, it is visible to Ubuntu, and we have configured
    a Linux partition on the disk. The next step is to create a Linux file system
    on the partition so that the operating system can use it to store files and data.
    The easiest way to create a file system on a partition is to use the mkfs.xfs
    utility:'
  prefs: []
  type: TYPE_NORMAL
- en: apt install xfsprogs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: umount /dev/sdb1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: mkfs.xfs -f /dev/sdb1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: meta-data=/dev/sdb1 isize=512 agcount=4, agsize=947520 blks
  prefs: []
  type: TYPE_NORMAL
- en: = sectsz=512 attr=2, projid32bit=1
  prefs: []
  type: TYPE_NORMAL
- en: = crc=1 finobt=1, sparse=1, rmapbt=0
  prefs: []
  type: TYPE_NORMAL
- en: = reflink=1 bigtime=1 inobtcount=1
  prefs: []
  type: TYPE_NORMAL
- en: data = bsize=4096 blocks=3790080, imaxpct=25
  prefs: []
  type: TYPE_NORMAL
- en: = sunit=0 swidth=0 blks
  prefs: []
  type: TYPE_NORMAL
- en: naming =version 2 bsize=4096 ascii-ci=0, ftype=1
  prefs: []
  type: TYPE_NORMAL
- en: log =internal log bsize=4096 blocks=2560, version=2
  prefs: []
  type: TYPE_NORMAL
- en: = sectsz=512 sunit=0 blks, lazy-count=1
  prefs: []
  type: TYPE_NORMAL
- en: realtime =none extsz=4096 blocks=0, rtextents=0
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we have created an XFS file system. XFS is a high-performance
    file system that is the default filesystem type on Ubuntu and includes several
    advantages in terms of parallel I/O performance and the use of journaling.
  prefs: []
  type: TYPE_NORMAL
- en: 33.5 An Overview of Journaled File Systems
  prefs: []
  type: TYPE_NORMAL
- en: A journaling filesystem keeps a journal or log of the changes being made to
    the filesystem during disk writing that can be used to rapidly reconstruct corruptions
    that may occur due to events such as a system crash or power outage.
  prefs: []
  type: TYPE_NORMAL
- en: There are several advantages to using a journaling file system. First, the size
    and volume of data stored on disk drives have grown exponentially over the years.
    The problem with a non-journaled file system is that following a crash, the fsck
    (filesystem consistency check) utility has to be run. The fsck utility will scan
    the entire filesystem validating all entries and ensuring that blocks are allocated
    and referenced correctly. It will attempt to fix the problem if it finds a corrupt
    entry. The issues here are two-fold. First, the fsck utility will not always be
    able to repair the damage, and you will end up with data in the lost+found directory.
    An application uses this data, but the system no longer knows where it was referenced
    from. The other problem is the issue of time. Completing the fsck process on an
    extensive file system can take a long time, potentially leading to unacceptable
    downtime.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, a journaled file system records information in a log area
    on a disk (the journal and log do not need to be on the same device) during each
    write. This is essentially an “intent to commit” data to the filesystem. The amount
    of information logged is configurable and ranges from not logging anything to
    logging what is known as the “metadata” (i.e., ownership, date stamp information,
    etc.) to logging the “metadata” and the data blocks that are to be written to
    the file. Once the log is updated, the system writes the actual data to the appropriate
    filesystem areas and marks an entry to say the data is committed.
  prefs: []
  type: TYPE_NORMAL
- en: After a crash, the filesystem can quickly be brought back online using the journal
    log, thereby reducing what could take minutes using fsck to seconds with the added
    advantage that there is considerably less chance of data loss or corruption.
  prefs: []
  type: TYPE_NORMAL
- en: 33.6 Mounting a File System
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have created a new file system on the Linux partition of our new
    disk drive, we need to mount it to be accessible and usable. To do this, we need
    to create a mount point. A mount point is simply a directory or folder into which
    the file system will be mounted. For this example, we will create a /backup directory
    to match our file system label (although these values don’t need to match):'
  prefs: []
  type: TYPE_NORMAL
- en: mkdir /backup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The file system may then be manually mounted using the mount command:'
  prefs: []
  type: TYPE_NORMAL
- en: mount /dev/sdb1 /backup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Running the mount command with no arguments shows us all currently mounted
    file systems (including our new file system):'
  prefs: []
  type: TYPE_NORMAL
- en: mount
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)
  prefs: []
  type: TYPE_NORMAL
- en: sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime,seclabel)
  prefs: []
  type: TYPE_NORMAL
- en: .
  prefs: []
  type: TYPE_NORMAL
- en: .
  prefs: []
  type: TYPE_NORMAL
- en: /dev/sdb1 on /backup type xfs (rw,relatime,seclabel,attr2,inode64,logbufs=8,logbsize=32k,noquota)
  prefs: []
  type: TYPE_NORMAL
- en: 33.7 Configuring Ubuntu to Mount a File System Automatically
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up the system so that the new file system is automatically mounted at
    boot time, an entry needs to be added to the /etc/fstab file. The format for an
    fstab entry is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <device> <dir> <type> <options> <dump> <fsck>
  prefs: []
  type: TYPE_NORMAL
- en: 'These entries can be summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: •<device> - The device on which the filesystem will be mounted.
  prefs: []
  type: TYPE_NORMAL
- en: •<dir> - The directory that is to act as the mount point for the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: •<type> - The filesystem type (xfs, ext4 etc.)
  prefs: []
  type: TYPE_NORMAL
- en: •<options> - Additional filesystem mount options, for example, making the filesystem
    read-only or controlling whether any user can mount the filesystem. Run man mount
    to review a complete list of options. Setting this value to defaults will use
    the default settings for the filesystem (rw, suid, dev, exec, auto, nouser, async).
  prefs: []
  type: TYPE_NORMAL
- en: •<dump> - Dictates whether the content of the filesystem is to be included in
    any backups performed by the dump utility. This setting is rarely used and can
    be disabled with a 0 value.
  prefs: []
  type: TYPE_NORMAL
- en: •<fsck> - Whether the filesystem is checked by fsck after a system crash and
    the order in which filesystems are to be checked. For journaled filesystems such
    as XFS this should be set to 0 to indicate that the check is not required.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows a fstab entry to automount our /backup partition
    on the /dev/sdb1 partition:'
  prefs: []
  type: TYPE_NORMAL
- en: /dev/sdb1 /backup xfs defaults 0 0
  prefs: []
  type: TYPE_NORMAL
- en: The /backup filesystem will now automount each time the system restarts.
  prefs: []
  type: TYPE_NORMAL
- en: 33.8 Adding a Disk Using Cockpit
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to working with storage using the command-line utilities outlined
    in this chapter, it is also possible to configure a new storage device using the
    Cockpit web console. To view the current storage configuration, log into the Cockpit
    console and select the Storage option as shown in [Figure 33-1](Adding_New_DIsk.xhtml#_idTextAnchor503):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/centos_cockpit_storage1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 33-1
  prefs: []
  type: TYPE_NORMAL
- en: 'To locate the newly added storage, scroll to the bottom of the Storage page
    until the Drives section comes into view (note that the Drives section may also
    be located in the top right-hand corner of the screen):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cockpit_drives.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 33-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of the above figure, the new drive is the 15.5 GB drive. Select
    the new drive to display the Drive screen as shown in [Figure 33-3](Adding_New_DIsk.xhtml#_idTextAnchor504):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cockpit_drive_details.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 33-3
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the Create partition button and use the dialog to specify how much
    space will be allocated to this partition, the filesystem type (XFS is recommended),
    and an optional label, filesystem mount point, and mount options. Note that additional
    partitions may be added to the drive if this new partition does not use all the
    available space. To change settings such as whether the filesystem is read-only
    or mounted at boot time, change the settings in the Mount options section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cockpit_drive_create_partition.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 33-4
  prefs: []
  type: TYPE_NORMAL
- en: Once the settings have been selected, click the Create partition button to commit
    the change. Upon completion of the creation process, the new partition will be
    added to the disk, the corresponding filesystem will be created and mounted at
    the designated mount point, and appropriate changes will be made to the /etc/fstab
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 33.9 Summary
  prefs: []
  type: TYPE_NORMAL
- en: This chapter has covered adding a physical or virtual disk drive to an existing
    Ubuntu system. This is a relatively simple process of ensuring the new drive has
    been detected by the operating system, creating one or more partitions on the
    drive, and then making filesystems on those partitions. Although several filesystem
    types are available on Ubuntu, XFS is generally recommended. Once the filesystems
    are ready, they can be mounted using the mount command. So that the newly created
    filesystems mount automatically on system startup, additions can be made to the
    /etc/fstab configuration file.
  prefs: []
  type: TYPE_NORMAL
