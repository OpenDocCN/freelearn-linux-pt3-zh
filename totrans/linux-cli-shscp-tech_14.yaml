- en: '*Chapter 14*: Interacting with Shell Scripts'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第14章*：与 Shell 脚本交互'
- en: We are almost done with explaining the basic concepts of scripting, but before
    we can say we are completely done with them, we need to learn how to interact
    with shell scripts. This isn't always necessary in shell scripting, but it may
    apply to most situations. For example, it's one thing to create a script that
    does one job and one job only. It's completely different to create a script that
    requires us to make some choices as it gets executed. If nothing else, this second
    type is a prime candidate for shell script interaction. In this chapter, we are
    going to cover three different ways to deal with shell script interaction.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了对脚本基本概念的解释，但在我们完全完成之前，我们需要学习如何与 Shell 脚本进行交互。这在 Shell 脚本中并非总是必要的，但在大多数情况下是适用的。例如，创建一个只做一项工作且仅做一项工作的脚本是一回事。而创建一个在执行过程中需要我们做出一些选择的脚本则完全不同。如果没有其他原因，这第二种类型的脚本就是
    Shell 脚本交互的一个典型候选。在本章中，我们将介绍三种不同的方式来处理 Shell 脚本的交互。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: Creating text-based interactive scripts
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建基于文本的交互式脚本
- en: Using expect to automate repetitive tasks based on text output
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 expect 自动化基于文本输出的重复任务
- en: Using dialog for menu-driven interactive scripts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 dialog 创建基于菜单的交互式脚本
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: As with all the chapters thus far, we are going to use the same virtual machine
    running the Bash shell. So, we need a virtual machine with Linux installed – any
    distribution is fine (in our case, it's going to be *Ubuntu 20.10*).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 就像到目前为止的所有章节一样，我们将使用运行 Bash Shell 的相同虚拟机。所以，我们需要一台安装了 Linux 的虚拟机——任何发行版都可以（在我们的案例中，它将是*Ubuntu
    20.10*）。
- en: Now, start your virtual machine!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，启动你的虚拟机！
- en: Creating text-based interactive scripts
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建基于文本的交互式脚本
- en: The one thing that we haven't done so far is put any interaction in our scripts.
    The reason for this is simple – at this point, we've only discussed how to output
    information and not how to get it from the user or any other source. In the real
    world, interaction is something that we need to deal with because it is at the
    core of creating any script. We could say that there are two kinds of interaction.
    First, our script can interact with the system itself. This means using different
    variables and other information that we can get from the system – for example,
    free space in memory or on mounted disks. You could say that this is not real
    interaction but instead just reading real-time data from the system. But, still,
    it's a very useful way of making sure that a script does what it needs to do.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们做的唯一一件事就是没有在脚本中加入任何交互。原因很简单——到此为止，我们只讨论了如何输出信息，而没有讨论如何从用户或其他来源获取信息。在现实世界中，交互是我们必须处理的事情，因为它是创建任何脚本的核心。我们可以说，交互有两种类型。首先，我们的脚本可以与系统本身进行交互。这意味着使用不同的变量和其他信息，我们可以从系统中获取这些信息——例如，内存或挂载磁盘上的空闲空间。你可以说这不是实际的交互，而只是从系统中读取实时数据。但即便如此，这也是确保脚本按需执行的非常有用的方法。
- en: Another thing that we can do is interact with the user starting it. If the script
    is run by the system, it isn't something that is going to interact with the user
    in any way, but user interaction is extremely important when we are creating scripts
    for day-to-day jobs. Consider this question – why would we create a script that
    backs up *a folder* (one folder only) when we can create a script that can be
    told to back up *one or more directories*? Isn't that way of designing a script
    much more usable?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个我们可以做的事情是与用户进行交互。如果脚本由系统运行，它不会以任何方式与用户交互，但当我们为日常工作创建脚本时，用户交互是非常重要的。考虑这个问题——为什么我们要创建一个只备份*一个文件夹*（仅一个文件夹）的脚本，而我们可以创建一个可以指定备份*一个或多个目录*的脚本呢？这种设计脚本的方式不是更具可用性吗？
- en: Getting ready
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: When we start creating our scripts, we must decide on the kind of interaction
    that we need in them. Depending on the type of script that's required, we may
    use interactive prompts, menus, some sort of pre-configuration, or even some graphical
    interface. For now, we are going to stay away from using GUIs for our scripts.
    However, we can use them if we need to with the help of some appropriate tools.
    Remember, scripts are barely more than some execution control that dictates how
    different commands and applications interact, so those commands are what matters
    most in the first place.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始创建我们的脚本时，我们必须决定它们需要的交互方式。根据所需的脚本类型，我们可以使用交互式提示、菜单、某种预配置或甚至一些图形界面。目前，我们将避免在我们的脚本中使用
    GUI。然而，如果需要的话，我们可以使用适当的工具帮助我们使用它们。记住，脚本基本上只是一些执行控制，决定不同命令和应用程序如何交互，因此首先要关注的是这些命令。
- en: For starters, our first recipe will be a simple interactive script asking the
    user for input and then acting on it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们的第一个配方将是一个简单的交互式脚本，要求用户输入并根据输入进行操作。
- en: How to do it…
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到…
- en: The main commands that we are going to use in this recipe are going to be `read`
    and `echo`. Before we do anything else, we need to learn a few tricks regarding
    these commands. In theory, `read` is simple to understand – it waits for user
    input and then stores that input in some variable. But to show you the different
    things that are made possible by this simple command, we need to show you a few
    examples.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将要使用的主要命令是 `read` 和 `echo`。在我们做任何其他事情之前，我们需要学习关于这些命令的一些技巧。理论上，`read`
    是很容易理解的——它等待用户输入，然后将该输入存储在某个变量中。但是为了向您展示这个简单命令所能实现的不同功能，我们需要展示一些例子。
- en: '`read`, in its basic form, accepts one argument – the variable – and then takes
    whatever the user types in and puts it into this variable so that we can use it
    later. Let''s consider the following example:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`read` 在其基本形式中接受一个参数——变量——然后接受用户输入并将其放入该变量中，以便我们稍后使用。让我们考虑以下例子：'
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If we quickly test this script, this is what we will get as a result:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们快速测试这个脚本，这将是我们得到的结果：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Sometimes, this is not enough. Sometimes, we need to get more than one value
    into our script. The problem here is the way users type in the values. Shell uses
    space characters as separators, so a space is going to be what separates the value
    in the `read` command. If we need to get a value that contains spaces, we will
    have to deal with it differently. As we saw in the previous example, this will
    only become a problem if we use more than one return variable.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有时这还不够。有时，我们需要在我们的脚本中获取多个值。这里的问题是用户输入值的方式。Shell 使用空格字符作为分隔符，因此空格将分隔 `read` 命令中的值。如果我们需要获取包含空格的值，我们将不得不以不同方式处理它。正如我们在前面的例子中看到的那样，只有在使用多个返回变量时，这才会成为问题。
- en: 'If, however, we use values that do not contain spaces, we can simply use the
    following code and save it in the `doublevar.sh` file:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们使用不包含空格的值，我们可以简单地使用以下代码并将其保存在 `doublevar.sh` 文件中：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, let''s try it and see if it works the way we are expecting it to:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们试一试，看看它是否按我们期望的方式工作：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We must stop here and do another test to clear a few things up. Bash performs
    no checks on what the type of the variable is. In our script, we presumed that
    the user is going to input numbers, but nothing stops them from using any string.
    Another thing would be how multiple values separated by spaces are going to be
    handled – the first value is going to be assigned to the first variable; everything
    after that is going to be assigned to the second one. If we use more than two
    variables to store values, the result is always going to be that each variable
    in the sequence will get one variable assigned and the last one will get whatever
    was left in the input line:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在这里停下来，做另一个测试来澄清一些事情。Bash 对变量的类型不进行任何检查。在我们的脚本中，我们假设用户将输入数字，但没有任何限制他们使用任何字符串。另一件事是如何处理由空格分隔的多个值——第一个值将被分配给第一个变量；其余的值将分配给第二个变量。如果我们使用超过两个变量来存储值，结果将始终是序列中的每个变量都会被分配一个变量，最后一个变量将得到输入行中剩余的内容：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Another way we can use `read` is to get the values into a predefined variable
    called `$REPLY`. If we simply omit the variable name, everything you type in is
    going to be in that variable, which can then be used in your script:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `read` 的另一种方式是将值获取到一个名为 `$REPLY` 的预定义变量中。如果我们简单地省略变量名，那么您输入的所有内容都将在该变量中，然后可以在您的脚本中使用：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'A simple test proves that this behaves exactly as if we gave the command a
    proper variable name:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的测试证明，这个行为和我们给命令一个正确的变量名时完全相同：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Another way of using `read` is by using the `-a` switch. By using this, we
    are saying that we want to store all the values it got as an array. After this
    switch, we need to state the name of the variable we are going to use to store
    the values, or we can simply use the default `$REPLY` variable. What we should
    not do is use more than one variable name. This is because we are storing multiple
    values in one variable, so it makes no sense to try and reference more than one
    variable in the first place:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`read`的另一种方式是通过使用`-a`选项。使用这个选项时，我们表示希望将所有获取的值存储为一个数组。在此选项后，我们需要指定用来存储这些值的变量名，或者我们可以简单地使用默认的`$REPLY`变量。我们不应该做的是使用多个变量名。这是因为我们将多个值存储在一个变量中，所以尝试引用多个变量本身就没有意义：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we are reading multiple values into a single variable. Since we didn't
    ask Bash to create an array, it is going to store everything into this variable,
    but there will be no way of referencing the elements inside this variable. Bash
    treats all the values in the variable as a single, first element, so if we try
    to print it out, we will get everything.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将多个值读取到一个变量中。由于我们没有要求Bash创建一个数组，它将把所有内容存储到这个变量中，但没有办法引用该变量内的元素。Bash将变量中的所有值视为一个单独的、首个元素，因此如果我们尝试打印它，我们将看到所有内容。
- en: 'The second time we do this, we are getting the values from the user. Here,
    we are using an array. Everything looks the same but if we reference the first
    element of the variable, we will only print the first element:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次执行这个操作时，我们正在获取用户输入的值。这里，我们使用了一个数组。一切看起来一样，但如果我们引用变量的第一个元素，我们只会打印出第一个元素：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, we need to experiment a bit with the `echo` command. In the entire scripting
    part of this book, we have been using this command in its most basic form to,
    well, output text to screen or, to be more precise, to standard output. This will
    work for the majority of cases, but there are some scripts where we need more
    control over the output. The problem with the way `echo` works is that it always
    terminates the string it outputs with a newline character, forcing the output
    into a new line once it''s printed whatever was given to it as a parameter. While
    this is alright for printing out information, when we try to interact with the
    user in our scripts, it will look strange if we always force the user to enter
    the values we are looking for in a new line. So, `echo` offers one additional
    option that changes the default behavior (`-n`). Let''s consider this example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要稍微实验一下`echo`命令。在本书的整个脚本部分中，我们一直在以最基本的形式使用这个命令来输出文本到屏幕，或者更准确地说，是输出到标准输出。这对于大多数情况都能正常工作，但有些脚本中我们需要更精确地控制输出。`echo`工作方式的问题在于它总是用换行符结束它输出的字符串，一旦它打印了作为参数传递的内容，输出就会强制换到新的一行。虽然对于打印信息来说，这没有问题，但当我们尝试在脚本中与用户交互时，如果总是强迫用户将我们需要的值输入到新的一行，看起来就很奇怪。所以，`echo`提供了一个额外的选项，改变了默认行为（`-n`）。让我们考虑这个例子：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'What we told `echo` to do here is that it should print the text inside quotation
    marks, but after that, it should stay in the same line. Since our `read` command
    naturally continues wherever the cursor was placed by the previous command, the
    result will be that the value we type in will appear most logically on screen:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里告诉`echo`做的是打印引号内的文本，但打印完后，它应该停留在同一行。由于我们的`read`命令会从前一个命令放置光标的位置继续执行，因此结果是我们输入的值最自然地会出现在屏幕上：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'There is another way to do this that looks more complicated but behaves the
    same:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种做法看起来更复杂，但表现与上面相同：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The reason we are showing you this is because this example uses special characters
    to denote the end of the line, but at the same time, there are more characters
    we can use for even finer control over the output. By default, the most commonly
    used are as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向你展示这个的原因是，这个例子使用了特殊字符来表示行的结束，但与此同时，还有更多的字符可以用来更精细地控制输出。默认情况下，最常用的是以下几种：
- en: '`\\ backslash`: When we need to output the actual `\` character.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\\ 反斜杠`：当我们需要输出实际的`\`字符时使用。'
- en: '`\a alert (BEL)`: When we want to warn the user by using a loud sound.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\a 警报（BEL）`：当我们想通过大声的声音警告用户时使用。'
- en: '`\b backspace`: We use this when we need to provide a backspace character,
    deleting whatever is on the same line under the cursor.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\b 退格`：当我们需要提供一个退格字符，删除光标所在行的内容时使用。'
- en: '`\c produce no further output`: This is used to tell `echo` to simply stop
    the output.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\c produce no further output`：这个用于告诉`echo`停止输出。'
- en: '`\t horizontal tab`: This is used to provide `tab` and align the output.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\t horizontal tab`：这个用于提供`tab`并对齐输出。'
- en: Now that we know about some of the basic `read` and `echo` syntaxes, let's try
    to put that to good use in a script.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了一些基本的`read`和`echo`语法，让我们在脚本中好好利用它们吧。
- en: How it works…
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Now that we know how to deal with everything in the Bash script that can be
    used for interaction, we can create a script that will show it all. Here, we are
    creating a simple menu:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何处理Bash脚本中用于交互的所有内容，我们可以创建一个展示所有内容的脚本。在这里，我们正在创建一个简单的菜单：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Try it out!
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 试试看！
- en: 'There is another way to create an interactive menu that we can use in our script
    – using the `select` command. This command is often used to create simple menus,
    like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种在脚本中创建交互式菜单的方式是使用`select`命令。这个命令通常用于创建简单的菜单，像这样：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`select` looks a lot like some sort of loop; it requires us to set a few variables
    in advance. `$PS3` contains the question that the user will see, while `$options`
    contains an array of strings that represent options. When a user runs this script,
    it will be presented with a list of numbered options, and they can input any of
    them as a number. `select` is going to then substitute the string from our options
    list based on the number that the user selected and run the appropriate command:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`select`看起来像某种循环；它要求我们提前设置一些变量。`$PS3`包含用户将看到的问题，而`$options`包含一个字符串数组，表示可选项。当用户运行这个脚本时，将展示一个编号选项列表，用户可以输入任何一个数字。`select`将根据用户选择的数字从我们的选项列表中替换相应的字符串，并执行相应的命令：'
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is a great way to quickly create a script with multiple choices.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这是快速创建一个多选项脚本的好方法。
- en: See also
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: 'A lot more can be found about the `echo` and `read` commands at the following
    links:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`echo`和`read`命令的更多信息可以在以下链接中找到：
- en: '[https://linuxhint.com/bash_read_command/](https://linuxhint.com/bash_read_command/)'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://linuxhint.com/bash_read_command/](https://linuxhint.com/bash_read_command/)'
- en: '[https://www.javatpoint.com/bash-read-user-input](https://www.javatpoint.com/bash-read-user-input)'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.javatpoint.com/bash-read-user-input](https://www.javatpoint.com/bash-read-user-input)'
- en: Using expect to automate repetitive tasks based on text output
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`expect`自动化基于文本输出的重复任务
- en: Bash is a formidable tool but sometimes, we need to do a particular thing that
    needs additional tools. In this recipe, we are going to be working with just such
    a tool called `expect`. Before we start, we must note that `expect` is not part
    of Bash scripting – it is a whole separate scripting language, written for a particular
    purpose, to enable interaction between your scripts and users and other systems.
    The idea behind it is to enable your scripts to not only execute `normal` commands
    that provide information when executed (command output) but to also be able to
    interact with any application that has a **command-line interface** (**CLI**)
    and get information from it.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Bash是一个强大的工具，但有时我们需要做一些特殊的事情，这时需要额外的工具。在这个示例中，我们将使用一个名为`expect`的工具。在开始之前，我们必须注意，`expect`并不是Bash脚本的一部分——它是一个完全独立的脚本语言，专门用于实现脚本与用户和其他系统之间的交互。它的核心思想是让脚本不仅能够执行提供信息的`普通`命令（命令输出），还能够与任何具有**命令行界面**（**CLI**）的应用程序进行交互，并从中获取信息。
- en: Getting ready
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In a simplified way, `expect` acts as a virtual keyboard that can type in some
    text and read what is on the screen. This is a powerful thing that is often needed
    because several applications and scripts are created by people who either had
    no reason to enable scripting support or just didn't want to do it. This means
    that without a tool such as `expect`, we will not be able to interact with those
    applications. This sometimes means that we will not be able to do what we want
    from inside our scripts.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，`expect`充当了一个虚拟键盘，可以输入文本并读取屏幕上的内容。这是一个强大的功能，因为许多应用程序和脚本是由那些没有启用脚本支持的开发者创建的，或者他们只是选择不这样做。这意味着没有像`expect`这样的工具，我们将无法与这些应用程序进行交互。这有时意味着我们将无法在脚本中执行我们想做的事情。
- en: In this recipe, we will learn how to use `expect` to interact with another shell
    on another computer, how to type in a password and log in, and how to type commands
    and get a response from the other side.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何使用`expect`与另一台计算机上的另一个Shell进行交互，如何输入密码并登录，如何输入命令并从对方获得响应。
- en: But before we even do that, we need to install `expect` if it isn't installed
    on the system since it is not a standard part of the system.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们做这些之前，如果系统中未安装`expect`，我们需要先安装它，因为它不是系统的标准组件。
- en: 'Use the following command and wait for it to finish:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令并等待它完成：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We need to use `sudo` here. Only an administrator can install packages, so expect
    to have to input your user password.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在这里使用`sudo`。只有管理员才能安装软件包，因此需要输入你的用户密码。
- en: How to do it…
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: Since `expect` is not Bash, we must tell our script to use it. The syntax is
    the same as when we're creating a script using Bash – we need to make running
    `expect` the first line of our script. Note that this immediately means that our
    script no longer uses any of the commands from Bash, but we get many new things
    we can do.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`expect`不是Bash，我们必须告诉脚本使用它。语法与创建Bash脚本时相同——我们需要将`expect`的运行放在脚本的第一行。请注意，这意味着我们的脚本将不再使用Bash的任何命令，但我们可以执行许多新操作。
- en: 'We are going to start with the simple `hello world` script:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从简单的`hello world`脚本开始：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: What the script does is exactly what the commands sound like they do; when we
    start it, the script is going to look for a `hello` string and after it receives
    it, it is going to reply with the `world` string.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本执行的操作与命令的字面意思完全一致；当我们启动它时，脚本将寻找`hello`字符串，并在收到后，回复`world`字符串。
- en: Strings are case-sensitive, so nothing else than the exact match will work.
    Also, `expect` has a built-in period during which it expects to get the string.
    If nothing is matched during that period, the script is going to continue from
    the next command. In our example, even if we give it no input, we are going to
    get the `world` string printed.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是区分大小写的，因此只有完全匹配的内容才会有效。另外，`expect`有一个内置的时间段，在此期间它会等待接收字符串。如果在此时间段内没有匹配的内容，脚本将继续执行下一个命令。在我们的示例中，即使我们不给它任何输入，`world`字符串也会被打印出来。
- en: 'When we start our script, we must use the `expect` command; we cannot start
    this script using Bash since it is written specifically for `expect`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启动脚本时，必须使用`expect`命令；我们不能使用Bash启动此脚本，因为它是专门为`expect`编写的：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We tried three different ways of spelling the string here, and only the exact
    match worked.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尝试了三种不同的拼写方式，只有完全匹配的才有效。
- en: 'Let''s do something more interesting and explain what we did along the way:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做些更有趣的事情，并解释我们在过程中做了什么：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This script is intended to enable you to quickly connect to another host using
    the `ssh` protocol. When we run it, we need to provide three things: the name
    or IP address of the host, the username to use, and the cleartext password for
    the user that will log in. We are aware that using a password in this way is not
    normal at all, but we are providing an example here.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本的目的是帮助你快速使用`ssh`协议连接到另一台主机。当我们运行它时，我们需要提供三件事：主机的名称或IP地址、要使用的用户名以及将要登录的用户的明文密码。我们知道以这种方式使用密码并不常见，但这里我们提供一个示例。
- en: At the start of the script, we are setting the timeout for the prompts. As we
    mentioned earlier, if the `expect` command doesn't detect any input, it will continue
    the script after the time specified in this `timeout` value. The next three lines
    deal with the arguments we passed to the script. We are assigning each of them
    to a variable so that we can use them later.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本开始时，我们设置了提示的超时时间。如前所述，如果`expect`命令没有检测到任何输入，它将在此`timeout`值指定的时间后继续执行脚本。接下来的三行代码处理我们传递给脚本的参数。我们将每个参数赋值给一个变量，以便稍后使用。
- en: After that, we are using the `spawn` command to call the `ssh` command in a
    separate process. We are using the standard `ssh` client and giving it usernames
    and hostnames so that we can start the login process.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们使用`spawn`命令在一个独立的进程中调用`ssh`命令。我们使用标准的`ssh`客户端，并为其提供用户名和主机名，以便我们能够启动登录过程。
- en: After this, our script waits until it detects that we need to type in the password.
    When it detects the `password:` part of the prompt, it sends our password in cleartext.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们的脚本会等待，直到检测到需要输入密码。当它检测到提示中的`password:`部分时，它会以明文形式发送我们的密码。
- en: 'The last command in the script is `interact` and it hands over control to us
    so that we can use our freshly logged-in session to do what we intend to do. This
    is what it looks like when it''s run:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本中的最后一条命令是`interact`，它将控制权交给我们，这样我们就可以使用刚刚登录的会话来执行我们打算做的事情。这就是执行时的样子：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is a good start if we need to work on a remote system. But how do we run
    other commands on the other system and what can we do with that?
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要在远程系统上工作，这是一个不错的起点。但我们如何在另一台系统上运行其他命令，又能做些什么呢？
- en: 'There are two ways to continue here; one is to simply wait for the prompt to
    show and then send commands, while another one is to script this *blindly* and
    just wait for a predetermined period and then send the commands that we need.
    So, let''s make an example script for both concepts. Our goal is to have a scenario
    in which one part of the script does its job as an *answer* to command output
    (in our script, this is the `ssh` part and its output). The second part is related
    to the concept of waiting for a predetermined period (`sleep 5` means waiting
    for 5 seconds) and then doing something. Let''s check out our example:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两种方式可以继续；一种是简单地等待提示符显示，然后发送命令，另一种是“盲目地”编写脚本，等待预定的时间，然后发送我们需要的命令。因此，让我们为这两种概念编写一个示例脚本。我们的目标是有一个场景，其中脚本的一部分作为命令输出的*回答*（在我们的脚本中，这是`ssh`部分及其输出）。第二部分与等待预定时间的概念有关（`sleep
    5`意味着等待5秒钟），然后做一些事情。让我们来看看我们的示例：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We added two things that we haven't mentioned previously. The first one is that
    we are using the `puts` command to print information to the screen. It behaves
    similar to `echo` does in Bash.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了两个之前未提到的内容。第一个是我们使用`puts`命令向屏幕打印信息。它的行为类似于Bash中的`echo`命令。
- en: The `$expect_out (buffer)` variable holds data that the script got from running
    commands between two matches. So, in our script, this is going to hold information
    that was provided by the `ip add` command. If you are wondering where the login
    information disappeared, it is not visible since we issued the `clear` command
    to clear the screen, which, in turn, cleared the buffer.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`$expect_out (buffer)`变量保存脚本在运行命令（在两个匹配之间）时获取的数据。因此，在我们的脚本中，这将保存`ip add`命令提供的信息。如果你想知道登录信息去了哪里，它不可见，因为我们发出了`clear`命令清除了屏幕，而这也清除了缓冲区。'
- en: How it works…
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: '`expect` is an amazing tool that has even more things up its sleeve. One of
    its main purposes is to automate administration tasks using scripts. One of the
    most common usages was what we did in the previous example – running commands
    remotely. The reason we may use it often is not only to automate logins but also
    to automate testing. After running a particular command, we can do whatever we
    want and then get the results into our scripts.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`expect`是一个令人惊叹的工具，甚至还有更多的功能。它的主要用途之一是通过脚本自动化管理任务。它最常见的用途之一就是我们在前一个示例中所做的——远程执行命令。我们可能经常使用它的原因不仅仅是为了自动化登录，还为了自动化测试。运行特定命令后，我们可以做任何我们想做的事情，然后将结果获取到我们的脚本中。'
- en: In this way, `expect` is usually used as part of another script. When we need
    some sort of data that only `expect` can provide, we call it and then continue
    processing the data in our main script. However, automating scripts can mean one
    more thing – getting them to accept information, which enables us to write tests
    to check if our script works. For this reason, `expect` has a tool that is used
    to create an `expect` script out of running any script that contains interaction
    with the user.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`expect`作为另一个脚本的一部分使用。当我们需要某些仅`expect`能够提供的数据时，我们调用它，然后继续在主脚本中处理这些数据。然而，自动化脚本还意味着另一件事——让它们接受信息，这使我们能够编写测试来检查脚本是否有效。因此，`expect`有一个工具，用来从任何包含与用户交互的脚本中创建一个`expect`脚本。
- en: 'The following is a quick example to demonstrate what we mean, but first, we
    are going to create a very simple script where we will use different ways of calling
    `echo` and `read` in Bash:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个快速示例，用于演示我们所说的内容，但首先，我们将创建一个非常简单的脚本，在其中使用不同方式调用`echo`和`read`命令：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, we are going to start the `autoexpect` tool to grab both the input and
    output for the script:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将启动`autoexpect`工具，以获取脚本的输入和输出：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here, `autoexpect` was tracking what our script used as prompts, as well as
    what we gave as answers. When we finished executing our script, it created an
    `expect` script, which enables us to completely automate running our Bash script.
    We are going to omit part of this script since it contains a lot of comments that
    give us both the information about the tool and the disclaimer. Here''s what the
    `autoexpect` output looks like; it is saved in a file named `script.exp`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`autoexpect`跟踪了我们的脚本使用的提示以及我们给出的答案。当我们执行完脚本后，它创建了一个`expect`脚本，允许我们完全自动化运行Bash脚本。我们将省略部分脚本，因为它包含了大量的注释，既提供了关于工具的信息，也给出了免责声明。以下是`autoexpect`的输出，它被保存在一个名为`script.exp`的文件中：
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This script is a good starting point for automating our work, but be careful
    of one fatal flaw. In the last part that checks the inputs and outputs, it logged
    every typo and error that we made during input, but it hasn't saved the entire
    process of deleting them, so this input will not work. Before we can use it, we
    must edit this script and sort all the errors and inputs out. After that, we can
    expand on it and use additional arguments to test how our script is going to behave.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本是自动化工作任务的一个良好起点，但有一个致命的缺陷要小心。在最后一部分检查输入和输出时，它记录了我们在输入过程中所犯的每一个错字和错误，但它没有保存删除它们的整个过程，因此这个输入无法正常工作。我们在使用它之前，必须编辑这个脚本，处理所有错误和输入问题。之后，我们可以在此基础上扩展，并使用附加参数测试脚本的行为。
- en: See also
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: '`expect` is amazing for testing. For more examples, please go to the following
    links:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`expect`非常适合进行测试。如需更多示例，请访问以下链接：'
- en: 'Expect command: [https://likegeeks.com/expect-command/](https://likegeeks.com/expect-command/)'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Expect 命令：[https://likegeeks.com/expect-command/](https://likegeeks.com/expect-command/)
- en: 'Expect man page: [https://linux.die.net/man/1/expect](https://linux.die.net/man/1/expect)'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Expect 手册页：[https://linux.die.net/man/1/expect](https://linux.die.net/man/1/expect)
- en: Using dialog for menu-driven interactive scripts
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`dialog`进行基于菜单的交互式脚本
- en: Now that we've used `expect`, we know how to interact with other applications.
    The only thing left to do is learn how to make our scripts more interactive. It
    will come as no surprise that this problem is already solved in a standard way.
    In this recipe, we will use `dialog`, a command that may look deceptively simple
    but enables you to create both complex and visually interesting interactions with
    end users.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经使用了`expect`，我们知道如何与其他应用程序交互。剩下要做的就是学习如何让我们的脚本更加互动。毫不奇怪，这个问题已经有了标准的解决方法。在这个配方中，我们将使用`dialog`，一个看起来简单但可以让你与最终用户创建复杂且视觉有趣交互的命令。
- en: Getting ready
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: By definition, `dialog`, as with any interaction, makes your scripts unusable
    in a non-interactive environment. This can be solved by either not using `dialog`
    at all or detecting if the script is running as a service or as an interactive
    script.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，`dialog`和任何交互工具一样，会使你的脚本在非交互环境中无法使用。可以通过不使用`dialog`或者检测脚本是作为服务运行还是作为交互式脚本运行来解决这个问题。
- en: 'Like `expect`, we must install `dialog` to use it. Simply use the following
    command:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 和`expect`一样，我们必须安装`dialog`才能使用它。只需使用以下命令：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Everything that you need is going to be installed as required.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 所有所需的内容将根据要求安装。
- en: How to do it…
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: '`dialog` is a whole application that contains not only menus but a lot of other
    widgets that are displayed in a GUI under text mode. It will use colors if they
    are available on your terminal (they probably are – terminals that are unable
    to show colors are long gone in our day and age) and will use cursor keys for
    navigation. We are going to show you a few of the most common ones, as well as
    how to use them.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`dialog`是一个完整的应用程序，不仅包含菜单，还有很多其他小部件，这些小部件会在文本模式下的GUI中显示。如果你的终端支持颜色，它将使用颜色（现代终端几乎都支持显示颜色），并且会使用光标键进行导航。我们将向你展示一些最常见的命令，并介绍如何使用它们。'
- en: 'For a start, try running this command:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，尝试运行此命令：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If everything has gone well, you should see something like this (the size will
    depend on your terminal window):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你应该看到类似这样的界面（具体大小取决于你的终端窗口）：
- en: '![Figure 14.1 – The dialog command enables us to create menus in a single line
    of our script'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.1 – `dialog`命令使我们能够在脚本中创建单行菜单'
- en: '](img/Figure_14.1_B16269.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.1_B16269.jpg)'
- en: Figure 14.1 – The dialog command enables us to create menus in a single line
    of our script
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.1 – `dialog`命令使我们能够在脚本中创建单行菜单
- en: '`dialog` acts as a good-looking proxy between your script and the user. Your
    script is responsible for the logic of the process you are trying to automate;
    `dialog` is responsible for dealing with user input and output. We need to do
    something with this menu; if we just call it from our Bash prompt, we have no
    use for it. The reason we used it this way was to show you how to call a widget.
    A lot of people expect a complicated procedure when they first see `dialog` being
    used in a script, which is just a command in one line and a couple of arguments.
    To demonstrate this, let''s create an actual menu and save it in a file named
    `menu.sh`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`dialog` 作为你的脚本与用户之间的一个漂亮代理工作。你的脚本负责你试图自动化的过程的逻辑；`dialog` 负责处理用户的输入和输出。我们需要对这个菜单做点什么；如果我们只是从
    Bash 提示符中调用它，那它就没有什么用途。我们这样使用它的原因是为了展示如何调用一个小部件。许多人在第一次看到`dialog`在脚本中使用时，会期望一个复杂的过程，实际上这只是一个单行命令和几个参数。为了演示这一点，让我们创建一个实际的菜单并将其保存在名为`menu.sh`的文件中：'
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: What are we doing here? `dialog` requires a couple of parameters for every widget
    it can display. It needs a lot of values to correctly show whether something comes
    from your terminal. These are values such as the width and height of the screen
    and how to display the output correctly. As a rule, widgets only require user-defined
    things – the height and width of the widget itself, titles and other strings that
    are used in the widget, and the choices the user has. They are different from
    widget to widget, depending on the way it works and is used. In our first example,
    we are using a menu widget that requires a list of options and the size of the
    menu. We needed this list of options as it helps the user who's starting this
    script make a correct choice. We are also providing it with the titles, although
    we don't need all of them for our menu to function.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做什么？`dialog` 为它可以显示的每个小部件需要几个参数。它需要许多值来正确显示某些内容是否来自你的终端。这些值包括屏幕的宽度和高度，以及如何正确显示输出。通常，小部件只需要用户定义的内容——小部件本身的高度和宽度、在小部件中使用的标题和其他字符串，以及用户的选择。根据小部件的工作方式和使用方式，这些内容因小部件而异。在我们的第一个示例中，我们使用的是一个菜单小部件，它需要一个选项列表和菜单的大小。我们需要这个选项列表，因为它帮助启动此脚本的用户做出正确的选择。我们还提供了标题，尽管我们并不需要所有标题就能让菜单正常运行。
- en: An interesting thing to notice here is the way `dialog` returns the value that
    the user chose. To get that, we are providing indices in our list of possible
    options. When we run `dialog`, we are going to assign the value it got from the
    user directly to a variable and then act accordingly.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个有趣的地方需要注意，就是`dialog`返回用户选择的值的方式。为了获取这个值，我们在可能的选项列表中提供了索引。当我们运行`dialog`时，我们会将它从用户那里获取的值直接赋给一个变量，然后根据该值进行操作。
- en: How it works…
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: '`dialog` is based on displaying different widgets using different graphical
    characters to give the feel of a graphical interface inside the normal terminal.
    As somebody who uses dialog, you can change almost all the elements'' appearance
    if you want, but usually, most scripts simply use `dialog` to quickly get the
    user to input the data they require.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`dialog` 基于使用不同的图形字符显示不同的小部件，从而在普通终端中给人一种图形界面的感觉。作为一个使用`dialog`的人，如果你愿意，你几乎可以改变所有元素的外观，但通常，大多数脚本只是简单地使用`dialog`来快速让用户输入他们需要的数据。'
- en: Using something like `dialog` is a great way to enable the user to choose values
    for different things in their script while avoiding a lot of input errors.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像`dialog`这样的工具是一种很好的方法，能够让用户为脚本中的不同事物选择值，同时避免大量输入错误。
- en: For another example, let's imagine we need to ask a user to provide us with
    a date. We can do this using a simple entry with the `read` and `echo` commands.
    This will work but with a big risk of the user using the wrong format. You could
    solve this by explaining to your users what format you expect, but they will inevitably
    forget and use the wrong one.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个示例是，假设我们需要请求用户提供一个日期。我们可以使用`read`和`echo`命令通过一个简单的输入框来实现。虽然这样可行，但有很大风险用户会使用错误的格式。你可以通过向用户解释你期望的格式来解决这个问题，但他们不可避免地会忘记并使用错误的格式。
- en: 'In `dialog`, you could do something simple, like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在`dialog`中，你可以做一些简单的事情，比如这样：
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following is the output:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '![Figure 14.2 – Using the calendar widget to display dates is easy'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.2 – 使用日历小部件显示日期非常简单'
- en: '](img/Figure_14.2_B16269.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.2_B16269.jpg)'
- en: Figure 14.2 – Using the calendar widget to display dates is easy
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.2 – 使用日历小部件显示日期非常简单
- en: The date we are going to get will be in the right format, depending on the regional
    setting of the system running the script, and the user can choose from several
    good-looking calendars. `dialog` helps a lot here since it will even jump to the
    current date if we do not specify which specific date is going to be the default.
    Depending on the type of terminal emulation, `dialog` may even support using a
    computer mouse to select data.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的日期将根据运行脚本的系统的区域设置以正确的格式显示，用户可以从几个好看的日历中进行选择。`dialog`在这里非常有用，因为如果我们没有指定默认的具体日期，它会自动跳到当前日期。根据终端仿真类型，`dialog`甚至可能支持使用计算机鼠标来选择数据。
- en: There are more very useful widgets that `dialog` provides, so we are going to
    show a few of them. We are not going to create a script for all of them since
    they are simple to use. The simplest way is to use the `—stdout` option to get
    the result of `dialog` into a variable and then work from there.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些非常有用的小部件是`dialog`提供的，我们将展示其中的一些。我们不会为所有小部件创建脚本，因为它们使用起来非常简单。最简单的方法是使用`—stdout`选项将`dialog`的结果存入变量，然后从那里继续工作。
- en: 'If we need to choose a directory, that can be a big problem since the user
    would usually forget to write the path correctly or use absolute paths instead
    of relative ones. By using a simple `dialog command`, such as the following, we
    can avoid a lot of problems:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要选择一个目录，这可能是一个大问题，因为用户通常会忘记正确写路径，或者使用绝对路径而不是相对路径。通过使用一个简单的`dialog 命令`，比如下面的命令，我们可以避免很多问题：
- en: '[PRE28]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This is the expected result:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这是预期的结果：
- en: '![Figure 14.3 – Choosing directories using dialog avoids a lot of errors'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.3 – 使用对话框选择目录可以避免很多错误'
- en: '](img/Figure_14.3_B16269.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.3_B16269.jpg)'
- en: Figure 14.3 – Choosing directories using dialog avoids a lot of errors
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.3 – 使用对话框选择目录可以避免很多错误
- en: 'A simple `dialog` is useful when we need to get a simple *yes* or *no* answer
    from the user. We can use the following code to do so:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要从用户那里获取一个简单的*是*或*否*答案时，简单的`dialog`非常有用。我们可以使用以下代码来实现：
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Using this `dialog` command, we should get the following output:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个`dialog`命令，我们应该得到以下输出：
- en: '![Figure 14.4 – Sometimes, you need to ask a simple question that will have
    a simple answer'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.4 – 有时候，你需要问一个简单的问题，答案也很简单'
- en: '](img/Figure_14.4_B16269.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.4_B16269.jpg)'
- en: Figure 14.4 – Sometimes, you need to ask a simple question that will have a
    simple answer
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.4 – 有时候，你需要问一个简单的问题，答案也很简单
- en: 'Then, we have more informative ones. In our scripts, we are often having to
    present the user with some information that they need to read. Having it in a
    formatted box is much nicer than simply printing it in a terminal:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有一些更具信息性的选择。在我们的脚本中，我们经常需要向用户展示一些他们需要阅读的信息。把它放在一个格式化的框中比直接在终端打印要好得多：
- en: '[PRE30]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This example will create the following output:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将生成以下输出：
- en: '![Figure 14.5 – Displaying text is easy and effective when you''re using the
    right widget'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.5 – 使用正确的小部件显示文本既简单又有效'
- en: '](img/Figure_14.5_B16269.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.5_B16269.jpg)'
- en: Figure 14.5 – Displaying text is easy and effective when you're using the right
    widget
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.5 – 使用正确的小部件显示文本既简单又有效
- en: 'There are a few widgets we will not mention as we are trying to give you a
    quick glimpse into what is possible. For the last example, we are going to show
    you a useful one – this widget shows the contents of a text file and automatically
    updates it with changes, enabling you, for example, to show a log to the user
    while they''re installing something:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些小部件我们不会提及，因为我们想快速向你展示一些可能的用法。对于最后一个例子，我们将向你展示一个非常有用的小部件——这个小部件显示文本文件的内容，并随着更改自动更新它，使你可以在用户安装某个东西时显示日志：
- en: '[PRE31]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This is the expected output:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这是预期的输出：
- en: '![Figure 14.6 – tailbox is the same as using tail -f on a file but is much
    better looking'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.6 – tailbox 就像在文件上使用 tail -f，但外观更好'
- en: '](img/Figure_14.6_B16269.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.6_B16269.jpg)'
- en: Figure 14.6 – tailbox is the same as using tail -f on a file but is much better
    looking
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.6 – tailbox 就像在文件上使用 tail -f，但外观更好
- en: This concludes our overview of what `dialog` can do. Make sure that you read
    the documentation to learn about the rest of the widgets that you can use, as
    well as how to use them correctly.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们对`dialog`功能的概述。确保你阅读文档，以了解其他可以使用的小部件以及如何正确使用它们。
- en: Note that there are other implementations of the same idea. One of those is
    called *whiptail* and is the same as `dialog` but uses a different way to draw
    objects on the screen. However, it is not as complete as `dialog`, and it lacks
    some widgets compared to `dialog`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，存在其他实现相同思想的工具。其中之一叫做 *whiptail*，它与`dialog`相同，但采用不同的方式在屏幕上绘制对象。然而，它并不像`dialog`那样完整，并且缺少一些与`dialog`相比的控件。
- en: See also
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '`dialog` man page: [https://linux.die.net/man/1/dialog](https://linux.die.net/man/1/dialog)'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dialog` 手册页：[https://linux.die.net/man/1/dialog](https://linux.die.net/man/1/dialog)'
- en: 'Menu box guide: [https://bash.cyberciti.biz/guide/A_menu_box](https://bash.cyberciti.biz/guide/A_menu_box)'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 菜单框指南：[https://bash.cyberciti.biz/guide/A_menu_box](https://bash.cyberciti.biz/guide/A_menu_box)
