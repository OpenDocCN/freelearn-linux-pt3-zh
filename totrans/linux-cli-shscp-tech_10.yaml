- en: '*Chapter 10*: Using Loops'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第10章*：使用循环'
- en: In the previous chapter, we started dealing with scripting, and we did a lot
    of learning about how scripts work and how they are structured. However, we missed
    a huge topic in scripting – influencing the order in which commands are executed
    when a script is run. There are a couple of things that we need to cover here,
    since there are multiple ways we can influence what is going to be the next command
    executed in a script.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们开始处理脚本编写，并且学习了很多关于脚本如何工作以及它们是如何结构化的内容。然而，我们忽略了脚本中的一个重要主题——影响脚本执行时命令执行顺序。这里有一些内容需要我们讲解，因为我们有多种方式可以影响脚本中接下来要执行的命令。
- en: We are going to start with a concept we call **iterators** or, more commonly,
    **loops**. There are a lot of things in everyday tasks that need to be done repeatedly,
    usually changing just one small thing in every iteration. This is where looping
    comes in.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个概念开始，这个概念叫做 **迭代器** 或更常见的 **循环**。日常任务中有很多事情需要重复执行，通常每次迭代只改变其中的一个小部分。这就是循环发挥作用的地方。
- en: 'We will cover the following recipes in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下配方：
- en: The `for` loop
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for` 循环'
- en: '`break` and `continue`'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`break` 和 `continue`'
- en: The `while` loop
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`while` 循环'
- en: The `test-if` loop
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test-if` 循环'
- en: The `case` loop
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`case` 循环'
- en: Logical looping with `and`, `or`, and `not`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `and`、`or` 和 `not` 进行逻辑循环
- en: The for loop
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: for 循环
- en: When we talk about loops, we usually make a distinction based on the place in
    the execution where the variable we are using changes its value. `for` loops,
    in that respect, belong to the group where a variable is set before each iteration
    and keeps its value until the next iteration is run. The most common task that
    we are going to perform by using a `for` loop is going to be using the loop to
    iterate through sets of things, usually either numbers or names.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论循环时，我们通常会根据变量值变化的执行位置来区分。`for` 循环在这方面属于那一类，在每次迭代之前设置变量，并保持其值直到下一次迭代运行。我们将通过使用
    `for` 循环来执行的最常见任务是使用循环遍历一组事物，通常是数字或名称。
- en: Getting ready
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before we begin introducing different ways of using a `for` loop, we need to
    address its abstract form:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始介绍不同的 `for` 循环使用方式之前，我们需要先讲解它的抽象形式：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: What do we have here? The first thing to note is that we have some reserved
    keywords that make Bash understand that we want to use a `for` loop. In this particular
    example, `item` is actually the name of the variable that will hold one value
    from the list in each loop iteration. The word `in` is a keyword that further
    helps us understand that we are going to use a set of values that we currently
    call a list, although it can be different things.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里有什么？首先需要注意的是，我们有一些保留关键字，这些关键字使得 Bash 明白我们要使用 `for` 循环。在这个特定的例子中，`item` 实际上是变量的名称，它将持有列表中每次循环迭代的一个值。`in`
    这个词是一个关键字，进一步帮助我们理解我们将使用一组值，这组值目前我们称之为列表，尽管它也可以是其他东西。
- en: After the list, there is a block that defines what commands we intend to run
    each time a loop is performed. Currently, we are going to work with this block
    as a single entity, containing commands that will be executed one after another
    without interruptions. Later in this chapter, we are going to introduce some conditional
    branching that will enable us to cover more possible workflow solutions, but for
    now, a block is uninterruptable.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表之后，有一个块，定义了我们每次执行循环时打算运行的命令。目前，我们将把这个块当作一个整体来处理，里面包含的命令会一个接一个地执行，直到没有中断。稍后在本章中，我们将介绍一些条件分支，这将使我们能够覆盖更多可能的工作流解决方案，但目前为止，块是不可中断的。
- en: What will probably surprise you is that a `for` loop is often used directly
    from the command line, even more often than in scripts. The reason is simple –
    there are a lot of tasks we can accomplish by using a simple `for` loop, and complicating
    them by creating scripts is to be avoided. A `for` loop in this form looks a little
    different than in the one we showed as our first example, the main difference
    being the semicolon that separates the keywords when we are using a single line
    to write out the loop.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会让你感到惊讶的是，`for` 循环通常是直接从命令行中使用的，甚至比在脚本中使用的次数还要多。原因很简单——有很多任务我们可以通过使用简单的 `for`
    循环来完成，反而通过创建脚本来让它们变得复杂是应该避免的。以这种形式写的 `for` 循环看起来与我们第一次示例中展示的有些不同，主要区别在于当我们用一行代码编写循环时，关键字之间使用了分号分隔。
- en: How to do it…
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Let''s start with a simple example. We are going to run through a list of servers
    and echo one in each iteration of the loop. Note that the shell takes our command
    from the prompt and repeats it before executing it:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的例子开始。我们将遍历一个服务器列表，并在每次循环迭代中输出其中一个。注意，shell会从提示符获取我们的命令，并在执行前将其重复一遍：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Using `echo` as a placeholder for commands when testing a loop is common. We
    are going to use this style of debugging a lot in our examples. `echo` as a command
    is probably the most useful one in this context since it changes nothing and,
    at the same time, enables us to see what the actual output is going to be.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试循环时，使用`echo`作为占位符命令是很常见的。我们将在示例中多次使用这种调试风格。`echo`作为命令在这种情况下可能是最有用的，因为它不会改变任何东西，同时使我们能够看到实际的输出结果。
- en: When creating a list of objects, we don't have to use any special characters
    to separate individual entries; bash is going to treat space as a delimiter, and
    as long as we separate our values by a space, `bash` is going to understand our
    intentions. A little later, we are going to show you how to change the character
    that separates a value in the list, but a space will work in almost all the circumstances.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建对象列表时，我们不需要使用任何特殊字符来分隔各个条目；bash会将空格作为分隔符，只要我们用空格分隔值，`bash`就能理解我们的意图。稍后，我们会展示如何更改列表中分隔值的字符，但空格在几乎所有情况下都能正常工作。
- en: The list we are using in the iterations can be explicitly defined, but more
    often than not, we are going to need to create it when we run our loop, in the
    command line or the script.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在迭代中使用的列表可以明确定义，但更多时候，我们需要在运行循环时创建它，无论是在命令行还是脚本中。
- en: A typical example of this is running a loop on a set of files in a directory.
    The way to do this is to use shell expansion. This means letting the shell run
    a command and then using its output as the list for the `for` loop. We can do
    this either by specifying a command in backticks (`` ` ``) or using `bash` notation
    of `$`(command). Both ways have the same result – a command is run and then piped
    to a list.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这方面的典型例子是对目录中的一组文件运行循环。实现这个的方法是使用shell扩展。这意味着让shell运行一个命令，然后将其输出作为`for`循环的列表。我们可以通过反引号（``
    ` ``）指定命令，或者使用`bash`的`$`（命令）语法。两者的结果相同——命令运行后输出会被传递给列表。
- en: 'Our example is going to be a loop that iterates through the current directory
    and runs the `file` command on each individual file, giving us information on
    what this particular file actually is. We are still on the command line:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例将是一个循环，它遍历当前目录，并对每个文件运行`file`命令，向我们提供关于该文件实际内容的信息。我们仍然处于命令行环境：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, let's deal with something more interesting. Often, we need to use numbers
    in our loops, either to count something or to create other objects. Almost all
    programming languages have some sort of loop that enables this. Bash is a sort
    of an exception to this rule, since it can do it in a couple of different ways.
    One is to use the `echo` command and a little bit of shell expansion to accomplish
    this task.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们处理一些更有趣的内容。通常，我们需要在循环中使用数字，无论是为了计数还是创建其他对象。几乎所有编程语言都有某种类型的循环来实现这一点。Bash在这方面有些例外，因为它能通过几种不同的方法来实现这一功能。其中一种方法是使用`echo`命令并加一点shell扩展来完成此任务。
- en: 'If you are unfamiliar with this, giving `echo` an argument that consists of
    a number formatted in curly brackets will make it output all the numbers in the
    interval that you specified:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不熟悉这个，当给`echo`传递一个由大括号格式化的数字作为参数时，它将输出你指定区间中的所有数字：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To use this in a loop, we simply do the same trick as we did in the previous
    example:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要在循环中使用它，我们只需要做与前一个示例中相同的技巧：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We are not limited to using a fixed step in the interval; if we simply mention
    an interval followed by a number, this number will be considered as a step value.
    A step value is basically a number that your variable is going to be incremented
    with in each loop iteration.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并不局限于使用固定的步长；如果我们仅提到一个区间后面跟着一个数字，那么这个数字将被视为步长值。步长值本质上是指在每次循环迭代中，变量将增加的数值。
- en: 'We are going to try a simple loop using multipliers of `20`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试一个使用`20`倍数的简单循环：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can combine shell expansion the same way that we normally do in the command
    line and create different values for our loop. For example, in order to create
    server names for three groups of servers, each containing six servers, we can
    use a simple one-line loop:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像在命令行中那样结合使用 shell 扩展，为我们的循环创建不同的值。例如，为了为三组服务器创建服务器名称，每组包含六个服务器，我们可以使用一个简单的单行循环：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Of course, loops can be embedded within each other by simply placing the inner
    loop into the `do-done` block of the outer loop. In this particular example, we
    are using shell expansion to loop through a list of values in both loops:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，循环可以嵌套，只需将内层循环放入外层循环的 `do-done` 块中。在这个特定的示例中，我们使用 shell 扩展在两个循环中遍历一个值列表：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works…
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: Now is the time to slowly switch from the command line to how we can use these
    loops in scripts. The biggest difference here is that `for` loops are way easier
    to read when formatted in a script.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候慢慢地从命令行过渡到如何在脚本中使用这些循环了。这里最大的区别是，`for` 循环在脚本中格式化后要比命令行更容易阅读。
- en: For our first example, we are going to mention another way of creating a set
    of numbers in a loop, a so-called *C-style loop*. As the name suggests, this loop
    takes its syntax from the C language. Each loop has three separate values. Of
    these, the first two are compulsory; the third is not. The first value is called
    either the *initialization value* or the *start value*. It gives us the value
    of the variable in the first loop iteration. One thing to note here is that we
    need to assign the initial value explicitly, which significantly differs from
    the usual style used in the *normal* `for` loop.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的第一个例子，我们将提到另一种在循环中创建数字集合的方法，所谓的 *C 风格循环*。正如名字所示，这种循环的语法来自 C 语言。每个循环有三个单独的值。其中前两个是强制性的；第三个不是。第一个值称为
    *初始化值* 或 *起始值*。它给我们提供了变量在第一次循环迭代中的值。这里需要注意的一点是，我们需要显式地分配初始值，这与 *常规* `for` 循环中通常使用的风格有显著不同。
- en: The second value in this loop variation is the *test condition*, occasionally
    known as the *boundary condition*. This represents the last valid value that our
    loop iterator will have before we finish the loop or, to put it more simply, the
    largest number if we count incrementally.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环变体中的第二个值是 *测试条件*，有时也叫 *边界条件*。它表示在我们完成循环之前，循环迭代器所能达到的最后一个有效值，或者更简单地说，就是当我们按递增顺序计数时的最大值。
- en: The third value can be omitted; it will default to `1`. If we use it, this is
    going to be the default step or increment that our loop is going to use.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个值可以省略；它将默认为 `1`。如果我们使用它，这将是循环将使用的默认步长或增量。
- en: 'Theoretically, this C-style `for` loop will look like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 从理论上讲，这个 C 风格的 `for` 循环将是这样的：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In reality, it has a more complex syntax, but it will look very familiar to
    all of you with experience in programming in C, as the name suggests:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，它有更复杂的语法，但对于所有有 C 编程经验的人来说，它看起来非常熟悉，正如名字所示：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Before we go on, let''s look at an example of a loop that we have already used
    but formatted as it would be in a script:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们看一个我们已经使用过的循环示例，并以脚本中的格式呈现：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As we can see, the only real difference here is the formatting and the omission
    of semicolons that directly stems from not having to parse the entire script in
    one line.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，唯一的实际区别是格式化和省略分号，这是因为我们不需要在一行中解析整个脚本。
- en: See also
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: 'In order to understand looping, you will probably need quite a few examples.
    Start with these links:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解循环，你可能需要一些例子。从这些链接开始：
- en: '[https://linuxhint.com/30_bash_loop_examples](https://linuxhint.com/30_bash_loop_examples)/'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://linuxhint.com/30_bash_loop_examples](https://linuxhint.com/30_bash_loop_examples)/'
- en: '[https://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-7.html](https://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-7.html)'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-7.html](https://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-7.html)'
- en: break and continue
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: break 和 continue
- en: Up until now, we haven't really done any conditional branching in our scripts.
    Everything we did was linear, even loops. Our script was able to execute commands
    line by line, starting from the first one, and if we had a loop, it was running
    until our conditions that we stated at the loop start were met. This means that
    our loops have a fixed, predetermined number of iterations. Sometimes, or to be
    more precise often, we need to do something that breaks this idea.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在脚本中实际上并没有做任何条件分支。我们做的所有事情都是线性的，即使是循环也是如此。我们的脚本能够逐行执行命令，从第一行开始，如果有循环，它会一直运行，直到满足我们在循环开始时定义的条件。这意味着我们的循环有一个固定的、预定的迭代次数。有时候，或者更准确地说，通常我们需要做一些事情来打破这种想法。
- en: Getting ready
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Imagine this example – you have a loop that has to iterate a number of times
    *unless* a condition is met. We said that our loops have the number of iterations
    fixed at the start of the loop, so we obviously need a way to end the loop prematurely.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有这样一个例子——你有一个循环，它必须迭代若干次，*除非*满足某个条件。我们说过，循环的迭代次数是在循环开始时就固定的，所以显然我们需要一种方法来提前结束循环。
- en: This is why we have a command called `break`. As the name suggests, this command
    breaks the loop by escaping from the command block it is included in and finishing
    the loop, regardless of the conditions that were used in the definition of the
    loop. The main reason why this is important is to establish control over the loop
    and handle any possible state that requires you to not finish the job you started
    in your loop. One more thing to note is that the `break` command is not limited
    only to `for` loops; it can be used in any other block of code, a thing that will
    become more useful later when we learn other ways to structure our scripts into
    blocks.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们有一个叫做 `break` 的命令。顾名思义，这个命令通过跳出它所在的命令块来打破循环，并结束循环，无论循环的定义中使用了什么条件。之所以这么重要，是因为它能帮助我们控制循环，处理任何可能要求我们在循环中不完成任务的状态。还需要注意的是，`break`
    命令不仅限于 `for` 循环；它可以在任何其他代码块中使用，等到我们学习如何将脚本结构化为块时，这会变得更加有用。
- en: How to do it…
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: 'It is always easy to start with an example, but in this particular case, we
    are going to start with an overall view of how this command works. We are going
    to use abstract commands instead of actual ones to help you understand the structure
    of this loop. After this, we are going to create some real-world examples:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 开始时使用一个例子总是比较容易，但在这个特定的案例中，我们将从这个命令如何工作的整体视角开始。我们将使用抽象命令代替实际命令，以帮助你理解这个循环的结构。之后，我们会创建一些实际的例子：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: What is going on here? The `for` loop by itself is a normal loop that gets executed
    using `1`, `2`, `3`, `4`, and `5` as values. `command1` and `command2` are going
    to get executed the way we expect them to be at least once, since they are the
    first thing after the start of the loop.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？`for` 循环本身是一个正常的循环，它使用 `1`、`2`、`3`、`4` 和 `5` 作为值来执行。`command1` 和 `command2`
    会按照预期至少执行一次，因为它们是循环开始后的第一个命令。
- en: The `if` statement is where things get interesting. We will talk a lot more
    about `if` statements, but we need to mention them here in their most basic form.
    Here, we have something called a break condition. This can be anything that can
    be resolved to a logical value. That means the result of our condition has to
    be either `true` or `false`. If the result is false, our condition is not met,
    and the loop continues by executing `command3`, looping back to the beginning
    of the loop, and assigning the next value to our variable.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` 语句是事情变得有趣的地方。我们将会更多地讨论 `if` 语句，但我们需要在这里提到它们的最基本形式。在这里，我们有一个叫做终止条件的东西。它可以是任何可以解析为逻辑值的东西。这意味着我们的条件结果必须是
    `true` 或 `false`。如果结果为 `false`，则条件未满足，循环将继续执行 `command3`，并回到循环的开始，给变量赋予下一个值。'
- en: We are more interested in what happens if the break condition evaluates to true.
    This means that we have met our condition and need to run the block of code that
    follows. A simple `break` statement is here, and it has no arguments. What will
    happen next is that the script will immediately exit the loop and go to execute
    `command4` and whatever is after it. The important thing is that `command3` will
    not be run in this case, and the loop will not repeat, regardless of the value
    of the loop variable.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更感兴趣的是，如果`break`条件为真时会发生什么。这意味着我们已经满足了条件，并需要运行后续的代码块。这里有一个简单的`break`语句，它没有参数。接下来发生的事情是，脚本会立即退出循环并执行`command4`以及其后的所有内容。重要的是，`command3`在这种情况下不会被执行，循环也不会重复，无论循环变量的值是什么。
- en: There is another statement called `continue` that can also be useful, although
    it is not used as much as `break`. `Continue` also breaks the loop in a way, but
    not permanently. Once you use `continue` in the loop, the program flow is going
    to immediately go to the start of the loop block without executing the remaining
    statements.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个叫做`continue`的语句也很有用，虽然它不像`break`那样使用频繁。`Continue`也以某种方式跳出循环，但不是永久性的。一旦在循环中使用`continue`，程序的流程将立即跳转到循环块的开始，而不执行剩余的语句。
- en: How it works…
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Having talked about the abstract structure, it is time to create an example.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 讲完抽象结构后，现在是时候创建一个例子了。
- en: 'Imagine we are counting using a `for` loop, but we want to break out of it
    as soon as we hit the number `4` as the value of our variable. Of course, we could
    do this by simply specifying number `5` as the upper value that we are counting,
    but we need to show how the loop works, so we are going to break out of it using
    the `break` statement:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在使用`for`循环计数，但我们希望一旦变量的值为`4`时就跳出循环。当然，我们也可以通过简单地将`5`指定为我们计数的上限来实现这一点，但我们需要展示循环的工作原理，因此我们将使用`break`语句跳出循环：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'It''s time to break down our script, but we are going to run it before we do
    that:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候拆解我们的脚本了，但我们在拆解之前先运行一次：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Our sample script looks a lot like our *abstract* example, but we used actual
    the `echo` command to emulate something that should happen. The most important
    part that we need to talk about is the `if` command; everything else is as we
    said in the first part of this recipe.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例脚本看起来非常像我们的*抽象*示例，但我们用了实际的`echo`命令来模拟应该发生的事情。我们需要讨论的最重要部分是`if`命令；其他部分和我们在食谱第一部分中所说的相同。
- en: We mentioned that we need to have a condition for our `break` statement to make
    any sense. In this particular case, we are using `if` with a `test` condition;
    basically, we are telling `bash` to compare two values and let us know whether
    they are the same or not. In `bash`, there are two ways to do this – one is to
    use the `=` operator we are used to, and another is to use the `-eq` or `equals`
    operator. The difference between these two is that `=` compares `strings`, while
    `-eq` compares integers. We will go into much more detail in later recipes, since
    they are important in scripting.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到过，为了让`break`语句有意义，我们需要一个条件。在这个特定的例子中，我们使用了带有`test`条件的`if`语句；基本上，我们在告诉`bash`去比较两个值，看看它们是否相等。在`bash`中，有两种方式可以做到这一点——一种是使用我们习惯的`=`操作符，另一种是使用`-eq`或`equals`操作符。这两者的区别在于，`=`用于比较`字符串`，而`-eq`用于比较整数。我们将在后续的食谱中详细讲解它们，因为它们在脚本中非常重要。
- en: 'Now, let''s see how the `continue` command works. We are going to slightly
    modify our script so that it skips over the third command once it hits `3` as
    the value of the variable:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`continue`命令是如何工作的。我们将稍微修改一下脚本，使其在变量值为`3`时跳过第三个命令：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'What we did is a simple change in the `if` statement; we changed the condition
    so that it checks whether the variable value is equal to `3`, and then we created
    a command block that skips over the rest of the loop when our condition is satisfied.
    Running it is simple:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的只是简单地修改了`if`语句；我们更改了条件，使其检查变量值是否等于`3`，然后创建了一个命令块，当条件满足时跳过循环的其余部分。运行它很简单：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The only real point here is noting that we finished all our iterations; the
    only thing we skipped was one instance of running the third command in the script.
    Also, note that the `continue` command in the loop is going to skip over everything
    up to the end of the current loop and go back to the beginning, while a `break`
    statement is going to skip the entire loop and not repeat it.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里唯一需要注意的是我们完成了所有迭代；唯一跳过的事情是脚本中第三个命令的执行。还需要注意的是，循环中的 `continue` 命令会跳过当前循环到达其末尾并返回到循环的开始，而
    `break` 语句则会跳过整个循环并不再重复执行。
- en: See also
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: 'Interrupting command flow can be a problem at first. More information is available
    at these links:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 中断命令流一开始可能是个问题。更多信息请参考以下链接：
- en: '[https://tldp.org/LDP/abs/html/loopcontrol.html](https://tldp.org/LDP/abs/html/loopcontrol.html)'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://tldp.org/LDP/abs/html/loopcontrol.html](https://tldp.org/LDP/abs/html/loopcontrol.html)'
- en: '[https://linuxize.com/post/bash-break-continue/](https://linuxize.com/post/bash-break-continue/)'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://linuxize.com/post/bash-break-continue/](https://linuxize.com/post/bash-break-continue/)'
- en: The while loop
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`while` 循环'
- en: Up until now, we have dealt with loops that have a fixed number of iterations.
    The reason is simple – if you are using a `for` loop, you need to specify *for*
    what values your loop is going to run, or what values your variable is going to
    have while in the loop.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们处理的循环都是固定次数的迭代。原因很简单——如果你使用 `for` 循环，你需要指定循环要运行的值，或者指定变量在循环中将拥有的值。
- en: The problem with this approach to looping is that sometimes you don't know in
    advance how many iterations you are going to need to do something. This is where
    the `while` loop comes into play.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这种循环方法的问题在于，有时你无法提前知道需要多少次迭代才能完成某个操作。这时，`while` 循环就派上用场了。
- en: Getting ready
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备开始
- en: The most important thing you need to know about the `while` loop is that it
    does its testing at the start of the loop. This means that we need to structure
    our script to run *while* something is true. This also means that we can make
    a loop that will never get executed; if we create a `while` loop that has a condition
    that is not met, `bash` is not going to run it at all. This has a number of great
    advantages, since it gives us the flexibility to use our loop as many times as
    we need without thinking about boundaries, and we can still use `break` when we
    need to get out of the loop before our condition is met.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要了解的最重要的事情是，`while` 循环在循环开始时进行测试。这意味着我们需要构建我们的脚本，使其在某些条件为真时运行 *while*。这也意味着我们可以创建一个永远不会执行的循环；如果我们创建一个
    `while` 循环，其条件未满足，`bash` 将完全不执行它。这具有很多优点，因为它使我们可以灵活地根据需要多次使用循环，而不必考虑边界，并且我们仍然可以在条件未满足时使用
    `break` 退出循环。
- en: How to do it…
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现……
- en: 'A `while` loop looks even simpler than a standard `for` loop; we have a condition
    that must be met, and a command block that is going to get executed. If the condition
    is not met, commands will not run and `bash` is going to skip over the block and
    continue running whatever is after the end of the `done` statement that terminates
    the block:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环看起来比标准的 `for` 循环更简单；我们有一个必须满足的条件和一个将要执行的命令块。如果条件不满足，命令将不会执行，`bash`
    会跳过该块，继续执行 `done` 语句后面的内容，该语句用于终止该块：'
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Condition, in this case, is the same logical condition that we mentioned earlier.
    There is also another way of using the `while` loop by having something called
    `control-command`, a command that runs and directly provides information for the
    loop to start. We are going to use this one a lot, since it enables us to, for
    example, read a file line by line, without specifying how many lines it has beforehand:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 条件，在这个例子中，与之前提到的逻辑条件相同。还有一种使用 `while` 循环的方法，通过拥有一个称为 `control-command` 的命令，它会执行并直接提供信息以启动循环。我们将经常使用这种方法，因为它使我们能够，例如，逐行读取文件，而无需预先指定文件的行数：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works…
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'As usual, we are going to give a few examples. First, we are going to repeat
    the task we already accomplished using the `for` loops. The idea is to loop until
    our value reaches `4` and then finish the loop. Note that the value can be a string,
    not necessarily a number:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们将提供一些示例。首先，我们将重复使用 `for` 循环已经完成的任务。我们的目标是循环直到值达到 `4`，然后结束循环。请注意，值可以是字符串，而不一定是数字：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: There are a few little things we need to emphasize. The first one is the condition
    we used. In our `for` loop, we compared whether the value is `4` and then used
    `break` to get out of our loop. In this case, we cannot do that; if we check whether
    the value of our `x` variable is `4`, the loop will never run, since the initial
    value is `1`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个小点需要强调。第一个是我们使用的条件。在我们的`for`循环中，我们比较了值是否为`4`，然后使用`break`跳出循环。在这种情况下，我们不能这么做；如果检查`x`变量的值是否为`4`，循环将永远不会运行，因为初始值是`1`。
- en: In a `while` loop, we need to check for the opposite – we want our loop to run
    until the value becomes `4`, so the condition has to be true in all cases *except*
    when our variable is exactly `4`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在`while`循环中，我们需要检查相反的条件——我们希望循环一直运行，直到值变为`4`，因此条件必须在所有情况下都为真，*除了*当我们的变量恰好是`4`时。
- en: Thankfully, the very same `while` keyword helps in creating the condition.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，正是这个`while`关键字帮助我们创建条件。
- en: We mentioned that instead of a condition, we can have a command. A typical example
    that you are going to use often is reading a file. We can do this using a `for`
    loop, but it would be needlessly complicated. `for` loops need to know the number
    of iterations before we even start a loop. In order to solve this problem using
    a `for` loop, we would need to count the lines in a file before we can start looping,
    and this would be both complicated and slow, since it requires us to open the
    file twice – first to count the lines and then to read them in the loop.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到过，除了条件之外，我们还可以使用命令。一个你将经常使用的典型例子是读取文件。我们可以使用`for`循环来实现这一点，但这会不必要地复杂。`for`循环需要在开始之前知道迭代的次数。为了使用`for`循环解决这个问题，我们需要在开始循环之前先统计文件中的行数，而这既复杂又慢，因为它需要我们打开文件两次——第一次是统计行数，第二次是在循环中读取。
- en: 'A much simpler way is to use a `while` loop. We simply run the loop while our
    command gives us some output – in this case, while it reads from a file. As soon
    as the command fails, the loop is over:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更简单的方法是使用`while`循环。我们只需在命令有输出时运行循环——在本例中，就是在从文件中读取内容时。只要命令失败，循环就结束：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You will notice that there are a few things we haven't yet seen in the scripts.
    The first one is the use of the variables. We sort of already did that when we
    were dealing with the `for` statements, but here you can see both how a variable
    is declared and how it is used. We'll talk a lot more about this later. Another
    thing is how we actually read the file. The `read` command has no arguments; it
    is intended to be used with standard input. Since we know how to redirect inputs
    and outputs, we are going to just redirect whatever is in the file as the input
    of the `read` command. This is why we used redirection in the last line of the
    script. It may look awkward, but it is the way to do it.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，在这些脚本中有一些我们还没有看到的内容。第一个是变量的使用。当我们处理`for`语句时，某种程度上我们已经做过这件事了，但在这里你可以看到变量是如何声明的，以及它是如何被使用的。稍后我们会详细讨论这个问题。另一个问题是我们是如何实际读取文件的。`read`命令没有参数，它是用来处理标准输入的。既然我们知道如何重定向输入输出，我们就可以将文件中的内容重定向为`read`命令的输入。这就是为什么我们在脚本的最后一行使用了重定向。它看起来可能有些不自然，但这是做这件事的正确方式。
- en: 'Sometimes, we have a reason to use a loop that never finishes, a so-called
    infinite loop. It looks counterintuitive, but this kind of loop is extremely common
    in scripts when we need to run the script over and over again and have no idea
    how many iterations we need. Sometimes, we may even want our script to run continuously
    and then use the `break` statement to stop it if something happens. An infinite
    `while` loop is simple; just use `:` as the condition:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要使用一个永不结束的循环，即所谓的无限循环。它看起来与直觉相悖，但这种循环在脚本中非常常见，当我们需要不断运行脚本，却不知道需要多少次迭代时。我们有时甚至希望脚本不断运行，并在发生某些事件时使用`break`语句来停止它。无限的`while`循环很简单；只需将`:`作为条件：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: See also
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: '[https://linuxize.com/post/bash-while-loop/](https://linuxize.com/post/bash-while-loop/)'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://linuxize.com/post/bash-while-loop/](https://linuxize.com/post/bash-while-loop/)'
- en: '[https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_09_02.html](https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_09_02.html)'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_09_02.html](https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_09_02.html)'
- en: '[https://www.redhat.com/sysadmin/bash-scripting-while-loops](https://www.redhat.com/sysadmin/bash-scripting-while-loops)'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.redhat.com/sysadmin/bash-scripting-while-loops](https://www.redhat.com/sysadmin/bash-scripting-while-loops)'
- en: The test-if loop
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试-如果循环
- en: When strictly talking about loops, we usually divide them into `for` and `while`
    loops. There are some other structures that we sometimes call loops, even though
    they are more structured like a block of commands. Other names for these could
    be `decision` loops or `decision` blocks, but for legacy reasons, they are usually
    referred to as `test-if` loops, `case` loops, or `logical` loops.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，当谈到循环时，我们通常将它们分为`for`循环和`while`循环。还有一些其他结构，我们有时也称之为循环，尽管它们更像是命令块的结构。这些结构有时被称为`decision`循环或`decision`块，但出于传统原因，它们通常被称为`test-if`循环、`case`循环或`logical`循环。
- en: The primary idea behind this is that any decision-making part of the code actually
    branches the code into different paths containing blocks of commands. Since branching
    and decision-making is probably the most important thing you will do in your scripts,
    we are going to show you some of the most commonly used structures that will find
    their way, more or less, into any script you make.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 其背后的主要思想是，任何决策性部分的代码实际上都会将代码分支到包含命令块的不同路径中。由于分支和决策是你在脚本中最常做的事情之一，我们将向你展示一些最常用的结构，这些结构或多或少会出现在你编写的任何脚本中。
- en: Getting ready
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, the most important thing is to understand that for any conditional
    branching, or for that matter, any conditions that you put in your code, you will
    use logical expressions. Logical expressions are, simply put, statements that
    can be either true or false.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个教程，最重要的是理解，对于任何条件分支，或者说任何你在代码中放入的条件，你将使用逻辑表达式。简单来说，逻辑表达式就是可以为真或为假的语句。
- en: 'Take, for example, statements such as the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下语句：
- en: The `something.txt` file exists.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`something.txt` 文件存在。'
- en: The number `2` is greater than the number `0`.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字`2`大于数字`0`。
- en: The `somedir` directory exists and is readable by the user Joe.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`somedir` 目录存在且 Joe 用户可以读取。'
- en: The `unreadable.txt` file is not readable by any user.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unreadable.txt` 文件任何用户都无法读取。'
- en: Every statement here is something that can be either true or false. The most
    important thing here is that there are no other logical states that we can define
    about any of the statements. Another thing is that every statement here refers
    to a particular object, a file, a directory, or a number, and gives us some attribute
    or state of that object.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的每个语句都是可以为真或为假的。最重要的是，这里没有其他逻辑状态可以定义在任何语句上。另一个需要注意的点是，这里每个语句都指向一个特定的对象，比如文件、目录或数字，并且给我们该对象的某些属性或状态。
- en: Having this in mind, we are going to introduce shell testing as a concept and
    then use it to help us work on our scripts.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 牢记这一点，我们将介绍 Shell 测试的概念，然后使用它来帮助我们编写脚本。
- en: How to do it…
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: We already introduced the concept of the `if` statement using `condition` to
    branch to one of the *evaluated* blocks of code. This condition has to be met,
    which means it needs to be resolved into a `true` or `false` statement. The `if`
    command is then going to decide which part of the code is going to run.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经引入了使用`condition`的`if`语句，以便将代码分支到其中一个*已评估*的代码块中。这个条件必须得到满足，这意味着它需要被解析为`true`或`false`语句。然后，`if`命令会决定哪一部分代码将被执行。
- en: This evaluation is also called *testing*, and there are two ways of doing it
    in shell. The `bash` shell has a command called `test` that is sometimes used
    in scripts. This command takes an *expression* and evaluates it to see whether
    the result is true or false. The result of the command is not printed in the output,
    but instead, the command assigns its *exit status* to the appropriate value.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这种评估也叫做*测试*，并且在 shell 中有两种方法可以执行测试。`bash` shell 有一个叫做`test`的命令，有时会在脚本中使用。这个命令接受一个*表达式*并对其进行评估，以查看结果是
    `true` 还是 `false`。命令的结果不会在输出中打印出来，而是将其*退出状态*分配给相应的值。
- en: Exit status is a value that each command will set after finishing, and we can
    check it from inside the command line, or from our script. This status is usually
    used to either see whether there were any errors executing a particular command
    or to pass some information, such as a logical value of a tested expression.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 退出状态是每个命令在完成后会设置的一个值，我们可以从命令行内部或从脚本中检查它。这个状态通常用来查看是否执行特定命令时发生了错误，或者传递一些信息，比如测试表达式的逻辑值。
- en: In order to test exit status, we can use a simple `echo` command. Let's do a
    few examples using a simple expression and the `test` command.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试退出状态，我们可以使用一个简单的`echo`命令。让我们通过一些示例，使用简单的表达式和`test`命令来演示。
- en: 'The first example uses the `echo` command to write out what the exit status
    was of the `test` command. In all the examples, `0` means `true` and `1` means
    `false`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个例子使用`echo`命令输出`test`命令的退出状态。在所有例子中，`0`表示`true`，`1`表示`false`：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: So, how come we got a result that says that `1=0` is true? We made a syntax
    error (on purpose) to show you probably the most common mistake in scripting.
    All commands will usually use a very strict syntax, and *test* is not an exception.
    The problem with this particular command is that it will not show an error; instead,
    it is going to just treat our expression like it is *one single argument* and
    then decide it is `true`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么我们得到了`1=0`是对的结果呢？我们故意犯了一个语法错误，目的是向你展示脚本中最常见的错误。所有命令通常都会使用非常严格的语法，而*test*命令也不例外。这个命令的问题在于它不会显示错误；相反，它会将我们的表达式当作*一个单一的参数*来处理，然后认为它是`true`。
- en: 'We can check this by using a completely nonsensical argument, such as a single
    word:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用一个完全无意义的参数来检查这一点，比如一个单词：
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As you can see, the result is logically true, even if it does not make any
    real sense. In reality, `test` requires spaces to understand which part of the
    expression is the operator and what are the operands. The right way to write our
    previous example is as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，结果在逻辑上是对的，即使它在实际中没有任何意义。实际上，`test`命令需要空格来理解表达式的各个部分是运算符还是操作数。我们之前例子的正确写法应该是这样的：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This is the result we expected. To check, we are going to try evaluating another
    expression:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们预期的结果。为了检查，我们将尝试评估另一个表达式：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: So, this one is true. This is completely what we expected. The reason we are
    using quotation marks here is that we are not actually evaluating numbers; we
    are comparing *strings*. What if we remove the quotation marks?
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这个是对的。完全符合我们的预期。我们使用引号的原因是我们实际上不是在评估数字，而是在比较*字符串*。如果我们去掉引号会怎么样？
- en: '[PRE25]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This also works okay; just to check, we are going to retry with something that
    should be false:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这也没问题；只是为了检查，我们将重新尝试一个应该是假的表达式：
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The result is also completely what we expected to see. Let''s now try something
    else. We said there is a difference between comparing numbers and strings. A number
    has the same value regardless of the number of zeroes preceding it:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 结果也完全是我们预期的样子。现在让我们尝试别的东西。我们曾说过，比较数字和字符串之间是有区别的。一个数字的值是固定的，无论它前面有多少个零：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Our command now states that these two are not equal. Why? Because the *strings*
    are not equal. `Bash` uses different operators to compare strings and numbers,
    and since we used the `1` for the strings, these values are not the same. The
    same goes for using them in quotation marks, just to show how quotes are handled:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的命令现在表示这两个不相等。为什么？因为*字符串*不相等。`Bash`使用不同的运算符来比较字符串和数字，而由于我们为字符串使用了`1`，所以这两个值不相同。即使使用引号也是如此，下面是如何处理引号的演示：
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The operator that we should have used for integer comparison is `-eq`; it will
    understand that we are comparing numbers and compare them accordingly:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该使用的整数比较运算符是`-eq`；它会理解我们在比较数字，并根据此进行比较：
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Regardless of whether we are using quotes or not, the result should be the
    same:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们是否使用引号，结果应该是一样的：
- en: '[PRE30]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'For the last example, we are going to see what happens when we confuse the
    operators the other way around and try to compare strings using the integer comparison:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最后一个例子，我们将看看当我们把运算符反过来使用并尝试使用整数比较来比较字符串时会发生什么：
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: What does this result mean? First, our test tried to evaluate the condition
    and realized there is an error in comparison, since it cannot compare a string
    and an integer or, to be more precise, that an integer cannot contain letters.
    We got the error in our output, so the command exited with the `2` status, which
    signifies an error. The result logically makes no sense, so the result is neither
    `0` nor `1`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果意味着什么？首先，我们的测试尝试评估条件，并意识到比较有误，因为它不能比较字符串和整数，或者更准确地说，一个整数不能包含字母。我们在输出中得到了错误，因此命令以`2`状态退出，这表示出现错误。结果在逻辑上没有意义，所以结果既不是`0`也不是`1`。
- en: 'The next thing we need to do is implement what we learned in actual scripting,
    but before that, we need to address one more thing. There are two ways to create
    our tests. One is by explicitly using the `test` command. Another is by using
    square brackets (`[ ]`). While we are going to use `test` a lot when we need to
    run something in the command line depending on some condition, when using the
    `if` statement, we are going to use square brackets most of the time, since they
    are easier to write and look better when glancing over the script. Just to make
    sure, here is one of the expressions we used, written in a different way. Please
    pay attention to the spaces inside the brackets; there needs to be a single space
    between the brackets and the expression we are using:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步我们需要做的是将所学内容应用到实际脚本中，但在此之前，我们需要再解决一个问题。创建测试的方式有两种。一种是显式使用`test`命令，另一种是使用方括号（`[
    ]`）。虽然在需要根据某些条件在命令行运行某些命令时我们会经常使用`test`，但在使用`if`语句时，我们大多数时候会使用方括号，因为它们更易于书写，并且在浏览脚本时看起来更整洁。为了确保理解，下面是我们使用的一个表达式，以不同的方式写出。请注意方括号内的空格；方括号和我们使用的表达式之间需要有一个空格：
- en: '[PRE32]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How it works…
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: We are going to write a small script that is going to test whether a file exists
    in the directory the script was run from. For that, we need to talk a little about
    some other operators that we can use.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个小脚本来测试文件是否存在于脚本运行的目录中。为此，我们需要讨论一些我们可以使用的其他运算符。
- en: 'If you take a look at the `man` page for the `test` command or at a `bash`
    manual, you will see that there are many different tests we can do, depending
    on what we want to check; the most common ones we are going to use are probably
    the following (taken directly from the man pages for `test(1)`):'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看`man`页面中的`test`命令或`bash`手册，你会看到有许多不同的测试，我们可以根据想要检查的内容来选择；我们最常用的测试可能如下（直接取自`test(1)`的手册页）：
- en: 'The `-d` file: The file exists and is a directory.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-d`文件：文件存在并且是一个目录。'
- en: 'The `-e` file: The file exists.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-e`文件：文件存在。'
- en: 'The `-f` file: The file exists and is a regular file.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-f`文件：文件存在并且是常规文件。'
- en: 'The `-r` file: The file exists and read permission is granted.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-r`文件：文件存在且具有读取权限。'
- en: 'The `-s` file: The file exists and has a size greater than zero.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-s`文件：文件存在并且大小大于零。'
- en: 'The `-w` file: The file exists and write permission is granted.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-w`文件：文件存在并且具有写入权限。'
- en: 'The `-x` file: The file exists and execute (or search) permission is granted.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-x`文件：文件存在并且具有执行（或搜索）权限。'
- en: 'Let''s create a script using this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这个来创建一个脚本：
- en: '[PRE33]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Probably the most important thing to learn here is the structure and the use
    of the `else` statement. There are two blocks or *parts* of code we define in
    an `if` statement – one is called `then` and the other `else`. They do as their
    names suggest; if the condition we used in the statement evaluates as true, then
    the `then` code block is going to get executed. If the condition is not met, then
    the `else` block will be run. These blocks are mutually exclusive; only one of
    them is going to get run.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这里最重要的内容可能是学习`else`语句的结构和用法。在`if`语句中，我们定义了两个代码块或*部分*——一个叫做`then`，另一个叫做`else`。它们的作用如其名；如果我们在语句中使用的条件为真，那么`then`代码块将会被执行。如果条件不成立，则会执行`else`代码块。这两个代码块是互斥的；它们中只会有一个被执行。
- en: Now, we are going to deal with a topic that will sometimes confuse you. We already
    mentioned that a script has a context it is running in. Among other things, there
    are two things you need to know every time your script is running – where it was
    run from and which user ran the script.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们要处理一个有时会让你感到困惑的话题。我们已经提到，脚本有一个它运行的上下文。除了其他事项之外，你每次运行脚本时需要知道两件事——它是从哪里运行的，以及是哪个用户运行了脚本。
- en: These two pieces of information are crucial, since they define how we are going
    to reference the files we need and what permissions we will have from inside of
    the script.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这两条信息至关重要，因为它们定义了我们如何引用需要的文件，以及从脚本中可以获得哪些权限。
- en: 'Our next task is going to be to create a script that will show us how to deal
    with all of this. What we are going to do is test whether the script can read
    and write the `root` directory and whether the directory even exists. The reference
    we are going to make to this directory is going to be relative, so we are going
    to presume that our script is being run from the `/` directory, which is usually
    false. Then, we are going to try and run the script in different directories and
    under different users, comparing the results:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的任务是创建一个脚本，展示如何处理所有这些问题。我们将测试脚本是否可以读取和写入`root`目录，以及该目录是否存在。我们对这个目录的引用将是相对的，因此我们假设脚本是从`/`目录运行的，尽管通常情况下并非如此。然后，我们将尝试在不同的目录和不同的用户下运行脚本，并比较结果：
- en: '[PRE34]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As you can see, we are basically testing for three different conditions. First,
    we are trying to see whether the directory exists at all and, after that, whether
    the script has read and write permissions.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们基本上在测试三种不同的条件。首先，我们试图检查目录是否存在，其次是检查脚本是否具有读写权限。
- en: 'First, we are going to try and run this as the current user in the directory
    that the script is created in. Then, we are going to go to the `/` directory and
    run it from there:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在脚本创建的目录中作为当前用户尝试运行它。然后，我们将转到`/`目录并从那里运行它：
- en: '[PRE35]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: What does all this tell us? Our first run was unable to find the directory since
    we were using a relative path in the script. This makes the directory that the
    script is run from important.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这些信息告诉我们什么？第一次运行时，由于我们在脚本中使用了相对路径，所以无法找到该目录。这使得脚本运行时的目录变得非常重要。
- en: 'Another thing we learned is how our checks work. We can independently check
    whether a file or directory exists, and different permissions that the current
    user has on a particular file. We are going to show that by running the script
    under a `root` user using the `sudo` command:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学到的另一个东西是如何进行检查。我们可以独立检查文件或目录是否存在，以及当前用户对特定文件拥有的不同权限。我们将通过在`root`用户下使用`sudo`命令来运行脚本来演示这一点：
- en: '[PRE36]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As soon as we change the context, we can see that the same script is not only
    able to see that the directory is there but also has full rights to use it.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们改变了上下文，就可以看到同一个脚本不仅能够看到该目录存在，而且还拥有完全的使用权限。
- en: 'Now, we are going to completely change our script to demonstrate how we can
    embed our checks into one another. Our script will once again test whether the
    `root` directory is in the current directory, but this time, the script is going
    to check whether it has read and write rights only if the directory exists. After
    all, it makes no sense to see whether you can read a directory that isn''t there:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将完全修改我们的脚本，演示如何将检查嵌套在一起。我们的脚本将再次测试`root`目录是否在当前目录中，但这次，只有在目录存在时，脚本才会检查是否具有读写权限。毕竟，检查一个不存在的目录是否可以读取是没有意义的：
- en: '[PRE37]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, we are going to run it in two directories to see if our script works;
    the main difference should be the output. Also, when you have a nested structure
    such as this one, always try to keep your indentation consistent. This means that
    you always should try to keep commands in the same block indented in such a way
    that it is immediately obvious where each command belongs:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在两个目录中运行它，以查看我们的脚本是否有效；主要的区别应该在于输出。同时，当你有这样的嵌套结构时，始终保持缩进的一致性非常重要。这意味着你应该始终确保同一块中的命令缩进一致，这样可以立刻清楚地知道每个命令属于哪个部分：
- en: '[PRE38]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We have now seen what can be done with different tests and conditions in `bash`.
    The next topic is similar to this one – the `case` statement or `case` loop.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到如何在`bash`中使用不同的测试和条件。接下来的话题与此类似——`case`语句或`case`循环。
- en: See also
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: '[https://www.thegeekdiary.com/bash-if-loop-examples-if-then-fi-if-then-elif-fi-if-then-else-fi/](https://www.thegeekdiary.com/bash-if-loop-examples-if-then-fi-if-then-elif-fi-if-then-else-fi/)'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.thegeekdiary.com/bash-if-loop-examples-if-then-fi-if-then-elif-fi-if-then-else-fi/](https://www.thegeekdiary.com/bash-if-loop-examples-if-then-fi-if-then-elif-fi-if-then-else-fi/)'
- en: '[https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_07_01.html](https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_07_01.html)'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_07_01.html](https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_07_01.html)'
- en: '[https://ryanstutorials.net/bash-scripting-tutorial/bash-if-statements.php](https://ryanstutorials.net/bash-scripting-tutorial/bash-if-statements.php)'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://ryanstutorials.net/bash-scripting-tutorial/bash-if-statements.php](https://ryanstutorials.net/bash-scripting-tutorial/bash-if-statements.php)'
- en: The case loop
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: case 循环
- en: Up until now, we have dealt with basic commands that allow us to do things we
    need when trying to write a script, such as looping, branching, breaking, and
    continuing program flow. A `case` loop, the topic of this recipe, is not strictly
    necessary, since the logic behind it can be created using a multi-nested group
    of individual `if` commands. The reason we are even mentioning this is simply
    because `case` is something that we are going to use a lot in our scripts, and
    the alternative of using `if` statements is both difficult to write and read,
    and complicated to debug.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经处理了一些基本命令，这些命令允许我们在编写脚本时完成必要的操作，比如循环、分支、跳出和继续程序流程。`case` 循环，本食谱的主题，并不是严格必要的，因为其背后的逻辑可以通过多层嵌套的
    `if` 命令来实现。我们之所以提到这个，纯粹是因为 `case` 是我们在脚本中会频繁使用的东西，而使用 `if` 语句的替代方案不仅难以编写和阅读，而且调试起来也很复杂。
- en: Getting ready
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: One could simply say that a `case` loop or `case` statement is just another
    way of writing multiple `if then else` tests. `Case` is not something that can
    be used in place of a normal `if` statement, but there is a common situation in
    which a `case` statement makes our lives a lot less complicated and our scripts
    much easier to debug and understand. But before we go into that, we need to understand
    a little bit about variables and branching. Once we start using `if` statements,
    we are quickly going to realize that they can be used, more or less, in two distinct
    ways. The first is the one everyone thinks about when thinking about an `if` statement
    – we have a variable and we compare it to another variable or a value. This is
    common and often done in a script. Something a little less common is when we have
    to compare a variable to a list of values. This happens most often when we need
    to sort things into groups or run a block of code depending on the user input.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 可以简单地说，`case` 循环或 `case` 语句只是另一种编写多个 `if then else` 测试的方式。`case` 并不能代替普通的 `if`
    语句，但有一个常见的情况，在这种情况下，`case` 语句能让我们的生活变得更加简单，脚本也更容易调试和理解。但在我们深入讨论之前，我们需要先了解一些关于变量和分支的知识。一旦我们开始使用
    `if` 语句，就会迅速意识到它们大致可以用两种不同的方式。第一种是大家在想到 `if` 语句时最常考虑的方式——我们有一个变量，并将它与另一个变量或一个值进行比较。这是很常见的，也是脚本中经常使用的。稍微不那么常见的是，当我们需要将一个变量与一组值进行比较时。这通常出现在我们需要将事物分类或根据用户输入执行某个代码块时。
- en: User input is probably the most popular reason a `case` statement is used. In
    scripts, this is often used once we start using arguments. Our scripts will have
    to reconfigure things based on what arguments the user chose when running the
    script. We will take a look at that a little bit later when we start dealing with
    passing arguments to a script, which will exclusively use `case` statements to
    run appropriate commands.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 用户输入可能是使用 `case` 语句最常见的原因。在脚本中，当我们开始使用参数时，通常会用到它。我们的脚本需要根据用户在运行脚本时选择的参数重新配置内容。稍后当我们开始处理传递参数到脚本时，我们将专门使用
    `case` 语句来执行相应的命令。
- en: User menus are another thing that is solved by using `case` statements; to generalize,
    each time a user has a multiple-choice answer to a question, this is going to
    get handled by a `case` statement.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 用户菜单是另一个通过使用 `case` 语句解决的问题；广义来说，每次用户需要对一个问题作出多项选择时，都可以通过 `case` 语句来处理。
- en: How to do it…
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: The best way to explain a `case` statement is by creating an example. Let's
    say that a user starts a script, and they have four choices of what they want
    the script to do. Right now, we are not prepared to deal with how they will input
    their choice, so let's just presume that there is a variable called `$1` that
    contains one of these values – `copy`, `delete`, `move`, and `help`. Our script
    will have to run the appropriate part of the code based on user input. In fact,
    this is the way arguments are handled, but we will talk about that later.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 解释 `case` 语句的最佳方法是通过一个例子。假设一个用户启动了一个脚本，他们有四个选项可以选择脚本执行的操作。现在，我们还没有准备好处理用户输入的方式，所以我们暂且假设有一个变量
    `$1`，它包含了以下四个值中的一个——`copy`、`delete`、`move` 和 `help`。我们的脚本需要根据用户的输入执行相应的代码部分。事实上，这就是如何处理参数的方法，不过我们稍后会讨论这一点。
- en: 'Our first version is going to use the `if – then – elif` loop:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个版本将使用 `if – then – elif` 循环：
- en: '[PRE39]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This works, but it has two problems. One is that it throws errors if there
    are no arguments given, since this means we are comparing a value to a variable
    without a value. The other problem is that this is complicated to read, even if
    we pay extra attention to using the right indentation. We are going to redo this
    using a `case` statement:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法有效，但有两个问题。一个是如果没有提供参数，它会抛出错误，因为这意味着我们在比较一个值和一个没有值的变量。另一个问题是，即使我们特别注意使用正确的缩进，这段代码也很难阅读。我们将使用`case`语句重新编写：
- en: '[PRE40]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The first thing you will notice is how simple and clean this looks. As well
    as being easier to write, the code is much easier to read and debug if we need
    to. There are just two simple things to pay attention to – the end of the statement
    block is defined as `esac`, which is `case` spelled backward, similar to how the
    `if` statement is terminated by `fi`. Another thing is that you have to use `;;`
    to terminate a line, since that's what's used to delimit choices in the `case`
    loop.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先会注意到的是，这看起来非常简单和清晰。除了更容易编写之外，如果需要的话，代码也更容易阅读和调试。只需注意两件简单的事——语句块的结束由`esac`定义，这是`case`反过来拼写的，类似于`if`语句通过`fi`来结束。另一个是你必须使用`;;`来终止一行，因为这是在`case`循环中用于分隔选项的符号。
- en: When matching values, you can also use limited regular expressions; this is
    the reason that the `*` `glob` is used to symbolize *zero or more characters*.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在匹配值时，你还可以使用有限的正则表达式；这也是为什么使用`*` `glob`来表示*零个或多个字符*。
- en: How it works…
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: Now that we know a lot more about scripting, we are going to do a simple script
    that searches for a string in a directory and lets us know what happened. We don't
    care about where the text is; we just want to know whether there is text that
    we used somewhere in the directory we ran our script in.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了更多关于脚本编写的内容，我们将编写一个简单的脚本，在一个目录中搜索一个字符串并告诉我们发生了什么。我们不关心文本在哪里；我们只想知道我们在运行脚本的目录中是否有使用过该文本。
- en: 'The things we need to know before we even start are as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，我们需要了解以下内容：
- en: '`$1` is going to hold a string value that is going to be the text we are searching
    for.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$1` 将保存一个字符串值，这个值是我们要搜索的文本。'
- en: '`$?` holds the `exit` value of a command that was just completed in the script.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$?` 保存了刚刚在脚本中完成的命令的`exit`值。'
- en: '`grep` as a command returns either `0` if it found something, `1` if it didn''t,
    or `2` if there was an error.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`grep`作为命令返回`0`（如果找到内容），`1`（如果没有找到），或`2`（如果发生错误）。'
- en: There is a special device called `/dev/null` that can be used if we need to
    silence some output.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个特殊的设备`/dev/null`，如果我们需要消除一些输出，可以使用它。
- en: 'Thanks to the `case` statement, this is a trivial task:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了`case`语句，这成了一项简单的任务：
- en: '[PRE41]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: For the last script, we are going to use `case` to combine another script from
    this chapter that was testing a directory and put it into a larger script. We
    are going to create a script that will be given a command and a filename as arguments.
    The command is going to be either `check`, `copy`, `delete`, or `help`. If we
    specify either `copy` or `delete`, the script will check whether it has the permissions
    to do the task and then the `echo` command that it would normally call.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最后一个脚本，我们将使用`case`来结合本章中另一个测试目录的脚本，并将其放入一个更大的脚本中。我们将创建一个接受命令和文件名作为参数的脚本。命令将是`check`、`copy`、`delete`或`help`。如果我们指定了`copy`或`delete`，脚本将检查是否有权限执行该任务，然后执行它通常会调用的`echo`命令。
- en: 'If we specify `check`, the script is going to check for permissions on a given
    file:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们指定`check`，脚本将检查给定文件的权限：
- en: '[PRE42]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'What we have done here is combine everything that we have done so far into
    a script that actually does something. The only thing we haven''t mentioned before
    is `$2` as the second argument in the script. In this case, we use it to get the
    filename we need to run the commands. This is how it all looks when run from the
    command line:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的就是将到目前为止做过的所有事情结合成一个实际执行的脚本。我们之前没有提到的唯一一件事是脚本中的第二个参数`$2`。在这种情况下，我们使用它来获取需要运行命令的文件名。以下是从命令行运行时的效果：
- en: '[PRE43]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: See also
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: 'When it comes to using `case` in your scripts, you will soon realize that a
    lot of examples are copied and pasted between sites. The following links are two
    good sources:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在脚本中使用`case`时，你会很快发现很多示例是从不同网站复制粘贴的。以下链接是两个很好的资源：
- en: https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_07_03.html
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_07_03.html
- en: https://www.shellhacks.com/case-statement-bash-example/
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: https://www.shellhacks.com/case-statement-bash-example/
- en: Logical looping with and, or, and not
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `AND`、`OR` 和 `NOT` 进行逻辑循环
- en: There is no way to escape logic when it comes to computers. We already dealt
    with some things you can do with evaluating conditions, but there is a lot more
    that can be done in `bash`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机中，逻辑是无法逃避的。我们已经处理了一些可以用来评估条件的操作，但在 `bash` 中还有很多其他操作可以进行。
- en: In this recipe, we are going to deal with different logical operators that help
    us with scripting in general. First, we are going to deal with what can be done
    on the command line, and then we are going to use that in scripts.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将介绍一些不同的逻辑运算符，它们有助于我们在脚本编写中解决问题。首先，我们将讨论在命令行上可以完成的操作，然后再将其应用到脚本中。
- en: Getting ready
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'First, let''s quickly talk about logic operators. So far, we mentioned expressions
    that have a value of true and false. We also mentioned a lot of different expressions
    that are built into `bash`, since they provide functionality crucial for everyday
    work on the command line. Now is the time to talk about logical operators that
    help us combine expressions and create complex solutions. We are going to start
    with the usual operators:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们快速讨论一下逻辑运算符。到目前为止，我们提到了值为 true 或 false 的表达式。我们还提到了一些 `bash` 中内置的各种不同表达式，因为它们提供了在命令行上日常工作中至关重要的功能。现在是时候谈谈逻辑运算符，它们帮助我们将表达式组合起来，创建复杂的解决方案。我们将从常见的运算符开始：
- en: '`&&` (the logical `AND`)'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`&&`（逻辑 `AND`）'
- en: '`||` (the logical `OR`)'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`||`（逻辑 `OR`）'
- en: The interesting thing about these is that they can be used directly on the command
    line. The command line in `bash` basically has four ways of executing commands.
    One is to run them one by one on each line. This is the usual way we work in interactive
    mode.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这些运算符的有趣之处在于它们可以直接在命令行上使用。在 `bash` 中，命令行有四种执行命令的方式。其中一种是逐行运行命令。这是我们在交互模式下工作的常见方式。
- en: How to do it…
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现……
- en: 'Sometimes, we need (or want) to run multiple commands on one line. This is
    mostly done by using `;` to separate commands, such as the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要（或希望）在一行上运行多个命令。这通常通过使用 `;` 来分隔命令，例如：
- en: '[PRE44]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As we can see, it is exactly the same as if we ran each command by itself, but
    shell just executes them in a row. We already used this when we tested different
    expressions using the `test` command. We needed to check what the exit status
    was of that command, so we always used `echo` directly after running the test.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这与单独运行每个命令完全相同，但 shell 会按顺序执行它们。当我们使用 `test` 命令测试不同的表达式时，我们已经用到了这一点。我们需要检查该命令的退出状态，因此在运行测试后我们总是直接使用
    `echo`。
- en: Sometimes, however, we can use a little logic to create shortcuts. This is where
    logical operators come into play. The remaining two ways to run multiple commands
    use them to not only run the command but also to run them conditionally.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时我们可以使用一些逻辑来创建快捷方式。这时，逻辑运算符发挥了作用。剩下的两种运行多个命令的方法，使用它们不仅运行命令，还可以根据条件运行命令。
- en: 'Imagine we want to perform a command after we make some kind of test – for
    example, we want to open a file but only if the file actually exists. We could
    write an `if` statement here, but it would make absolutely no sense to complicate
    things like that. This is where we can use the logical `AND`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想在进行某些测试后执行一个命令——例如，我们想要打开一个文件，但仅当该文件确实存在时。我们可以在这里写一个 `if` 语句，但将事情复杂化完全没有意义。这时我们可以使用逻辑
    `AND`：
- en: '[PRE45]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In general, using `&&` between commands tells `bash` to run the command on the
    right only if the command on the left succeeded. In our example, this means that
    we have a file named `output` in our directory. On the left, we are doing a quick
    test if this file exists. Once this is successful, we run `cat` to output the
    file contents.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在命令之间使用 `&&` 告诉 `bash` 只有在左侧命令成功时，才运行右侧的命令。在我们的示例中，这意味着我们在目录中有一个名为 `output`
    的文件。在左侧，我们快速测试文件是否存在。一旦测试成功，我们运行 `cat` 来输出文件内容。
- en: In the second example, we intentionally used the wrong filename, and the `cat`
    command hasn't been run, since the file is not there.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个示例中，我们故意使用了错误的文件名，而 `cat` 命令没有被执行，因为文件不存在。
- en: 'Another logical operand we can use is the logical `OR`. The operator to use
    is `||` in the same way as before. This operator instructs `bash` to run the command
    on the right only if the command on the left failed:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个我们可以使用的逻辑运算符是逻辑 `OR`。使用的运算符是 `||`，与之前一样。这个运算符指示 `bash` 只有在左侧命令失败时，才运行右侧的命令：
- en: '[PRE46]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This is the exact opposite of the previous example. Our `cat` command ran only
    when the test failed. A structure such as this is sometimes used in scripts to
    create fail-safes or to quickly run things such as updates.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这是与前一个示例完全相反的情况。我们的`cat`命令只有在测试失败时才会执行。像这样的结构有时会在脚本中使用，以创建故障保护机制或快速运行诸如更新之类的任务。
- en: 'What is nice is that this enables us to immediately do something, depending
    on the test:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 好的一点是，这使我们能够根据测试的结果立即执行某些操作：
- en: '[PRE47]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: These operators also exist in test expressions, allowing us to create different
    conditions that would otherwise require multiple `if` statements.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这些运算符也存在于测试表达式中，允许我们创建不同的条件，否则需要多个`if`语句。
- en: How it works…
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Testing a condition is hopefully now completely familiar to you. We are going
    to try and combine a few of them to explain what different operators can do. For
    example, if we want to quickly check whether a file exists and is readable, we
    can do it by either testing whether it is readable or explicitly combining those
    two things into one statement:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 测试条件现在应该对你来说完全熟悉了。我们将尝试结合几个条件来解释不同运算符的作用。例如，如果我们想快速检查一个文件是否存在并且可读，我们可以通过测试它是否可读，或者明确地将这两者结合成一个语句来实现：
- en: '[PRE48]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'These tests are going to be most useful when dealing with strings and numbers.
    For instance, we can try and find whether a number is within an interval in a
    script, as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试在处理字符串和数字时最为有用。例如，我们可以尝试在脚本中检查一个数字是否在一个区间内，如下所示：
- en: '[PRE49]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We are going to run this script, but before we even do that, we can see that
    it looks complicated, more than it should be. It is not just the fact that we
    have to use two `if` statements to make sure that we handle both parts of the
    outside interval; this script demands a lot of explanations, even though it is
    only a couple of lines long. Does it work? Yes, as we can see here:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要运行这个脚本，但在我们开始之前，可以看到它看起来很复杂，比应有的复杂。问题不仅仅在于我们必须使用两个`if`语句来确保处理外部区间的两个部分；即使这个脚本只有几行，它也需要大量的解释。它能正常工作吗？是的，正如我们在这里看到的：
- en: '[PRE50]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, we are going to use logical operators to optimize our script:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用逻辑运算符来优化我们的脚本：
- en: '[PRE51]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We are using double brackets here because we have to. There are multiple ways
    to achieve the same goal, and there are some older versions of the syntax, but
    it is best practice to use double brackets when dealing with multiple expressions.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用双括号是因为我们必须这么做。有多种方式可以实现相同的目标，还有一些旧版本的语法，但处理多个表达式时，最好使用双括号。
- en: See also
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: 'Dealing with logical operators is, in part, complicated because there are so
    many of them. You can find much more information here:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 处理逻辑运算符部分之所以复杂，是因为它们种类繁多。你可以在这里找到更多信息：
- en: '[https://linuxhint.com/bash_operator_examples/#o23](https://linuxhint.com/bash_operator_examples/#o23)'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://linuxhint.com/bash_operator_examples/#o23](https://linuxhint.com/bash_operator_examples/#o23)'
- en: '[https://opensource.com/article/19/10/programming-bash-logical-operators-shell-expansions](https://opensource.com/article/19/10/programming-bash-logical-operators-shell-expansions)'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://opensource.com/article/19/10/programming-bash-logical-operators-shell-expansions](https://opensource.com/article/19/10/programming-bash-logical-operators-shell-expansions)'
