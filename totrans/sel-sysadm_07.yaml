- en: '*Chapter 6*: Configuring SELinux through Infrastructure-as-Code Orchestration'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第六章*：通过基础设施即代码编排配置 SELinux'
- en: 'With the advent of large distributed application platforms, cloud services,
    and the high adoption of virtualized infrastructure, system administrators are
    actively managing their systems through **Infrastructure-as-Code** frameworks:
    orchestration and configuration tooling that uses source code-like information
    to manage the systems.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 随着大型分布式应用平台、云服务的出现，以及虚拟化基础设施的广泛采用，系统管理员正通过**基础设施即代码（Infrastructure-as-Code）**框架来积极管理他们的系统：这些框架使用类似源代码的信息来管理系统，包括编排和配置工具。
- en: 'In this chapter, administrators will learn how to distribute and load custom
    SELinux policy modules, set file context definitions and apply those to the systems,
    set the permissive state of the system or SELinux domains, configure the SELinux
    settings on the systems, and how to customize SELinux actions if they are not
    supported by the tooling. We will apply this with four popular automation frameworks:
    Ansible, Chef, Puppet, and SaltStack.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，管理员将学习如何分发和加载自定义 SELinux 策略模块，设置文件上下文定义并将其应用到系统，设置系统或 SELinux 域的宽松状态，配置系统上的
    SELinux 设置，以及如何在工具不支持的情况下自定义 SELinux 操作。我们将使用四个流行的自动化框架来进行应用：Ansible、Chef、Puppet
    和 SaltStack。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introducing the target settings and policies
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍目标设置和策略
- en: Using Ansible for SELinux system administration
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Ansible 进行 SELinux 系统管理
- en: Utilizing SaltStack to configure SELinux
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用 SaltStack 配置 SELinux
- en: Automating system management with Puppet
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Puppet 自动化系统管理
- en: Wielding Chef for system automation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Chef 进行系统自动化
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code files for this chapter can be found in our Git repository at [https://github.com/PacktPublishing/SELinux-System-Administration-Third-Edition](https://github.com/PacktPublishing/SELinux-System-Administration-Third-Edition).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在我们的 Git 仓库中找到：[https://github.com/PacktPublishing/SELinux-System-Administration-Third-Edition](https://github.com/PacktPublishing/SELinux-System-Administration-Third-Edition)。
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/2T4Fksv](https://bit.ly/2T4Fksv)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，了解代码的实际操作：[https://bit.ly/2T4Fksv](https://bit.ly/2T4Fksv)
- en: Introducing the target settings and policies
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍目标设置和策略
- en: Before we embark on the journey of using these four automation frameworks, we
    need to clarify what we want to accomplish. After all, to truly compare automation
    frameworks, we need to test each framework with the same tests each time.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用这四个自动化框架之前，我们需要明确我们希望实现的目标。毕竟，要真正比较自动化框架，我们需要每次使用相同的测试来测试每个框架。
- en: The idempotency of actions
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作的幂等性
- en: Whenever we create a remote management environment with a central repository,
    we need to consider the impact of running remote management activities on the
    system. A very common best practice, strongly adopted by all these frameworks,
    is idempotency.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们创建一个带有中央存储库的远程管理环境时，需要考虑运行远程管理活动对系统的影响。一个非常常见的最佳实践，所有这些框架都强烈采纳的，就是幂等性。
- en: 'An **idempotent** task is a task that will not modify a system if the system''s
    state is already how it should be. Or, differently put, repeatedly executing a
    task does not affect the system or the processes that run on it if nothing needs
    to be changed. As an example, consider loading an SELinux module: if the module
    is already loaded, then the module should not be reloaded. If it isn''t loaded
    yet, then we will load the proper module.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**幂等**任务是指如果系统的状态已经是所需的状态，那么执行该任务不会修改系统。换句话说，重复执行一个任务不会影响系统或正在运行的进程，前提是无需进行更改。例如，考虑加载
    SELinux 模块：如果模块已经加载，则不应重新加载该模块。如果模块尚未加载，则会加载适当的模块。'
- en: While most actions supported by the automation frameworks are idempotent, we
    will need to create custom actions ourselves if the framework does not support
    what we want. For instance, if the framework does not support loading SELinux
    modules, then we need to write our own code to do so.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然自动化框架支持的大多数操作都是幂等的，但如果框架不支持我们需要的功能，我们需要自己创建自定义操作。例如，如果框架不支持加载 SELinux 模块，我们就需要编写自己的代码来完成此操作。
- en: Most orchestration frameworks will envelope non-idempotent tasks in a definition
    that is more idempotent. For instance, if a change in a configuration file requires
    a system reboot, then the enveloped definition would be something like *reboot
    after file change*. The engine can check the state of the file (when it changed)
    and the system (when it rebooted) and deduce whether a reboot is needed or not,
    even though a system reboot as a task is a non-idempotent task.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编排框架会将非幂等任务封装在更为幂等的定义中。例如，如果配置文件的更改需要系统重启，那么封装后的定义可能是*在文件更改后重启*。引擎可以检查文件的状态（更改时间）和系统的状态（重启时间），从而推断是否需要重启，即使系统重启本身是一个非幂等的任务。
- en: Policy and state management
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 策略和状态管理
- en: The first set of scenarios that we want to support through the automation frameworks
    is to ensure that SELinux is active (enforcing) and that the right SELinux policy
    is loaded, a task usually performed by the machine's package management system.
    While allowing the package management system to handle this is convenient, it
    only offers the ability to use distribution-specific default policies. Sysadmins
    of systems with different security requirements will be restrained when using
    default policies and will need to create custom policies and policy handling routines.
    So, we will examine how to distribute and load custom policies.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望通过自动化框架支持的第一个场景是确保SELinux处于活动（强制）模式，并且正确的SELinux策略已加载，这是机器的包管理系统通常执行的任务。虽然让包管理系统处理这一任务比较方便，但它只能使用发行版特定的默认策略。具有不同安全需求的系统的系统管理员在使用默认策略时会受到限制，因此他们需要创建自定义策略和策略处理程序。因此，我们将研究如何分发和加载自定义策略。
- en: 'The custom policy we will use in the examples is a CIL policy, which is very
    new and often not directly supported by the automation frameworks. However, it
    gives us a nice reoccurring situation to create custom rules within the automation
    framework. We store the policy itself in a file called `test.cil` that has the
    following content:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在示例中使用的自定义策略是CIL策略，这是一种非常新的策略，自动化框架通常不直接支持它。然而，它为我们提供了一个很好的重复性场景，允许我们在自动化框架中创建自定义规则。我们将策略本身存储在一个名为`test.cil`的文件中，文件内容如下：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This simple policy will enable logging any transition from the `staff_sudo_t`
    domain to the `sysadm_t` domain and is easy to test out with `sudo`. In our example,
    it serves no other purpose than to quickly allow us to verify that the policy
    has been correctly loaded.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的策略将启用日志记录任何从`staff_sudo_t`域到`sysadm_t`域的过渡，并且可以通过`sudo`快速进行测试。在我们的示例中，它的唯一作用是快速验证策略是否已正确加载。
- en: State-wise, we will ensure that the system is in enforcing mode, but have the
    `zoneminder_t` SELinux domain marked as permissive.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在状态管理方面，我们将确保系统处于强制模式，但将`zoneminder_t` SELinux域标记为宽松模式。
- en: SELinux configuration settings
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SELinux配置设置
- en: The second group of actions we want to take up is to configure the system with
    the various SELinux settings we've discussed in different chapters before. Most
    of these we've seen through the `semanage` commands, and we will learn how the
    various automation frameworks support these entries, and to what extent.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望采取的第二组操作是根据之前章节中讨论的各种SELinux设置来配置系统。我们之前通过`semanage`命令看到过大多数这些设置，我们将学习各种自动化框架如何支持这些设置，并且支持到什么程度。
- en: We will not go through every setting, but rather focus on the supported configuration
    sets within each automation framework. If a framework does not support a particular
    configuration (such as the `semanage ibpkey` one, which is fairly new), we will
    need to create custom actions for this. In that case, we will show how to approach
    this once, as it is a recurring and similar approach for the others as well.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会逐一讲解每个设置，而是集中讨论每个自动化框架中支持的配置集。如果某个框架不支持某个特定配置（例如`semanage ibpkey`配置，这个配置相对较新），我们需要为此创建自定义操作。在这种情况下，我们将演示如何处理这一问题，因为这种处理方法在其他场景中也会重复出现，且类似。
- en: Setting file contexts
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置文件上下文
- en: The third and final group of actions we want to see is how the automation frameworks
    support applying file contexts to resources. This can be applying an `semanage
    fcontext` configuration, after which a restore operation is done (such as with
    `restorecon`), but also validating whether the framework supports applying contexts
    directly.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望看到的第三组操作是自动化框架如何支持将文件上下文应用于资源。这可以是应用`semanage fcontext`配置，之后进行恢复操作（例如使用`restorecon`），也可以是验证框架是否支持直接应用上下文。
- en: Directly applying the context allows administrators to use the frameworks directly
    without having to twiddle with creating and reapplying file context definitions
    (which can have some performance overhead). However, this should only be considered
    if the automation framework is the sole method through which system changes can
    be made. In any other case, having missing file context definitions might lead
    to administrators resetting contexts to an incorrect state.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 直接应用上下文允许管理员直接使用框架，而无需费力地创建和重新应用文件上下文定义（这可能会带来一定的性能开销）。然而，只有在自动化框架是唯一可以进行系统更改的方法时，才应考虑这样做。在任何其他情况下，缺失的文件上下文定义可能会导致管理员将上下文重置为错误的状态。
- en: Recovering from mistakes
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从错误中恢复
- en: In this chapter, we're diving into the various frameworks that allow managing
    SELinux across a multitude of systems. It is not the intention of this chapter
    to explain the frameworks themselves in detail, nor the secure configuration of
    the frameworks themselves. We don't recommend immediately applying this to production
    systems without testing first, and make sure to have backups!
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了允许在多个系统上管理 SELinux 的各种框架。本章的目的是介绍这些框架的核心支持功能，而不是详细解释框架本身或框架本身的安全配置。我们不建议在没有测试的情况下立即将其应用于生产系统，务必确保做好备份！
- en: That being said, many settings applied in this chapter are easily corrected
    if things fail. We refer to [*Chapter 2*](B16276_02_Final_VK.xhtml#_idTextAnchor045),
    *Understanding SELinux Decisions and Logging*, to selectively put SELinux in permissive
    mode if needed.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，本章中应用的许多设置如果出现问题是可以轻松纠正的。我们参考[*第 2 章*](B16276_02_Final_VK.xhtml#_idTextAnchor045)，*理解
    SELinux 决策和日志记录*，在需要时选择性地将 SELinux 设置为宽容模式。
- en: Furthermore, each framework can easily be suspended, allowing administrators
    to correct issues without being affected by the framework overwriting the changes
    immediately after.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，每个框架都可以轻松暂停，允许管理员在不受框架立即覆盖更改影响的情况下修正问题。
- en: Comparing frameworks
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较框架
- en: Every framework we discuss further has its own approach to infrastructure automation
    and configuration. It is not the intention of this book to dwell on the details
    of each framework, but rather to focus on its core support and how it deals with
    SELinux. We will also abstract away how to handle different Linux distributions
    and have all examples based on CentOS.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进一步讨论的每个框架都有自己对基础设施自动化和配置的处理方式。本书的目的不是详细探讨每个框架的细节，而是专注于它们的核心支持功能，以及它们如何处理
    SELinux。我们还将抽象化如何处理不同的 Linux 发行版，并且所有示例都基于 CentOS。
- en: Furthermore, these frameworks are continuously improving and evolving. When
    we consider these frameworks in this chapter, we only explore how they are commonly
    used, and not how they can specialize in specific deployments. For instance, if
    a framework uses an agent-based architecture by default but also supports SSH-based
    connections, we will only consider the agent-based one in this book, as that is
    the default setup for these frameworks and we want to focus on the SELinux configuration
    support features.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这些框架不断改进和发展。在本章中，我们仅探讨它们的常见用法，而不是它们如何在特定部署中发挥作用。例如，如果一个框架默认使用基于代理的架构，但也支持基于
    SSH 的连接，我们只会考虑基于代理的架构，因为这是这些框架的默认设置，我们希望专注于 SELinux 配置支持功能。
- en: But don't let this stop you from experimenting with the frameworks further and
    adapting them to your own liking! That said, let's dive into our first engine,
    Ansible.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 但不要让这阻止你进一步实验这些框架，并根据自己的喜好进行调整！话说回来，让我们深入了解第一个引擎——Ansible。
- en: Using Ansible for SELinux system administration
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Ansible 进行 SELinux 系统管理
- en: The first orchestration and automation tooling we'll consider is Ansible, a
    very popular open source solution for the remote management of systems. Ansible
    has commercial backing through Red Hat but does not limit its support to Red Hat
    or even Linux systems. Other environments such as Windows environments or even
    network setups have significant Ansible-based support.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先考虑的编排和自动化工具是 Ansible，它是一个非常流行的开源解决方案，用于远程管理系统。Ansible 得到了 Red Hat 的商业支持，但并不限制其支持
    Red Hat 或甚至 Linux 系统。其他环境，如 Windows 环境甚至网络设置，也有显著的基于 Ansible 的支持。
- en: How Ansible works
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ansible 的工作原理
- en: '**Ansible** generally uses a central server that hosts the configuration and
    interprets the settings. The Ansible runtime then connects to the remote systems
    over SSH, sending the necessary data to a temporary location, and then executes
    the steps locally.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ansible** 通常使用一个托管配置并解析设置的中央服务器。然后，Ansible 运行时通过 SSH 连接到远程系统，将必要的数据发送到临时位置，并在本地执行步骤。'
- en: 'The use of SSH as its main connection approach has significant advantages:
    administrators know how this protocol works and how to configure and control it.
    Furthermore, Ansible does not require any additional deployments on the target
    machines, except for Python and libselinux''s Python bindings (which are often
    installed on SELinux-enabled machines by default).'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SSH 作为主要连接方式有显著的优势：管理员知道该协议是如何工作的以及如何进行配置和控制。此外，Ansible 不需要在目标机器上进行额外的部署，除了
    Python 和 libselinux 的 Python 绑定（这些通常在启用了 SELinux 的机器上默认安装）。
- en: Ansible knows how to address the various resources through its modules. **Ansible
    modules** contain the logic that Ansible uses to execute tasks correctly. The
    module code is distributed to the target machines and is executed on the remote
    systems.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 通过其模块知道如何访问各种资源。**Ansible 模块**包含 Ansible 用于正确执行任务的逻辑。模块代码会分发到目标机器，并在远程系统上执行。
- en: The definitions that administrators configure systems with are stored in Ansible
    playbooks. **Playbooks** define how a system should be configured, and Ansible
    will read and interpret playbooks to see what it must execute on each system.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 管理员配置系统时使用的定义存储在 Ansible 剧本中。**剧本**定义了系统应如何配置，Ansible 将读取和解释剧本，以了解它必须在每个系统上执行什么。
- en: To facilitate the management of Ansible playbooks in larger environments, Ansible
    uses **Ansible roles** to bundle coherent definitions. Administrators can then,
    in their playbooks, assign roles to systems to automatically uplift the state
    of those systems accordingly. For instance, a role can be created to create a
    properly configured web server, a database, and so on.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于在更大的环境中管理 Ansible 剧本，Ansible 使用 **Ansible 角色** 来捆绑一致的定义。管理员可以在剧本中为系统分配角色，以自动提升这些系统的状态。例如，可以创建一个角色来创建一个正确配置的
    Web 服务器、数据库等。
- en: In this chapter, we will create a role called `packt_selinux` and apply it to
    a remote system. Within that role, we will show how to configure and execute the
    various SELinux tasks using Ansible.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个名为 `packt_selinux` 的角色，并将其应用于远程系统。在该角色中，我们将展示如何使用 Ansible 配置和执行各种
    SELinux 任务。
- en: Installing and configuring Ansible
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装和配置 Ansible
- en: 'To install and set up Ansible, most Linux distributions offer out-of-the-box
    support for the framework. On CentOS, the following steps can be taken. Users
    of other distributions can easily deduce the steps for their platform:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装和设置 Ansible，大多数 Linux 发行版都提供对该框架的开箱即用支持。在 CentOS 上，可以执行以下步骤。其他发行版的用户可以轻松推导出适用于其平台的步骤：
- en: 'You need to enable **Extra Packages for Enterprise Linux** (**EPEL**), after
    which you can install Ansible easily. Execute this on the master node (from which
    you want to manage the other systems):'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要启用 **企业 Linux 的附加包**（**EPEL**），然后就可以轻松安装 Ansible。请在主节点（你希望管理其他系统的节点）上执行以下命令：
- en: '[PRE1]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once installed, create an SSH key pair to use between the master system and
    the target systems that we will be managing with Ansible. Use the `ssh-keygen`
    command to create a key pair on the master system, and then copy the public key
    (`~/.ssh/id_rsa.pub`) to the remote systems, saving it as `~/.ssh/authorized_keys`:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，创建一对 SSH 密钥，用于主系统和目标系统之间的通信。使用 `ssh-keygen` 命令在主系统上创建密钥对，然后将公钥（`~/.ssh/id_rsa.pub`）复制到远程系统，保存为
    `~/.ssh/authorized_keys`：
- en: '[PRE2]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Test to see whether the remote connection works properly, for instance, by
    executing the `id` command remotely:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试远程连接是否正常工作，例如，通过远程执行 `id` 命令：
- en: '[PRE3]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If the test is successful, we can configure Ansible to see this remote system
    as one of the nodes it will be managing. To accomplish this, edit `/etc/ansible/hosts`
    and add the hostname to the list:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果测试成功，我们可以配置 Ansible，将此远程系统视为它将管理的节点之一。为此，请编辑 `/etc/ansible/hosts` 并将主机名添加到列表中：
- en: '[PRE4]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To see whether Ansible can correctly manage the remote system, we can ask it
    to gather all the facts about the remote system. Facts in Ansible represent the
    discovered settings of the remote system and can be used to fine-tune playbooks
    and roles later. For instance, the Ansible facts discovered of the distribution
    can be used to select which package name an installation uses:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了查看Ansible是否能够正确管理远程系统，我们可以让它收集有关远程系统的所有信息。Ansible中的事实代表了发现的远程系统设置，可用于稍后调整playbook和角色。例如，Ansible发现的发行版信息可以用来选择安装时使用的包名称：
- en: '[PRE5]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The output of the last task is a large set of discovered facts, showing us that
    the connection succeeded and that Ansible is ready to manage the remote system.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一项任务的输出是一组大量发现的事实，显示我们连接成功，并且Ansible已经准备好管理远程系统。
- en: Creating and testing the Ansible role
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和测试Ansible角色
- en: 'To allow reusable configurations across multiple systems, Ansible recommends
    the use of its Ansible roles. We will create a role called `packt_selinux`, have
    it create a custom directory, and then assign this role to the remote system:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许在多个系统间共享可重用的配置，Ansible建议使用其Ansible角色。我们将创建一个名为`packt_selinux`的角色，让它创建一个自定义目录，然后将这个角色分配给远程系统：
- en: 'Use `ansible-galaxy` to create an empty yet ready-to-use role:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ansible-galaxy`创建一个空的、但已准备好使用的角色：
- en: '[PRE6]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Edit the `main.yml` file and have it create a custom directory. The content
    of the file should look like this:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`main.yml`文件，并创建一个自定义目录。文件的内容应如下所示：
- en: '[PRE7]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In later steps, this file will be extended with more and more blocks. Each block
    will start with a name that identifies the block, and then the state definition.
    In the current block, we used Ansible's `file` module to assert that a file or
    directory is available with the parameters given.
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在后续步骤中，该文件将通过更多的块进行扩展。每个块都以一个名称开始来标识该块，然后是状态定义。在当前块中，我们使用了Ansible的`file`模块来断言在给定参数下文件或目录是可用的。
- en: 'Assign the role to the remote system and apply the playbook. We accomplish
    this by first creating an `/etc/ansible/site.yml` file with the following content:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将角色分配给远程系统并应用playbook。我们通过首先创建一个`/etc/ansible/site.yml`文件，并添加以下内容来实现：
- en: '[PRE8]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Run this playbook to apply the setting defined in our role to the remote systems:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行此playbook，将我们角色中定义的设置应用于远程系统：
- en: '[PRE9]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Ansible will display its progress, as well as for which tasks it has executed
    a change. In our case, a change would mean that the directory has been created.
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Ansible将显示其进度，以及执行更改的任务。在我们的案例中，更改意味着目录已被创建。
- en: Now that we have tested our role and assigned the role to the remote system,
    all we need to do is update the role gradually until it contains all the logic
    we need. No other configuration is needed, and after each change, we can rerun
    the `ansible-playbook` command from the main server.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经测试了我们的角色并将其分配给远程系统，接下来要做的就是逐步更新角色，直到它包含我们所需的所有逻辑。不需要其他配置，且在每次更改后，我们可以从主服务器重新运行`ansible-playbook`命令。
- en: Assigning SELinux contexts to filesystem resources with Ansible
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Ansible为文件系统资源分配SELinux上下文
- en: In the current role, we create a custom directory inside `/usr/share/selinux`.
    This parent directory has the `usr_t` SELinux type set, so the newly created subdirectory
    has it as well. The SELinux user of this directory, however, will be different,
    as Ansible has created the directory after remotely logging in to the system.
    In a default CentOS configuration, this means that the target directory's context
    will have `unconfined_u` as its SELinux user component.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前角色中，我们在`/usr/share/selinux`内创建了一个自定义目录。这个父目录已设置为`usr_t` SELinux类型，因此新创建的子目录也会继承该类型。然而，该目录的SELinux用户会有所不同，因为Ansible在远程登录到系统后创建了这个目录。在默认的CentOS配置中，这意味着目标目录的上下文将具有`unconfined_u`作为其SELinux用户组件。
- en: 'Let''s update the definition in `main.yml` and explicitly set the SELinux user
    and type:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`main.yml`中的定义，并显式设置SELinux用户和类型：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: After applying the change (using `ansible-playbook`), the updated definition
    results in a correctly set SELinux user and SELinux type for this directory.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 应用更改后（使用`ansible-playbook`），更新后的定义将为该目录正确设置SELinux用户和SELinux类型。
- en: 'In this case, we added two parameters to the file definition: `setype` and
    `seuser`. The Ansible file module supports the following SELinux-related parameters:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们为文件定义添加了两个参数：`setype`和`seuser`。Ansible文件模块支持以下与SELinux相关的参数：
- en: '`seuser` is the SELinux user of the resource. Set this to `system_u` for system
    resources, as used in the example.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`seuser` 是资源的 SELinux 用户。对于系统资源，设置为 `system_u`，如示例中所使用的。'
- en: '`serole` is the SELinux role of the resource. This is generally not used, as
    role inheritance on the system will generally result in the resource being labeled
    with the `object_r` role, which is correct most of the time.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`serole` 是资源的 SELinux 角色。通常不使用此参数，因为系统上的角色继承通常会导致资源被标记为 `object_r` 角色，这在大多数情况下是正确的。'
- en: '`setype` is the SELinux type of the resource and is the most commonly used
    SELinux parameter in file modules.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setype` 是资源的 SELinux 类型，是文件模块中最常用的 SELinux 参数。'
- en: '`selevel` is the SELinux sensitivity level for the resource. By default, it
    is set to `s0`.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selevel` 是资源的 SELinux 敏感度级别，默认值为 `s0`。'
- en: As we've learned from the example already, you do not need to declare the type
    if the inherited context is correct.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从示例中已经学到的，如果继承的上下文是正确的，你不需要声明类型。
- en: Loading custom SELinux policies with Ansible
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Ansible 加载自定义 SELinux 策略
- en: Ansible's current release has no support for loading custom SELinux modules.
    While custom modules are found on Ansible galaxy (the ecosystem where contributors
    can add more modules), let's see how we would handle distributing a custom policy
    to the systems under Ansible control and loading the module, but only if it is
    not loaded yet.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 当前的版本不支持加载自定义的 SELinux 模块。虽然在 Ansible galaxy（一个贡献者可以添加更多模块的生态系统）中可以找到自定义模块，但我们来看一下如何将自定义策略分发到
    Ansible 控制的系统上，并在模块尚未加载时加载它。
- en: 'While we could start creating custom modules ourselves, let''s use a combination
    of tasks in the existing role to accomplish this. We will try to accomplish the
    following tasks in sequence:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以开始创建自定义模块，但我们将使用现有角色中的任务组合来实现这一目标。我们将按顺序尝试完成以下任务：
- en: Upload a custom policy called `test.cil` to the remote system.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将名为 `test.cil` 的自定义策略上传到远程系统。
- en: Check whether this custom policy is already loaded.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查此自定义策略是否已经加载。
- en: Load the custom policy, but only if the previous check failed.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载自定义策略，但仅在前面的检查失败时。
- en: 'These three tasks are handled through three modules: the `copy` module, the
    `shell` module, and the `command` module. We will use each of these modules in
    separate steps:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个任务通过三个模块处理：`copy` 模块、`shell` 模块和 `command` 模块。我们将在不同的步骤中使用每个模块：
- en: Create the custom policy mentioned earlier in this chapter by placing the `test.cil`
    file in the `files/` folder of the `packt_selinux` role.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本章前面提到的自定义策略，通过将 `test.cil` 文件放入 `packt_selinux` 角色的 `files/` 文件夹中来创建。
- en: 'Create a new code block in the `main.yml` file of the role, with the following
    content:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在角色的 `main.yml` 文件中创建一个新的代码块，内容如下：
- en: '[PRE11]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This will ensure that the `test.cil` file, currently on the master machine,
    is distributed to the target nodes in the directory we've previously created.
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将确保 `test.cil` 文件（当前在主机上）被分发到目标节点，存放在我们之前创建的目录中。
- en: 'Next, we check whether the policy is already loaded. For this, we use the `shell`
    module and use the fail or success state later. Hence, we store the return in
    the `test_is_loaded` variable, and explicitly tell Ansible to ignore a failure
    as we use this as a check rather than a state definition:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们检查策略是否已经加载。为此，我们使用 `shell` 模块，并稍后使用失败或成功的状态。因此，我们将返回值存储在 `test_is_loaded`
    变量中，并明确告诉 Ansible 忽略失败，因为我们将其作为检查，而不是状态定义：
- en: '[PRE12]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `command` module loads the policy file, and only if the previous task failed:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`command` 模块加载策略文件，且仅在前一个任务失败时加载：'
- en: '[PRE13]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This approach shows how we can use our knowledge of SELinux to define and set
    states. This method can be used for other SELinux settings as well, for instance,
    by validating the output of listings (for example, with `semanage`) before defining
    or adjusting settings.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法展示了如何利用我们对 SELinux 的了解来定义和设置状态。这个方法也可以应用于其他 SELinux 设置，例如，在定义或调整设置之前，通过验证列表输出（例如，使用
    `semanage`）来进行检查。
- en: Using Ansible's out-of-the-box SELinux support
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Ansible 开箱即用的 SELinux 支持
- en: 'Ansible has quite a few modules available to provide native support for several
    SELinux-related settings, which we briefly cover here:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 提供了许多模块，原生支持多种与 SELinux 相关的设置，以下是我们简要介绍的：
- en: 'The `selinux` module can be used to set or change the SELinux state (enforcing
    or permissive) as well as to select the appropriate SELinux policy type (such
    as targeted):'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selinux` 模块可用于设置或更改 SELinux 状态（强制或宽容），以及选择适当的 SELinux 策略类型（例如，targeted）：'
- en: '[PRE14]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'With the `seboolean` module, the SELinux booleans can be adjusted at will:'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`seboolean`模块，可以随意调整SELinux布尔值：
- en: '[PRE15]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `sefcontext` module allows us to change SELinux file context definitions:'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sefcontext`模块允许我们更改SELinux文件上下文定义：'
- en: '[PRE16]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'With `selinux_permissive`, we can selectively mark certain SELinux policy domains
    as permissive:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`selinux_permissive`，我们可以选择性地将某些SELinux策略域标记为宽松模式：
- en: '[PRE17]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `selogin` module can be used to map a login to an SELinux user, as with
    `semanage login`:'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selogin`模块可以用来将登录映射到SELinux用户，就像`semanage login`一样：'
- en: '[PRE18]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`seport` can be used to create an SELinux port mapping:'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`seport`可以用来创建SELinux端口映射：'
- en: '[PRE19]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Other SELinux settings might be supported through custom modules, but with the
    method presented earlier, administrators can already start configuring SELinux
    across all systems in their environment.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 其他SELinux设置可能通过自定义模块得到支持，但通过前面介绍的方法，管理员已经可以开始在其环境中的所有系统上配置SELinux。
- en: Utilizing SaltStack to configure SELinux
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SaltStack配置SELinux
- en: The second orchestration and automation framework we'll consider is SaltStack,
    which has commercial backing by the SaltStack company. SaltStack uses a declarative
    language similar to Ansible and is also written in Python. In this chapter, we
    will use the open source SaltStack framework, but an enterprise version of SaltStack
    is available as well, which adds more features on top of the open source one.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要考虑的第二个编排和自动化框架是SaltStack，它得到了SaltStack公司商业支持。SaltStack使用类似于Ansible的声明式语言，并且也是用Python编写的。在本章中，我们将使用开源的SaltStack框架，但也有SaltStack的企业版，它在开源版本的基础上增加了更多的功能。
- en: How SaltStack works
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SaltStack的工作原理
- en: '**SaltStack**, often also described as just Salt, is an automation framework
    that uses an agent/server model for its integrations. Unlike Ansible, SaltStack
    generally requires agent installations on the target nodes (called **minions**)
    and activation of the minion daemons to enable communications to the master. This
    communication is encrypted, and the minion authentication uses public-key validation,
    which needs to be approved on the master to ensure no rogue minions participate
    in a SaltStack environment.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**SaltStack**，通常也被称为Salt，是一个自动化框架，使用代理/服务器模型进行集成。与Ansible不同，SaltStack通常要求在目标节点（称为**minions**）上安装代理，并激活minion守护进程以实现与主服务器的通信。此通信是加密的，minion认证使用公钥验证，必须在主服务器上进行批准，以确保没有恶意minion参与SaltStack环境。'
- en: 'While agent-less installations are possible with SaltStack as well, we will
    focus on agent-based deployments. In such a configuration, the minions regularly
    check with the master to see whether any updates need to be applied. But administrators
    do not need to wait until the minion pulls the latest updates: you can also trigger
    updates from the master, effectively pushing changes to the nodes.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管SaltStack也支持无代理安装，但我们将重点介绍基于代理的部署。在这种配置下，minions会定期与主服务器检查是否需要应用任何更新。但管理员无需等到minion拉取最新的更新：你还可以从主服务器触发更新，从而将更改推送到节点。
- en: The target state that a minion should be in is written down in a `.sls` suffix.
    These Salt State files can refer to other state files, to allow a modular design
    and reusability across multiple machines.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: minion应该处于的目标状态被写入以`.sls`为后缀的文件中。这些Salt State文件可以引用其他状态文件，从而实现模块化设计并在多台机器上重用。
- en: If we need more elaborate coding, SaltStack supports the creation and distribution
    of modules, called **Salt execution modules**. However, unlike Ansible's Galaxy,
    no community repositories currently exist to find more execution modules.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要更复杂的编码，SaltStack支持创建和分发模块，称为**Salt执行模块**。然而，与Ansible的Galaxy不同，目前没有社区仓库来寻找更多的执行模块。
- en: Installing and configuring SaltStack
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装和配置SaltStack
- en: 'The installation of SaltStack is similar across the different Linux distributions.
    Let''s see how the installation is done on a CentOS machine:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: SaltStack的安装在不同的Linux发行版中类似。让我们看看在CentOS机器上是如何安装的：
- en: 'We first need to enable the SaltStack repository that contains its software.
    The project maintains the repository definitions through RPM files that can be
    installed immediately:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先需要启用包含SaltStack软件的仓库。该项目通过RPM文件来维护仓库定义，这些文件可以立即安装：
- en: '[PRE20]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once we have enabled the repository on all systems, install `salt-master` on
    the master, and `salt-minion` on the remote systems:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们在所有系统上启用了软件仓库，就可以在主服务器上安装`salt-master`，并在远程系统上安装`salt-minion`：
- en: '[PRE21]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Before we start the daemons on the systems, we first update the minion configuration
    to point to the master. By default, the minions will attempt to connect to a host
    with the hostname `salt`, but this can be easily changed by editing `/etc/salt/minion`
    and setting the right hostname:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在启动系统上的守护进程之前，我们首先更新 minion 配置以指向主节点。默认情况下，minion 会尝试连接到主机名为 `salt` 的主节点，但可以通过编辑
    `/etc/salt/minion` 并设置正确的主机名来轻松更改：
- en: '[PRE22]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'With the minion configured, we can now launch the SaltStack master (`salt-master`)
    and minion (`salt-minion`) daemons:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置好 minion 后，我们现在可以启动 SaltStack 的主节点（`salt-master`）和 minion（`salt-minion`）守护进程：
- en: '[PRE23]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The minion will connect to the master and present its public key. To list the
    agents currently connected, use `salt-key -L`:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Minion 将连接到主节点并展示其公钥。要列出当前连接的代理，可以使用 `salt-key -L`：
- en: '[PRE24]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Once we have accepted the key, the master will know and control the minion.
    Let''s see whether we can properly interact with the remote system:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们接受了密钥，主节点就会知道并控制该 minion。让我们看看是否能够与远程系统正确交互：
- en: '[PRE25]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This command will list all system services on the minion.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个命令将列出 minion 上的所有系统服务。
- en: The `salt` command is the main command used to query and interact with the remote
    minions from the master. If the last command is successfully returning all system
    services, then SaltStack is correctly configured and ready to manage the remote
    systems.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`salt` 命令是用于从主节点查询和与远程 minion 交互的主要命令。如果上一个命令成功返回了所有系统服务，那么 SaltStack 就已经正确配置并准备好管理远程系统。'
- en: Creating and testing our SELinux state with SaltStack
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建并测试我们的 SELinux 状态与 SaltStack
- en: 'Let''s create our SELinux state called `packt_selinux`, and have it applied
    to the remote minion:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为 `packt_selinux` 的 SELinux 状态，并将其应用到远程 minion 上：
- en: 'We first need to create the top file. This file is the master file for SaltStack,
    from which the entire environment is configured:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先需要创建顶级文件。此文件是 SaltStack 的主配置文件，通过它来配置整个环境：
- en: '[PRE26]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, we create the state definition for `packt_selinux`:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们为 `packt_selinux` 创建状态定义：
- en: '[PRE27]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Place the SELinux `test.cil` module, as defined earlier on in this chapter,
    inside `/srv/salt/packt_selinux` as we refer to it in the state definition. Once
    placed, we can apply this state to the environment:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将本章前面定义的 SELinux `test.cil` 模块放置在 `/srv/salt/packt_selinux` 目录下，这也是我们在状态定义中引用的位置。放置后，我们可以将此状态应用到环境中：
- en: '[PRE28]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `state.apply` subcommand of the `salt` command is used to apply the state
    across the environment. Each time we modify our state definition, this command
    can be used to force an update to the minions. Without this, the minions will
    (by default) update their state every 60 minutes. These scheduled state updates
    are called mine updates and are configured on the agents inside `/etc/salt/minion`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`salt` 命令的 `state.apply` 子命令用于将状态应用到整个环境。每次修改状态定义时，可以使用此命令强制更新 minions。否则，minions
    将默认每 60 分钟更新一次其状态。这些计划的状态更新称为 mine 更新，并在 `/etc/salt/minion` 中的代理上进行配置。'
- en: Assigning SELinux contexts to filesystem resources with SaltStack
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 SaltStack 为文件系统资源分配 SELinux 上下文
- en: At the time of writing, support for addressing SELinux types in resources has
    not yet reached the stable versions of SaltStack. SaltStack, however, supports
    running commands but only if a certain test has succeeded (or failed).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在写作时，SaltStack 尚未在稳定版本中完全支持在资源中处理 SELinux 类型。然而，SaltStack 支持运行命令，但只有在某个测试成功（或失败）之后才能执行。
- en: 'Update the `init.sls` file and add the following code to it:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 `init.sls` 文件，并在其中添加以下代码：
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `cmd.run` approach allows us to easily create custom SELinux support using
    the commands we've seen earlier on in this book. The `unless` check contains the
    test to see whether we need to execute the command or not, allowing us to create
    idempotent state definitions.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmd.run` 方法允许我们通过本书前面所见的命令轻松创建自定义 SELinux 支持。`unless` 检查包含一个测试，以判断是否需要执行该命令，从而允许我们创建幂等的状态定义。'
- en: Loading custom SELinux policies with SaltStack
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 SaltStack 加载自定义 SELinux 策略
- en: 'Let''s load our custom SELinux module on the remote systems. SaltStack has
    support for loading SELinux modules through the `selinux.module` state:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在远程系统上加载我们的自定义 SELinux 模块。SaltStack 支持通过 `selinux.module` 状态加载 SELinux 模块：
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As in the previous section, we need to add an `unless` statement, as otherwise,
    SaltStack will attempt to load the SELinux module repeatedly every time the state
    is applied.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一部分一样，我们需要添加一个 `unless` 语句，否则每次应用状态时，SaltStack 都会尝试重复加载 SELinux 模块。
- en: Using SaltStack's out-of-the-box SELinux support
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 SaltStack 内置的 SELinux 支持
- en: 'SaltStack''s native SELinux support is gradually expanding but still has much
    room for improvement:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: SaltStack对SELinux的原生支持正在逐步扩展，但仍有很大的改进空间：
- en: 'With `selinux.boolean`, the SELinux boolean values can be set on the target
    machines:'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`selinux.boolean`，可以在目标机器上设置SELinux布尔值：
- en: '[PRE31]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The file contexts, as managed with `semanage fcontext`, can be defined using
    the `selinux.fcontext_policy_present` state:'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件上下文（由`semanage fcontext`管理）可以使用`selinux.fcontext_policy_present`状态进行定义：
- en: '[PRE32]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: To remove the definition, use the `selinux.fcontext_policy_absent` definition.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 若要删除定义，请使用`selinux.fcontext_policy_absent`定义。
- en: 'With `selinux.mode`, we can put the system in enforcing or permissive mode:'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`selinux.mode`，我们可以将系统置于强制模式或宽容模式：
- en: '[PRE33]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Port mappings are handled using the `selinux.port_policy_present` state:'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端口映射通过`selinux.port_policy_present`状态来处理：
- en: '[PRE34]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: With the `cmd.run` approach mentioned earlier, we can apply SELinux configuration
    updates to systems in a repeatable fashion for unsupported settings.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面提到的`cmd.run`方法，我们可以以可重复的方式将SELinux配置更新应用于不支持的设置的系统。
- en: Automating system management with Puppet
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Puppet自动化系统管理
- en: Puppet is the third automation framework that we will check out. It is the oldest
    one in our list, with its first release in 2005, and is commonly seen as the baseline
    against which other automation frameworks are compared. It has commercial backing
    through the Puppet company, also often referred to as Puppet Labs.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet是我们将要检查的第三个自动化框架。它是我们列表中最古老的一个，首次发布于2005年，通常被视为其他自动化框架的基准。它得到了Puppet公司（也常被称为Puppet
    Labs）的商业支持。
- en: How Puppet works
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Puppet如何工作
- en: Like SaltStack, **Puppet** uses an agent/server-based model with public-key
    authentication of the agents to ensure no rogue agents are active within the environment.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 与SaltStack类似，**Puppet**使用基于代理/服务器的模型，并通过公钥认证代理，确保环境中没有恶意代理活跃。
- en: The **Puppet master** has access to the **Puppet manifests**, which is the declaration
    of the state that Puppet wants to achieve. These manifests use a specific language
    inspired by Ruby and can refer to classes provided by modules to ensure reusability
    across the environment.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**Puppet主节点**可以访问**Puppet清单**，这是Puppet希望实现的状态声明。这些清单使用一种受到Ruby启发的特定语言，并可以引用由模块提供的类，以确保在环境中具有可重用性。'
- en: '**Puppet modules**, hence, are the workhorse within Puppet, and Puppet has
    a significant community called Puppet Forge that allows you to download and install
    modules created by the community to more easily manage your environment.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**Puppet模块**因此是Puppet的工作马，而Puppet拥有一个重要的社区，称为Puppet Forge，允许您下载和安装社区创建的模块，以更轻松地管理您的环境。'
- en: Puppet agents will regularly connect to the master, informing the master of
    the current details of the remote machine. These current details are called **facts**
    and can be used by Puppet to dynamically handle changes in the environment. The
    master then compiles the target state in what it calls a **catalog** and sends
    that catalog over to the agent. The agent then applies this catalog and reports
    the results back.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet代理会定期连接到主节点，向主节点报告远程机器的当前详细信息。这些当前详细信息被称为**事实**，Puppet可以利用这些信息动态处理环境中的变化。主节点随后将目标状态编译成所谓的**目录**并将该目录发送到代理。代理然后应用此目录并报告结果。
- en: Installing and configuring Puppet
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装和配置Puppet
- en: 'The Puppet company offers integrated packages for several Linux distributions.
    The following instructions focus on RPM-compatible distributions, but other platforms
    have very similar instructions:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet公司提供多个Linux发行版的集成包。以下说明重点介绍与RPM兼容的发行版，但其他平台也有非常相似的说明：
- en: 'The Puppet company provides repository definitions through RPM files. After
    the repositories are established, you can install `puppetserver` and `pdk` (on
    the master) and `puppet-agent` (on the remote systems) so that the software is
    readily available to use:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Puppet公司通过RPM文件提供存储库定义。在建立存储库后，您可以安装`puppetserver`和`pdk`（在主节点上）以及`puppet-agent`（在远程系统上），使软件随时可用：
- en: '[PRE35]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Configure the master to have its certificate properly named. Edit the `puppet.conf`
    file inside `/etc/puppetlabs/puppet` and, within the `[master]` section, update
    or add the following settings:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置主节点，使其证书命名正确。编辑`/etc/puppetlabs/puppet`中的`puppet.conf`文件，并在`[master]`部分内更新或添加以下设置：
- en: '[PRE36]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Start the Puppet server so that the clients can start connecting to it:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Puppet服务器，以便客户端可以开始连接到它：
- en: '[PRE37]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'On the remote systems, edit the same configuration file, and update or add
    the following settings in the `[main]` section:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在远程系统上，编辑相同的配置文件，并在`[main]`部分更新或添加以下设置：
- en: '[PRE38]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Next, start the Puppet agent:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，启动Puppet代理：
- en: '[PRE39]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'On the master node, we can now query the pending certificate requests. It should
    display the requests from the agents we recently started:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主节点上，我们现在可以查询待处理的证书请求。它应该显示我们最近启动的代理的请求：
- en: '[PRE40]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We can accept this request (sign the certificate) as follows:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式接受此请求（签署证书）：
- en: '[PRE41]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To validate whether the connection works, log in on the remote machine and
    trigger the agent to apply the (currently empty) catalog:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了验证连接是否正常工作，请登录到远程机器并触发代理应用（当前为空的）目录：
- en: '[PRE42]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Unlike SaltStack, where we can push a change to the agents, Puppet relies on
    the agents to frequently poll the server. In the configuration we made earlier,
    we configured the agent to check every hour. With the `puppet agent --test` command,
    we can signal the agent to run the state check immediately.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 与SaltStack不同，Puppet依赖代理频繁轮询服务器，而不是将更改推送到代理。在我们之前做的配置中，我们将代理配置为每小时检查一次。通过`puppet
    agent --test`命令，我们可以立即指示代理运行状态检查。
- en: Creating and testing the SELinux class with Puppet
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Puppet创建和测试SELinux类
- en: 'Let''s create our `packt_selinux` class, through which we will configure our
    remote machine''s SELinux settings:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建`packt_selinux`类，通过它我们将配置远程机器的SELinux设置：
- en: 'Call the `/etc/puppetlabs/code/modules` directory:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`/etc/puppetlabs/code/modules`目录：
- en: '[PRE43]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The result is an empty module with lots of default files and directories. We
    will be mostly working with the module's manifest file.
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果是一个空模块，包含许多默认文件和目录。我们将主要与模块的清单文件一起工作。
- en: 'Inside the `packt_selinux/manifests` directory, create a new file named `init.pp`
    with the following content:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`packt_selinux/manifests`目录中，创建一个名为`init.pp`的新文件，内容如下：
- en: '[PRE44]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Next, inside the `/etc/puppetlabs/code/environments/production/manifests` location,
    create a file called `site.pp` with the following content:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`/etc/puppetlabs/code/environments/production/manifests`位置创建一个名为`site.pp`的文件，内容如下：
- en: '[PRE45]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `site.pp` file provides the top-level hierarchy for Puppet to associate
    its environment with the appropriate definitions. In this example, the node with
    the hostname `rem1.internal.genfic.local` is configured through a reference to
    `packt_selinux`, the module we created previously.
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`site.pp`文件为Puppet提供了顶级层次结构，用于将其环境与适当的定义关联。在此示例中，主机名为`rem1.internal.genfic.local`的节点通过引用我们之前创建的`packt_selinux`模块进行配置。'
- en: Inside the `packt_selinux` module, we've created the `packt_selinux` class,
    which currently is composed of a single directive to create `/usr/share/selinux/custom`.
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`packt_selinux`模块内部，我们创建了`packt_selinux`类，该类目前由一个指令组成，用于创建`/usr/share/selinux/custom`。
- en: 'With these definitions in place, have the remote agent update its state:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置这些定义后，让远程代理更新其状态：
- en: '[PRE46]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In product environments, it is common to have this command either scheduled
    regularly or to run the Puppet agent continuously as a daemon.
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在产品环境中，通常会定期安排此命令执行，或者持续运行Puppet代理作为守护进程。
- en: With the class properly assigned to the node, we can expand our configuration
    with more SELinux details.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在将类正确分配给节点后，我们可以通过更多的SELinux细节扩展我们的配置。
- en: Assigning SELinux contexts to filesystem resources with Puppet
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Puppet为文件系统资源分配SELinux上下文
- en: 'Let''s augment our current class definition with the following snippet:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下代码段增强当前的类定义：
- en: '[PRE47]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: For this block to work properly, we need to place the `test.cil` SELinux module
    in the `files/` folder inside the `packt_selinux` module location. This block
    will have Puppet upload the file to the directory, with the dependency set that
    the directory must exist. The `require` statement refers to the previously defined
    block.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使此块正常工作，我们需要将`test.cil` SELinux模块放置在`packt_selinux`模块位置中的`files/`文件夹内。此块将使Puppet将文件上传到该目录，并设置依赖关系，要求该目录必须存在。`require`语句指向先前定义的块。
- en: 'We also see that Puppet has out-of-the-box support for SELinux type definitions.
    The file class has several SELinux-supported parameters that can be used:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到Puppet对SELinux类型定义提供了开箱即用的支持。文件类具有几个支持SELinux的参数，可以使用：
- en: '`seluser` defines the SELinux user for the resource.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`seluser`定义了资源的SELinux用户。'
- en: '`selrole` defines the SELinux role for the resource.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selrole`定义了资源的SELinux角色。'
- en: '`seltype` defines the SELinux type for the resource.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`seltype`定义了资源的SELinux类型。'
- en: '`selrange` defines the SELinux sensitivity range for the resource.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selrange`定义了资源的SELinux敏感度范围。'
- en: '`selinux_ignore_defaults` tells Puppet to ignore the default SELinux context
    (as queried from the SELinux policy).'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selinux_ignore_defaults`告诉Puppet忽略默认的SELinux上下文（如从SELinux策略查询到的）。'
- en: Our previous example is thus actually superfluous because Puppet will actively
    query the SELinux policy to discover what the right resource context is and apply
    this. With `selinux_ignore_defaults` set to `true`, Puppet will not query and
    adjust the context accordingly, which can be useful when testing out new setups
    that do not have proper context definitions set.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的示例实际上是多余的，因为Puppet会主动查询SELinux策略以发现正确的资源上下文并应用。设置`selinux_ignore_defaults`为`true`时，Puppet将不会查询并调整上下文，这在测试没有正确上下文定义的新配置时非常有用。
- en: Loading custom SELinux policies with Puppet
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Puppet加载自定义SELinux策略
- en: Puppet does have support for loading and managing SELinux modules. However,
    its support is currently restricted to the more traditional SELinux policy modules,
    and not the CIL powered ones.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet确实支持加载和管理SELinux模块。然而，它的支持目前仅限于传统的SELinux策略模块，而不包括基于CIL的模块。
- en: 'So, let''s create another block in our module definition that loads the `test.cil`
    file, but only if no test SELinux module is already loaded:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们在模块定义中创建另一个块，加载`test.cil`文件，但仅在没有已加载测试SELinux模块的情况下：
- en: '[PRE48]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This approach allows us to create custom SELinux configuration adjustments if
    the native Puppet support does not suffice.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法允许我们在本地Puppet支持不足的情况下，创建自定义的SELinux配置调整。
- en: Using Puppet's out-of-the-box SELinux support
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Puppet的开箱即用的SELinux支持
- en: Puppet has a few SELinux-related classes supported out of the box but has more
    support through Puppet Forge, an ecosystem of community-contributed modules. One
    of the modules that we can recommend is the `puppet-selinux` module, which Puppet
    (the company) maintains on Puppet Forge (and thus has a higher chance of remaining
    supported in later versions of Puppet).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet有一些开箱即用的SELinux相关类，并通过Puppet Forge提供更多支持，Puppet Forge是一个由社区贡献模块组成的生态系统。我们推荐的一个模块是`puppet-selinux`模块，Puppet（公司）在Puppet
    Forge上维护该模块（因此更有可能在Puppet的后续版本中保持支持）。
- en: 'Installing new modules is quite easy, using the `puppet module` command:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 安装新模块非常简单，可以使用`puppet module`命令：
- en: '[PRE49]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We can then refer to the `selinux` class (provided through this module) within
    our manifest:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以在清单中引用通过此模块提供的`selinux`类：
- en: 'The `selinux` class can be directly used to set the enforcing (or permissive)
    state of the system:'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以直接使用`selinux`类来设置系统的强制（或宽松）状态：
- en: '[PRE50]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The (native) `selboolean` class can be used to set SELinux booleans:'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （本地）`selboolean`类可以用于设置SELinux布尔值：
- en: '[PRE51]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'SELinux file contexts can be defined using the `selinux::fcontext` class:'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SELinux文件上下文可以使用`selinux::fcontext`类定义：
- en: '[PRE52]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Equivalence definitions for the file context are handled by `selinux::fcontext::equivalence`,
    like so:'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件上下文的等效定义由`selinux::fcontext::equivalence`处理，方式如下：
- en: '[PRE53]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Custom port mappings are handled by `selinux::port`:'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义端口映射由`selinux::port`处理：
- en: '[PRE54]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Individual SELinux domains can be made permissive using `selinux::permissive`:'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用`selinux::permissive`将单独的SELinux域设置为宽松模式：
- en: '[PRE55]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'If standard SELinux modules are present, the use of `selmodule` allows loading
    it up. In this case, it will search for the SELinux module named after the block,
    inside the directory referred to by `selmoduledir`:'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在标准的SELinux模块，则使用`selmodule`可以加载它。在这种情况下，它将在`selmoduledir`引用的目录中查找以块名称命名的SELinux模块：
- en: '[PRE56]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: While other SELinux-supporting modules might be available on Puppet Forge, be
    sure to validate whether these modules are mature and sufficiently stable. If
    their support is uncertain, you might want to pursue the `exec` route, as used
    earlier on, in *Loading custom SELinux policies with Puppet*.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在Puppet Forge上可能会有其他支持SELinux的模块，但请确保验证这些模块是否成熟且足够稳定。如果它们的支持不确定，您可能需要采用之前使用过的`exec`方式，如在*使用Puppet加载自定义SELinux策略*一节中所示。
- en: Wielding Chef for system automation
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Chef进行系统自动化
- en: The last automation framework we will explore is Chef. Chef is a slightly more
    hands-on and development-oriented automation framework than the previous ones,
    but powerful nonetheless. It has commercial backing by the similarly named company
    Chef.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要探讨的最后一个自动化框架是Chef。Chef相比于前面提到的框架，更偏向于手动操作和开发导向，但它仍然非常强大。它有类似名称的公司Chef提供商业支持。
- en: How Chef works
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Chef的工作原理
- en: Chef has a slightly more extensive approach to automation and requires slightly
    more work to get up and running. Once set up, however, it offers a very flexible
    and programmable environment wherein infrastructure automation can be worked out.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: Chef 对自动化有着稍微更为广泛的方法，并且需要更多的工作来启动和运行。然而，一旦设置完成，它提供了一个非常灵活和可编程的环境，可以在其中完成基础设施自动化。
- en: 'There are three types of systems in the Chef architecture:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Chef 架构中有三种类型的系统：
- en: The **Chef server** acts as the central hub on which the automation code is
    maintained, and which interacts with the remote systems to apply the changes.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Chef 服务器** 充当中央枢纽，用于维护自动化代码，并与远程系统交互以应用更改。'
- en: The **Chef workstation** is an endpoint on which administrators and engineers
    develop Chef recipes (code) and cookbooks and interact with the Chef server. There
    can be multiple Chef workstations per Chef environment.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Chef 工作站** 是管理员和工程师开发 Chef recipes（代码）和 cookbooks 并与 Chef 服务器交互的端点。每个 Chef
    环境可以有多个 Chef 工作站。'
- en: The **Chef client** is an agent running on the remote systems (nodes) managed
    by the Chef environment.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Chef 客户端** 是在由 Chef 环境管理的远程系统（节点）上运行的代理。'
- en: Developers create automation code in **recipes**, which are like tasks. Multiple
    recipes are bundled in a **cookbook** and uploaded to the Chef server before the
    recipes can be applied to one or more nodes. Cookbooks can be compared with modules
    in the previous automation frameworks.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者在 **recipes** 中创建自动化代码，这些代码类似于任务。多个 recipes 被打包在一个 **cookbook** 中，并上传到 Chef
    服务器，然后可以将这些 recipes 应用于一个或多个节点。可以将 cookbooks 与之前的自动化框架中的模块进行比较。
- en: The Chef clients and server use public key-based authentication and encryption
    for their interactions. It is the client that takes the initiative, connecting
    to the server to download the latest cookbooks and other resources, after which
    it calculates and applies the latest changes, sending feedback on these changes
    back to the server.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: Chef 客户端和服务器使用基于公钥的身份验证和加密进行它们的交互。客户端采取主动措施，连接服务器以下载最新的 cookbooks 和其他资源，然后计算并应用最新的更改，并将这些更改的反馈发送回服务器。
- en: Installing and configuring Chef
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装和配置 Chef
- en: A full Chef installation requires a few components to be installed. The Chef
    workstation and the Chef server need to be installed by the administrator, whereas
    the Chef agents will be installed by Chef later.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的 Chef 安装需要管理员安装几个组件。Chef 工作站和 Chef 服务器需要管理员安装，而 Chef 代理将由 Chef 后续安装。
- en: Installing the Chef workstation
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 Chef 工作站
- en: To install and use Chef, first download the Chef workstation. All Chef software
    can be downloaded from [https://downloads.chef.io](https://downloads.chef.io).
    For CentOS, the Chef workstation is available as an RPM, which can be installed
    using `yum`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装和使用 Chef，请先下载 Chef 工作站。所有 Chef 软件都可以从 [https://downloads.chef.io](https://downloads.chef.io)
    下载。对于 CentOS，Chef 工作站以 RPM 的形式提供，可以使用 `yum` 进行安装。
- en: 'However, unlike common packaged software, the Chef workstation dependencies
    are not explicitly listed as RPM dependencies, causing the software to be installed
    without its necessary libraries. At the end of the installation, the RPM file
    will execute a post-installation script that checks the dependencies and reports
    on the missing libraries:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，与常见的打包软件不同，Chef 工作站的依赖关系没有显式列出为 RPM 依赖关系，导致软件在没有必要的库的情况下安装。安装结束时，RPM 文件将执行一个后安装脚本，检查依赖关系并报告缺少的库：
- en: '[PRE57]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The dependencies, currently, require the following CentOS packages to be installed:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，依赖关系需要安装以下 CentOS 软件包：
- en: '[PRE58]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'After the installation, run `chef -v` (as a regular, non-root user) to verify
    whether all dependencies are met:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，作为常规非根用户运行 `chef -v` 来验证是否满足所有依赖：
- en: '[PRE59]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The command should output the versions of the included Chef components.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 命令应输出包含的 Chef 组件的版本。
- en: Installing and configuring the Chef server core
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装和配置 Chef 服务器核心
- en: 'The second installation is the Chef server core. This software is again made
    available as RPM:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个安装是 Chef 服务器核心。此软件再次以 RPM 的形式提供：
- en: 'Install the Chef server core using `yum`:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `yum` 安装 Chef 服务器核心：
- en: '[PRE60]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: After the installation finishes, we need to configure it for our environment.
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 安装完成后，我们需要为我们的环境配置它。
- en: 'Create a directory named `/var/opt/chef`. We will use this directory to store
    the cryptographic keys to authenticate against the Chef server:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `/var/opt/chef` 的目录。我们将使用这个目录来存储用于身份验证 Chef 服务器的加密密钥：
- en: '[PRE61]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Next, configure the Chef server using `chef-server-ctl`:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用 `chef-server-ctl` 配置 Chef 服务器：
- en: '[PRE62]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This will set up the Chef server on the current system. This setup can take
    a while to complete, but once finished, we can continue with creating a user account
    inside of Chef.
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将在当前系统上设置Chef服务器。此设置可能需要一些时间才能完成，但完成后，我们可以继续在Chef中创建用户帐户。
- en: 'Let''s create an account called `chefadmin` for the user `lisa` on this system
    and give it a custom password:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在此系统上为用户`lisa`创建一个名为`chefadmin`的帐户，并为其设置自定义密码：
- en: '[PRE63]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Create an organization unit inside the Chef configuration, which we associate
    with the newly created user:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Chef配置中创建一个组织单元，并将其与新创建的用户关联：
- en: '[PRE64]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: With this done, the server administration itself is all done, and we can start
    creating our development environment.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，服务器管理已经完成，我们可以开始创建我们的开发环境。
- en: Preparing the development environment
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备开发环境
- en: 'As mentioned earlier on, Chef is somewhat more development-oriented than the
    previous automation frameworks. The user that will interact with Chef (using the
    Chef workstation) needs to establish a development environment first:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Chef比以前的自动化框架更偏向开发。将与Chef交互的用户（使用Chef工作站）需要首先建立开发环境：
- en: 'We previously created an account called `chefadmin` for the user `lisa`. Now,
    log in as the user `lisa` and create a development environment in the user''s
    home directory:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们之前为用户`lisa`创建了一个名为`chefadmin`的帐户。现在，以用户`lisa`身份登录并在用户的主目录中创建开发环境：
- en: '[PRE65]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We create a Git-enabled environment as the Chef utilities require it. If you
    have no active Git configuration yet, you might need to add your email and name:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个支持Git的环境，因为Chef工具需要它。如果你还没有激活Git配置，你可能需要添加你的电子邮件和名字：
- en: '[PRE66]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Next, create the Chef knife configuration as `.chef/knife.rb` within this environment
    (so `~/chef/.chef/knife.rb` in our example):'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在此环境中创建Chef刀具配置文件`.chef/knife.rb`（在我们的示例中是`~/chef/.chef/knife.rb`）：
- en: '[PRE67]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Download the certificates that the Chef server uses (these certificates are
    self-signed certificates) and then check the SSL connection:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载Chef服务器使用的证书（这些证书是自签名证书），然后检查SSL连接：
- en: '[PRE68]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'If the checks are successful, we can commit the changes:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果检查成功，我们可以提交更改：
- en: '[PRE69]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: We are now ready to start our recipe and cookbook development.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经准备好开始我们的食谱和食谱开发了。
- en: Creating the SELinux cookbook
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建SELinux食谱
- en: 'The cookbook we are going to develop will contain the various SELinux configuration
    entries, which are then assigned to the remote node:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要开发的食谱将包含各种SELinux配置项，然后将这些配置项分配给远程节点：
- en: 'Let''s start by creating a cookbook called `packt_selinux`:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从创建一个名为`packt_selinux`的食谱开始：
- en: '[PRE70]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The `recipes/default.rb` file contains the actual logic we want to apply to
    the remote systems. Let''s create a definition for the `/usr/share/selinux/custom`
    directory:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`recipes/default.rb`文件包含我们希望应用于远程系统的实际逻辑。让我们为`/usr/share/selinux/custom`目录创建一个定义：'
- en: '[PRE71]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now upload the cookbook to the Chef server:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将食谱上传到Chef服务器：
- en: '[PRE72]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'We can query the available cookbooks on the Chef server with the `list` subcommand:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`list`子命令查询Chef服务器上可用的食谱：
- en: '[PRE73]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'With the cookbook available, let''s bootstrap the target node. Bootstrapping
    only needs to occur once, but must be triggered from a Chef authenticated user:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了食谱可用后，让我们启动目标节点。引导过程只需要执行一次，但必须由Chef认证用户触发：
- en: '[PRE74]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'This ensures the Chef server knows the remote system. We can query the nodes
    using `knife node list` and get more details about a node with the `show` subcommand:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这确保了Chef服务器知道远程系统。我们可以使用`knife node list`查询节点，并使用`show`子命令获取有关节点的更多详细信息：
- en: '[PRE75]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Assign the `packt_selinux` recipe to the node using the `run_list add` subcommand:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`run_list add`子命令将`packt_selinux`食谱分配给节点：
- en: '[PRE76]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'For our purposes, we will trigger the `chef-client` command on the remote system
    to download and apply the latest changes:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的目的，我们将在远程系统上触发`chef-client`命令，以下载并应用最新的更改：
- en: '[PRE77]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: If this command returns successfully, then Chef is ready to manage the remote
    system using the cookbook we've developed.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此命令成功返回，那么Chef已经准备好使用我们开发的食谱来管理远程系统。
- en: Assigning SELinux contexts to filesystem resources with Chef
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Chef为文件系统资源分配SELinux上下文
- en: 'Chef has limited native support for SELinux contexts. When instructed to create
    or modify files on nodes, it will relabel those files according to the present
    file context definitions on the nodes. We can, however, subscribe to events defined
    in the recipe, and trigger appropriate actions when they occur. For instance,
    to explicitly set the context of a directory, we can create something like this:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: Chef对SELinux上下文的原生支持有限。当被指示在节点上创建或修改文件时，它会根据节点上当前的文件上下文定义重新标记这些文件。然而，我们可以订阅在食谱中定义的事件，并在这些事件发生时触发适当的操作。例如，要显式设置目录的上下文，我们可以创建类似这样的内容：
- en: '[PRE78]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'After adding this to the `recipes/default.rb` file, we first need to upload
    the updated cookbook to the server:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在将其添加到`recipes/default.rb`文件后，我们首先需要将更新后的cookbook上传到服务器：
- en: '[PRE79]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Afterward, we can rerun `chef-client` on the remote node to apply this updated
    recipe. If the directory was previously already created, the recipe will not change
    anything as the subscription will not be triggered.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以在远程节点上重新运行`chef-client`以应用此更新的食谱。如果目录之前已经创建，则食谱不会更改任何内容，因为订阅不会被触发。
- en: Loading custom SELinux policies with Chef
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Chef加载自定义SELinux策略
- en: 'Let''s update our recipe to include the logic to load a custom policy. We will
    use two blocks in our recipe, one to upload the `test.cil` file to the node, and
    another one to load it, but only if it was not loaded previously:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新我们的食谱，以包括加载自定义策略的逻辑。我们将在食谱中使用两个块，一个用于将`test.cil`文件上传到节点，另一个用于加载它，但仅在之前未加载时：
- en: '[PRE80]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Put the `test.cil` file in a folder called `files` inside the `packt_selinux`
    cookbook directory, before uploading the updated cookbook and reapplying the changes
    using `chef-client`.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 将`test.cil`文件放入`packt_selinux` cookbook目录下名为`files`的文件夹中，然后上传更新后的cookbook并使用`chef-client`重新应用更改。
- en: Using Chef's out-of-the-box SELinux support
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Chef的开箱即用SELinux支持
- en: While Chef itself has limited out-of-the-box SELinux support, cookbooks are
    available online on Chef Supermarket (where the Chef community manages and distributes
    their custom cookbooks). Chef (the company) maintains the `selinux` cookbook itself,
    which allows managing the SELinux state of a system, whereas the `selinux_policy`
    cookbook addresses a few other SELinux settings.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Chef本身对SELinux的原生支持有限，但在Chef超市（Chef社区管理和分发自定义cookbook的地方）在线提供了许多cookbook。Chef（公司）本身维护`selinux`
    cookbook，它允许管理系统的SELinux状态，而`selinux_policy` cookbook处理一些其他SELinux设置。
- en: 'Let''s download and install the `selinux` and `selinux_policy` cookbooks:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们下载并安装`selinux`和`selinux_policy` cookbooks：
- en: '[PRE81]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Next, adjust the `metadata.rb` file of our own cookbook to include the dependency
    to this newly added cookbook:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，调整我们自己的cookbook中的`metadata.rb`文件，添加对新添加的cookbook的依赖：
- en: '[PRE82]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'We can now use some of the predefined recipes to handle SELinux configuration
    settings:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用一些预定义的食谱来处理SELinux配置设置：
- en: 'With `selinux_state`, we can place the system in an enforcing or permissive
    state:'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`selinux_state`，我们可以将系统置于强制模式或宽容模式：
- en: '[PRE83]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The `selinux_policy_boolean` recipe can configure an SELinux boolean value:'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selinux_policy_boolean`食谱可以配置SELinux布尔值：'
- en: '[PRE84]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'With `selinux_policy_port`, a custom SELinux port mapping can be defined:'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`selinux_policy_port`，可以定义自定义的SELinux端口映射：
- en: '[PRE85]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'A file context definition can be set using `selinux_policy_fcontext`:'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用`selinux_policy_fcontext`设置文件上下文定义：
- en: '[PRE86]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'An SELinux domain can be put in permissive mode using the `selinux_policy_permissive`
    recipe:'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用`selinux_policy_permissive`食谱将SELinux域设置为宽容模式：
- en: '[PRE87]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Don't forget to upload the changed cookbook before calling `chef-client` on
    the remote systems.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在远程系统上调用`chef-client`之前，别忘了上传更改后的cookbook。
- en: Summary
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Automation frameworks such as Ansible, SaltStack, Puppet, and Chef can be easily
    used to manage SELinux settings on a multitude of systems. While not all frameworks
    can deal with SELinux settings natively, this is easily mitigated by either using
    community-provided modules or by creating custom rules that check and update the
    settings accordingly. In this chapter, we've seen how to accomplish this by installing
    a custom, CIL-based SELinux policy.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 像Ansible、SaltStack、Puppet和Chef这样的自动化框架可以轻松用于管理多个系统上的SELinux设置。虽然并非所有框架都能原生处理SELinux设置，但通过使用社区提供的模块或创建自定义规则来检查和更新设置，可以轻松解决这个问题。在本章中，我们已经看到如何通过安装基于CIL的自定义SELinux策略来实现这一点。
- en: We learned that these frameworks all have their specific approaches. Ansible,
    for instance, does not use any software installations on remote systems and communicates
    with the target systems using SSH. The other frameworks all use an agent/server
    model but have their own views on configuring settings (the syntax between Puppet
    and SaltStack is noticeably different) or design (Chef uses a workstation where
    developers have their development environment). All these frameworks are easily
    put in place and configured and can handle most SELinux settings without any problems.
    All tools have a way of modularizing the definitions so they can be applied easily
    against a larger number of systems.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解到这些框架都有各自的方法。例如，Ansible 不使用远程系统上的任何软件安装，并使用 SSH 与目标系统通信。其他框架都使用代理/服务器模型，但在配置设置（Puppet
    和 SaltStack 之间的语法明显不同）或设计（Chef 使用开发人员拥有其开发环境的工作站）上有各自的观点。所有这些框架都很容易安装和配置，并且可以处理大多数
    SELinux 设置而不会出现任何问题。所有工具都有一种模块化定义的方式，因此可以轻松地应用到更多的系统中。
- en: Now that we know how to apply SELinux settings consistently, let's see what
    other SELinux controls exist, but now through userspace application-specific support.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何一致地应用 SELinux 设置，让我们看看还有哪些 SELinux 控制存在，但现在通过用户空间应用程序特定的支持。
- en: Questions
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which of the four tools have native support for setting SELinux contexts on
    resources?
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪一款工具原生支持在资源上设置 SELinux 上下文？
- en: How do these orchestration tools allow reusable customization beyond native
    support?
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些编排工具如何允许超出原生支持的可重用定制？
- en: What are some obvious differences between the listed orchestration tools?
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出的编排工具之间有哪些明显的区别？
