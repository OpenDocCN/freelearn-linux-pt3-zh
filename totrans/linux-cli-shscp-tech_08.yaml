- en: '*Chapter 8*: Using the Command Line to Find, Extract, and Manipulate Text Content'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Manipulating text is an everyday job for a full-time system administrator. It
    can happen for a variety of reasons – for example, you could just be trying to
    find a service option that you saw somewhere in some configuration file, without
    remembering what the name of the configuration file is. You know, those moments
    on Monday morning when you haven't had two cups of your favorite pick-me-up drink
    and your CPU hasn't booted properly yet? Or, maybe, when you're working with a
    text file that has a lot of content, but needs specific changes to be made, such
    as changing some configuration options from off to on, true to false, 0 to 1,
    and so on. This chapter is going to act as a prequel to one of the later chapters
    discussing shell scripting examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Using text commands to merge file content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting DOS text to Linux text and vice versa
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `cut`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `egrep`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `sed`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For these recipes, we're going to use one Linux machine – we can use `client1`
    from our previous recipes. It doesn't really matter which virtual machine gets
    used as all the commands that we are going to discuss in these recipes work the
    same way on all Linux distributions.
  prefs: []
  type: TYPE_NORMAL
- en: Using text commands to merge file content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start with something simple – which is merging file content. Of course,
    we are only discussing text content here as merging binary files would be pointless.
    Our goal is to learn how to use two commands – `paste` and `cat` – to do simple
    things, such as concatenation and merging line by line. Let's start!
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just need one Ubuntu and one CentOS machine for this recipe. Here, we are
    going to use `cli1` and `cli2` to master these commands.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Starting with the simplest command for this chapter – `cat` – let''s see some
    examples of what it does. If we type in a command such as `cat filename.txt` –
    if a file named `filename.txt` exists – we are going to get the content of that
    file on display. Let''s check an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Using the cat command on a text file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.1_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.1 – Using the cat command on a text file
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we used the `cat` command to show the content of an `auth.log` file located
    in the `/var/log` directory. If we have been using this machine for a while, there
    will be other files with `auth.log` as a prefix, then a number, and the `gz` extension.
    Let''s check:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Finding content that we are going to use'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.2_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.2 – Finding content that we are going to use
  prefs: []
  type: TYPE_NORMAL
- en: 'So, for the purpose of this recipe, let''s use the `auth.log` and `auth.log.1`
    files. What happens if we want to have one file that contains both `auth.log`
    and `auth.log.1` content? We''d either open a text editor and do a bit of copy-pasting,
    or we can use `cat` to do that for us. The `cat` command can be used with multiple
    files at the same time, such as `cat auth.log auth.log.1`, which would show us
    the content of the first file followed by the content of the second file. The
    only thing that we need to do is to redirect the text output from that command
    to a new file, which we can easily do by using the `>` sign. Let''s say that we
    want to save the output of this command to a file in the `/root` directory called
    `auth-full.log`. Here''s how we''d do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – Using the cat command to concatenate files'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.3_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.3 – Using the cat command to concatenate files
  prefs: []
  type: TYPE_NORMAL
- en: '`cat` actually displays text files line by line, which is a property that we
    will heavily use in our chapters relating to shell script examples.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If for some reason we wanted to merge files line by line, we could''ve used
    the `paste` command. Let''s see how that would work. Seeing that these files are
    just way too big, we are going to create two files. Let''s say that the first
    file (named `first.txt`) will have the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The second file (named `second.txt`) will have this content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s use the `paste` command and check the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – Using the paste command to combine text files line by line'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.4_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.4 – Using the paste command to combine text files line by line
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the `paste` command combines two files line by line, by putting
    them one next to the other.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These two commands are rather simple in operation:'
  prefs: []
  type: TYPE_NORMAL
- en: By default, `cat` displays the complete content of a file or set of files, line
    by line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, `paste` combines files line by line, side by side.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are two very different approaches to text manipulation, both with real-life
    use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Our next recipe is a simple one as well – how to deal with a situation when
    we transfer text files from Microsoft OSs to Linux in terms of making them usable
    in Linux. As we are going to see, there are some fundamental differences with
    `.txt` formats between Microsoft OSs and Linux, which makes the next recipe a
    necessity. Stay tuned for it!
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you need more information about using `cat` or `paste`, make sure that you
    check out the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Basic `cat` command examples in Linux: [https://www.tecmint.com/13-basic-cat-command-examples-in-linux/](https://www.tecmint.com/13-basic-cat-command-examples-in-linux/%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `paste` command in Linux (merge lines): [https://linuxize.com/post/paste-command-in-linux/](https://linuxize.com/post/paste-command-in-linux/%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting DOS text to Linux text and vice versa
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a strange idea – you might have thought a `.txt` file is a `.txt` file,
    right? Wrong.
  prefs: []
  type: TYPE_NORMAL
- en: There are subtle differences between `.txt` file formats in DOS/Windows and
    Linux. Sometimes, those differences can make you mad in a matter of seconds. We've
    had our fair share of experiences of that – scripts not working as input files
    were prepared on Windows, not on Linux; different treatment of CSV files in Excel
    *by design*... sometimes it's just too funny when, after hours of deliberation,
    you realize that something as simple as a `.txt` file created on another OS can
    make such a mess. Let's explain what the problem is and work through it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We just need one Ubuntu machine for this recipe. Let''s say we are going to
    continue using `cli1` to master these commands. Furthermore, we need to install
    one package, called `dos2unix`. So, if we are using `cli1` (Ubuntu), we need to
    type in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: After this package is installed, we are ready to do our recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s say that we created a `.txt` file called `txtsample.txt` in Notepad
    on Windows, which has the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we upload this file to our `cli1` machine and open it in vi or vim to
    check its content. This is what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – What our file seems to look like'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.5_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.5 – What our file seems to look like
  prefs: []
  type: TYPE_NORMAL
- en: 'Everything seems fine, right? Now, let''s do the same thing all over again,
    but this time, start vi or vim with the `-b` option. For example, use the `vi`
    `-b txtsample.txt` command and check the file content now. It should look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6 – What our file actually looks like'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.6_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.6 – What our file actually looks like
  prefs: []
  type: TYPE_NORMAL
- en: We can see `^M` characters) in the vi/vim editor now. This is one of those subtle
    differences between the way Notepad and Linux text editors treat `.txt` files.
    Linux shell commands aren't necessarily going to treat this type of text in a
    friendly manner, and sometimes scripts will not work properly because of these
    *extra* characters that Linux commands don't need.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this problem is a simple package and command called `dos2unix`
    that we installed in the *Getting ready* step of this recipe. After that, it''s
    a simple procedure of typing in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s open this file in vi with the same `-b` option now and check the file
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7 – End result – a file that''s stripped of CRs'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.7_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.7 – End result – a file that's stripped of CRs
  prefs: []
  type: TYPE_NORMAL
- en: Now that's much better.
  prefs: []
  type: TYPE_NORMAL
- en: There are other examples of this approach – end-of-file characters, *invisible*
    characters that sometimes appear out of nowhere in Excel-exported CSV files. So,
    we have to make sure that we are aware of this problem and its simple solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could also use tools such as `tr`, `awk`, and `perl` to do the same thing.
    Let''s use `tr` as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Let's now explain how this works and why it's such a problem.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A CR is a character that has been used through the years as a control mechanism
    to set the end of a line, and, as a result, start a new line of text. For those
    of us old enough to remember the old typewriter machines, the CR on a mechanical
    typewriter machine would be that funny lever that we had to pull to get to a new
    line. By extension, this is a part of ASCII code that helps with cursor positioning
    (beginning of the next line).
  prefs: []
  type: TYPE_NORMAL
- en: If we don't clear our `.txt` files of these characters (and others), we might
    have problems with scripting. In our last two chapters of this book with shell
    script examples, we're going to have multiple example scripts that use the `cat`
    command to input something from a `.txt` file into a loop. These characters might
    mess that procedure up, and we don't want that.
  prefs: []
  type: TYPE_NORMAL
- en: '`dos2unix` and the mentioned `tr` command strip the input file of CRs. We might
    debate which method is better, but at the end of the day, it''s about results,
    and both methods work. We prefer the `dos2unix` method; but, of course, you might
    prefer the `tr` way.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you need more information about converting DOS `.txt` files to Linux, refer
    to the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dos2unix` man page: [https://linux.die.net/man/1/dos2unix](https://linux.die.net/man/1/dos2unix%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`yr` man page: [https://linux.die.net/man/1/tr](https://linux.die.net/man/1/tr%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using cut
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are tools in IT that get elevated to greatness by the simple fact that
    they are great tools. The next three tools that we are going to use are tools
    that fit the description of some of the greatest CLI tools ever invented. For
    us, `cut` is the second greatest CLI command of all time; if you want to find
    out which command takes the coveted *#1* spot, stay tuned for the next recipes.
  prefs: []
  type: TYPE_NORMAL
- en: '`cut` is a tool that can make our lives a lot easier if we''re working with
    preformatted input. For example, it will easily work with CSV, as that''s a formatted
    type of content that can be easily digested by `cut`. Let''s learn about `cut`
    by doing some examples next.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just need one Ubuntu machine for this recipe, so let's keep using `cli1`.
    The `cut` command is a standard part of any Linux distribution and that's how
    it should be, as it's more important than other commands, such as `ls`, `mkdir`,
    and `ps`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s first create a sample CSV file. For example, we are going to create
    a CSV file with user data, and use `cut` on top of that file. Here''s what we
    used for this recipe (CSV file content):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8 – Sample input CSV file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.8_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.8 – Sample input CSV file
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now going to check what we can do with this file and the `cut` command.
    Let''s start with some simple things. For example, first we are going to extract
    just names from this file, which translates to the first field (before the first
    comma sign):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.9 – Extracting the first field from a standard-format file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.9_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.9 – Extracting the first field from a standard-format file
  prefs: []
  type: TYPE_NORMAL
- en: 'By using the `cut` command and two switches, we were able to easily extract
    names from the CSV file. Now, let''s add a bit more to the process. Let''s extract
    the name and login (first and third fields):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.10 – Extracting the first and third fields from our sample file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.10_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.10 – Extracting the first and third fields from our sample file
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, let''s now extract the first three fields – name, surname, and
    login:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.11 – Extracting a range of fields from our sample file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.11_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.11 – Extracting a range of fields from our sample file
  prefs: []
  type: TYPE_NORMAL
- en: 'We could also choose to sort that output alphabetically:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.12 – Sorting output from a cut file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.12_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.12 – Sorting output from a cut file
  prefs: []
  type: TYPE_NORMAL
- en: 'One other classic example is using `cut` to output fields from one specific
    field onward – for example, from the second field to the last field:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.13 – Extracting fields from the second field onward'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.13_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.13 – Extracting fields from the second field onward
  prefs: []
  type: TYPE_NORMAL
- en: If you're heavily into Microsoft PowerShell, this will kind of remind you of
    the `Import-Csv` PowerShell cmdlet, although the similarities end there, seeing
    as PowerShell is an object-based shell language.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from these examples, the `cut` command is very useful for situations
    where we have an input file that's in some sort of standard format that uses some
    character as a delimiter between fields. We can easily use it to extract content
    from our text files and to prepare text-based input for other actions that might
    follow using `cut` in a shell script.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`cut` is a straightforward command that has only one prerequisite – we need
    to have an input file that''s formatted in some sort of standard format. That
    translates to having a file with fields delimited by the same character. If that
    criterion is met, we can easily use `cut` to do wonders in one-liner commands
    and shell scripts.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most commonly, we use two parameters with the `cut` command:'
  prefs: []
  type: TYPE_NORMAL
- en: The `-f` parameter is used to select which field(s) or field range we are going
    to use to be extracted by using the `cut` command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `-d` parameter is used to select a delimiter, a character that separates
    our text strings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can also use it in conjunction with other commands, such as `sort`, `tr`,
    and `uniq`, to do further manipulation of the output extracted by using the `cut`
    command. We can even use its parameter called `--output-delimiter` to change the
    input delimiter to some other output delimiter.
  prefs: []
  type: TYPE_NORMAL
- en: This was a warmup exercise before the big star of the show – the `egrep` command
    – as its significance can't be overstated. Let's talk about `egrep` next.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you need more information about networking in CentOS and Ubuntu, make sure
    that you check out the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cut` man page: [https://man7.org/linux/man-pages/man1/cut.1.html](https://man7.org/linux/man-pages/man1/cut.1.html%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bash `cut` command examples: [https://linuxhint.com/bash-cut-command-examples/](https://linuxhint.com/bash-cut-command-examples/%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using egrep
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using `egrep`, and regular expressions in general, is something like page one,
    chapter one stuff from the never-written *How to be both cool and incredibly useful*
    IT manual. It is, without a shadow of a doubt, the most useful command that was
    ever invented in the UNIX/Linux world for system administration. It doesn't really
    matter whether we're looking for a specific string in a file or set of directories,
    whether we're trying to find a line in a big text file where a specific string
    is located, or whether we're trying to find where a specific string isn't, `egrep`
    can do all of that for us. We are focusing on `egrep` specifically, as it supports
    both concepts that are behind this command – regular expressions and extended
    regular expressions. That's where we are going to start – first, by explaining
    the merits of using regular expressions, and then moving on from that to explain
    why `egrep` is such an important command. So, buckle up and get ready to go!
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to use two virtual machines for this recipe – the Ubuntu-based
    `cli1` and CentOS-based `cli2`. That's going to enable us to have more examples
    as logging configuration on Ubuntu is a bit different from CentOS, and CentOS's
    logging configuration makes it easier to drive some points home. So, start both
    of these virtual machines and let's get going.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using regular expressions comes naturally to everyone if we take some time to
    get to know how to use them. By extension, our first *frontend* to regular expressions
    is using the `grep` or `egrep` command. These commands enable us to find a text
    string inside a text file or text input.
  prefs: []
  type: TYPE_NORMAL
- en: Let's use a simple example. In [*Chapter 4*](B16269_04_Final_PD_ePub.xhtml#_idTextAnchor077),
    *Using Shell to Configure and Troubleshoot Network*, we used the `ps` command
    to display running processes. Let's say that we want to do this now, but by using
    regular expressions. For example, we need to list all the processes on our Linux
    server that were started by user `student`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we start with the `ps` command first – for example, if we use the `ps auwwx`
    command – we are going to get an output like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.14 – ps auwwx input, cut short for formatting reasons'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.14_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.14 – ps auwwx input, cut short for formatting reasons
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's discuss the fact that this is a text output for just a second – it
    has a lot of letters and numbers. Also, let's focus on the fact that all processes
    running on our system are represented by a line in the `ps` command output – a
    line that, as seen in the figure, starts with the `root, www-data` string, or
    some other string that represents the user that owns the process. How about if
    we figure out a way of using that as a property to filter the `ps` command output
    as text, by using the idea of *line starts with* `student` for it?
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted to do that, we would use a simple command: `ps auwwx | grep ^student`.
    As we discussed previously, the `|` sign means *we want to send the output of
    the first command to the second command*. Furthermore, `grep` means *we want to
    filter something out*. And this `^student` thing? That''s what we call a regular
    expression pattern, with the `^` character being a regular expression symbol.
    Specifically, it''s an anchor, which when used with `grep` or some other regular
    expression-aware command means *line starts with* the character, or a set of characters
    that follow. Let''s put that theory into practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.15 – Using our first regular expression'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.15_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.15 – Using our first regular expression
  prefs: []
  type: TYPE_NORMAL
- en: So, here we go, we filtered our output by using the `student` string as a filter.
    We can also see that each appearance of that string is marked in red. This comes
    from the fact that `grep` commands use the `--color` option by default – an option
    that highlights the string that we were using as a condition for filtering.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that now we want to find all lines in our `ps auwwx` output that
    end with the `bash` string. We can easily use regular expressions for that. Here''s
    how we''d do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.16 – Using a regular expression to find a string at the end of a
    line'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.16_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.16 – Using a regular expression to find a string at the end of a line
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we''ve used the `ps` command as it''s convenient and familiar. Let''s
    now move on to other examples that are going to use text files as a basis. The
    first one that comes to mind is `/usr/share/dict/words`, a dictionary text file
    that contains more than 100,000 words. The format of that file is *one word per
    line*, so more than 100,000 words equals more than 100,000 lines. Let''s try to
    find all the lines that have the `parrot` string in them. Here''s the command
    and result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.17 – Using grep directly on a text file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.17_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.17 – Using grep directly on a text file
  prefs: []
  type: TYPE_NORMAL
- en: So, the `grep` command can also be directly used on a text file, which is very
    useful when dealing with scripts, input files into scripts, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, so good. Let''s make things a bit more complicated. Let''s say that
    we need to find all lines in the same file (`/usr/share/dict/words`) that contain
    a string conforming to these rules:'
  prefs: []
  type: TYPE_NORMAL
- en: The line needs to start with `p`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The letter `p` needs to be *followed by a vowel*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A vowel needs to be followed by the `ta` string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All of a sudden, things get much more complicated. Imagine having to find these
    words using a regular text editor. Writing down all these combinations would lead
    us to the following words that we''re looking for:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pata`, followed by anything'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`peta`, followed by anything'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pita`, followed by anything'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pota`, followed by anything'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`puta`, followed by anything'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a regular text editor, it would take us five different sequential finds to
    find all the words, and even then, we'd have to press *next-next-next* for all
    the next appearances in case one of these string samples can be matched multiple
    times.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where regular expressions can be of great help. We could do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.18 – Finding a more complex string sample'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.18_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.18 – Finding a more complex string sample
  prefs: []
  type: TYPE_NORMAL
- en: By using the `^p[aeiou]ta` regular expression, we were able to find all of the
    words matching that criterion easily. When using these square brackets to input
    a regular expression sample, we are basically saying to the regular expression-aware
    command to search for *either a, or e, or i, or o, or u* as a character inside
    the regular expression string.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, getting to know regular expressions can be quite useful. Let''s
    add some more of them with a short explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 8.1 – Commonly used regular expression symbols and their meaning'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16269_08_Table_1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 8.1 – Commonly used regular expression symbols and their meaning
  prefs: []
  type: TYPE_NORMAL
- en: There are many more regular expressions that we can use, but let's just start
    with these and then move on to more complex examples – for example, extended regular
    expressions.
  prefs: []
  type: TYPE_NORMAL
- en: How about matching numbers? Matching numbers with regular expressions is, let's
    say, *fun*. Especially if we need to find a number range – things get really complicated
    real soon if that's the case. Let's discuss this by using three examples – one
    for a single-digit number range, one for a simple double-digit number range, and
    one for a more complex double-digit number range. We can extrapolate how this
    logic would work on larger numbers. Let's start with a simpler example – for example,
    a number range from 0 to 5 – and just work with regular expressions, forgetting
    the `grep` command for a second. In regular expression terms, that would be `[0-5]`.
  prefs: []
  type: TYPE_NORMAL
- en: For our next example, let's use a simple double-digit number range – let's say,
    14-19\. In regular expression terms, we'd write that as `1[4-9]`.
  prefs: []
  type: TYPE_NORMAL
- en: This means 1 as a leading number (tens), and then the number range from 4 to
    9, which equals 14-19\.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we specifically chose to use the `grep` command to do these first examples
    as it works with basic regular expressions. We need to add a `-E` switch to the
    `grep` command or start using the `egrep` command if we want to move on to extended
    regular expressions. So far, we've covered some basics, so it's time to make things
    a bit more complicated. Everything that we've discussed so far is what we call
    `\?` and `\|` get replaced in EREs with `?` and `|`. That makes the syntax cleaner
    and easier on the eye, so to speak. Let's work on some examples, first by continuing
    our *using regular expressions to match numbers* discussion.
  prefs: []
  type: TYPE_NORMAL
- en: 'What happens if we need to find a number range, for example, 37-94? Regular
    expressions can''t work with multiple-digit numbers in ranges – we need to slice
    that into ones, tens, hundreds, and so on. And then, we need to use a very well-known
    concept called the union of a set (of ranges) to combine all of the ranges into
    one range that fits the regular expression that we wanted to find. Keeping in
    mind that we are going to need a set – a set of numbers, in this example – we
    are going to do this by using EREs. Let''s see how that works with minimization
    in mind – we want to have a regular expression that''s as short as possible. Knowing
    the fact that we need to use the union of a set, the simplest way to do this number
    range would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 37-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 40-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 90-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In regular expression terms, those sets would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`3[7-9]` for 37-39'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[4-8][0-9]` for 40-89'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`9[0-4]` for 90-94'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As a regular expression, we''d write it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`3[7-9]|[4-8][0-9]|9[0-4]`'
  prefs: []
  type: TYPE_NORMAL
- en: Here, the `|` sign basically stands for *or*. This is a way of implementing
    a union set when using regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keeping in mind that Ubuntu''s version of the `/usr/share/dict/words` file
    doesn''t have a single number in it, we added a couple of numbers to the top of
    this file just so that we have something to test with. For example, we added the
    following to the top of this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`41`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`58`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`36`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`95`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`94`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We deliberately chose these numbers as they contain both numbers that are conformant
    to the regular expression that we made (41, 58, and 94 will be a match) and numbers
    that aren''t (36 and 95). If we use `grep` with our regular expression on this
    file with added numbers, we will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.19 – Using a union set works and we found our matches'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.19_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.19 – Using a union set works and we found our matches
  prefs: []
  type: TYPE_NORMAL
- en: As we grow the number of digits that we're looking for, regular expressions
    get more and more complex. We should always minimize as much as we can, but there
    will be situations where we must make a lot of union sets to find something that
    we are looking for. That's just the name of the game, nothing to be scoffed at.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next example is going to find words (non-numbered only) that are 19 to
    20 characters long, made of letters only. We''re still using the same file as
    before, so let''s see how we do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.20 – Finding words of specific length'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.20_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.20 – Finding words of specific length
  prefs: []
  type: TYPE_NORMAL
- en: Easy, right? We matched all the lowercase and uppercase characters and then
    said *words need to have 19 to 20 of those*.
  prefs: []
  type: TYPE_NORMAL
- en: Things tend to get even more complicated when you're trying to create a regular
    expression for some words that are common, yet different, especially if word length
    is variable, and even more so if number ranges are involved. But all of that doesn't
    bring us closer to explaining what the practical point, the real value of regular
    expressions, is. Everything that we did so far seems like general hocus pocus,
    *trying to find some text – why should we care about that?* Generally speaking,
    we were only describing the principle, as using generic examples helps. Realistically,
    there's absolutely no way to learn regular expressions by reading 10-15 pages
    of text. But we are now going to make an educated effort to move this story along
    to real-life, practical uses of regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: There are some common services that use `grep` and/or regular expressions constantly.
    We have to keep in mind that this recipe is about `grep` as a command, not about
    regular expressions only.
  prefs: []
  type: TYPE_NORMAL
- en: For example, regular expressions are heavily used for mail filtering. Checking
    the body of an email – basically text content – is easy if you have a regular
    expression-enabled mail filter. From an everyday system administrator standpoint,
    regular expressions are constantly used for parsing through log files and finding
    valuable information in them. Let's make that point now by using regular expressions
    on log files, as that's one of the most commonly used practices that's been happening
    for decades now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now switch to `cli2`, our CentOS-based system, and use `/var/log/messages`
    for the next examples. This file contains the main system log on CentOS, so it''s
    perfectly suitable to use regular expressions to find something in it. Let''s
    start with the simple stuff. For example, let''s say that we need to find all
    log entries in `/var/log/messages` that were made on October 6, and even more
    specifically, at the ninth hour, by a service called `PackageKit`. Let''s first
    check the structure of this log file – it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.21 – Format of a file that we''re going to use grep on'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.21_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.21 – Format of a file that we're going to use grep on
  prefs: []
  type: TYPE_NORMAL
- en: As we were discussing in our previous recipe about the `cut` command, we can
    see that this file *kind of* has a standard format. There's a timestamp at the
    beginning, the hostname after that, the service and PID after that, and then some
    kind of text message. Also, notice the fact that the timestamp part has a very
    cool addition – its format is not `Oct 6` with a single space between; it has
    two spaces. This is very important as it keeps the date format a fixed length
    when we get to double-digit dates, such as `Oct` `15`. It just makes everything
    formatted nicely, which is cool.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the simple fact is that we can easily output this by using `grep`. Let''s
    do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.22 – Filtering out data that we wanted to filter out'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.22_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.22 – Filtering out data that we wanted to filter out
  prefs: []
  type: TYPE_NORMAL
- en: The first part of the command greps out all messages from `Oct 6` that starts
    with `09` in the hour part of the timestamp; then, we piped that out to another
    `grep` command that searches for the `PackageKit` string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next example – and this one becomes more common as we get older – is, let''s
    say that we can''t remember the name of a file where the `firewall` string is
    used. We remember that it was somewhere in the `/etc/sysconfig` folder, but we
    can''t seem to remember what the filename was – one of those *it''s early Monday
    morning, I haven''t had time to wake up* moments. This is what we could do by
    using `grep`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.23 – Using grep on a stack of files all at once'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.23_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.23 – Using grep on a stack of files all at once
  prefs: []
  type: TYPE_NORMAL
- en: The `grep` option `-r` means *recursive* and the `-i` option means *case insensitive*.
    Also, the `-r` option ignores any symbolic links as it recursively moves through
    subdirectories. If we want that behavior to change, we can use the `-r` option,
    which will take symbolic links into account. As we have the capability to use
    recursive search through file contents, that means `grep` is going to dive into
    subdirectories and go through all files. That means we must add one caveat to
    our discussion – we really, *really shouldn't* use this on binary files, for obvious
    reasons. It would make a big mess on our terminal output, if nothing else.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s end this recipe by using `egrep` for a much more complex scenario involving
    EREs and different text patterns on text input, the caveat being that we want
    to see a bit of *context* around our text pattern matches. Let''s say that we''re
    trying to go through our `dmesg` boot log, and we are searching for all the hard
    disks – all the `/dev/hd*` and `/dev/sd` devices. We could use the following command
    for that purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check what the output would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If we take a look at the end of this output, we can see that the last two lines
    don't match our regular expression used to filter data. That's because we used
    the `-C2` parameter with `egrep`, and that option enables `egrep` to show two
    lines preceding and two lines following our pattern match. We can divide that
    option into options `-A` and `-B` (after and before the match, respectively) if
    we want to specify a custom number of lines to appear after and before our pattern
    match. There are many more `grep` options available, but these are enough to get
    us started. We will add some more examples of using regular expressions and some
    topics we didn't cover here in the next recipe, about the `sed` command.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`grep` is a pattern-matching command that can work in a variety of different
    ways – either as a standalone command that takes text files as input or as something
    that we pipe input to in a command set. Its purpose is clear – find specific text
    patterns in a large set of text. A couple of years ago, its default output changed
    a little bit as it used to show the lines matching our search pattern, while now
    it does that and it does it in color, by marking the found search pattern in red.'
  prefs: []
  type: TYPE_NORMAL
- en: '`grep` works by implementing the idea of text pattern search into a programmable
    command that''s a regular part of shell scripts, as we''ll explain in the last
    two chapters with practical examples of scripting. As such, it''s an irreplaceable
    part of a system administrator''s toolkit as it enables us to find important text
    data from one or many files, therefore bringing a sort of chaos into order.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The most commonly used options are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-E` (or `egrep`): By default, `grep` recognizes BREs only. If we use the `-E`
    parameter, it works with EREs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-i`: Case-insensitive search.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-v`: Invert match, find the opposite of our search pattern: `A`, `-B`, `-C`
    – options providing *context* to our output, by showing A number of lines after,
    B number of lines before, or C number of lines before and after our pattern match.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-n`: Show the line number where the pattern match appears.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's continue our quest to use CLI-based utilities that can do important things
    on text content by moving on to look at the `sed` command in our next recipe.
    That will also give us some more scope to further our knowledge about regular
    expressions, as `sed` can use them to be even more useful than its usual, vanilla
    self.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you need more information about `grep` in Linux, you can check out the following
    links:'
  prefs: []
  type: TYPE_NORMAL
- en: '`grep` man page: [https://man7.org/linux/man-pages/man1/grep.1p.html](https://man7.org/linux/man-pages/man1/grep.1p.html%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '20 useful `grep` command examples in Linux: [https://www.linuxbuzz.com/grep-command-examples-linux/](https://www.linuxbuzz.com/grep-command-examples-linux/%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Regular expressions in `grep`: [https://linuxize.com/post/regular-expressions-in-grep/](https://linuxize.com/post/regular-expressions-in-grep/%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Stanford''s regular expression cheat sheet: [http://stanford.edu/~wpmarble/webscraping_tutorial/regex_cheatsheet.pdf](http://stanford.edu/~wpmarble/webscraping_tutorial/regex_cheatsheet.pdf%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using sed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to our discussion about manipulating text, we absolutely must discuss
    `sed`. It's a go-to tool to solve so many problems where quick solutions are needed
    and a lot of text is involved. I can list more than a few examples just from the
    past couple of years where it saved my skin. For example, I had a couple of projects
    that required migrating WordPress sites from one domain to another. As it was
    something that needed to be done in a flash, testing migration modules wasn't
    an option. The simpler way was to just export the MySQL database, change *domain1*
    to *domain2*, and check whether it worked. Later, I had a couple more projects
    like that where it wasn't just a domain name change; subdomain name changes were
    needed too, and so on. Keeping in mind that it would take me weeks to do this
    manually on a database that was gigabytes in size – yes, `sed` really helped me
    out in those jams. Let's discuss the merits of using `sed` and learn by working
    on a couple of examples. In the last two chapters of this book, we're also going
    to go through some of these WordPress-based examples so that we can see how that's
    done in a jiffy.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's continue using the `cli2` machine from the previous recipe. If it's shut
    down, turn it back on so that we can learn about using `sed`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we're using `cut`, we are working with standard-formatted input that needs
    to be transformed in some way. When we're using `grep`, we are looking to find
    a text sample just for the purpose of finding that text sample. What happens if
    we need to find some text sample and change it to something else?
  prefs: []
  type: TYPE_NORMAL
- en: For most users, the answer is, *I'm going to open my favorite editor and do
    a search and replace*.
  prefs: []
  type: TYPE_NORMAL
- en: Precisely. And that's what `sed` is mostly about, especially if we have a file
    that's really big, gigabytes and more in size. It's about having the capability
    to do a search and replace, based on text patterns and regular expressions, without
    having to open an editor.
  prefs: []
  type: TYPE_NORMAL
- en: Have you ever tried to open a 1 GB text file in Notepad or Wordpad to do search
    and replace, and if so, how did that work out for you? Let alone having to read
    multiple large files on multiple systems, especially non-Windows systems?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do some simple, a bit complicated, and more complicated scenarios with
    `sed`. The first scenario is going to be related to inserting and appending a
    bit of text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check the result of this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.24 – First example of using the sed command'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.24_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.24 – First example of using the sed command
  prefs: []
  type: TYPE_NORMAL
- en: The `-i` switch in this command does inline replacement. Keeping in mind that
    we used `sed` without any additional options, it didn't replace anything with
    anything, just inserted the line before the `echo` command, although logic suggests
    that the `echo` command's output should've been first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally speaking, `sed` has the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, in our previous example, we didn''t use any options at the beginning
    or end of the `sed` quotes; we only used source text. `sed` can also be used to
    extract specific lines from a file. For example, let''s say that we want to extract
    lines 5-10 from the `/var/log/messages` file in our `cli2` CentOS machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.25 – Using sed to extract a specific part of a text file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.25_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.25 – Using sed to extract a specific part of a text file
  prefs: []
  type: TYPE_NORMAL
- en: The default way of operation for `sed` is to print every line, and if there
    is a substitution being made by our source/destination text configuration, it
    will print the substituted text instead of printing the original one. That's why
    we have `-n`, as we don't want to print any new lines as we're not doing any kind
    of substitution. `'5,10p'` means print from lines 5 to 10.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also do the opposite of that – let''s say, we want to print all lines
    from a file, and delete lines 5 to 10\. We can use the following command to do
    that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use `sed` to display some lines that are not successive in a text
    file, for example, display lines 20-25 and 40-100 in `somefile.txt` (`-e` used
    per expression):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: But that's all just using `sed` for some very pedestrian stuff. Let's now start
    using it for what we'd mostly use it for, which is string replacement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that we have a text file called `sample.txt` with the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '*This camera produces some weird sounds. Sometimes it buzzes, sometimes it
    squeals, and always manages to somehow produce un-camera-like high-pitched squeal
    that should only be audible to dolphins and whales. As a camera, it''s good. As
    a camera with ability to record sound, it''s useless. So, we need a camera.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first `sed`-based task is going to be to replace all instances of `camera`
    with `microphone`. For that, we need to use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, the word `camera` gets replaced with the word `microphone` in
    the console, and the end result looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.26 – Using sed to replace words without saving these changes to
    our original file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.26_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.26 – Using sed to replace words without saving these changes to our
    original file
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to replace `camera` with `microphone` and for these changes to be
    saved to the original file, we need to use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, this is the end result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.27 – Using sed to replace words and saving those changes to the
    original file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.27_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.27 – Using sed to replace words and saving those changes to the original
    file
  prefs: []
  type: TYPE_NORMAL
- en: The `sed` options `s` and `g` are for searching for a word or regular expression
    and then replacing it globally. By using the `-i` switch, we made that replacement
    operation in place, which means saving replacement changes to the original file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some more examples are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'a) Insert blank lines for each non-empty line in the original file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'b) Keep the original file content by creating a backup file and do an inline
    replacement in the original file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'c) Replace the word `somethingtochange` with `somethingtobechangedto` when
    the `practice` string appears in the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'd) Negation of the previous statement: Replace `somethingtochange` with `somethingtochangeto`
    and only replace it if the `practice` string does not appear in the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'e) We can delete the line that matches some pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'f) Let''s search for a number inline and append a currency symbol before the
    number (regular expression for finding numbers used, as well as a backslash for
    proper quoting):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'g) Let''s replace `/bin/bash` with `/bin/tcsh` in `/etc/password` (a regular
    expression isn''t needed here, but we have to use the `\` character for correct
    interpretation of the `/` character as the `/` character is a special character):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, `sed` is a very powerful tool that can be used to do a lot of
    changes *on the fly*. We are going to show some more examples of using `sed` in
    scripts later in this book, specifically in the last two chapters with shell script
    examples. That will give us further insight into `sed` and its usefulness in everyday
    work.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a command-line text replacement utility, `sed` requires us to *explain* what
    we want to do to it. That's the reason why the structure of `sed` commands seems
    a bit *descriptive* – that's just because it is. It also has a lot of options
    and switches, which add to the overall usability and possible usage scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic command structure is usually something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, it might be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, `sed` is often used in scripts, either standalone or as a part of
    a serial pipeline, something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Whichever way we use `sed`, it's essential to learn at least some of its switches
    and settings, starting with the most commonly used ones – `s` and `g` inside `sed`
    expressions and `-i` as a command-line parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say we have a command such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, this has multiple important options. The `-i` option, as we mentioned,
    is all about interactive change that's going to implement our search-and-replace
    criteria in the original file. Without it, we are going to get results from our
    `sed` command to the screen, basically results written to the console. Options
    inside the quotes – `s` and `g` – are the most-used `sed` options, and they mean
    search and globally replace, that is, in the whole file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could do the same thing without the `-i` option, by doing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: But, as you might imagine, this requires more typing and is generally more complicated.
  prefs: []
  type: TYPE_NORMAL
- en: The `sed` command-line option `-n` can be used to suppress output to the terminal,
    and that's the reason why it's used often. If we have a large text file that we're
    modifying and we aren't using the `-i` option, this might be the go-to option
    to use if we don't want our console filled with text data.
  prefs: []
  type: TYPE_NORMAL
- en: 'One more very useful option is the `-f` option, as it allows us to use an input
    `sed` file with replacement definitions. Say we run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We create a `seddefinitionfile.sed` file that contains this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We can use these options to do multiple `sed` transformations in one command.
    We just need to create `sed` definitions in the file and use it.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter in this book is going to introduce us to the world of shell
    scripting – and the whole second half of the book is about shell scripting. We
    will get to use all the tools that we discussed up to now there, and combine them
    to create shell scripts, some of the most used programming-based administration
    tools ever. Take a short break and get ready to shell script!
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you need more information about networking in CentOS and Ubuntu, make sure
    that you check out the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sed` manual page: [https://man7.org/linux/man-pages/man1/sed.1p.html](https://man7.org/linux/man-pages/man1/sed.1p.html%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '50 `sed` command examples: [https://linuxhint.com/50_sed_command_examples/](https://linuxhint.com/50_sed_command_examples/%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sed` quick reference guide: https://kwiki.kryptsec.com/books/sed-editor/page/sed-quick-reference-guide'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
