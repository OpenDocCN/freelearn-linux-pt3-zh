- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Illustrating the Layout of Physical Media
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 说明物理介质的布局
- en: “If I had asked people what they wanted, they would have said faster horses.”
    – Henry Ford
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: “如果我问人们他们想要什么，他们会说更快的马。” — 亨利·福特
- en: In the first seven chapters of this book, we explored the organization of storage
    hierarchy in the Linux kernel, the organization of different layers, the different
    abstraction methods, and the representation of physical storage devices. We’re
    now done with explaining the software side of things in the storage stack, which
    means it’s time to take a look at the actual hardware and see what lies beneath.
    I thought it would be best if we got to look at the different types of storage
    media so that we could not only understand their operations but also see why the
    Linux kernel uses different schedulers and techniques to handle the different
    types of drives. In short, getting to know the internals of disk drives will make
    the information presented earlier in this book a lot more relevant.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的前七章中，我们探讨了 Linux 内核中存储层次结构的组织方式、不同层次的组织方式、不同的抽象方法以及物理存储设备的表示方式。我们现在已经完成了对存储堆栈中软件部分的解释，这意味着是时候看看实际硬件，了解其中的奥秘了。我认为最好的方式是通过了解不同类型的存储介质，这样我们不仅能理解它们的工作原理，还能看到为什么
    Linux 内核使用不同的调度器和技术来处理不同类型的硬盘。简而言之，了解磁盘驱动器的内部结构将使本书中之前呈现的信息更具相关性。
- en: The choice of a hardware medium has evolved over the last few years, as there
    are now considerable options available in the market, not only for enterprise
    storage but also for personal use. These different storage options are suited
    to specific environments and workload types. For instance, in some scenarios,
    people look for capacity-oriented solutions, while in others, maximizing performance
    is the ultimate concern. Either way, there is a solution available for every scenario.
    For enterprise environments, vendors offer storage arrays that can implement a
    hybrid solution and contain a mix of these options.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件介质的选择在过去几年中发生了变化，因为市场上现在有大量的选择，不仅适用于企业存储，也适用于个人使用。这些不同的存储选项适用于特定的环境和工作负载类型。例如，在某些场景中，人们寻求容量优先的解决方案，而在其他场景中，最大化性能是最终目标。无论如何，每种场景都有相应的解决方案。对于企业环境，供应商提供可以实现混合解决方案的存储阵列，包含这些选项的组合。
- en: Most protocols and systems were built and designed with spinning hard drives
    in mind. The storage stack in Linux is no exception to this rule. When discussing
    scheduling in the block layer, we saw how techniques such as merging and coalescing
    are geared toward mechanical drives so that the number of sequential operations
    can be increased. As this chapter is all about the physical layout and structure
    of different types of drives, we’ll see in detail why spinning drives are slower
    than the rest.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数协议和系统在设计时都考虑到了旋转硬盘。Linux 中的存储堆栈也不例外。在讨论块层调度时，我们看到合并和合并等技术是针对机械硬盘的，以便增加顺序操作的数量。由于本章完全涉及不同类型硬盘的物理布局和结构，我们将详细了解为什么旋转硬盘比其他硬盘更慢。
- en: We’ll start by introducing the traditional and oldest form of storage available
    today, the rotating hard drive. We’ll discuss its physical structure, design,
    and working principles. After that, we’ll move on to solid-state drives and see
    what makes them different from mechanical drives. We’ll discuss their internal
    structure and layout, and explain their operating principles. We’ll also briefly
    discuss the concept of drive endurance and see how it differs for both mechanical
    and solid-state drives. Finally, we’ll discuss the **Non-Volatile Memory Express**
    (**NVMe**) interface, which has revolutionized the performance of solid-state
    drives.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从介绍今天最传统、最古老的存储形式——旋转硬盘开始。我们将讨论其物理结构、设计和工作原理。之后，我们将转向固态硬盘，看看它们与机械硬盘有何不同。我们将讨论它们的内部结构和布局，并解释它们的工作原理。我们还将简要讨论硬盘耐久性的概念，并了解机械硬盘和固态硬盘在这方面的区别。最后，我们将讨论**非易失性内存快车道**（**NVMe**）接口，它彻底改变了固态硬盘的性能。
- en: 'We’re going to discuss the following main topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论以下主要话题：
- en: Understanding mechanical hard drives
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解机械硬盘
- en: Explaining the architecture of solid-state drives
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释固态硬盘的架构
- en: Understanding drive endurance
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解硬盘耐久性
- en: Reinventing SSDs with NVMe
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 NVMe 重新定义固态硬盘
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The material presented in this chapter is operating system-agnostic. As such,
    there aren’t any commands or concepts that are specifically tied to Linux. However,
    it will help if you have some basic knowledge about the different types of storage
    media options available today.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节介绍的内容与操作系统无关。因此，没有与Linux特定绑定的命令或概念。不过，如果你对今天可用的不同类型的存储介质选项有一些基本知识，会有所帮助。
- en: Understanding mechanical hard drives
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解机械硬盘
- en: Mechanical drives, also known as hard disks, magnetic disks, rotating disks,
    or spinning disks, are the only mechanical component in a modern computer system.
    We’ve often addressed them, or, as some might say, *degraded* them, in this book
    by calling them slower or legacy drives. The truth is that even though the use
    of mechanical drives has declined in recent years, they are still commonly seen
    in today’s enterprise environments, in a slightly different role. Since there
    are better storage options available for performance-sensitive applications, hard
    drives are mostly used for cold data storage. Because of higher capacities and
    lower costs, mechanical drives are still an integral part of any environment.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 机械硬盘，也称为硬盘、磁盘、旋转盘或旋转盘，是现代计算机系统中唯一的机械组件。在本书中，我们通常通过称它们为更慢或遗留驱动器来描述它们。事实上，尽管近年来机械硬盘的使用有所下降，但它们仍然广泛存在于今天的企业环境中，扮演了稍有不同角色。由于性能敏感的应用程序有更好的存储选项可用，因此硬盘主要用于冷数据存储。由于更高的容量和较低的成本，机械硬盘仍然是任何环境中不可或缺的一部分。
- en: 'Let’s briefly describe the major components of a mechanical drive:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要描述机械硬盘的主要组成部分：
- en: '**Platter**: A hard disk consists of multiple thin circular disks, known as
    platters. All data on a hard drive is recorded on these platters. To maximize
    capacity, data can be read from and written to both the top and bottom sides of
    the platter surface. The surface of the platter is magnetized from both ends.
    The total number of these platters and their storage capacities determine the
    total capacity of the hard disk.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**盘片**：硬盘由多个薄圆盘组成，称为盘片。所有硬盘上的数据都记录在这些盘片上。为了最大化容量，数据可以从盘片表面的顶部和底部进行读写。盘片表面从两端磁化。这些盘片的总数和它们的存储容量决定了硬盘的总容量。'
- en: '**Spindle**: The drive platters rotate under the power of the drive spindle
    motor, which is designed to maintain constant speeds. The hard disk platter rotates
    at a rate of several thousand **revolutions per minute** (**rpm**), with standard
    spindle speeds being 5,400 rpm, 7,200 rpm, 10,000 rpm, and 15,000 rpm, as all
    platters are connected to a single spindle motor. Therefore, they all spin at
    the same time and rotate at the same speed.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主轴**：驱动盘片旋转依靠驱动主轴电机的动力，该电机设计用于保持恒定的转速。硬盘盘片以每分钟数千转（**rpm**）的速度旋转，标准主轴转速为5,400
    rpm、7,200 rpm、10,000 rpm和15,000 rpm，因为所有盘片都连接到单个主轴电机上。因此，它们同时旋转并以相同的速度旋转。'
- en: '**R/W (R/W)** **head**: As a novice, I was under the impression that data is
    etched on the hard drive in expressed or written form. Well, to burst that bubble,
    data is expressed by the pattern of a magnetic signal on moving media. Drives
    have two R/W heads per platter, one each for the top and bottom sides. During
    data writing, the R/W head modifies the magnetic orientation on the platter’s
    surface, while in data reading mode, the head detects the magnetic orientation
    on the surface of the platter. It’s fascinating to note that the R/W head never
    touches the surface of the platter.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**读写（R/W）头**：作为新手，我一直以为数据是以书面形式或书写形式刻在硬盘上的。事实上，数据是通过移动介质上磁信号的模式来表达的。每个盘片上有两个读写头，分别位于顶部和底部。在写数据时，读写头修改盘片表面的磁方向，而在读取数据模式下，读头检测盘片表面的磁方向。值得注意的是，读写头永远不会触碰盘片表面。'
- en: '**Actuator arms**: The actuator arm assembly is responsible for mounting the
    **R/W** heads. The actuator arms play a crucial role in the accurate positioning
    of the R/W heads to the specific locations where data is to be read from or written
    to.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**臂式臂**：臂式臂组件负责安装**读写**头。臂式臂在将读写头精确定位到需要读取或写入数据的特定位置方面起着至关重要的作用。'
- en: '**Controller**: The disk controller is a vital component that oversees the
    operation of the components mentioned earlier, and it interacts with the host
    system. It carries out instructions from the host, manages the R/W heads, and
    controls the actuator arms.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制器**：磁盘控制器是一个重要组件，负责管理之前提到的各个组件的运行，并与主机系统进行交互。它执行来自主机的指令，管理读写头，并控制驱动臂。'
- en: Now that we’re familiar with the major components of a mechanical drive, let’s
    take a look at the geometry of mechanical drives.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了机械硬盘的主要组件，让我们来看看机械硬盘的几何结构。
- en: Looking at the physical layout and addressing
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看物理布局和寻址
- en: 'The geometry of a hard drive describes how data is organized on the platters.
    This organization is based on dividing the platter surface into concentric rings
    called tracks. A cylinder is a vertical section that intersects the corresponding
    ring across all platters and is used to refer to specific locations on the disk.
    A cylinder consists of the same track number on each platter. Each track is further
    divided into smaller units known as sectors. The sector is the smallest addressable
    unit on a hard drive. We discussed the concept of block sizes in [*Chapter 3*](B19430_03.xhtml#_idTextAnchor053).
    A block is a group of sectors and is a property of a filesystem. A sector is the
    physical property of the drive, and its structure is created by the drive manufacturer
    during initial formatting. Initially, the most common sector size used was 512
    bytes. However, some modern drives also use 4 KB sectors. The following is an
    illustration of the physical arrangement of the mechanical drive:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 硬盘的几何描述了数据在盘片上的组织方式。这种组织方式是基于将盘片表面分成同心圆环，称为磁道。柱面是一个垂直部分，穿过所有盘片上的相应磁道，用于指代磁盘上的特定位置。柱面由每个盘片上的相同磁道号组成。每个磁道进一步划分为更小的单元，称为扇区。扇区是硬盘上最小的可寻址单元。我们在[*第3章*](B19430_03.xhtml#_idTextAnchor053)中讨论过块大小的概念。块是一组扇区，是文件系统的属性。扇区是硬盘的物理属性，其结构由硬盘制造商在初次格式化时创建。最初，最常见的扇区大小是512字节。然而，一些现代硬盘也使用4KB的扇区。以下是机械硬盘物理结构的示意图：
- en: '![Figure 8.1 – The mechanical drive structure](img/B19430_08_01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.1 – 机械硬盘结构](img/B19430_08_01.jpg)'
- en: Figure 8.1 – The mechanical drive structure
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – 机械硬盘结构
- en: There are a couple of techniques used to address the physical locations on the
    hard drive. One such technique is known as **cylinders, heads, and sectors** (**CHS**).
    The physical geometry of a hard disk is usually expressed in terms of CHS. A combination
    of the CHS numbers can be used to identify any location on the disk. To locate
    an address on the drive, the host operating system had to be aware of the CHS
    geometry of the disk.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种技术可以用来寻址硬盘上的物理位置。一种被称为**柱面、磁头和扇区**（**CHS**）。硬盘的物理几何通常通过CHS表示。CHS的组合可以用来标识磁盘上的任何位置。为了在硬盘上定位一个地址，主机操作系统必须知道磁盘的CHS几何信息。
- en: CHS has now been replaced by **logical block addressing** (**LBA**). LBA is
    another form of disk addressing that simplifies address management on the operating
    system side. LBA uses a linear addressing scheme to access physical data blocks.
    When using LBA, instead of addressing sectors through CHS, each sector is assigned
    a unique logical number. Using it, the hard disk is simply addressed as a single,
    large device, which simply counts the existing sectors starting at 0\. It is then
    the job of the disk controller to translate LBA addresses into CHS addresses.
    The host operating system needs to know only the size of the disk drive in terms
    of the number of logical block addresses.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: CHS现在已被**逻辑块寻址**（**LBA**）所取代。LBA是另一种磁盘寻址方式，它简化了操作系统侧的地址管理。LBA使用线性寻址方案来访问物理数据块。使用LBA时，不再通过CHS寻址扇区，而是为每个扇区分配一个唯一的逻辑编号。通过这种方式，硬盘被简化为一个单一的大设备，只需从0开始计数现有的扇区。然后，磁盘控制器的任务是将LBA地址转换为CHS地址。主机操作系统只需要知道磁盘驱动器的大小，以逻辑块地址的数量表示即可。
- en: Looking at bad sectors
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看坏道
- en: Bad sectors or blocks are areas on the drive that can no longer be written to
    or read from, either because they have been corrupted or become damaged. In such
    cases, the drive controller will remap the logical sector to a different physical
    sector. This can be done transparently, without the knowledge of the host operating
    system.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 坏扇区或坏块是硬盘上无法再写入或读取的区域，可能是因为它们已损坏或受到损坏。在这种情况下，硬盘控制器会将逻辑扇区重映射到另一个物理扇区。这一过程可以透明地进行，操作系统不会察觉到。
- en: There are two different types of bad sectors – hard bad sectors and soft bad
    sectors. A **hard bad sector** will have suffered physical damage, such as from
    a physical impact or a manufacturing defect. A hard error is usually uncorrectable,
    and such a sector cannot be used for further storage of data. A **soft bad sector**
    is a location on the hard drive that is identified as problematic by the host
    operating system. Such a sector can be identified by the operating system if the
    **error-correcting code** (**ECC**) of the sector does not match the information
    that is written to that location. If an application attempts to retrieve data
    from a sector and discovers that the ECC does not match the sector’s content,
    this may indicate the presence of a soft sector error. These errors can be rectified
    and resolved by using various methods.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 坏扇区有两种类型——硬坏扇区和软坏扇区。**硬坏扇区**是由于物理损坏（例如，物理冲击或制造缺陷）导致的。硬错误通常是无法修复的，这样的扇区无法再用于存储数据。**软坏扇区**是硬盘上由主操作系统识别为有问题的区域。如果该扇区的**纠错码**（**ECC**）与写入该位置的信息不匹配，操作系统可以识别该扇区为有问题。如果应用程序尝试从某个扇区读取数据并发现ECC与该扇区的内容不匹配，这可能表示该扇区存在软坏扇区错误。这些错误可以通过多种方法进行修正和解决。
- en: Looking at hard drive performance
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看硬盘性能
- en: We’ve often used the term *seeking* or *seek time* while highlighting the performance
    limitations of mechanical drives. The seek time of a drive refers to the time
    taken to position the R/W head across the platter surface, over the correct track.
    As repeatedly pointed out, random access operations are very costly for mechanical
    drives. When accessing data on random tracks, the seek time will increase, as
    the R/W head will have to be continuously moved. The lower the seek time of a
    drive, the faster the servicing of the I/O requests.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在强调机械硬盘的性能限制时，我们经常使用*寻道*或*寻道时间*这个术语。硬盘的寻道时间是指将读写头移动到磁盘表面正确轨道所花费的时间。如前所述，机械硬盘的随机访问操作非常昂贵。当访问随机轨道上的数据时，寻道时间会增加，因为读写头需要不断移动。硬盘的寻道时间越低，I/O请求的服务速度越快。
- en: Once the R/W head has been positioned over the correct track, the next task
    is to position the required sector under the head. To achieve this, the platter
    is spun to position the requested sector under the R/W head. The total time taken
    to complete this task is known as rotational latency. This operation is dependent
    on the speed of the spindle motor. The higher the RPM of the motor, the lower
    will be the rotational latency. Again, if requests are for adjacent sectors on
    a track, the rotational latency will be on the lower side. To read and write data
    on random sectors, the rotational latency will be higher.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦读写头定位到正确的轨道，接下来的任务是将所需的扇区定位到头部下方。为此，磁盘盘片会旋转，以将请求的扇区定位到读写头下方。完成这一任务的总时间被称为旋转延迟。这个操作依赖于主轴电机的速度。电机的转速越高，旋转延迟就越低。同样，如果请求的是同一轨道上的相邻扇区，旋转延迟会较低。要在随机扇区上读写数据时，旋转延迟会更高。
- en: The drive heads require alignment over a specific area of the spinning disk
    to read or write data, resulting in a delay before data can be accessed. To launch
    a program or load a file, the drive may have to read from various locations, which
    can lead to multiple delays as the platters need to spin into the correct position
    each time.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动头需要在旋转磁盘的特定区域进行对准才能读取或写入数据，这导致在数据能够访问之前会出现延迟。要启动程序或加载文件，驱动器可能需要从多个位置读取数据，这可能导致多次延迟，因为每次磁盘盘片都需要旋转到正确的位置。
- en: Understanding where mechanical drives lag
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解机械硬盘的延迟问题
- en: Ever since their inception, it was quite clear that mechanical drives could
    not possibly match the speeds at which CPUs operate. Response times for mechanical
    drives are measured in milliseconds, as compared to nanoseconds for CPUs. The
    presence of mechanical components in the design also limits the performance. It
    is not that efforts were not made to improve the physical structure of hard drives.
    For instance, hard drives were equipped with a small on-disk cache to improve
    performance. Over the years, the speed of the spindle motor has increased from
    a few hundred rpm to as high as 15,000 rpm. Smaller platter surfaces were also
    designed for performance improvement. All these factors have contributed to significantly
    improving the performance of mechanical drives. However, despite all this, even
    the fastest rotating drives are still far too slow compared to a CPU. A major
    portion of time is spent on the movement of mechanical parts.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 自从固态硬盘问世以来，显而易见，机械硬盘无法与CPU的运行速度相匹配。机械硬盘的响应时间以毫秒为单位，而CPU则以纳秒为单位。设计中存在的机械部件也限制了性能。这并不是说没有努力改善硬盘的物理结构。例如，硬盘配备了小型磁盘缓存以提升性能。多年来，主轴电机的转速从几百转每分钟提升到高达15,000转每分钟。还设计了更小的盘片表面以提高性能。所有这些因素都有助于显著提高机械硬盘的性能。然而，尽管如此，即便是最快的旋转硬盘，与CPU相比依然太慢。大部分时间都花费在机械部件的运动上。
- en: Because of the limitations in the speed of mechanical components, the performance
    of hard drives falls short in comparison with some modern storage options. The
    performance of a hard drive is deeply dependent on the read-and-write patterns
    of the applications. For sequential operations, the performance is significantly
    better. However, for random access operations, the hard drive performance deteriorates
    as these operations involve the frequent movement of the R/W head and the continuous
    rotation of the platter surface. However, despite these drawbacks, mechanical
    drives are still considered an important part of any enterprise environment. The
    lower per-gigabyte cost of mechanical drives makes them an excellent choice for
    cases where capacity is the primary concern.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于机械部件速度的限制，硬盘性能在与一些现代存储选项相比时显得力不从心。硬盘的性能深受应用程序读写模式的影响。对于顺序操作，性能显著更好。然而，对于随机访问操作，硬盘的性能会退化，因为这些操作涉及频繁移动读写头和盘片的连续旋转。尽管存在这些缺点，机械硬盘仍然被视为企业环境中重要的组成部分。机械硬盘每千兆字节的成本较低，使其在容量为首要考量的情况下，仍然是一个非常好的选择。
- en: Now that we have a fundamental understanding of mechanical drives, let’s explore
    solid-state drives and examine how they differ from traditional rotating media.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对机械硬盘有了基本的了解，让我们来探讨一下固态硬盘，并看看它们与传统旋转介质有何不同。
- en: Explaining the architecture of solid-state drives
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释固态硬盘的架构
- en: The performance of enterprise storage took a huge leap with the introduction
    of **SSDs**. SSDs are so-called since they are based on semiconductor materials.
    Unlike rotating drives, SSDs do not have any mechanical parts and use non-volatile
    memory chips to store data. Given the absence of moving components, it is no surprise
    that SSDs are way faster than mechanical drives. They offer a significant upgrade
    over traditional drives and have gradually replaced mechanical drives as the first-choice
    storage media.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 企业存储性能随着**固态硬盘（SSDs）**的引入发生了巨大的飞跃。SSD之所以被称为固态硬盘，是因为它们基于半导体材料。与旋转硬盘不同，SSD没有任何机械部件，使用非易失性内存芯片来存储数据。由于没有活动部件，SSD的速度远远快于机械硬盘也就不足为奇了。它们提供了对传统硬盘的显著升级，并逐渐取代了机械硬盘，成为首选存储介质。
- en: SSDs make use of flash memory chips for the permanent storage of data. There
    are two options in this regard, NAND and NOR flash. Most SSDs use NAND flash chips,
    as they offer faster write and erasure times. At the risk of diving too much into
    electronics (my least favorite subject in college), a NAND flash is made up of
    floating-gate transistors, and electrons are stored in a floating gate. When the
    floating gate contains a charge, it is read as zero. This signifies that data
    is stored in a cell, contrary to what we typically think (you can see why I didn’t
    like electronics).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: SSD使用闪存芯片来实现数据的永久存储。在这方面有两个选择，NAND和NOR闪存。大多数SSD使用NAND闪存芯片，因为它们提供更快的写入和擦除速度。冒着过多探讨电子学的风险（这是我大学时最不喜欢的科目），NAND闪存由浮栅晶体管组成，电子存储在浮栅中。当浮栅中包含电荷时，它被读取为零。这意味着数据存储在单元中，这与我们通常的想法相反（你可以理解为什么我不喜欢电子学了）。
- en: 'The primary components of an SSD are displayed as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: SSD的主要组件如下所示：
- en: '![Figure 8.2 – Architecture of an SSD](img/B19430_08_02.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.2 – SSD的架构](img/B19430_08_02.jpg)'
- en: Figure 8.2 – Architecture of an SSD
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 – SSD的架构
- en: The SSD controller performs a variety of functions and presents the raw storage
    in the NAND flash to the host.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: SSD控制器执行各种功能，并将NAND闪存中的原始存储呈现给主机。
- en: Looking at the physical layout and addressing
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看物理布局和寻址
- en: 'Each NAND flash memory in an SSD consists of the following components:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: SSD中的每个NAND闪存内存包含以下组件：
- en: '**Gates**: Floating-gate transistors are a crucial component of SSDs, responsible
    for the conduction, retention, and release of the electrical charge in the cells,
    using the electrons stored within the floating gate.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**门**：浮栅晶体管是SSD的关键组件，负责电荷在单元中的传导、保持和释放，利用存储在浮栅中的电子。'
- en: '**Cell**: A cell is a basic unit of storage that can contain a single piece
    of data, with its electrical charge representing the value of the bit(s). As we
    will see shortly, cells can hold either a single level or multiple levels of charge.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元**：单元是存储的基本单位，可以包含单个数据，其电荷表示位的值。正如我们将要看到的，单元可以存储单一电平或多个电平的电荷。'
- en: '**Byte**: A single byte comprises eight cells.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字节**：一个字节包含八个单元。'
- en: '**Page**: In SSDs, a page is comparable to a sector on a hard drive and represents
    the smallest unit that can be written to and read from. Typically, a page has
    a size of 4 KB, although it can be larger than this value.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**页**：在SSD中，页类似于硬盘上的扇区，表示可以被写入和读取的最小单位。通常，页面大小为4 KB，尽管它也可以大于此值。'
- en: '**Block**: A block is a collection of pages in an SSD. Erase operations in
    SSDs are carried out in terms of blocks, which means that all pages within a block
    must be erased together.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**块**：块是SSD中一组页的集合。SSD中的擦除操作是按块进行的，这意味着块中的所有页面必须一起擦除。'
- en: 'Internally, bits in an SSD are stored in cells, which are then organized into
    pages. Pages are grouped into blocks, which are in turn encapsulated in a plane,
    as illustrated in *Figure 8**.3*. A die chip typically consists of multiple planes:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，SSD中的位被存储在单元中，这些单元然后被组织成页。页面被分组成块，块又封装在一个平面中，如*图 8.3*所示。一个芯片通常由多个平面组成：
- en: '![Figure 8.3 – A die layout in SSDs](img/B19430_08_03.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.3 – SSD中的芯片布局](img/B19430_08_03.jpg)'
- en: Figure 8.3 – A die layout in SSDs
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – SSD中的芯片布局
- en: 'The terms *SLC* and *MLC* describe the number of bits that are stored per cell.
    In addition to SLC and MLC, there are also `SLC NAND`, the flash controller only
    needs to know whether the bit is 0 or 1\. With `MLC NAND`, the cell can have four
    values – `00`, `01`, `10`, or `11`. Similarly, with `TLC NAND`, the cell can have
    `8` values, and QLC can have `16` values. The following diagram displays the relationship
    between various types of SSDs:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*SLC*和*MLC*这两个术语描述了每个单元存储的位数。除了SLC和MLC之外，还有`SLC NAND`，此时闪存控制器只需知道该位是0还是1。对于`MLC
    NAND`，单元可以有四个值——`00`、`01`、`10`或`11`。同样，对于`TLC NAND`，单元可以有`8`个值，而QLC可以有`16`个值。下图显示了不同类型SSD之间的关系：'
- en: '![Figure 8.4 – A comparison of SLC, MLC, TLC, and QLC flash](img/B19430_08_04.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.4 – SLC、MLC、TLC和QLC闪存的比较](img/B19430_08_04.jpg)'
- en: Figure 8.4 – A comparison of SLC, MLC, TLC, and QLC flash
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 – SLC、MLC、TLC和QLC闪存的比较
- en: Like a mechanical drive, SSDs also use LBA to address physical locations, but
    there are some extra components involved in this process. A NAND flash uses a
    **flash translation layer** (**FTL**) to map logical block addresses to physical
    pages. The FTL hides the inner complexities of the NAND flash memory and only
    exposes an array of logical block addresses to the host. This is deliberately
    done to emulate a mechanical drive, as most of the stack on the operating system
    side is optimized to work with mechanical drives.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于机械硬盘，固态硬盘（SSD）也使用逻辑块地址（LBA）来寻址物理位置，但这个过程涉及到一些额外的组件。NAND闪存使用**闪存转换层**（**FTL**）将逻辑块地址映射到物理页面。FTL隐藏了NAND闪存内部的复杂性，只向主机暴露逻辑块地址的数组。这样做是故意模拟机械硬盘，因为操作系统端的大部分技术栈都是为机械硬盘优化的。
- en: Looking at reads and writes
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看读写操作
- en: Unlike a hard drive, where a sector is a fundamental unit for all operations,
    SSDs use different units to perform different operations. The SSDs read and write
    data at the page level, while all erase operations are performed at the block
    level. The sectors in mechanical drives can be rewritten repeatedly, whereas pages
    in SSDs can never be overwritten, and as we’ll see in the subsequent section,
    there is a good reason for that.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 与硬盘不同，硬盘的扇区是所有操作的基本单位，而SSD使用不同的单位来执行不同的操作。SSD在页面级别读取和写入数据，而所有的擦除操作都在块级别进行。机械硬盘中的扇区可以反复重写，而SSD中的页面则无法被覆盖，正如我们在后续部分将看到的那样，这背后有其原因。
- en: The equivalent of sectors in SSDs is pages. It is not possible to read a single
    cell individually. Read operations align with the native page size of the device.
    For instance, given a page size of 4 KB, if you want to read 2 KB of data, the
    flash controller will fetch the full 4 KB page. Similarly, writes also follow
    the same routine. The write operations align on a page and occur by page size.
    Given a page size of 4 KB, writing 6 KB of data will use two 4 KB pages.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: SSD中扇区的等价物是页面。无法单独读取单个单元。读操作与设备的原生页面大小对齐。例如，假设页面大小为4 KB，如果你想读取2 KB的数据，闪存控制器将获取整个4
    KB页面。同样，写入操作也遵循相同的规律。写入操作按页面对齐，并按页面大小发生。假设页面大小为4 KB，写入6 KB的数据将使用两个4 KB的页面。
- en: Erasing, garbage collection, and the illusion of available space
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 擦除、垃圾回收和可用空间的假象
- en: When an application writes to a NAND flash, the flash must allocate a new blank
    page for the new data. Erasing NAND flash memory requires a high voltage, and
    if performed at the page level, it can negatively impact neighboring cells and
    limit their lifespan. Therefore, SSDs erase data at the block level to mitigate
    this issue, though it increases the complexity of the erase operation. The erase
    operation is a crucial factor in determining the lifespan of a NAND flash. The
    term **Program and Erase Cycle** (**P/E**) reflects the life of an SSD, based
    on the number of P/E cycles the NAND flash can endure. When a block is written
    to and erased, that is counted as one cycle. This is important because blocks
    can be written to a finite number of times, beyond which they cannot write new
    data anymore.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序向NAND闪存写入数据时，闪存必须为新数据分配一个新的空白页面。擦除NAND闪存需要高电压，如果在页面级别进行擦除，可能会对相邻单元造成负面影响，限制其寿命。因此，SSD在块级别擦除数据，以减少这一问题，尽管这增加了擦除操作的复杂性。擦除操作是决定NAND闪存寿命的关键因素。**编程和擦除周期**（**P/E**）这个术语反映了SSD的寿命，基于NAND闪存可以承受的P/E周期数。当一个块被写入并擦除时，这算作一个周期。这很重要，因为块可以写入有限次数，超出这个次数后，它们就无法再写入新数据了。
- en: 'So, how does an SSD erase data? Let’s say that we write some data to an SSD.
    The write operation, also called the program operation, takes place at the page
    level. After some time, we realize that the previously written data needs to be
    updated with some new content. There are two cases here:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，SSD是如何擦除数据的呢？假设我们向SSD写入一些数据。写入操作，也称为编程操作，发生在页面级别。一段时间后，我们意识到之前写入的数据需要用一些新内容更新。这里有两种情况：
- en: Enough free pages are available in blocks
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 足够的空闲页面是以块为单位提供的。
- en: Enough free pages are available, but all blocks contain a mix of free, used,
    and stale pages, or a mix of used and stale pages
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有足够的空闲页面，但所有块包含自由页面、已使用页面和陈旧页面的混合，或者包含已使用页面和陈旧页面的混合。
- en: Let’s say that there are free pages available. The flash controller will write
    the updated data to any free empty pages, and the older pages will be marked as
    stale. The pages that are marked as stale are part of a block. It is quite possible
    that some of the other pages in the same block contain data that is in use. When
    a page in a block needs to be updated, the flash controller reads the contents
    of the entire block (which contains the said page) in its memory and computes
    the updated value of the page. Then, it performs an erase operation on that block.
    This block erase operation erases the contents of the entire block, including
    the pages, other than the one that was to be updated. The flash controller then
    writes the previous contents of the block and the updated value of said page.
    This entire process is called write amplification. Write amplification refers
    to a situation where the number of write operations performed by the storage device
    is more than the number of operations performed by the host device.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有空闲页面可用。闪存控制器将把更新后的数据写入任何空闲的空页面，而旧页面将被标记为过时。这些被标记为过时的页面是一个块的一部分。很可能，块中其他页面包含的是正在使用的数据。当块中的某个页面需要更新时，闪存控制器会在内存中读取整个块的内容（其中包括该页面），并计算该页面的更新值。然后，它会对该块执行擦除操作。该块擦除操作会擦除整个块的内容，包括除了要更新的页面之外的所有页面。接着，闪存控制器会写回该块的先前内容和该页面的更新值。这个过程叫做写放大。写放大是指存储设备执行的写操作次数多于主机设备执行的操作次数。
- en: 'As all erase operations are performed at the block level, how can we reclaim
    space occupied by stale pages? Surely, the controller will not wait for all pages
    in a block to become stale before erasing them? If that’s the case, then the drive
    will run out of free pages very soon. Clearly, this approach can have some dangerous
    consequences. This brings us to the second point – how will an SSD cope with a
    situation when there aren’t enough free pages available to accommodate new writes,
    or all the blocks contain a combination of used and stale pages? To reclaim stale
    pages, the erase operation needs to be applied at the block level, but where do
    we put all the pages that are currently in use? The following figure highlights
    this specific scenario:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有擦除操作都在块级别进行，那么我们如何回收被过时页面占用的空间呢？控制器肯定不会等到一个块中的所有页面都变为过时状态后才擦除它们吧？如果真是这样，驱动器很快就会用尽空闲页面。显然，这种方法可能带来一些危险后果。这就引出了第二个问题——当没有足够的空闲页面来容纳新的写入，或者所有块都包含已用和过时页面的组合时，SSD如何应对这种情况？为了回收过时页面，擦除操作需要在块级别进行，但我们应该将当前正在使用的所有页面放在哪里呢？下面的图示突出展示了这一特定场景：
- en: '![Figure 8.5 – Where do we write incoming data?](img/B19430_08_05.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.5 – 我们将如何写入 incoming 数据？](img/B19430_08_05.jpg)'
- en: Figure 8.5 – Where do we write incoming data?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 – 我们将如何写入 incoming 数据？
- en: That’s where the illusion of over-provisioning comes in. There’s a lot more
    space in a flash drive than is visible to the end user. This unallocated space
    is reserved by the SSD controller for operations such as wear leveling and garbage
    collection. That extra space comes in handy in situations such as when there is
    a need to free up stale blocks. The process of cleaning up stale blocks is known
    as garbage collection. Usually, SSDs can have 20-40% extra capacity than advertised.
    Flash drive vendors use this trick across the board, from SSDs used for personal
    systems to SSDs used in enterprise storage arrays. This extra space contributes
    to improving the endurance and write performance of the SSD.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是过度配置幻象的来源。闪存驱动器中有比终端用户可见的更多空间。这些未分配的空间被SSD控制器保留，用于像磨损均衡和垃圾回收这样的操作。额外的空间在一些情况下非常有用，例如需要释放过时的块时。清理过时块的过程称为垃圾回收。通常，SSD的实际容量可以比宣传的多20-40%。闪存驱动器供应商在各类SSD中普遍使用这种技巧，从个人系统使用的SSD到企业存储阵列中使用的SSD都有。这部分额外的空间有助于提升SSD的耐用性和写入性能。
- en: Looking at wear leveling
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 观察磨损均衡情况
- en: Given the limited number of P/E cycles, the purpose of the wear-leveling operation
    is to increase an SSD lifespan by making sure that data is distributed evenly
    across the pages. When data in a particular cell needs to be modified, the wear-leveling
    process informs the FTL to remap the LBA to point to the new block. Wear-leveling
    marks the old data as stale. As explained earlier, the current block does not
    have to be erased. All these decisions are taken to extend the life of a cell.
    For instance, if a host application frequently updates values in a single cell,
    and the flash controller modifies the same block again and again, the insulators
    of this cell will wear out more quickly.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Looking at bad block management
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As each cell can only go through a finite number of P/E cycles, it is important
    to keep track of cells that have become defective and cannot be programmed or
    erased anymore. From this point, the cell is considered to be a bad block. The
    controller keeps a table of all the bad blocks. If pages in the block contain
    valid data, then existing data in the block is copied over to a new block, and
    the bad block table is updated.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Looking at SSD performance
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The use of NAND flash in SSDs makes SSDs really fast. Although the performance
    is still nowhere near as fast as the main memory, it's multiple orders of magnitude
    faster than a spinning hard drive. The absence of any mechanical components ensures
    that an SSD is not pinned down by the factors that limit a mechanical drive’s
    performance. Random access operations, which are the Achilles heel of a mechanical
    drive, are no longer a worry when using SSDs.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Understanding where SSDs lag
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The thing with electronic devices is that they’re mostly designed to last for
    a certain period of time. This is also the case with SSDs; there is a certain
    life expectancy associated with them. Again, to keep the physics and electronics
    stuff short and sweet, the write process in SSDs stores electrons, and the erase
    process drains the voltage in the floating-gate transistor. This sequence of events
    is known as the P/E cycle. Each NAND cell contains insulators that help to retain
    voltage in a cell. Every time a cell goes through a P/E cycle, the insulator goes
    through some damage. The extent of this damage is limited in nature, but over
    time, this builds up, and eventually, the insulators will lose their capabilities.
    This may result in voltage leakage, which can result in a change between voltage
    states. After this, the cell will be considered defective and can no longer be
    used for storage. If too many cells reach their fate, the drive will cease to
    work properly. This is why mechanical hard drives have better endurance than SSDs.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll often see that the specification sheet for an SSD will contain the number
    of P/E cycles that it can endure. However, this does not mean that SSDs cannot
    be used for long-term storage. Although there is a limit associated with their
    life expectancy, that limit is usually quite long. It can continue to be used
    for years. There are a lot of tools out there that can check the health and wear
    level of an SSD. *Table 8.1* highlights some common drive operations for mechanical
    drives and SSDs, showing their fundamental units:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '| **Drive** | **Operation** | **Unit** |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
- en: '| Mechanical disk | Read | Sector |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
- en: '| Write | Sector |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
- en: '| Update | Sector |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
- en: '| Erase | Sector |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
- en: '| Bad block management | Sector |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
- en: '| SSD | Read | Page |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
- en: '| Write | Page |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
- en: '| Update | Block |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
- en: '| Erase | Block |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
- en: '| Bad block management | Block |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
- en: Table 8.1 – The operational units of SSDs and HDDs
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: In terms of performance, SSDs offer huge benefits compared to traditional mechanical
    drives. They have far lower latencies, which has pushed applications toward new
    performance thresholds. They have now become common not only in enterprise environments
    but also in personal systems. They do not have any mechanical components, and
    most drives make use of the NAND flash for persistent storage of data. They have
    far more complex internal structures and policies than a rotating drive. They
    are more expensive than mechanical drives but outperform them in almost every
    other aspect.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Let’s briefly touch on the topic of drive endurance before we delve into the
    world of NVMe drives.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Understanding drive endurance
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is usually an endurance rating associated with both mechanical drives
    and SSDs. The endurance of a drive defines multiple things, such as its maximum
    performance, workload limits, and its **mean time between failures** (**MBTF**).
    Owing to their contrasting natures, the endurance of mechanical drives and SSDs
    is measured in differing ways.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'The endurance ratings for both types of drives are expressed in different ways.
    As explained earlier, cells in the NAND flash can go through a finite number of
    P/E cycles. Once this limit is reached, the cell will become defective. The endurance
    rating for SSDs is a function of the number of P/E cycles for which the NAND is
    rated. It is important to note that NAND cells only wear out for write (program)
    and erase operations. For read operations, this overhead is negligible. The metrics
    to measure the endurance of SSDs are as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '**Drive Writes per Day** (**DWPD**): The DWPD rating shows how many times you
    can overwrite an entire SSD each day of its life'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Terabytes written** (**TBW**): The TBW rating represents how much data can
    be written to a drive across its entire life, before you may need to replace it'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you have an SSD of 100 GB, with a warranty period of three years and a DWPD
    rating of 1, that means you can write 100 GB of data to the drive every single
    day, for the next three years, which means your TBW rating will be 109 TBW:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '*100 GB x 365 days x 3 years ≈**109 TB*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'Mechanical hard drives are different, as they are not impacted by P/E cycles.
    The magnetic platter surface on mechanical drives supports the overwriting of
    data. If there is already data in the physical location to be written, the existing
    data can be directly overwritten with new data. However, while SSD ratings are
    affected only by write operations and not by the number of read operations, mechanical
    drives on the other hand are affected by both read and write operations. Hence,
    the rating for mechanical drives is specified in terms of the number of bytes
    written and/or read. This workload limit does not have an official term, but going
    by the terms used for SSD, this can be unofficially called **Drive Writes/Read
    per Day** (**DWRPD**). The impact of read and write operations on drive endurance
    is illustrated in *Table 8.2*:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '| **Drive type** | **Workload rating** | **Operation** | **Effect** **on endurance**
    |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
- en: '| Mechanical disk | DWPD | Read | Decreases |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
- en: '| Write | Decreases |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
- en: '| SSD | DWRPD | Read | Negligible impact |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
- en: '| Write | Decreases |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
- en: Table 8.2 – Drive endurance
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '*Table 8.2* summarizes the effect of read and write operations on both types
    of drives. The actual warranted values will differ across the different storage
    vendors. The workload limits for mechanical drives are also expressed in terms
    of the TB of data that can be read/written per year. When checking for endurance,
    keep in mind that terms such as DWPD and TBW are just numbers. It is critical
    to understand that the warranty period is the key to determining the actual endurance.
    It’s best to use both the warranty period and DWPD when choosing a drive.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s explore how the NVMe interface has revolutionized traditional SSDs.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Reinventing SSDs with NVMe
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several transport protocols that are used to access mechanical and
    SSDs. Protocols such as SATA, SCSI, and SAS were originally designed for mechanical
    drives. Hence, these are more geared toward leveraging the potential of rotating
    drives. With the inception of SSDs, these protocols began to be used for these
    types of drives as well. Most SSDs, especially in the earlier days, used SATA
    and SAS ports, just like any other mechanical drive. They would easily fit into
    existing mechanical drive slots and get connected to the system through a SATA
    or SAS controller. Despite the major performance gains when using SSDs, the fact
    that the interfaces, protocols, and command sets that were originally written
    for mechanical drives were being used for SSDs was considered an overhead, and
    it was widely thought that this somewhat restricted flash drives from unleashing
    their full potential.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'The NVMe interface was designed specifically for technologies such as the NAND
    flash. NVMe is often confused as a new type of drive, but technically, it’s not.
    The NVMe is a storage access and transport protocol for SSDs. It acts as a communication
    interface that operates directly over a PCIe interface. A standard SSD is a drive
    with SATA or SAS interfaces. These drives are accessed by the host operating system
    through traditional SCSI protocols. An NVMe SSD uses the M2 physical form factor
    and uses the NVMe logical interface, developed specifically for these types of
    drives. The NVMe drive is accessed solely using a PCIe interface. On the host
    operating system, separate drivers and protocols are used to access NVMe drives.
    In short, remember the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '*Every NVMe drive is an SSD, but not every SSD is an* *NVMe drive.*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: NVMe skips the route taken by traditional SSDs and connects directly to the
    CPU through the PCIe interface, utilizing PCIe slots on the motherboard. The smaller
    the signal path between storage and CPU, the better the performance. Additionally,
    PCIe uses four lanes for storage devices, resulting in data exchange that is four
    times faster than a SATA connection, which only has one lane. When combined with
    an NVMe SSD, there is an exponential increase in performance.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: The performance boost doesn’t happen only because of the powerful hardware.
    The software stack also needs optimization to take full advantage of the hardware.
    Sometimes, a hardware component can only be as good as the software controlling
    it. For instance, the SATA and SAS interfaces support a single queue with 32 and
    256 commands respectively. On the other hand, NVMe has 64,000 queues and 64,000
    commands per queue. That’s a difference of a staggering magnitude. There is a
    separate command set written for the NVMe interface, which is entirely different
    from all the older SATA and SCSI protocols. The older protocols were designed
    specifically for mechanical drives and had a large software footprint. NVMe only
    has a handful of commands, which ensures that a very small number of CPU cycles
    are spent when processing I/O requests.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'As NVMe defines both the communication interface and the method through which
    storage is presented to the system, this allows for the use of a single driver
    in the software stack to control the device. For legacy protocols, every vendor
    is required to develop a driver for every single device to support the required
    functionality. *Figure 8**.6* represents a summarized hierarchy of the storage
    stack, while highlighting the overhead differences when using the NVMe and SCSI
    protocols:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6 – NVMe versus the SCSI stack](img/B19430_08_06.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
- en: Figure 8.6 – NVMe versus the SCSI stack
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to performance, NVMe drives easily offer the fastest transfer
    speeds for any available SSD. The read and write performance of NVMe SSDs are
    far superior to any standard SSD. Due to their exceptional performance, NVMe SSDs
    are priced significantly higher than standard SSDs, which is not unexpected, since
    the NVMe interface and protocol were designed to fully utilize the capabilities
    of SSDs.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After spending most of our time examining the software side of things, this
    chapter focused solely on the actual physical hardware. Because of this, almost
    all of the information presented in this chapter can be considered platform-agnostic.
    The hardware capabilities are the same; it’s up to the software that drives the
    hardware to make it reach its full potential.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: We discussed the three most common storage options available on the market today
    – rotating hard drives, SSDs, and NVMe drives. The spinning mechanical drive is
    one of the oldest forms of storage media available on the market today. It has
    gone through a few changes over the last few decades, which have improved its
    performance to some extent. As it consists of several mechanical components, there
    is a hard limit associated with its performance. After all, the spindle motor
    that spins its platter surface can only spin so fast. Because of limitations in
    the hard drive’s performance, SSDs came into existence. SSDs do not have any mechanical
    parts and consist solely of electronic components. They use a NAND flash for permanent
    storage of data, which makes them extremely fast compared to rotating drives.
    As the write and erase processes apply and drain voltage from cells, SSDs can
    endure a limited number of program and erase cycles, which somewhat limits their
    life span.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Previously, SSDs were limited by the use of protocols and interfaces that were
    originally designed for mechanical drives. However, with the emergence of NVMe,
    this limitation was overcome. NVMe was specifically developed for the NAND flash
    and serves as a storage access and transport protocol for SSDs. Unlike traditional
    SSDs, NVMe operates directly over a PCIe interface, which makes it significantly
    faster.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: We have now reached the end of *Part 3* of this book. I hope you found the information
    in it useful. In *Part 4*, we’ll discuss and explore some tools and techniques
    for troubleshooting and analyzing storage performance.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 4: Analyzing and Troubleshooting Storage Performance'
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This part will focus on the different criteria that can be used to evaluate
    and gauge storage performance. We’ll present the different metrics for assessing
    performance and discuss the different tools and techniques that can be used to
    investigate performance in each layer of the storage stack. We’ll also present
    some recommended practices that can help to improve storage performance.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'This part contains the following chapters:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B19430_09.xhtml#_idTextAnchor160), *Analyzing Physical Storage
    Performance*'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B19430_10.xhtml#_idTextAnchor184), *Analyzing Filesystems and
    the Block Layer*'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B19430_10.xhtml#_idTextAnchor184)，*分析文件系统和块层*'
- en: '[*Chapter 11*](B19430_11.xhtml#_idTextAnchor199), *Tuning the I/O Stack*'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B19430_11.xhtml#_idTextAnchor199)，*调优I/O栈*'
