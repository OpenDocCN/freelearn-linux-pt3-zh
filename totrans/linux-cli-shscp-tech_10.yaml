- en: '*Chapter 10*: Using Loops'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we started dealing with scripting, and we did a lot
    of learning about how scripts work and how they are structured. However, we missed
    a huge topic in scripting – influencing the order in which commands are executed
    when a script is run. There are a couple of things that we need to cover here,
    since there are multiple ways we can influence what is going to be the next command
    executed in a script.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to start with a concept we call **iterators** or, more commonly,
    **loops**. There are a lot of things in everyday tasks that need to be done repeatedly,
    usually changing just one small thing in every iteration. This is where looping
    comes in.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The `for` loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`break` and `continue`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `while` loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `test-if` loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `case` loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logical looping with `and`, `or`, and `not`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The for loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we talk about loops, we usually make a distinction based on the place in
    the execution where the variable we are using changes its value. `for` loops,
    in that respect, belong to the group where a variable is set before each iteration
    and keeps its value until the next iteration is run. The most common task that
    we are going to perform by using a `for` loop is going to be using the loop to
    iterate through sets of things, usually either numbers or names.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we begin introducing different ways of using a `for` loop, we need to
    address its abstract form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: What do we have here? The first thing to note is that we have some reserved
    keywords that make Bash understand that we want to use a `for` loop. In this particular
    example, `item` is actually the name of the variable that will hold one value
    from the list in each loop iteration. The word `in` is a keyword that further
    helps us understand that we are going to use a set of values that we currently
    call a list, although it can be different things.
  prefs: []
  type: TYPE_NORMAL
- en: After the list, there is a block that defines what commands we intend to run
    each time a loop is performed. Currently, we are going to work with this block
    as a single entity, containing commands that will be executed one after another
    without interruptions. Later in this chapter, we are going to introduce some conditional
    branching that will enable us to cover more possible workflow solutions, but for
    now, a block is uninterruptable.
  prefs: []
  type: TYPE_NORMAL
- en: What will probably surprise you is that a `for` loop is often used directly
    from the command line, even more often than in scripts. The reason is simple –
    there are a lot of tasks we can accomplish by using a simple `for` loop, and complicating
    them by creating scripts is to be avoided. A `for` loop in this form looks a little
    different than in the one we showed as our first example, the main difference
    being the semicolon that separates the keywords when we are using a single line
    to write out the loop.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start with a simple example. We are going to run through a list of servers
    and echo one in each iteration of the loop. Note that the shell takes our command
    from the prompt and repeats it before executing it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Using `echo` as a placeholder for commands when testing a loop is common. We
    are going to use this style of debugging a lot in our examples. `echo` as a command
    is probably the most useful one in this context since it changes nothing and,
    at the same time, enables us to see what the actual output is going to be.
  prefs: []
  type: TYPE_NORMAL
- en: When creating a list of objects, we don't have to use any special characters
    to separate individual entries; bash is going to treat space as a delimiter, and
    as long as we separate our values by a space, `bash` is going to understand our
    intentions. A little later, we are going to show you how to change the character
    that separates a value in the list, but a space will work in almost all the circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: The list we are using in the iterations can be explicitly defined, but more
    often than not, we are going to need to create it when we run our loop, in the
    command line or the script.
  prefs: []
  type: TYPE_NORMAL
- en: A typical example of this is running a loop on a set of files in a directory.
    The way to do this is to use shell expansion. This means letting the shell run
    a command and then using its output as the list for the `for` loop. We can do
    this either by specifying a command in backticks (`` ` ``) or using `bash` notation
    of `$`(command). Both ways have the same result – a command is run and then piped
    to a list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our example is going to be a loop that iterates through the current directory
    and runs the `file` command on each individual file, giving us information on
    what this particular file actually is. We are still on the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's deal with something more interesting. Often, we need to use numbers
    in our loops, either to count something or to create other objects. Almost all
    programming languages have some sort of loop that enables this. Bash is a sort
    of an exception to this rule, since it can do it in a couple of different ways.
    One is to use the `echo` command and a little bit of shell expansion to accomplish
    this task.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are unfamiliar with this, giving `echo` an argument that consists of
    a number formatted in curly brackets will make it output all the numbers in the
    interval that you specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To use this in a loop, we simply do the same trick as we did in the previous
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We are not limited to using a fixed step in the interval; if we simply mention
    an interval followed by a number, this number will be considered as a step value.
    A step value is basically a number that your variable is going to be incremented
    with in each loop iteration.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to try a simple loop using multipliers of `20`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can combine shell expansion the same way that we normally do in the command
    line and create different values for our loop. For example, in order to create
    server names for three groups of servers, each containing six servers, we can
    use a simple one-line loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, loops can be embedded within each other by simply placing the inner
    loop into the `do-done` block of the outer loop. In this particular example, we
    are using shell expansion to loop through a list of values in both loops:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now is the time to slowly switch from the command line to how we can use these
    loops in scripts. The biggest difference here is that `for` loops are way easier
    to read when formatted in a script.
  prefs: []
  type: TYPE_NORMAL
- en: For our first example, we are going to mention another way of creating a set
    of numbers in a loop, a so-called *C-style loop*. As the name suggests, this loop
    takes its syntax from the C language. Each loop has three separate values. Of
    these, the first two are compulsory; the third is not. The first value is called
    either the *initialization value* or the *start value*. It gives us the value
    of the variable in the first loop iteration. One thing to note here is that we
    need to assign the initial value explicitly, which significantly differs from
    the usual style used in the *normal* `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: The second value in this loop variation is the *test condition*, occasionally
    known as the *boundary condition*. This represents the last valid value that our
    loop iterator will have before we finish the loop or, to put it more simply, the
    largest number if we count incrementally.
  prefs: []
  type: TYPE_NORMAL
- en: The third value can be omitted; it will default to `1`. If we use it, this is
    going to be the default step or increment that our loop is going to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theoretically, this C-style `for` loop will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In reality, it has a more complex syntax, but it will look very familiar to
    all of you with experience in programming in C, as the name suggests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we go on, let''s look at an example of a loop that we have already used
    but formatted as it would be in a script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the only real difference here is the formatting and the omission
    of semicolons that directly stems from not having to parse the entire script in
    one line.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to understand looping, you will probably need quite a few examples.
    Start with these links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://linuxhint.com/30_bash_loop_examples](https://linuxhint.com/30_bash_loop_examples)/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-7.html](https://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-7.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: break and continue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until now, we haven't really done any conditional branching in our scripts.
    Everything we did was linear, even loops. Our script was able to execute commands
    line by line, starting from the first one, and if we had a loop, it was running
    until our conditions that we stated at the loop start were met. This means that
    our loops have a fixed, predetermined number of iterations. Sometimes, or to be
    more precise often, we need to do something that breaks this idea.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine this example – you have a loop that has to iterate a number of times
    *unless* a condition is met. We said that our loops have the number of iterations
    fixed at the start of the loop, so we obviously need a way to end the loop prematurely.
  prefs: []
  type: TYPE_NORMAL
- en: This is why we have a command called `break`. As the name suggests, this command
    breaks the loop by escaping from the command block it is included in and finishing
    the loop, regardless of the conditions that were used in the definition of the
    loop. The main reason why this is important is to establish control over the loop
    and handle any possible state that requires you to not finish the job you started
    in your loop. One more thing to note is that the `break` command is not limited
    only to `for` loops; it can be used in any other block of code, a thing that will
    become more useful later when we learn other ways to structure our scripts into
    blocks.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is always easy to start with an example, but in this particular case, we
    are going to start with an overall view of how this command works. We are going
    to use abstract commands instead of actual ones to help you understand the structure
    of this loop. After this, we are going to create some real-world examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: What is going on here? The `for` loop by itself is a normal loop that gets executed
    using `1`, `2`, `3`, `4`, and `5` as values. `command1` and `command2` are going
    to get executed the way we expect them to be at least once, since they are the
    first thing after the start of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: The `if` statement is where things get interesting. We will talk a lot more
    about `if` statements, but we need to mention them here in their most basic form.
    Here, we have something called a break condition. This can be anything that can
    be resolved to a logical value. That means the result of our condition has to
    be either `true` or `false`. If the result is false, our condition is not met,
    and the loop continues by executing `command3`, looping back to the beginning
    of the loop, and assigning the next value to our variable.
  prefs: []
  type: TYPE_NORMAL
- en: We are more interested in what happens if the break condition evaluates to true.
    This means that we have met our condition and need to run the block of code that
    follows. A simple `break` statement is here, and it has no arguments. What will
    happen next is that the script will immediately exit the loop and go to execute
    `command4` and whatever is after it. The important thing is that `command3` will
    not be run in this case, and the loop will not repeat, regardless of the value
    of the loop variable.
  prefs: []
  type: TYPE_NORMAL
- en: There is another statement called `continue` that can also be useful, although
    it is not used as much as `break`. `Continue` also breaks the loop in a way, but
    not permanently. Once you use `continue` in the loop, the program flow is going
    to immediately go to the start of the loop block without executing the remaining
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having talked about the abstract structure, it is time to create an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine we are counting using a `for` loop, but we want to break out of it
    as soon as we hit the number `4` as the value of our variable. Of course, we could
    do this by simply specifying number `5` as the upper value that we are counting,
    but we need to show how the loop works, so we are going to break out of it using
    the `break` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s time to break down our script, but we are going to run it before we do
    that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Our sample script looks a lot like our *abstract* example, but we used actual
    the `echo` command to emulate something that should happen. The most important
    part that we need to talk about is the `if` command; everything else is as we
    said in the first part of this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: We mentioned that we need to have a condition for our `break` statement to make
    any sense. In this particular case, we are using `if` with a `test` condition;
    basically, we are telling `bash` to compare two values and let us know whether
    they are the same or not. In `bash`, there are two ways to do this – one is to
    use the `=` operator we are used to, and another is to use the `-eq` or `equals`
    operator. The difference between these two is that `=` compares `strings`, while
    `-eq` compares integers. We will go into much more detail in later recipes, since
    they are important in scripting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see how the `continue` command works. We are going to slightly
    modify our script so that it skips over the third command once it hits `3` as
    the value of the variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'What we did is a simple change in the `if` statement; we changed the condition
    so that it checks whether the variable value is equal to `3`, and then we created
    a command block that skips over the rest of the loop when our condition is satisfied.
    Running it is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The only real point here is noting that we finished all our iterations; the
    only thing we skipped was one instance of running the third command in the script.
    Also, note that the `continue` command in the loop is going to skip over everything
    up to the end of the current loop and go back to the beginning, while a `break`
    statement is going to skip the entire loop and not repeat it.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Interrupting command flow can be a problem at first. More information is available
    at these links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://tldp.org/LDP/abs/html/loopcontrol.html](https://tldp.org/LDP/abs/html/loopcontrol.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://linuxize.com/post/bash-break-continue/](https://linuxize.com/post/bash-break-continue/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The while loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until now, we have dealt with loops that have a fixed number of iterations.
    The reason is simple – if you are using a `for` loop, you need to specify *for*
    what values your loop is going to run, or what values your variable is going to
    have while in the loop.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with this approach to looping is that sometimes you don't know in
    advance how many iterations you are going to need to do something. This is where
    the `while` loop comes into play.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most important thing you need to know about the `while` loop is that it
    does its testing at the start of the loop. This means that we need to structure
    our script to run *while* something is true. This also means that we can make
    a loop that will never get executed; if we create a `while` loop that has a condition
    that is not met, `bash` is not going to run it at all. This has a number of great
    advantages, since it gives us the flexibility to use our loop as many times as
    we need without thinking about boundaries, and we can still use `break` when we
    need to get out of the loop before our condition is met.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A `while` loop looks even simpler than a standard `for` loop; we have a condition
    that must be met, and a command block that is going to get executed. If the condition
    is not met, commands will not run and `bash` is going to skip over the block and
    continue running whatever is after the end of the `done` statement that terminates
    the block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Condition, in this case, is the same logical condition that we mentioned earlier.
    There is also another way of using the `while` loop by having something called
    `control-command`, a command that runs and directly provides information for the
    loop to start. We are going to use this one a lot, since it enables us to, for
    example, read a file line by line, without specifying how many lines it has beforehand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As usual, we are going to give a few examples. First, we are going to repeat
    the task we already accomplished using the `for` loops. The idea is to loop until
    our value reaches `4` and then finish the loop. Note that the value can be a string,
    not necessarily a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: There are a few little things we need to emphasize. The first one is the condition
    we used. In our `for` loop, we compared whether the value is `4` and then used
    `break` to get out of our loop. In this case, we cannot do that; if we check whether
    the value of our `x` variable is `4`, the loop will never run, since the initial
    value is `1`.
  prefs: []
  type: TYPE_NORMAL
- en: In a `while` loop, we need to check for the opposite – we want our loop to run
    until the value becomes `4`, so the condition has to be true in all cases *except*
    when our variable is exactly `4`.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, the very same `while` keyword helps in creating the condition.
  prefs: []
  type: TYPE_NORMAL
- en: We mentioned that instead of a condition, we can have a command. A typical example
    that you are going to use often is reading a file. We can do this using a `for`
    loop, but it would be needlessly complicated. `for` loops need to know the number
    of iterations before we even start a loop. In order to solve this problem using
    a `for` loop, we would need to count the lines in a file before we can start looping,
    and this would be both complicated and slow, since it requires us to open the
    file twice – first to count the lines and then to read them in the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'A much simpler way is to use a `while` loop. We simply run the loop while our
    command gives us some output – in this case, while it reads from a file. As soon
    as the command fails, the loop is over:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that there are a few things we haven't yet seen in the scripts.
    The first one is the use of the variables. We sort of already did that when we
    were dealing with the `for` statements, but here you can see both how a variable
    is declared and how it is used. We'll talk a lot more about this later. Another
    thing is how we actually read the file. The `read` command has no arguments; it
    is intended to be used with standard input. Since we know how to redirect inputs
    and outputs, we are going to just redirect whatever is in the file as the input
    of the `read` command. This is why we used redirection in the last line of the
    script. It may look awkward, but it is the way to do it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, we have a reason to use a loop that never finishes, a so-called
    infinite loop. It looks counterintuitive, but this kind of loop is extremely common
    in scripts when we need to run the script over and over again and have no idea
    how many iterations we need. Sometimes, we may even want our script to run continuously
    and then use the `break` statement to stop it if something happens. An infinite
    `while` loop is simple; just use `:` as the condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[https://linuxize.com/post/bash-while-loop/](https://linuxize.com/post/bash-while-loop/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_09_02.html](https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_09_02.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.redhat.com/sysadmin/bash-scripting-while-loops](https://www.redhat.com/sysadmin/bash-scripting-while-loops)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The test-if loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When strictly talking about loops, we usually divide them into `for` and `while`
    loops. There are some other structures that we sometimes call loops, even though
    they are more structured like a block of commands. Other names for these could
    be `decision` loops or `decision` blocks, but for legacy reasons, they are usually
    referred to as `test-if` loops, `case` loops, or `logical` loops.
  prefs: []
  type: TYPE_NORMAL
- en: The primary idea behind this is that any decision-making part of the code actually
    branches the code into different paths containing blocks of commands. Since branching
    and decision-making is probably the most important thing you will do in your scripts,
    we are going to show you some of the most commonly used structures that will find
    their way, more or less, into any script you make.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, the most important thing is to understand that for any conditional
    branching, or for that matter, any conditions that you put in your code, you will
    use logical expressions. Logical expressions are, simply put, statements that
    can be either true or false.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take, for example, statements such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `something.txt` file exists.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number `2` is greater than the number `0`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `somedir` directory exists and is readable by the user Joe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `unreadable.txt` file is not readable by any user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every statement here is something that can be either true or false. The most
    important thing here is that there are no other logical states that we can define
    about any of the statements. Another thing is that every statement here refers
    to a particular object, a file, a directory, or a number, and gives us some attribute
    or state of that object.
  prefs: []
  type: TYPE_NORMAL
- en: Having this in mind, we are going to introduce shell testing as a concept and
    then use it to help us work on our scripts.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We already introduced the concept of the `if` statement using `condition` to
    branch to one of the *evaluated* blocks of code. This condition has to be met,
    which means it needs to be resolved into a `true` or `false` statement. The `if`
    command is then going to decide which part of the code is going to run.
  prefs: []
  type: TYPE_NORMAL
- en: This evaluation is also called *testing*, and there are two ways of doing it
    in shell. The `bash` shell has a command called `test` that is sometimes used
    in scripts. This command takes an *expression* and evaluates it to see whether
    the result is true or false. The result of the command is not printed in the output,
    but instead, the command assigns its *exit status* to the appropriate value.
  prefs: []
  type: TYPE_NORMAL
- en: Exit status is a value that each command will set after finishing, and we can
    check it from inside the command line, or from our script. This status is usually
    used to either see whether there were any errors executing a particular command
    or to pass some information, such as a logical value of a tested expression.
  prefs: []
  type: TYPE_NORMAL
- en: In order to test exit status, we can use a simple `echo` command. Let's do a
    few examples using a simple expression and the `test` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first example uses the `echo` command to write out what the exit status
    was of the `test` command. In all the examples, `0` means `true` and `1` means
    `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: So, how come we got a result that says that `1=0` is true? We made a syntax
    error (on purpose) to show you probably the most common mistake in scripting.
    All commands will usually use a very strict syntax, and *test* is not an exception.
    The problem with this particular command is that it will not show an error; instead,
    it is going to just treat our expression like it is *one single argument* and
    then decide it is `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can check this by using a completely nonsensical argument, such as a single
    word:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the result is logically true, even if it does not make any
    real sense. In reality, `test` requires spaces to understand which part of the
    expression is the operator and what are the operands. The right way to write our
    previous example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the result we expected. To check, we are going to try evaluating another
    expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: So, this one is true. This is completely what we expected. The reason we are
    using quotation marks here is that we are not actually evaluating numbers; we
    are comparing *strings*. What if we remove the quotation marks?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This also works okay; just to check, we are going to retry with something that
    should be false:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is also completely what we expected to see. Let''s now try something
    else. We said there is a difference between comparing numbers and strings. A number
    has the same value regardless of the number of zeroes preceding it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Our command now states that these two are not equal. Why? Because the *strings*
    are not equal. `Bash` uses different operators to compare strings and numbers,
    and since we used the `1` for the strings, these values are not the same. The
    same goes for using them in quotation marks, just to show how quotes are handled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The operator that we should have used for integer comparison is `-eq`; it will
    understand that we are comparing numbers and compare them accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Regardless of whether we are using quotes or not, the result should be the
    same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'For the last example, we are going to see what happens when we confuse the
    operators the other way around and try to compare strings using the integer comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: What does this result mean? First, our test tried to evaluate the condition
    and realized there is an error in comparison, since it cannot compare a string
    and an integer or, to be more precise, that an integer cannot contain letters.
    We got the error in our output, so the command exited with the `2` status, which
    signifies an error. The result logically makes no sense, so the result is neither
    `0` nor `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing we need to do is implement what we learned in actual scripting,
    but before that, we need to address one more thing. There are two ways to create
    our tests. One is by explicitly using the `test` command. Another is by using
    square brackets (`[ ]`). While we are going to use `test` a lot when we need to
    run something in the command line depending on some condition, when using the
    `if` statement, we are going to use square brackets most of the time, since they
    are easier to write and look better when glancing over the script. Just to make
    sure, here is one of the expressions we used, written in a different way. Please
    pay attention to the spaces inside the brackets; there needs to be a single space
    between the brackets and the expression we are using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to write a small script that is going to test whether a file exists
    in the directory the script was run from. For that, we need to talk a little about
    some other operators that we can use.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you take a look at the `man` page for the `test` command or at a `bash`
    manual, you will see that there are many different tests we can do, depending
    on what we want to check; the most common ones we are going to use are probably
    the following (taken directly from the man pages for `test(1)`):'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `-d` file: The file exists and is a directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `-e` file: The file exists.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `-f` file: The file exists and is a regular file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `-r` file: The file exists and read permission is granted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `-s` file: The file exists and has a size greater than zero.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `-w` file: The file exists and write permission is granted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `-x` file: The file exists and execute (or search) permission is granted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s create a script using this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Probably the most important thing to learn here is the structure and the use
    of the `else` statement. There are two blocks or *parts* of code we define in
    an `if` statement – one is called `then` and the other `else`. They do as their
    names suggest; if the condition we used in the statement evaluates as true, then
    the `then` code block is going to get executed. If the condition is not met, then
    the `else` block will be run. These blocks are mutually exclusive; only one of
    them is going to get run.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are going to deal with a topic that will sometimes confuse you. We already
    mentioned that a script has a context it is running in. Among other things, there
    are two things you need to know every time your script is running – where it was
    run from and which user ran the script.
  prefs: []
  type: TYPE_NORMAL
- en: These two pieces of information are crucial, since they define how we are going
    to reference the files we need and what permissions we will have from inside of
    the script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next task is going to be to create a script that will show us how to deal
    with all of this. What we are going to do is test whether the script can read
    and write the `root` directory and whether the directory even exists. The reference
    we are going to make to this directory is going to be relative, so we are going
    to presume that our script is being run from the `/` directory, which is usually
    false. Then, we are going to try and run the script in different directories and
    under different users, comparing the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are basically testing for three different conditions. First,
    we are trying to see whether the directory exists at all and, after that, whether
    the script has read and write permissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we are going to try and run this as the current user in the directory
    that the script is created in. Then, we are going to go to the `/` directory and
    run it from there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: What does all this tell us? Our first run was unable to find the directory since
    we were using a relative path in the script. This makes the directory that the
    script is run from important.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another thing we learned is how our checks work. We can independently check
    whether a file or directory exists, and different permissions that the current
    user has on a particular file. We are going to show that by running the script
    under a `root` user using the `sudo` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As soon as we change the context, we can see that the same script is not only
    able to see that the directory is there but also has full rights to use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are going to completely change our script to demonstrate how we can
    embed our checks into one another. Our script will once again test whether the
    `root` directory is in the current directory, but this time, the script is going
    to check whether it has read and write rights only if the directory exists. After
    all, it makes no sense to see whether you can read a directory that isn''t there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are going to run it in two directories to see if our script works;
    the main difference should be the output. Also, when you have a nested structure
    such as this one, always try to keep your indentation consistent. This means that
    you always should try to keep commands in the same block indented in such a way
    that it is immediately obvious where each command belongs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We have now seen what can be done with different tests and conditions in `bash`.
    The next topic is similar to this one – the `case` statement or `case` loop.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[https://www.thegeekdiary.com/bash-if-loop-examples-if-then-fi-if-then-elif-fi-if-then-else-fi/](https://www.thegeekdiary.com/bash-if-loop-examples-if-then-fi-if-then-elif-fi-if-then-else-fi/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_07_01.html](https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_07_01.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://ryanstutorials.net/bash-scripting-tutorial/bash-if-statements.php](https://ryanstutorials.net/bash-scripting-tutorial/bash-if-statements.php)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The case loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until now, we have dealt with basic commands that allow us to do things we
    need when trying to write a script, such as looping, branching, breaking, and
    continuing program flow. A `case` loop, the topic of this recipe, is not strictly
    necessary, since the logic behind it can be created using a multi-nested group
    of individual `if` commands. The reason we are even mentioning this is simply
    because `case` is something that we are going to use a lot in our scripts, and
    the alternative of using `if` statements is both difficult to write and read,
    and complicated to debug.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One could simply say that a `case` loop or `case` statement is just another
    way of writing multiple `if then else` tests. `Case` is not something that can
    be used in place of a normal `if` statement, but there is a common situation in
    which a `case` statement makes our lives a lot less complicated and our scripts
    much easier to debug and understand. But before we go into that, we need to understand
    a little bit about variables and branching. Once we start using `if` statements,
    we are quickly going to realize that they can be used, more or less, in two distinct
    ways. The first is the one everyone thinks about when thinking about an `if` statement
    – we have a variable and we compare it to another variable or a value. This is
    common and often done in a script. Something a little less common is when we have
    to compare a variable to a list of values. This happens most often when we need
    to sort things into groups or run a block of code depending on the user input.
  prefs: []
  type: TYPE_NORMAL
- en: User input is probably the most popular reason a `case` statement is used. In
    scripts, this is often used once we start using arguments. Our scripts will have
    to reconfigure things based on what arguments the user chose when running the
    script. We will take a look at that a little bit later when we start dealing with
    passing arguments to a script, which will exclusively use `case` statements to
    run appropriate commands.
  prefs: []
  type: TYPE_NORMAL
- en: User menus are another thing that is solved by using `case` statements; to generalize,
    each time a user has a multiple-choice answer to a question, this is going to
    get handled by a `case` statement.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The best way to explain a `case` statement is by creating an example. Let's
    say that a user starts a script, and they have four choices of what they want
    the script to do. Right now, we are not prepared to deal with how they will input
    their choice, so let's just presume that there is a variable called `$1` that
    contains one of these values – `copy`, `delete`, `move`, and `help`. Our script
    will have to run the appropriate part of the code based on user input. In fact,
    this is the way arguments are handled, but we will talk about that later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first version is going to use the `if – then – elif` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This works, but it has two problems. One is that it throws errors if there
    are no arguments given, since this means we are comparing a value to a variable
    without a value. The other problem is that this is complicated to read, even if
    we pay extra attention to using the right indentation. We are going to redo this
    using a `case` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The first thing you will notice is how simple and clean this looks. As well
    as being easier to write, the code is much easier to read and debug if we need
    to. There are just two simple things to pay attention to – the end of the statement
    block is defined as `esac`, which is `case` spelled backward, similar to how the
    `if` statement is terminated by `fi`. Another thing is that you have to use `;;`
    to terminate a line, since that's what's used to delimit choices in the `case`
    loop.
  prefs: []
  type: TYPE_NORMAL
- en: When matching values, you can also use limited regular expressions; this is
    the reason that the `*` `glob` is used to symbolize *zero or more characters*.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we know a lot more about scripting, we are going to do a simple script
    that searches for a string in a directory and lets us know what happened. We don't
    care about where the text is; we just want to know whether there is text that
    we used somewhere in the directory we ran our script in.
  prefs: []
  type: TYPE_NORMAL
- en: 'The things we need to know before we even start are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$1` is going to hold a string value that is going to be the text we are searching
    for.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$?` holds the `exit` value of a command that was just completed in the script.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`grep` as a command returns either `0` if it found something, `1` if it didn''t,
    or `2` if there was an error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a special device called `/dev/null` that can be used if we need to
    silence some output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Thanks to the `case` statement, this is a trivial task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: For the last script, we are going to use `case` to combine another script from
    this chapter that was testing a directory and put it into a larger script. We
    are going to create a script that will be given a command and a filename as arguments.
    The command is going to be either `check`, `copy`, `delete`, or `help`. If we
    specify either `copy` or `delete`, the script will check whether it has the permissions
    to do the task and then the `echo` command that it would normally call.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we specify `check`, the script is going to check for permissions on a given
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'What we have done here is combine everything that we have done so far into
    a script that actually does something. The only thing we haven''t mentioned before
    is `$2` as the second argument in the script. In this case, we use it to get the
    filename we need to run the commands. This is how it all looks when run from the
    command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When it comes to using `case` in your scripts, you will soon realize that a
    lot of examples are copied and pasted between sites. The following links are two
    good sources:'
  prefs: []
  type: TYPE_NORMAL
- en: https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_07_03.html
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: https://www.shellhacks.com/case-statement-bash-example/
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logical looping with and, or, and not
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is no way to escape logic when it comes to computers. We already dealt
    with some things you can do with evaluating conditions, but there is a lot more
    that can be done in `bash`.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to deal with different logical operators that help
    us with scripting in general. First, we are going to deal with what can be done
    on the command line, and then we are going to use that in scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let''s quickly talk about logic operators. So far, we mentioned expressions
    that have a value of true and false. We also mentioned a lot of different expressions
    that are built into `bash`, since they provide functionality crucial for everyday
    work on the command line. Now is the time to talk about logical operators that
    help us combine expressions and create complex solutions. We are going to start
    with the usual operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '`&&` (the logical `AND`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`||` (the logical `OR`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The interesting thing about these is that they can be used directly on the command
    line. The command line in `bash` basically has four ways of executing commands.
    One is to run them one by one on each line. This is the usual way we work in interactive
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, we need (or want) to run multiple commands on one line. This is
    mostly done by using `;` to separate commands, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, it is exactly the same as if we ran each command by itself, but
    shell just executes them in a row. We already used this when we tested different
    expressions using the `test` command. We needed to check what the exit status
    was of that command, so we always used `echo` directly after running the test.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, however, we can use a little logic to create shortcuts. This is where
    logical operators come into play. The remaining two ways to run multiple commands
    use them to not only run the command but also to run them conditionally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine we want to perform a command after we make some kind of test – for
    example, we want to open a file but only if the file actually exists. We could
    write an `if` statement here, but it would make absolutely no sense to complicate
    things like that. This is where we can use the logical `AND`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In general, using `&&` between commands tells `bash` to run the command on the
    right only if the command on the left succeeded. In our example, this means that
    we have a file named `output` in our directory. On the left, we are doing a quick
    test if this file exists. Once this is successful, we run `cat` to output the
    file contents.
  prefs: []
  type: TYPE_NORMAL
- en: In the second example, we intentionally used the wrong filename, and the `cat`
    command hasn't been run, since the file is not there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another logical operand we can use is the logical `OR`. The operator to use
    is `||` in the same way as before. This operator instructs `bash` to run the command
    on the right only if the command on the left failed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This is the exact opposite of the previous example. Our `cat` command ran only
    when the test failed. A structure such as this is sometimes used in scripts to
    create fail-safes or to quickly run things such as updates.
  prefs: []
  type: TYPE_NORMAL
- en: 'What is nice is that this enables us to immediately do something, depending
    on the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: These operators also exist in test expressions, allowing us to create different
    conditions that would otherwise require multiple `if` statements.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Testing a condition is hopefully now completely familiar to you. We are going
    to try and combine a few of them to explain what different operators can do. For
    example, if we want to quickly check whether a file exists and is readable, we
    can do it by either testing whether it is readable or explicitly combining those
    two things into one statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'These tests are going to be most useful when dealing with strings and numbers.
    For instance, we can try and find whether a number is within an interval in a
    script, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to run this script, but before we even do that, we can see that
    it looks complicated, more than it should be. It is not just the fact that we
    have to use two `if` statements to make sure that we handle both parts of the
    outside interval; this script demands a lot of explanations, even though it is
    only a couple of lines long. Does it work? Yes, as we can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are going to use logical operators to optimize our script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: We are using double brackets here because we have to. There are multiple ways
    to achieve the same goal, and there are some older versions of the syntax, but
    it is best practice to use double brackets when dealing with multiple expressions.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Dealing with logical operators is, in part, complicated because there are so
    many of them. You can find much more information here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://linuxhint.com/bash_operator_examples/#o23](https://linuxhint.com/bash_operator_examples/#o23)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://opensource.com/article/19/10/programming-bash-logical-operators-shell-expansions](https://opensource.com/article/19/10/programming-bash-logical-operators-shell-expansions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
