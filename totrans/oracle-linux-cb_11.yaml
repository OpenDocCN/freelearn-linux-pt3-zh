- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lions, Tigers, and Containers – Oh My! Podman and Friends
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These days, it’s all about containers. Docker made containers cool and brought
    them into the mainstream, and Podman is here to come to the rescue as an open
    source container runtime that is open and available to all. Oracle Linux 7 includes
    Oracle Container Runtime for Docker, whereas Oracle Linux 8 and beyond include
    Podman, Buildah, and Skopeo.
  prefs: []
  type: TYPE_NORMAL
- en: 'With every new release, Podman closes the gap between it and Docker. With Podman
    v2.0, it began offering a fully compliant build that enables technologies such
    as `docker-compose` to work interchangeably with Podman. With Podman v4.1.0, you
    are now able to seamlessly mount the host machine’s home directory into the Podman
    machine VM, making it available within container volume mounts. This chapter is
    largely intended for users who have some basic experience with Docker, and will
    help users understand the differences between Docker and Podman so that they can
    successfully migrate their workloads to this so-called “drop-in replacement.”
    If you’re not familiar with Docker or are new to the concept of containers, it
    may be helpful to peruse the Get Started guide from Docker, which can be found
    here: [https://docs.docker.com/get-started/](https://docs.docker.com/get-started/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Ridding yourself of demons – err um – daemons, with Podman
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Giving your containers a root canal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating handy-dandy utility containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Compose with Podman
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing stacks with pods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containerized databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Buildah and Skopeo – Podman’s friends with benefits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Podman, Buildah, and Skopeo are all included in the `container-tools` module
    from application streams:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The source code for the recipes in this chapter can be found at [https://github.com/PacktPublishing/Oracle-Linux-Cookbook](https://github.com/PacktPublishing/Oracle-Linux-Cookbook).
  prefs: []
  type: TYPE_NORMAL
- en: Ridding yourself of demons – err um – daemons, with Podman
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker and Podman are both tools that aim to make it easier to run and manage
    containers on a host machine. Since Podman is the new kid on the block, you may
    be wondering how you can switch from Docker to Podman. While technically it is
    possible to run both Docker and Podman together on the same system, there are
    very few practical reasons to do this. Since both tools provide the same core
    capabilities, I would advise you to choose one or the other.
  prefs: []
  type: TYPE_NORMAL
- en: One of the key benefits of switching to Podman is you will inherently lose the
    daemon that lurked behind the scenes of Docker. You see, Docker relies on a daemon
    that does all the heavy lifting of managing containers. This may not seem so bad
    on the surface, but there are some things to be aware of when it comes to this
    architecture.
  prefs: []
  type: TYPE_NORMAL
- en: For starters, having an extra daemon running in the background means there is
    one more point of failure. If that dedicated daemon for Docker crashes, you lose
    all your containers. The additional daemon also increases your attack surface,
    and because the Docker daemon has root access to the system, any compromise made
    to the Docker daemon puts your system at greater risk.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe aims to exorcise those demons – err, um – discontinue the use of
    the Docker daemon. The best thing is, if you aren’t using Docker and you only
    ever installed Podman, you don’t need to worry about anything – that’s because
    Podman is rootless by default, and it leverages **systemd** to manage your containers.
    **systemd** is a tried-and-tested system-level daemon that provides an array of
    system components, including a system and service manager, parallelization capabilities,
    logging, and utilities to manage and maintain system configuration.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if you were previously using Docker, we’re going to show
    you how to switch. It’s really quite simple – all you need to do is remove Docker
    and install Podman.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I’m running on x86-64 bit architecture, but Oracle Linux and Podman also work
    on Arm. However, it’s important to know that not all containers are compiled in
    Arm, or vice versa. With that being said, it may be easier to follow this guide
    using an x86-64 bit CPU:'
  prefs: []
  type: TYPE_NORMAL
- en: Oracle Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Podman
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Remove Docker by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After this, you will be able to install Podman with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ sudo groupdel docker
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now you’re running containers without the Docker daemon, and by default with
    Podman, you’re rootless.
  prefs: []
  type: TYPE_NORMAL
- en: Giving your containers a root canal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Straight from the Docker documentation, you will find that “*The Docker daemon
    binds to a Unix socket instead of a TCP port. By default that Unix socket is owned
    by the user root and other users can only access it using sudo. The Docker daemon
    always runs as the* *root user.*”
  prefs: []
  type: TYPE_NORMAL
- en: The documentation then proceeds to instruct you to add your user to the `docker`
    group in order to use Docker without using `sudo`. That sounds great, right? Well,
    the thing is, the `docker` group grants privileges equivalent to the `root` user.
    This can have dire consequences. For instance, any location on your host filesystem
    can be mounted into the container – and I do mean any! This even includes the
    `/` (root) directory and the container can then alter your host filesystem without
    any restrictions. There are several other security vulnerabilities that are a
    direct result of this architecture, but you get the picture.
  prefs: []
  type: TYPE_NORMAL
- en: What’s different about Podman is that by default, it runs rootless; in other
    words, you can run containers using Podman without root privileges. When I first
    heard this, I thought it meant the user in the container was not root, but that’s
    not really the case. Rootless containers simply mean that the user instantiating
    the containers does not have root privileges. There are a few things to know about
    running a container without root privileges, and this recipe aims to instruct
    you how to run rootless containers, while at the same time explaining the differences
    between rootless and rootful.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Oracle Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Podman
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To run rootless containers with Podman, all you need to do is use Podman as
    a user without root privileges. Also, do not append `sudo` to any Podman commands,
    because if you do, you would then be running the container as the root user.
  prefs: []
  type: TYPE_NORMAL
- en: What’s different about rootless containers?
  prefs: []
  type: TYPE_NORMAL
- en: Network modes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are three common network modes supported by Podman:'
  prefs: []
  type: TYPE_NORMAL
- en: Bridged
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: macvlan
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: slirp4netns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, there’s a **bridged** network, which is the default used by rootful Podman.
    Bridged networking creates a network interface on the host and dedicates this
    interface to the container. Another network mode is **macvlan**, which is a virtual
    LAN that basically forwards an entire network interface from the host into the
    container. Finally, there is **slirp4netns**, which enables you to connect a network
    namespace to the internet in a completely unprivileged way. Rootless Podman leverages
    **slirp4netns** because unprivileged users lack the ability to create network
    interfaces on the host. In order to bypass this limitation, **slirp4netns** instead
    creates a tunnel from the host and into the container in order to forward traffic.
  prefs: []
  type: TYPE_NORMAL
- en: Network ports
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you run your containers without root access, you may run into issues exposing
    certain network ports. For example, it is common for users to expose ports `80`
    and/or `443` when running containers; however, if you try to do this while running
    a rootless container, you will see a message like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Rootless Podman is limited to exposing ports `1024` and above. If you wanted
    to expose a lower port, you would need to first configure this as root in order
    to allow unprivileged users to expose lower port numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say you wanted to allow rootless Podman to expose the standard HTTP web
    port (port `80`). In this case, you can run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If you want these settings to persist, simply follow the guidance of the error
    message received earlier. That is, edit the `/etc/sysctl.conf` file and append
    `net.ipv4.ip_unprivileged_port_start=80`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating handy-dandy utility containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe shows how to use Podman to quickly spin up a container to complete
    useful tasks.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will walk you through the process of creating super useful utilities
    leveraging containers. The basic principle of containers encourages us to formulate
    our containers to do only one thing – that is, to provide some form of utility
    and nothing more. You should not create a container that does too much. With that
    being said, most container images already exist to provide a useful utility. In
    this recipe, we are going to look at examples of containers that serve a useful
    purpose, and we’re going to explore how to make use of this.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will require the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Oracle Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Podman
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main intention of this recipe is to show how we can use containers to achieve
    a function without installing additional packages on our local machine. Once you
    have Podman installed on your local machine, you can tap into an entire ecosystem
    of useful packages and utilities without installing more packages – instead, you
    simply run a container image that contains those packages, or, alternatively,
    you create a new container and install the desired packages there.
  prefs: []
  type: TYPE_NORMAL
- en: Why would anyone prefer to do this? For starters, it allows you to minimize
    the number of packages and dependencies you’re installing on your host machine.
    With fewer packages, you reduce your attack surface in terms of security. Additionally,
    your operating system’s repositories might be limited to access to certain packages,
    or it might not have access to the latest versions. Instead of going through the
    effort of adding potentially untrusted repositories to install the packages you
    need, why not simply launch a container that contains everything you need for
    the specific function you’re trying to achieve?
  prefs: []
  type: TYPE_NORMAL
- en: Before we try to tap into the true potential of containers, we first need to
    discuss a few important concepts that will make this process a bit easier.
  prefs: []
  type: TYPE_NORMAL
- en: Entrypoint
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The entrypoint of a container defines what command the container will run by
    default. You can find the entrypoint of a container by specifying the `inspect`
    command and piping that to `jq` to extract only the entrypoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, pull the image if you don’t already have it on your system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s inspect the image and run `jq` to query for the entrypoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`jq` installed on our computer. In this case, we can pipe the output of `inspect`
    to a container that contains `jq`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In either case, the output of this command will be `/usr/local/bin/pandoc`.
  prefs: []
  type: TYPE_NORMAL
- en: This tells us that when we run the `pandoc/core` container, the default command
    that gets executed will be `/usr/local/bin/pandoc`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, a container’s entrypoint might be a script. For example, you might
    check for the entrypoint and learn that the entrypoint is `docker-entrypoint.sh`.
    You can reveal more about this file by overriding the entrypoint and using `cat`
    to see the contents of the file. For example, let’s say we were to inspect the
    `node` container image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We would find that the entrypoint is `docker-entrypoint.sh`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s override the entrypoint to examine the contents of this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the output is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This is because in the case of the `node` image, the `docker-entrypoint.sh`
    file is not in the working directory; instead, it is found in the path. So, we’ll
    try another way to examine this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – Output of docker-entrypoint.sh](img/B18349_11_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – Output of docker-entrypoint.sh
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know about the default entrypoint, we can use this as we determine
    what we’re going to do with the container. Sometimes we might want to use the
    default entry point as intended, whereas other times we might benefit from overriding
    the default entrypoint to use some other available packages within the container
    – it all depends on what we’re trying to do.
  prefs: []
  type: TYPE_NORMAL
- en: Working directory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You’ll often want to specify the working directory inside the container, because
    that’s where the container is configured by default to perform its work. To get
    the working directory of a container, you can run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, you get bonus points if you do this without installing `jq` by running
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In either case, the output of this command will be `/data`.
  prefs: []
  type: TYPE_NORMAL
- en: This tells us that when we run the `pandoc/core` container, the default working
    directory inside the container is `/data`.
  prefs: []
  type: TYPE_NORMAL
- en: Volume mounting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to make use of a container that performs a task against files on your
    local machine, you’ll first need to mount a volume into the container. An easy
    way to do this is to specify your present working directory by specifying `$(pwd)`.
    Another method might be to specify `./`. The order in which this is done is by
    declaring the host machine’s directory first, and the container’s directory second.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you wanted to mount the present working directory of the host
    machine into the working directory of the container, you would run `-v $(pwd):/data`.
    In this example, we are saying we want our present working directory on the host
    machine to be accessible inside the container at the `/data` path. Remember, we
    found the working directory of the container when we used the `podman` `inspect`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Super useful utility containers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we’ve discussed some of the important concepts, I am going to list
    examples of useful utilities I’ve found in containers and then will expand on
    the practicality of leveraging containers for these functions.
  prefs: []
  type: TYPE_NORMAL
- en: Converting a Markdown file to docx using pandoc
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this example, let’s imagine we have a document that we want to convert to
    another type. There are many tools we can leverage to do this, but one such tool
    that comes to mind is pandoc. Rather than installing pandoc on my local machine,
    I’ll simply run the `pandoc/core` container, which has pandoc preinstalled. The
    entrypoint in the `pandoc` container is `/bash/pandoc`. This means that anything
    after the specification of the container image will automatically append to the
    `pandoc` command inside the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can run `--help` after the `pandoc/core` command to learn how to use the
    utility, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'From that (you can also view the man page maintained here: [https://linux.die.net/man/1/pandoc](https://linux.die.net/man/1/pandoc)),
    I now have some insight into how to use pandoc. In this case, I can use the `pandoc`
    command within the container by mounting my present working directory into the
    container and specifying my source document and what I want the output to be,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Since the working directory inside the container is `/data`, and since I have
    that mounted to my host system, if the container creates a new file inside that
    directory, I will be able to find the output on my host system. Cool!
  prefs: []
  type: TYPE_NORMAL
- en: Making a change to an image or video file using FFMPEG
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this example, we will leverage FFMPEG within a container in the same way
    we leveraged pandoc in the previous container. Using the FFMPEG container is especially
    handy because FFMPEG tends to rely on lots and lots of dependencies that I’d prefer
    not to install on my local machine. Additionally, it’s nice that the official
    FFMPEG container comes packaged with the latest version, and it works great!
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like in the previous example, we can run `--help` after the `ghcr.io/linuxserver/ffmpeg`
    command to learn how to use FFMPEG, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'From the output (you can also view the man page maintained here: [https://linux.die.net/man/1/ffmpeg](https://linux.die.net/man/1/ffmpeg)),
    I can see a plethora of options, but for the sake of brevity, I will simply show
    how you can use `ffmpeg` from a container to convert video within a container,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This command will start at 00 hours, 00 minutes, and 30 seconds (specified by
    `-ss`) into the video, and will record 5 seconds (specified by `-t`). It will
    then convert the video, and the output can be found in `./config/output.mp4`.
  prefs: []
  type: TYPE_NORMAL
- en: Using Node.js within a container
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s say we need to build a Node.js application. To do this, we’ll want to
    use Node and npm. In [*Chapter 10*](B18349_10.xhtml#_idTextAnchor304), we discussed
    the usefulness of application streams and how you can leverage application streams
    to install different versions of Node.js. Well, just like anything else in life,
    there is *more than one way to skin* *a cat*.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than installing Node.js on your host system, why not leverage Node.js
    within a container instead? The `node` container includes Node and npm. By default,
    when you run the `node` container, you are executing the `node` command, as this
    is the default entrypoint (as you may recall from earlier when we discussed entrypoints).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say we want to use the `npm` command instead – we can do this by overriding
    the entrypoint. At this point, we know we can override the entrypoint by leveraging
    bash and appending a command at the end, but we also need to know where to mount
    our host system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'From this, we can see that the default working directory within the container
    is null. Does that mean we can’t use the container the way we want? Of course
    not, because we can simply override the entrypoint and take matters into our own
    hands. In this scenario, I will mount the present working directory from my host
    system into an `/app` directory, and I’ll override the entry point to bash so
    I can instruct the container to change directory to `/app` before I run the `npm`
    command to build my Node.js application. Here’s how that can be done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Once NPM completes the build, you’ll find your application binaries inside a
    directory called `./build` on your host machine
  prefs: []
  type: TYPE_NORMAL
- en: 'But wait, just as I mentioned earlier, there is *more than one way to skin
    a cat*. A more elegant way to achieve the same thing might be to instead tell
    Podman where you want the working directory to be. If we do this, we don’t even
    need to set bash as our entry point – instead, we can jump straight into npm.
    This can be done with the `-w` (or `--workdir`) command, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In my opinion, the second approach is cleaner, but the end result is the same.
  prefs: []
  type: TYPE_NORMAL
- en: Running a lightweight NGINX web server to preview a web page locally
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this example, we might as well continue from the last exercise, where we
    built a Node.js application. Now that we have our Node .js application built/compiled,
    let’s host it inside an NGINX container. We can do this by simply mounting the
    build directory into the `/user/share/nginx/html` directory inside the NGINX container.
  prefs: []
  type: TYPE_NORMAL
- en: How did I know to host it inside this specific directory? In this case, I had
    to read up on the NGINX documentation for the NGINX container. You can usually
    find this type of documentation on any container registry that hosts the container
    you’re looking to run.
  prefs: []
  type: TYPE_NORMAL
- en: 'The command to host our build directory locally is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'With Podman, the default setting for rootless ports cannot expose privileged
    port `80`. If you have not changed this setting, you will see a message such as
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You can override this setting if you have root privileges, with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, you can simply choose to use a port number of `1024` or higher.
    Once you have the container running, you can preview the local website by navigating
    to `http://localhost` (if you’re using port `80`) or `http://localhost:8080` (or
    whatever port that you assigned if you did not go with port `80`).
  prefs: []
  type: TYPE_NORMAL
- en: Docker Compose with Podman
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Podman is a powerful container engine that is typically accessed via a `docker-compose.yml`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: While Docker Compose is a great utility for configuring your containers as code,
    it’s important to know that Docker Compose was designed to be used with Docker.
    With that being said, there are a few things to be aware of when using Docker
    Compose with Podman.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will require the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Oracle Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Podman
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Compose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we’re going to talk about how you can use Docker Compose with
    Podman.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since Compose files typically involve multiple containers and applications
    communicating with one another, I recommend the use of the Netavark- and Aardvark-based
    network stack rather than the CNI-based stack. Netavark and Aardvark are new in
    Podman 4.0 and offer reduced overhead and significant performance enhancements.
    Additionally, I experienced issues with the default CNI-based stack, whereas switching
    to Netavark and Aardvark enabled my containers to communicate with each other
    as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To switch out your network stack, simply specify `netavark` as the network
    backend in the `/usr/share/containers/containers.conf` file. You can do this quickly
    by running the following `sed` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you already running containers on your system, you will need to run `sudo
    podman system reset` in order to fully switch to the Netavark- and Aardvark-based
    network stack, but just be aware that this command will remove all your existing
    images, containers, pods, networks, and volumes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that is out of the way, let’s start by installing Docker Compose:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: sudo dnf install podman-docker
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to enable the Podman socket:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To use Docker Compose in a rootless manner, use this command:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'To use Docker Compose in a rootful manner, use this command:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that Docker Compose is ready to go, we’ll need a Compose file to test things
    with. Let’s first examine a Compose file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.2 – Compose file for Portainer](img/B18349_11_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – Compose file for Portainer
  prefs: []
  type: TYPE_NORMAL
- en: In a `docker-compose.yml` file, we define how we want Docker (or Podman in this
    case) to run multi-container applications. In the case of this `docker-compose.yml`
    file, we define the services and the volumes we want Podman to create, and we
    configure various parameters of the service to our liking.
  prefs: []
  type: TYPE_NORMAL
- en: Info
  prefs: []
  type: TYPE_NORMAL
- en: For a comprehensive overview of the entire Compose specification, see [https://docs.docker.com/compose/compose-file/](https://docs.docker.com/compose/compose-file/).
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s test things and see if Docker Compose will work. Save the contents
    of the Compose file in a file named `docker-compose.yml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using the terminal, change directory to the same directory you saved the `docker-compose.yml`
    file in and run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Congratulations, you are now using Docker Compose with Podman.
  prefs: []
  type: TYPE_NORMAL
- en: Managing stacks with pods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Keeping everything organized with stacks and prepping for Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Podman supports concepts that do not exist in Docker. One of the big ones is
    pods – so I guess that’s where the name *Podman* derives from... *Podman = Pod
    Manager*. In this recipe, you will learn how to keep things organized by managing
    stacks with Podman. We’ll achieve this functionality through the use of pods.
    Pods consist of one or more containers. Because pods are the smallest deployable
    units that you can create and manage in Kubernetes, familiarizing yourself with
    pods will help you bridge the gap between containers and Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will require the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Oracle Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Podman
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Compose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we jump into the recipe, we should first discuss a little more about
    pods. As mentioned previously, pods consist of one or more containers. Pods will
    always contain an `infra` container, which, by default is based on the `k8s.gcr.io/pause`
    image. The `infra` container basically does nothing but sleep – this ensures that
    the container continues to run even while idle, and it holds the port bindings,
    namespaces, and cgroups from the kernel. Once the pod is created, the attributes
    assigned to the `infra` container cannot be changed. It’s important to remember
    that any ports that need to be exposed will need to be done during the initial
    creation of the pod.
  prefs: []
  type: TYPE_NORMAL
- en: Outside of the pod exists a **conmon** (**container monitor**) instance that
    watches the primary process of the container. Each container has its own instance
    of conmon.
  prefs: []
  type: TYPE_NORMAL
- en: The following diagram provides an architectural overview of what makes up a
    pod.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – Architectural overview of a pod](img/B18349_11_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – Architectural overview of a pod
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the Podman commands that relate to pods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As can be seen from the preceding commands, you can use the Podman CLI to create
    a pod and run your containers within the pod.
  prefs: []
  type: TYPE_NORMAL
- en: Manual pod creation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s say we wanted to deploy Wiki.js inside a pod. Wiki.js is open source
    Wiki software built on Node.js and relies on a database backend. In other words,
    we want a pod that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4 – Architecture of a Wiki.js pod](img/B18349_11_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.4 – Architecture of a Wiki.js pod
  prefs: []
  type: TYPE_NORMAL
- en: 'We can construct this pod manually by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to create a pod. As we do this, we need to ensure we configure
    the port mappings to allow ingress into port `3000`. We will do this using the
    `podman` `pod` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '--pod tag to ensure this container runs inside the same pod as the database:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Automatic pod creation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Podman allows you to create pods manually using the command-line interface,
    but another cool feature of Podman is that it natively supports Kubernetes manifests.
    Since pods are the smallest deployable units that you can create and manage in
    Kubernetes, this means that deploying Kubernetes manifests in Podman will result
    in the creation of pods by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Writing a full Kubernetes manifest is outside the scope of this recipe, but
    I’m going to show you how you can generate a Kubernetes manifest automatically
    using Podman, and subsequently use that manifest to deploy your containers into
    pods. Since we just learned about using Compose files in the previous recipe,
    we’re going to leverage them again here, and then we’ll supercharge them by converting
    them into Kubernetes manifests:'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to do is to deploy your containers from a Compose file. For
    this recipe, we’ll start with a Compose file for Wiki.js.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.5 – Compose file for Wiki.js](img/B18349_11_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.5 – Compose file for Wiki.js
  prefs: []
  type: TYPE_NORMAL
- en: Wiki.js requires two containers, one for the application itself, and the other
    is a PostgreSQL database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our Compose file, let’s use Docker Compose to deploy the containers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once the containers are running, verify that everything works by pointing your
    browser to http://127.0.0.1:3000.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you see the Wiki.js setup screen, you’re good to go. At this point, we’re
    going to generate a Kubernetes manifest (called `wikijs.yaml`) from the two containers
    we just launched:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that the Kubernetes manifest is generated, let’s bring down the containers
    we just launched:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Podman run –rm -v ${PWD}:/workdir docker.io/mikefarah/yq e -i '(select(.kind
    == "Pod").spec.containers[] | select(.name == "wikijs" ).env[] | select(.name
    == "DB_HOST")).value = "wikijs-pod-wikijs-db"' wikijs.yaml
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the *Creating handy-dandy utility containers* recipe for more information
    on how to use a container as a utility.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve corrected the `DB_HOST` value, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Verify that the pod is running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, go ahead and navigate to http://127.0.0.1:3000.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Containerized databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe discusses best practices regarding the use of containerized databases.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will require the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Oracle Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Podman
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Containers make databases a much easier pill to swallow for your everyday application
    deployments. There’s not a lot to discuss in this recipe, but there are a few
    best practices with containerized databases that will definitely be useful to
    know about.
  prefs: []
  type: TYPE_NORMAL
- en: Do one thing and one thing only
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Just as a core principle of containers is to do one thing and one thing only,
    the same principle applies to containerized databases. What do I mean by that?
    Well, for starters, you might be inclined to launch a containerized database and
    subsequently create multiple schemas within that database and/or multiple databases
    within that single container. Let’s say you have several applications that require
    a MySQL database, then it probably seems like a good idea to have a single MySQL
    database container with separate database schemas for each containerized application…
    something that looks a bit like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.6 – What not to do with containerized databases](img/B18349_11_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.6 – What not to do with containerized databases
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem with this architecture is that it does not adhere well to the principle
    of doing one thing and one thing only. Instead, I recommend spinning up a separate
    container for each database an application needs. Name that container so that
    it is complementary to the application it’s paired with – something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.7 – A better way to use containerized databases](img/B18349_11_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.7 – A better way to use containerized databases
  prefs: []
  type: TYPE_NORMAL
- en: For example, let’s say you have a WordPress container that requires a database.
    In this scenario, if you named your WordPress container `wordpress01`, then you
    should name your MySQL container `wordpress01-db`. Having a separate container
    for every database you want to run will make it easier to troubleshoot issues
    and will additionally serve as a more reliable architectural model for your deployed
    applications. If you need to take one containerized database down, you’re then
    only affecting one application, rather than all of them if you chose to run multiple
    databases within one container.
  prefs: []
  type: TYPE_NORMAL
- en: Data storage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Persistent data is something you’ll need to address when running databases
    in containers. With Podman, you have two primary options: volumes and bind mounts.
    With volumes, Podman will manage the storage of your database by writing the data
    to disk using its own internal volume management system. With bind mounts, you
    will need to specify a location on the host system and mount that into the container.
    Either option is fine, and typically volumes are easier because it requires less
    configuration by the user, but the downside is that the data can be more difficult
    to locate on the host system. Additionally, it is possible for the volumes to
    be deleted by mistake via careless use of the `podman volume prune` command. With
    that being said, for demonstrations or quick tests, I like to use volumes, but
    for persistent data that is truly important, I prefer to use bind mounts.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating volumes is simple. There are a few ways in which Podman allows for
    the creation of volumes. You can create a volume manually from the command line
    via the `podman volume create [NAME]` command. You can also let Podman do the
    heavy lifting for you, as it is capable of creating volumes automatically during
    container creation. Podman can create a named volume if you specify the name;
    for example, running `podman run -v my_data:/var/lib/mysql mysql:8-oracle` will
    create a volume called `my_data`. Podman can also create an anonymous volume if
    you leave out the `-v my_data:/data` specification and instead run `podman run
    -``it oraclelinux:8`.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to use a bind mount instead, all you need to do is specify the location
    of where that mount should reside on the host system. For example, if you want
    to store your data in `/mnt/hdd/podman/volumes/`, you would simply need to specify
    this location as the source location. I prefer to set my volume location as an
    environment variable called `VOLUME_DIR` so that I can reference it with `${VOLUME_DIR}`.
    Then, when I specify creating a bind mount in the container, I simply use `podman
    run -v ${VOLUME_DIR}/wordpress:/var/lib/mysql mysql:8-oracle`. This will ensure
    that all my data is stored in a predictable location on my system, and each container
    gets its dedicated folder within that path.
  prefs: []
  type: TYPE_NORMAL
- en: Initialization scripts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Most containerized databases feature a way to facilitate the running of scripts
    after initial setup, which can be very handy. This is typically done by allowing
    the user to mount a directory from the host machine that contains `.sql` and/or
    `.sh` files into the `/docker-entrypoint-initdb.d` directory of the container.
    The scripts are generally executed in alphabetical order and thus can be easily
    controlled by adding a prefix with a number, for example, `01_users.sql`, `02_permissions.sql`,
    `03_hostname.sh`, and so forth:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The MySQL database:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The MySQL database supports `*.sh` and `*.sql` scripts in the following mount
    points:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*.sh and *.js scripts in the following mount points:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Controlling the startup order
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using a Compose file, you are able to control the startup order of your containers
    by using condition attributes. A nice way to ensure your database is up and running
    (and ready to accept connections) is to configure a health check against the database.
    Once the health check succeeds, the database container will become healthy. The
    application that requires the database can be configured not to start until the
    database container enters a healthy state. This can be done using the `depends_on`
    option.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wanted to add a health check to a PostgreSQL database, you could configure
    that with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, for the application, you would simply specify the service name (in this
    example, `wikijs-db`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: When these options are configured properly, you will no longer see repeated
    connection failures as the application tries to connect to a database that isn’t
    ready, because the application container won’t even start until the database container
    is healthy.
  prefs: []
  type: TYPE_NORMAL
- en: Tying it all together
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we’ve discussed these database best practices, it’s time to tie it
    all together with a Compose file to deploy a WordPress website. WordPress requires
    a MySQL database, so in the Compose file, we’re deploying two services: `wordpress01`
    (WordPress content management system) and `wordpress01-db` (MySQL database).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.8 – Visual topology of an application and its database](img/B18349_11_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.8 – Visual topology of an application and its database
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `wordpress01` service, we can easily reference the database host by
    the name label assigned to the service of the database – this is all thanks to
    the awesome name resolution capabilities supported by Podman `dns` plugins. You’ll
    also see that we are leveraging a health check on the `wordpress01-db` service
    so that it doesn’t become healthy until `mysqladmin` is able to get a response
    from pinging the database service, and `wordpress01` is configured with `depends_on`
    so that it will not try to start until `wordpress01-db` is in a healthy state.
    Since this example is intended to be a quick proof-of-concept deployment, I chose
    to use a named volume rather than a bind mount for the data, but you can also
    see the use of a bind mount for the initialization scripts. Last but not least,
    notice that we’re using a dedicated database container (`wordpress01-db`) that
    is complementary to the application container (`wordpress01`). The contents of
    the Compose file for this WordPress website might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.9 – Compose file for WordPress](img/B18349_11_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.9 – Compose file for WordPress
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and try to deploy this setup for yourself. You can view the logs of
    the application with `podman logs -f wordpress01` to see that it connects to the
    database successfully on the first attempt. Let’s use Docker Compose to create
    and start the containers. You can do that just as we described in the earlier
    recipe on Docker Compose, by navigating to the directory where your `docker-compose.yml`
    file lives and running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Buildah and Skopeo – Podman’s friends with benefits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The title of this chapter mentions *Podman and Friends*. Well, up until this
    point, you have probably noticed we didn’t talk much about Podman’s friends. Podman
    brings along a couple of companions to facilitate all your container management
    needs. These buddies of Podman are otherwise known as Buildah and Skopeo.
  prefs: []
  type: TYPE_NORMAL
- en: Where Podman is primarily focused on running containers, Buildah focuses on
    building them, and Skopeo focuses on handling images and transferring them to/from
    remote container registries.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will require the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Oracle Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Podman
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Buildah
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Skopeo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we’ll explore the basic usage of Buildah and Skopeo to reveal
    how these two friends of Podman can enhance your experience and workflow when
    dealing with containers.
  prefs: []
  type: TYPE_NORMAL
- en: Building container images with Buildah
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While Podman can be used for basic container image builds, Buildah is a utility
    that is fully focused on building OCI-compliant images. Not only can Buildah be
    used to build images from a Containerfile or Dockerfile, but it can also very
    neatly change existing container images.
  prefs: []
  type: TYPE_NORMAL
- en: 'First things first, let’s see how Buildah can be used to build images from
    a Containerfile. With Podman, we build images using the `podman build -t <image_name>.`
    command. When we call on Podman to perform a build, it is actually using a subset
    of Buildah’s functionality to build the image. To use Buildah directly, we only
    need to use a slightly different command. For example, let’s say we have a file
    named `Containerfile` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to build it with Buildah. You’ll enter `buildah bud -t <image_name>`.
    In this example, I’m going to name the image `ol-repo-sync`. Let’s do this now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The results in this scenario are the same as if you were to do this with Podman.
    Where Buildah really shines, is its ability to make changes to working containers,
    and it can also create new images from working containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to keep things simple for this recipe, we’re going to replicate what
    was specified in `Containerfile`, except instead of using `Containerfile` directly,
    we’re going to do things ad hoc with Buildah. So let’s make some changes to a
    pre-existing Oracle Linux 8 image and store it as a new image. First, we’re going
    to run `buildah from` to load up a working container in Buildah:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s going to return the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This tells us the name of the newly created working container. Now that we
    have a Buildah container ready to work with, let’s add some packages to it. In
    this example, we’re going to add the same packages that `Containerfile` specified
    earlier. Enter the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: You will see the DNF package manager do its thing, and afterward, you will be
    left with an Oracle Linux base image plus the new packages we installed as a result
    of the `buildah` `run` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to define the `entrypoint` into this container. We can do
    this by leveraging the `buildah` `config` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, there appears to be a bug in Buildah that populates
    the `cmd` value unless we explicitly give it an empty value first. This can lead
    to unexpected behavior of the resulting image. According to the documentation
    for Buildah, setting `entrypoint` without defining a value for `cmd` should clear
    out any assigned value for `cmd`, but that was not the case in my testing of Buildah
    version `1.29.1`. To circumvent this, I found it best to explicitly set `cmd`
    to an empty value before defining the entry point for the image.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to create a new image from this working container, all we need to
    do is run the `buildah commit` command. In this example, we’re going to name it
    `ol-repo-sync-buildah` so we can compare it with the image built from the aforementioned
    `Containerfile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we’ve created the image using Buildah, we can run `podman inspect`
    against both `ol-repo-sync` and `ol-repo-sync-buildah` and we’ll see that the
    two are more or less identical. Also, take note of the size of the two images.
    We can check that by using the `buildah` `images` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.10 – Listing of Buildah images](img/B18349_11_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.10 – Listing of Buildah images
  prefs: []
  type: TYPE_NORMAL
- en: This time around, we can see that the size is a bit smaller because we leveraged
    the DNF package manager from the host system to install packages in the container
    via the `buildah mount` command. This is obviously not a huge difference in size,
    but it begins to show the benefits that Buildah brings to the table with containers.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, Buildah grants us fine-tuned control of our container images
    and it can be a very powerful ally because it allows us to temporarily mount files
    and packages from the host system in the container to perform actions without
    ever actually installing said files and packages in the container. Ultimately,
    you’re able to achieve a leaner container image. Furthermore, Buildah provides
    the ability to script out your container image builds as it’s all done from the
    command line. This can prove to be very powerful when combined with things such
    as automation and/or CI/CD pipelines. It may take some time to get the hang of
    building your container images with Buildah, but the results can be rewarding
    if you stick with it.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting remote images using Skopeo
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do you remember when we talked about the need to pull an image before you can
    inspect it? This was covered in the *Creating handy-dandy utility containers*
    recipe. Well, what if I told you that we can leverage Skopeo to inspect images
    that are in remote repositories without needing to first pull them to our local
    machine? That is exactly what we’re going to do here.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the *Creating handy-dandy utility containers* recipe, you were instructed
    to run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s because if you tried to run `podman image inspect` without first pulling
    the container to your local machine, you would see the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Error: inspecting object: pandoc/core: image not known`Skopeo allows us to
    work directly with container images living in remote repositories. To illustrate
    how this works, let’s first get rid of our local `pandoc/core` container image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the image is removed from our local machine, let’s use Skopeo to inspect
    the image directly from its remote repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Pretty nifty, right? I did notice there were some minor changes to the JSON
    paths that affected how I needed to structure my `jq` command to properly extract
    the entry point I was looking for, but all in all, leveraging Skopeo to inspect
    remote images yields the same information that you would get if you first pulled
    it in with Podman. I can definitely see advantages to using Skopeo, especially
    when working with larger images and/or when needing to inspect images in an automated
    CICD pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Handling remote images with Skopeo
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Skopeo can also be used to transfer container images from one remote container
    repository to another, without needing to pull/download it locally first. The
    syntax is similar to the standard Linux `cp` command. In `cp`, we use `cp <source>
    <destination>`, and with Skopeo we use `skopeo copy <source> <destination>`. As
    an example, if we want to copy the `pandoc/core` image from one registry to another,
    all we need to do is run this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, we can also transfer it to our local Podman container storage through
    the use of the `containers-storage` prefix, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, if we wanted to specify some other location, we could simply
    use the `dir` prefix followed by the path. But in this case, be sure the path
    exists prior and omit any characters that are incompatible with the Linux filesystem,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, Skopeo can also be used to delete images from remote repositories or
    from local container storage. To do this, simply run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
