- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with PowerShell 7 and Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Welcome to the final section of the book, where over the next four chapters
    we’ll look at using PowerShell 7 in different environments. In this chapter, we’ll
    be looking at the peculiarities of Windows-based systems, and the various workarounds
    that exist to allow us to use PowerShell 7 effectively. We’ll also look at when
    we absolutely need to use native Windows PowerShell instead. It’s important to
    remember that PowerShell 7 is an open source product and is subject to fast-paced
    change. The examples in this and subsequent chapters are true at the time of writing,
    but may not be true at the time of reading. Also; there are bugs. The PowerShell
    GitHub pages are a powerful source of information regarding recent changes, and
    also things that don’t work the way they should: [https://github.com/PowerShell/PowerShell](https://github.com/PowerShell/PowerShell).'
  prefs: []
  type: TYPE_NORMAL
- en: As we covered in [*Chapter 1*](B17600_01.xhtml#_idTextAnchor013), *Introduction
    to PowerShell 7 – What It Is and How to Get It*, PowerShell 7.2 and later are
    built on the .NET 6 platform, the latest version of .NET Core. However, Windows
    PowerShell and many Windows applications are built using the .NET 4.5 framework,
    which is not open source, and contains much proprietary code. This has led to
    some incompatibilities, where things that work in Windows PowerShell won’t work
    in PowerShell 7\. We’ll be covering them in this chapter, and then look at how
    we can use the **Common Information Model** (**CIM**) and **Windows Management
    Instrumentation (WMI)** to work with our Windows machines.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main topics we will cover in this chapter are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding PowerShell 7 and Windows PowerShell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring compatibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What doesn’t work with PowerShell 7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing machines with CIM and WMI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding PowerShell 7 and Windows PowerShell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The key to understanding how we can use PowerShell 7 on Windows is to understand
    that PowerShell 7 is built on a fundamentally different platform; PowerShell 7
    is built on an open source, stripped-down version of .NET, whereas Windows PowerShell
    is built on the full proprietary .NET Framework. This means that Windows PowerShell
    has a greater degree of native compatibility with the Windows operating system
    and many of the applications that run on it and can make use of elements of .NET
    Framework that are not accessible to PowerShell 7\. Microsoft uses the terminology
    **Desktop edition** for PowerShell running on .NET Framework, and **Core edition**
    for PowerShell running on open source .NET.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 11*](B17600_11.xhtml#_idTextAnchor218), *Creating Our First Module*,
    we learned that most PowerShell functionality comes from using extensible libraries
    called modules, and looked at how modules are put together. To run a command in
    a module, PowerShell must first load that module. Microsoft has done a pretty
    good job of rewriting the core PowerShell modules and the more heavily used ones,
    such as the Active Directory module, but not all modules are compatible with PowerShell
    7; sometimes the authors haven’t got around to it yet, but sometimes the incompatibility
    is because key functionality in the module relies on features of .NET Framework
    that just aren’t in the open source .NET Core. If we attempt to load these incompatible
    modules, they will generally either cause an error or just not work. In the next
    section, we’ll see how we can get around this. Sometimes, however, we will find
    that things just don’t work, and we need to use Windows PowerShell. We’ll examine
    some of those cases in the third section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring compatibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s all very well saying that some modules aren’t compatible with PowerShell
    7, but how do we know which ones are OK to use, and what happens when they aren’t?
    The good news is that most of this process is automated and transparent to the
    casual user; we need to know about it however so we can understand why bad things
    happen sometimes. To understand compatibility, we’ll need to remember what we
    learned about modules and module manifests from [*Chapter 11*](B17600_11.xhtml#_idTextAnchor218),
    *Creating Our First Module*, and the section on PowerShell remoting that we did
    in the last chapter, [*Chapter 12*](B17600_12.xhtml#_idTextAnchor236), *Securing
    PowerShell*.
  prefs: []
  type: TYPE_NORMAL
- en: Which modules are compatible with PowerShell 7?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s have a look at some modules to see how we can tell whether they are compatible
    with PowerShell 7\. Run this cmdlet in Windows PowerShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We should see something like the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1 – Uncovering compatible editions](img/B17600_13_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.1 – Uncovering compatible editions
  prefs: []
  type: TYPE_NORMAL
- en: We can see that we have seven modules loaded. Four of them have compatibility
    information; `Microsoft.PowerShell.Management` says it is compatible with Desktop
    and Core editions. `Microsoft.Powershell.Utility`, `Microsoft.PowerShell.Security`,
    and `Microsoft.WSMan.Management` are only compatible with the Desktop edition.
    We could have run the command in PowerShell 7, but of course then it would generally
    only show modules that were compatible with the Core edition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Three of the modules have no compatibility information available; this may
    mean that they were written before PowerShell Core was released, and are therefore
    only compatible with the Desktop edition, or it may be that they are the wrong
    type of module to have compatibility information. Recall that there are four types
    of modules; script modules, manifest modules, binary modules, and dynamic modules.
    Manifest modules contain a manifest file with a `.Psd1` extension. We can check
    what the type of the module is by running `Get-Module <modulename>`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2 – Checking the module type](img/B17600_13_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.2 – Checking the module type
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we can see that `PSReadline` is a script module, and so doesn’t
    have an associated manifest file that could contain compatibility information.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what can we do when we need some functionality, but the module isn’t listed
    as compatible with PowerShell 7? We have three choices:'
  prefs: []
  type: TYPE_NORMAL
- en: Find a compatible version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Load it anyway
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Compatibility mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s take a look at these methods.
  prefs: []
  type: TYPE_NORMAL
- en: Finding a compatible version
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Microsoft.PowerShell.Utility` module shown previously in *Figure 13**.1*
    is really useful; for a start, it provides the `ConvertTo-*` cmdlets. We know
    that these work in PowerShell 7, because we’ve been using them throughout the
    book. Look at the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.3 – Microsoft.PowerShell.Utility in PowerShell 7](img/B17600_13_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.3 – Microsoft.PowerShell.Utility in PowerShell 7
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, the `Microsoft.PowerShell.Utility` module is loaded in our PowerShell
    7 session. How is that? Check the version numbers shown in the different screenshots.
    PowerShell 7 loads `Microsoft.PowerShell.Utility 7.0.0.0`, whereas Windows PowerShell
    loads `Microsoft.PowerShell.Utility 3.1.0.0`. Different versions of core PowerShell
    modules have been supplied with PowerShell 7, and are installed in `C:\program
    files\powershell\7\Modules`. Some third-party modules will have specific versions
    that are compatible with PowerShell 7, even if the one we currently have is not,
    and it’s worth checking on the repository if this is the case. For instance, in
    the PowerShell gallery, we can include the search term `Tags:"core"` to find modules
    that are compatible with PowerShell 7, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.4 – Searching the PowerShell gallery for a module that is compatible](img/B17600_13_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.4 – Searching the PowerShell gallery for a module that is compatible
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, I’ve included two search terms; the first is the string `databases`
    and the second is `Tags:"core"`. This has found me a module for manipulating databases
    that will run on PowerShell 7\. Let’s see what we can do if there is no compatible
    version.
  prefs: []
  type: TYPE_NORMAL
- en: Loading it anyway
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we don’t find a version of the module compatible with PowerShell 7, we can
    attempt to load it anyway. This might work, although quite often the module will
    load but then not work as expected when we come to use it. I include this method
    as a last resort and a sort of warning; there are articles on the internet that
    recommend doing this. Personally, I wouldn’t.
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, how do you load a module that doesn’t have a compatible version?
    We can use the `-SkipEditionCheck` parameter of `Import-Module` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.5 – Forcing a module to load](img/B17600_13_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.5 – Forcing a module to load
  prefs: []
  type: TYPE_NORMAL
- en: In this example, I’ve used the `-SkipEditionCheck` parameter to try to force
    PowerShell 7 to load the `RemoteDesktop` module in a PowerShell 7 session with
    admin privileges. As we can see, this hasn’t worked very well. The problem is
    that with some modules it does work, while with others it doesn’t, but it doesn’t
    produce an error like `RemoteDesktop` does. So, what is the right way to do this?
    We use Compatibility mode.
  prefs: []
  type: TYPE_NORMAL
- en: Using Compatibility mode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using Compatibility mode in recent versions of PowerShell 7 is easy. Just import
    the module you want to load, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the following figure, something magical happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.6 – Using Compatibility mode](img/B17600_13_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.6 – Using Compatibility mode
  prefs: []
  type: TYPE_NORMAL
- en: In the first command, all I’ve done is use `Import-Module` with no parameters.
    PowerShell checks for a compatible module, and when it doesn’t find one it creates
    a remote session to run Windows PowerShell in the background. The module is loaded
    into this remote session, which is running on the local machine. It warns us that
    this is what it has done. In the second command, I check what remote sessions
    are running, and we can see that there is a session called `WinPSCompatSession`
    created. We saw remote sessions in [*Chapter 12*](B17600_12.xhtml#_idTextAnchor236),
    *Securing PowerShell*. In that chapter, though, we explicitly created the sessions.
    The `WinPSCompatSession` is an example of implicit remoting.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two important things to remember about Compatibility mode. The first
    important thing is that `WinPSCompatSession` is running Windows PowerShell, not
    PowerShell 7\. Look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.7 – Demonstrating the PowerShell version running in WinPSCompatSession](img/B17600_13_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.7 – Demonstrating the PowerShell version running in WinPSCompatSession
  prefs: []
  type: TYPE_NORMAL
- en: In the first command, I’m putting `WinPSCompatSession` into a variable called
    `$session` so I can easily use it. On the second line, I pass the `$session` variable
    to `Invoke-Command` and call the `PSVersion` property of the `$PSVersionTable`
    automatic variable from within that session. We can see from the result that the
    session is running PowerShell version 5.1 – Windows PowerShell. In the third command,
    I get the same information for the local terminal session, where I’m running PowerShell
    7.3.8.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second important thing is that this is a remote session, and therefore
    behaves differently to directly running commands. The most important difference
    is that the output has been deserialized, which we can see in the warning in *Figure
    13**.6*. Recall that the output of a command is a PowerShell object. To pass a
    PowerShell object from a remote computer to the local computer, the object is
    converted to CliXML (the specialized form of XML that PowerShell uses to serialize
    objects) on the remote end of the session, and then converted back to a PowerShell
    object at the local end. This has implications for what we can do with the object,
    as it now has different methods and properties. Let’s see what this looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.8 – Deserialized objects](img/B17600_13_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.8 – Deserialized objects
  prefs: []
  type: TYPE_NORMAL
- en: 'In the top pane I am using Windows PowerShell to run the `Get-WmiObject win32_bios
    | gm` command to get the `TypeName` and members of the object that the `Get-WmiObject`
    command generates: `System.Management.ManagementObject`. Note it has no methods,
    and `PSComputerName` is an `AliasProperty`, so if we call `PSComputerName`, we
    actually get the value of the `__SERVER` property.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the lower pane, I am using PowerShell 7 to run `Get-WmiObject` inside the
    `WinPSCompatSession` session using `Invoke-Command`, and then getting the members
    of the returned object. As we can see, this is now a `Deserialized.System.Management.ManagementObject`,
    and the methods and properties are subtly changed. For example, `PSComputerName`
    is now a `NoteProperty` that contains a string: `PSComputerName=localhost`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, this is fairly easy to remember when we are explicitly using `Invoke-Command`.
    We know that what we get back is running in a remote session and will be a deserialized
    object. However, because this can happen transparently in the background, it is
    easy to accidentally load a module in Compatibility mode, and then be surprised
    that the objects we are working with aren’t behaving quite the way we expect them
    to. Some administrators like to prevent implicit imports in PowerShell compatibility
    by editing the `powershell.config.json` file to include the JSON line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This doesn’t disable Compatibility mode altogether, however, it just makes
    us more mindful of when we are using it. We can still explicitly use Compatibility
    mode by adding the `-UseWindowsPowerShell` parameter of the `Import-Module` cmdlet,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.9 – Explicitly using PowerShell Compatibility](img/B17600_13_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.9 – Explicitly using PowerShell Compatibility
  prefs: []
  type: TYPE_NORMAL
- en: In the command on the first line, I import the `ScheduledTasks` module as normal,
    with no parameters. In the second line, I test for the presence of the compatibility
    session – as we can see, no remote session has been opened. In the third line,
    I remove the module, and in the fourth line I reload it, this time adding the
    `-UseWindowsPowershell` parameter. In the fifth line, I again test for the compatibility
    session, and there it is.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also prevent specific modules from loading in Compatibility mode altogether
    by editing the deny list in the `powershell.config.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try and load a module on that list, then we will see an error similar
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.10 – No, you can’t load the PSScheduledJob module](img/B17600_13_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.10 – No, you can’t load the PSScheduledJob module
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s important to understand the limitations of Compatibility mode. There are
    four main ones:'
  prefs: []
  type: TYPE_NORMAL
- en: It only works on local computers – you can’t call Compatibility mode while already
    in a remote session on another machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It requires Windows PowerShell 5.1 to be installed on the local machine – older
    machines might still have only Windows PowerShell 3.0 or 4.0 installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It returns deserialized objects based on values – not live objects that can
    be manipulated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There can be only one compatibility session running on a machine at any one
    time, so all modules that use Compatibility will share a runspace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s also important to remember that this area of PowerShell 7 is one that lots
    of people are actively working on, and each new version of PowerShell is better
    than the last, and each new version of Windows is more compatible with PowerShell
    7\. Lots of the instructions and tutorials on the internet date very quickly,
    and so will this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: What doesn’t work with PowerShell 7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: However, there are some things on Windows that just don’t work with PowerShell
    7 and aren’t likely to either. In this section we’ll cover a few of them, which
    will set us up nicely for the final section of the chapter, *Managing machines
    with CIM* *and WMI*.
  prefs: []
  type: TYPE_NORMAL
- en: The `-ComputerName` parameter had been ported from Windows PowerShell to PowerShell
    7; unfortunately, some of the protocols and models that this parameter uses in
    Windows are not compatible with PowerShell 7, and so the parameter didn’t work.
    In the most recent releases of PowerShell 7, such as 7.3, the parameter has finally
    been removed from the non-working cmdlets. For people moving from Windows PowerShell
    to PowerShell 7, however, it can still cause confusion. The workaround is to use
    `Invoke-Command` instead.
  prefs: []
  type: TYPE_NORMAL
- en: Some important administration modules like `UpdateServices` for managing **Windows
    Server Update Services** (**WSUS**) won’t work in Compatibility mode as they rely
    on manipulating the objects that are returned through their methods, which don’t
    survive the deserialization process.
  prefs: []
  type: TYPE_NORMAL
- en: '**Windows Management Instrumentation** (**WMI**) commands aren’t included in
    PowerShell 7, as Microsoft has been trying to deprecate them since PowerShell
    3.0, preferring people to use the more lightweight CIM commands. They remain popular,
    however, and many people still use WMI over CIM. We’ll be discussing these CIM
    commands and how to use them in the next section, as it is an important topic.'
  prefs: []
  type: TYPE_NORMAL
- en: Managing machines with CIM and WMI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CIM and WMI are related technologies for managing local and remote machines.
    In this section, we will look at the basics of each and discuss their similarities
    and differences.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to CIM and WMI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CIM and WMI are based on the **Web-Based Enterprise Management** (**WBEM**)
    standard introduced by the **Distributed Management Task Force** (**DMTF**) in
    1996\. WMI is Microsoft’s implementation of a set of tools based on WBEM, released
    in 1998, and CIM is an open standard from the DMTF that defines how the entities
    in an environment are represented and related. It was released in 1999\. In a
    Windows environment, CIM uses elements of WMI but uses a different set of protocols
    to access them; WMI uses the **Distributed Common Object Model** (**DCOM**) protocol,
    which is proprietary, and CIM uses the **Web Services for Management** (**WS-MAN**)
    protocol over HTTP, which we saw in [*Chapter 12*](B17600_12.xhtml#_idTextAnchor236),
    *Securing PowerShell*.
  prefs: []
  type: TYPE_NORMAL
- en: Both technologies link to a common repository – the WMI repository, which we’ll
    look at shortly. This repository holds information about the type of objects we
    might want to manage, such as printers, clients, network adapters, and so on,
    and instances of those objects.
  prefs: []
  type: TYPE_NORMAL
- en: The PowerShell CIM commands allow us to connect to local and remote machines
    via WS-MAN to the **Windows Remote Management** (**WinRM**) endpoint that we use
    for remote sessions. We can do this either as an ad hoc connection or via a CIM
    session, similar to remoting.
  prefs: []
  type: TYPE_NORMAL
- en: WMI only supports ad hoc connections over DCOM. This means WinRM doesn’t need
    to be enabled on the remote machine.
  prefs: []
  type: TYPE_NORMAL
- en: Why CIM is better than WMI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: CIM is slightly newer, but crucially uses an open connection protocol – WS-MAN.
    This requires a pair of static network ports to be available on machines and any
    devices in the network. DCOM uses the **Remote Procedure Call** (**RPC**) protocol,
    which relies heavily on ephemeral TCP/IP ports; it’s much easier to run WS-MAN
    over a network than it is to run DCOM because of this difference. There are lots
    of other reasons why WS-MAN is better than DCOM, but the biggest stumbling block
    in my experience is DCOM’s requirement for ephemeral ports.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft has been trying since PowerShell 3.0 in 2012 to deprecate the WMI
    cmdlets and persuade people to use the CIM cmdlets instead, as CIM uses a lighter
    protocol with less of a network footprint; RPC has many disadvantages, and I’ve
    spent a good chunk of my career identifying and fixing problems that have resulted
    from RPC. However, plenty of people still use the WMI cmdlets, and there are lots
    of popular scripts available on the internet that use them.
  prefs: []
  type: TYPE_NORMAL
- en: The WMI cmdlets are not available within PowerShell 7, but we will see many
    workarounds on the internet involving `Invoke-Command` that enable us to use them
    via Compatibility mode.
  prefs: []
  type: TYPE_NORMAL
- en: Commands that use CIM and WMI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The WMI repository is huge and confusing, as we shall see. Therefore, it’s
    better, where possible, to use a dedicated cmdlet rather than a CIM or WMI cmdlet.
    What does that look like? For instance, we might use `Get-CimInstance Win32_Printer`
    to query the printers on a machine, but it’s quicker and more intuitive to use
    the `Get-Printer` cmdlet, demonstrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.11 – Looking for printers](img/B17600_13_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.11 – Looking for printers
  prefs: []
  type: TYPE_NORMAL
- en: Both commands are looking for the HP printer on my local machine. They both
    use CIM to query the WMI repository. Arguably, the second command is easier to
    run and remember, and is generally faster too. `Get-Printer` supports the `-ComputerName`
    parameter for remote machines and even supports using CIM sessions. Before digging
    around for hours to work out how to do something using a CIM cmdlet, check there
    isn’t already a handy pre-written cmdlet that does what we want. Of course, `Get-Printer`
    is a Windows PowerShell cmdlet, and therefore we need to be running on a Windows
    client and use Compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: Repository
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The WMI repository is a hierarchical database – a tree structure. At the top
    level are namespaces – essentially containers. Namespaces contain classes. A class
    represents a type of object, such as a printer, and contains instances of that
    type of object. Each instance of a class has the same set of properties and methods
    as other instances of a class – although they may not all be populated or enabled.
    There is a class called `__NAMESPACE`, with two underscores (`_`), that contains
    namespaces, so a namespace may contain other namespaces as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The root namespace is called, unimaginatively, `root`. We can see the contents
    of this with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can see the instances of the `__NAMESPACE` class with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The contents of the namespaces and classes may vary on each machine, as hardware
    and software will create their own namespaces and classes when installed. The
    important namespace for most people though is `root/CIMV2`, shown in the following
    figure.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.12 – Finding the CIMV2 namespace](img/B17600_13_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.12 – Finding the CIMV2 namespace
  prefs: []
  type: TYPE_NORMAL
- en: In the first command, I’m listing out the first 10 returned classes in the `root`
    namespace. There are 75 classes in the root namespace on my client so I’m only
    listing the first 10 – this number will likely differ on yours. In the second
    command, I’m listing the instances of the `__NAMESPACE` class on my machine –
    again, there is quite a large number, and yours may be different. The `CIMV2`
    namespace is highlighted.
  prefs: []
  type: TYPE_NORMAL
- en: The `CIMV2` namespace contains the Microsoft Windows classes. We can use `Get-CimClass`
    to list them out, but there are over 1,200 classes in this namespace on my machine;
    most of them called either `MSFT_*` or `Win32_*`. With so many classes, we can
    see that finding things in the repository can be a challenge. Microsoft has done
    a reasonable job of documenting the contents of the `root/CIMV2` namespace online,
    but the contents of other namespaces are typically not well documented, and finding
    out what things do and how to use them can be a bit of an exercise.
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 13**.11*, we used the `Get-CimInstance Win32_Printer` command, without
    specifying a namespace – this is because PowerShell has the `CIMV2` namespace
    set as the default, so that we don’t have to add the `-Namespace 'root/CIMV2'`
    parameter to every command.
  prefs: []
  type: TYPE_NORMAL
- en: Querying data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We use CIM and WMI for two main tasks – finding out information and changing
    things, frequently on large numbers of machines at once. Let’s start by looking
    at how we can find things out. We’ve already seen two CIM cmdlets that we can
    use; `Get-CimClass` and `Get-CimInstance`.
  prefs: []
  type: TYPE_NORMAL
- en: Get-CimClass
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This cmdlet gets a list of the CIM classes in a specified namespace, or in
    the default namespace if no namespace is given. There are a few parameters for
    this cmdlet:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-ClassName`: This allows us to either specify a class, or provide a partial
    class name when we’re looking for a specific class; e.g., `Get-CimClass -ClassName
    *disk*` will get all the classes in `CIMV2` with the word `disk` in the name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Namespace`: This allows us to specify a namespace other than `root/CIMV2`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-ComputerName`: This parameter allows us to specify a machine other than the
    local machine. We can use an FQDN, a NetBIOS name, or an IP address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-MethodName`: This parameter allows us to search for classes that have a particular
    method. For example, `Get-CimClass -MethodName ''term*''` will return the `Win32_Process`
    class, which has a `Terminate` method. No prizes for guessing what that method
    does.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-PropertyName`: Similar to the `-MethodName` parameter, this allows us to
    search for classes with a particular property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-QualifierName`: Qualifiers are like tags that are applied to classes. There
    is no standard list (a bit like tags), but they can sometimes be quite useful.
    For instance, we can use `Get-CimClass -QualifierName ''deprecated''` to retrieve
    a list of classes that are being phased out, and probably shouldn’t be used in
    a script.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Amended`: This parameter gets amended information – usually information that
    changes depending on the locale of the machine. Localizable information is often
    presented numerically and requires a lookup to be translated into the local language
    – this parameter will do that.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-OperationTimeoutSec`: If we are running the command against a remote computer,
    it’s possible that the machine is unresponsive or not even switched on. This allows
    us to specify a timeout other than the default network timeout set for the local
    machine, which is by default 3 minutes. If we were querying 1,000 machines, and
    10% of them are switched off or not connected to the network, this allows us to
    complete the command in less than 5 hours.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-CimSession`: This allows us to run the command in a pre-existing CIM session.
    More on CIM sessions shortly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s take a look at `Get-CimInstance` next.
  prefs: []
  type: TYPE_NORMAL
- en: Get-CimInstance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This cmdlet gets the instances of a given CIM class – again, the default namespace
    is root/CIMV2\. It has many of the same parameters as `Get-CimClass`, with a few
    differences. Let’s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-CimSession`: Same as for `Get-CimClass`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-ClassName`: Same as for `Get-CimClass`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-ComputerName`: Same as for `Get-CimClass`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Filter`: Allows us to specify a filter string to only get certain instances.
    For instance, `Get-CimInstance -Classname Win32_Printer -Filter "Name like ''HP%''"`
    will find the HP printer on my machine. Note that we must use **Windows Query
    Language** (**WQL**) or **Cassandra Query** **Language** (**CQL**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-KeyOnly`: Returns only the key properties of an instance, rather than all
    the properties.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Namespace`: Same as for `Get-CimClass`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '-`OperationTimeoutSec`: Same as for `Get-CimClass`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Property`: Unlike `Get-CimClass`, this doesn’t search for instances with
    a given property; remember, all instances of a class have the same properties
    and methods. Notice it is `-Property`, not `-PropertyName`. We can use this parameter
    to retrieve a list of specified properties, rather than all the properties of
    an instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Query`: Allows us to specify a query string written in WQL or CQL. For example,
    `Get-CimInstance -Query "SELECT * from Win32_Printer WHERE name LIKE ''HP%''"`
    will find my HP printer, again.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-QueryDialect`: Specifies the dialect the query is written in. The default
    is WQL, so we would generally only use this parameter if we were supplying a query
    written in CQL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Shallow`: By default, `Get-CimInstance` returns all instances of a class,
    and instances of any child classes. This parameter prevents any results from child
    classes being returned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can see that both these cmdlets have a `-ComputerName` parameter for working
    with remote machines. Each time we use this parameter, we create and then remove
    an ad hoc CIM session. If we have a bunch of commands to run against a remote
    machine then we can create a persistent CIM session in the same way as we can
    create a persistent PowerShell remoting session. Let’s see how we can do this.
  prefs: []
  type: TYPE_NORMAL
- en: CIM sessions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are four cmdlets for manipulating CIM sessions – `New-CimSession`, `Get-CimSession`,
    `Remove-CimSession`, and `New-CimSessionOption`. They behave in a very similar
    way to the PowerShell remoting cmdlets, and `Get-CimSession` and `Remove-CimSession`
    do exactly what you would expect. Note that CIM sessions work best in an Active
    Directory domain environment that uses Kerberos, which is the default authentication
    scheme. If this isn’t available, then the remote machines will need to be added
    to the TrustedHosts exception list in WinRM. Let’s take a quick look at how `New-CimSession`
    works.
  prefs: []
  type: TYPE_NORMAL
- en: 'The cmdlet has the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-Authentication`: Which authentication scheme we want to use. This will depend
    on the environment we are working in. Kerberos is the best option for a domain
    environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-CertificateThumbprint`: If we are working in a certificate-based authentication
    scheme, then we will need to provide the details of our certificate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-ComputerName`: The name of the remote computer we want to work on. If not
    given, then a CIM session to the local machine over DCOM is created. WSMan is
    used for remote computers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Credential`: Again, depending on the authentication scheme we are working
    with, we might need to give a credential object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Name`: We can assign a friendly name to the session to make it easier to
    work with.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-OperationTimeoutSec`: This is the same as for `Get-CimClass`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Port`: We can specify a particular TCP port if our network is restricted,
    but this isn’t recommended.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-SessionOption`: This allows us to set advanced options for the session by
    creating a `SessionOption` object with `New-CimSessionOption`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-SkipTestConnection`: This stops the cmdlet testing the session connectivity
    before creating it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are a number of advanced options covering the use of proxy servers and
    controlling how we work with different authentication schemes. These can all be
    set with the `New-CimSessionOption` cmdlet, but we’re not going to go into them
    here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this all works in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.13 – Working with CIM sessions](img/B17600_13_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.13 – Working with CIM sessions
  prefs: []
  type: TYPE_NORMAL
- en: In the first command, I create a new CIM session on the local machine and give
    it a friendly name, `localsession`. In the second command, I get the details of
    my session using the friendly name; notice this is using WSMan, not DCOM, even
    though it’s the local machine. That’s because I specified the local machine with
    the `-ComputerName` parameter, so the cmdlet automatically uses a WSMan session.
    Neat, huh? In the final command, I remove the session.
  prefs: []
  type: TYPE_NORMAL
- en: So, that’s the cmdlets we can use to get information about classes and instances.
    In the next section, we’ll look at how we can manipulate the properties of instances
    and use their methods.
  prefs: []
  type: TYPE_NORMAL
- en: Making changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can use the CIM cmdlets to manipulate the objects in the WMI repository as
    well; we can change their properties (sometimes) or use their methods. Let’s start
    with changing properties.
  prefs: []
  type: TYPE_NORMAL
- en: Changing properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we will see all the methods and properties of an HP printer installed
    on our local client. If we don’t have an HP printer installed, then we’ll get
    an error, but we can change the search string to match the sort of printer we
    might have; for instance `''can*''` will find Canon printers. Note that the properties
    are followed by a string that looks like `{get;set;}`. If it only reads `{get;}`
    then it is not writable. Let’s see how changing a writable property looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.14 – Changing the properties with Set-CimInstance](img/B17600_13_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.14 – Changing the properties with Set-CimInstance
  prefs: []
  type: TYPE_NORMAL
- en: In the first command, I’m creating a variable called `$printer` and putting
    my HP printer in it. In the second command, I’m calling the variable, just to
    check the right thing is in there. It is.
  prefs: []
  type: TYPE_NORMAL
- en: In the third command, I’m checking the current value of the `Comment` property
    of the `$printer` variable – we can see it’s empty. In the fourth command, I’m
    changing the property of the variable to `I` `Love PowerShell`.
  prefs: []
  type: TYPE_NORMAL
- en: The fifth command is the important bit – I’m taking the contents of the variable,
    and now I’m writing them back to the instance in the WMI repository with the `Set-CimInstance`
    cmdlet. The variable contains a WMI object so I’m using the `-InputObject` parameter
    of the cmdlet. Has it worked? Let’s take a look.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.15 – My printer has an opinion](img/B17600_13_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.15 – My printer has an opinion
  prefs: []
  type: TYPE_NORMAL
- en: Of course it worked. Phew. If we look at the list of properties on a printer
    object, we can see that the majority of them are not writable. For instance, there
    is a `Default` property, but it’s not writable, and we can’t set it with `Set-CimInstance`.
    In the next section, we’ll look at a cmdlet that could do it, `Invoke-CimMethod`.
  prefs: []
  type: TYPE_NORMAL
- en: Discovering methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We know that objects have properties and methods, and that includes the objects
    in the WMI repository. We’ve looked at the properties, seen how to get them, and
    how to set them. Now we’re going to look at the methods those objects may have.
    Here, we’re going to see just why working with the WMI repository is sometimes
    such a pain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first problem is knowing the name of the class we want, and we saw how
    to do that in the preceding section on querying data. Once we know the name of
    the class, we need to understand what methods are available. The `Get-CimClass`
    cmdlet doesn’t discover all the methods by default, unlike the `Get-WmiObject`
    cmdlet, so we have to use something like the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This will expose the full set of methods. Once we’ve got our method, of course,
    we need to know how to use it. Because WMI isn’t part of PowerShell, the PowerShell
    documentation won’t help us. Most of the time, we can find out what we need to
    know from the Microsoft website, here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://learn.microsoft.com/en-us/windows/win32/cimwin32prov/cimwin32-wmi-providers](https://learn.microsoft.com/en-us/windows/win32/cimwin32prov/cimwin32-wmi-providers)'
  prefs: []
  type: TYPE_NORMAL
- en: However, it takes a bit of searching, and quite often the examples are given
    in Visual Basic, not PowerShell. Let’s see how we might do it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next section, we’re going to see how to start and stop a process, so
    let’s use the `Win32_Process` documentation, here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://learn.microsoft.com/en-us/windows/win32/cimwin32prov/win32-process](https://learn.microsoft.com/en-us/windows/win32/cimwin32prov/win32-process)'
  prefs: []
  type: TYPE_NORMAL
- en: We can see if we scroll down that there is a *Methods* section. The most likely
    method there is `Create`. If we click on the link, we can see that the `Create`
    method has a `CommandLine` parameter. Let’s see how that might work.
  prefs: []
  type: TYPE_NORMAL
- en: Invoking methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we have our method, and a likely parameter for that method, let’s give
    it a try. First of all, we’ll need our `Invoke-CimMethod` cmdlet. This cmdlet
    has the following parameters, many of which work in ways we should now be familiar
    with:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-ClassName`: Same as for `Get-CimClass`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-CimClass`: We can use this parameter to specify a WMI class instead of the
    `-ClassName` parameter. We need to pass it a WMI class object, however, via a
    variable, instead of a string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-CimSession`: Same as for `Get-CimClass`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Namespace`: Same as for `Get-CimClass`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-ComputerName`: Same as for `Get-CimClass`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-MethodName`: This is a mandatory parameter that accepts a string; the name
    of the method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Arguments`: Here, we specify the parameters we are passing to the method,
    as an `iDictionary` hash table, like this: `-Arguments @{ ParameterName = ''``value''}`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-OperationTimeoutSeconds`: Same as for `Get-CimClass`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Query` and `-QueryDialect`: Same as for `Get-CimInstance`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s start the Notepad program; we may want to close any running instances
    of Notepad, especially if we’re working on Windows 11\. First, we’ll use the `Invoke-CimMethod`
    cmdlet. We’ll need the class name, `Win32_Process`, the method name, `Create()`,
    and the argument. We’ll use `CommandLine = ''notepad.exe''`, as `notepad.exe`
    is in the `PATH` environmental variable, so shouldn’t need a location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'And it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.16 – Invoking a method](img/B17600_13_016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.16 – Invoking a method
  prefs: []
  type: TYPE_NORMAL
- en: We can see the return value (`0`) indicates success, and we get the `ProcessId`
    of the new Notepad process we’ve created. Note that this command may create the
    process in the background; we don’t see the Notepad window suddenly appear, but
    we’ll see it on the taskbar.
  prefs: []
  type: TYPE_NORMAL
- en: Activities
  prefs: []
  type: TYPE_NORMAL
- en: How could we close the `notepad.exe` process we just started with PowerShell?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'How can we set a printer as the default with PowerShell? Hint: we can’t use
    the Windows PowerShell `Set-Printer` cmdlet.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That’s all we’re going to cover here. Just remember that properties and methods
    are not well documented, and that quite often there will be a PowerShell cmdlet
    specifically written for our purpose, either as part of PowerShell 7 or Windows
    PowerShell. Let’s summarize this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started the final section of the book in this chapter on using PowerShell
    in different environments. We’ve started with the Windows environment, arguably
    the environment in which PowerShell is most effective. However, we saw there are
    some important differences between PowerShell 7 and Windows PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: We saw that PowerShell 7 can’t necessarily use modules written for Windows PowerShell,
    and we looked at three ways of coping with that; finding an equivalent module
    for PowerShell 7, loading the module anyway, or using Compatibility mode.
  prefs: []
  type: TYPE_NORMAL
- en: While most of the time Compatibility mode is used transparently, we looked at
    how it works, and some cases where we might want to limit how it is used. However,
    it is incredibly useful, and we saw that it is getting better all the time.
  prefs: []
  type: TYPE_NORMAL
- en: We moved on to look at some stuff that just doesn’t work with PowerShell 7,
    and why. Generally, this is related to older modules that are no longer worth
    rewriting to be compatible with PowerShell 7.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then looked at one of the most useful ways to use PowerShell 7 on a Windows
    machine: using CIM to manipulate the WMI repository. We took some time to understand
    the WMI repository, then moved on to how we can get the properties of objects
    there to understand the environment on both our local machine and remote machines.'
  prefs: []
  type: TYPE_NORMAL
- en: The final section looked at how to manipulate the properties of objects in the
    WMI repository, and then looked at how we can call the methods on those objects
    to affect the wider computing environment.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it for this chapter. In the next chapter, we’re going to look at how
    we can use PowerShell 7 on Linux and macOS machines.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What type of modules have compatibility information?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why might a module have no compatibility information?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ve run `Get-PSSession`, and we can see that there is a remote session called
    `WinPSCompatSession` running on the localhost machine. What version of PowerShell
    is it running?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What sort of objects do we get back from commands run in the `WinPSCompatSession`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our local admin has disabled implicit Windows compatibility on our machine.
    How can we still import modules in Compatibility mode?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What CIM class contains instances of namespaces?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of the `-OperationTimeoutSecs` parameter on the `Get-CimInstance`
    cmdlet?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What cmdlet would we use to change the properties of a WMI object?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we pass method parameters to `Invoke-CimMethod` and what format do they
    need to be in?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*.**NET Framework*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/.NET_Framework](https://en.wikipedia.org/wiki/.NET_Framework)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Module compatibility*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://learn.microsoft.com/en-us/powershell/gallery/concepts/module-psedition-support](https://learn.microsoft.com/en-us/powershell/gallery/concepts/module-psedition-support)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*PowerShell editions*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_powershell_editions](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_powershell_editions)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Differences in* *PowerShell 7*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://learn.microsoft.com/en-us/powershell/scripting/whats-new/differences-from-windows-powershell](https://learn.microsoft.com/en-us/powershell/scripting/whats-new/differences-from-windows-powershell)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Web-Based* *Enterprise Management*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Web-Based_Enterprise_Management](https://en.wikipedia.org/wiki/Web-Based_Enterprise_Management)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Common* *Information Model*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Common_Information_Model_(computing)](https://en.wikipedia.org/wiki/Common_Information_Model_(computing))'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*WSMan*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/WS-Management](https://en.wikipedia.org/wiki/WS-Management)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Windows* *Management Instrumentation*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Windows_Management_Instrumentation](https://en.wikipedia.org/wiki/Windows_Management_Instrumentation)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Distributed Component* *Object Model*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Distributed_Component_Object_Model](https://en.wikipedia.org/wiki/Distributed_Component_Object_Model)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Migrating from Windows PowerShell 5.1 to* *PowerShell 7.x*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://learn.microsoft.com/en-us/powershell/scripting/whats-new/migrating-from-windows-powershell-51-to-powershell-7](https://learn.microsoft.com/en-us/powershell/scripting/whats-new/migrating-from-windows-powershell-51-to-powershell-7)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*About Windows* *PowerShell Compatibility*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_windows_powershell_compatibility](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_windows_powershell_compatibility)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*PowerShell 7* *module compatibility*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://learn.microsoft.com/en-us/powershell/scripting/whats-new/module-compatibility](https://learn.microsoft.com/en-us/powershell/scripting/whats-new/module-compatibility)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Modules with compatible* *PowerShell editions*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://learn.microsoft.com/en-us/powershell/gallery/concepts/module-psedition-support](https://learn.microsoft.com/en-us/powershell/gallery/concepts/module-psedition-support)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*About* *PowerShell editions*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_powershell_editions](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_powershell_editions)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Implicit remoting*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://devblogs.microsoft.com/scripting/remoting-the-implicit-way/](https://devblogs.microsoft.com/scripting/remoting-the-implicit-way/)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Getting WMI objects* *with Get-CimInstance*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://learn.microsoft.com/en-us/powershell/scripting/samples/getting-wmi-objects--get-ciminstance-?view=powershell-7.4](https://learn.microsoft.com/en-us/powershell/scripting/samples/getting-wmi-objects--get-ciminstance-?view=powershell-7.4)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Using PowerShell CIM cmdlets to explore* *WMI classes*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://devblogs.microsoft.com/scripting/using-powershell-cim-cmdlets-to-explore-wmi-classes/](https://devblogs.microsoft.com/scripting/using-powershell-cim-cmdlets-to-explore-wmi-classes/)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
