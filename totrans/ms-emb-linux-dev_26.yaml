- en: '21'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '21'
- en: Real-Time Programming
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实时编程
- en: 'Much of the interaction between a computer system and the real world happens
    in real time, and so this is an important topic for developers of embedded systems.
    I have touched on real-time programming in several places so far: in [*Chapter
    17*](Chapter_17.xhtml#_idTextAnchor542), we looked at scheduling policies and
    priority inversion, and in [*Chapter 18*](Chapter_18.xhtml#_idTextAnchor581),
    I described the problems with page faults and the need for memory locking. Now
    it is time to bring these topics together and look at real-time programming in
    some depth.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机系统与现实世界之间的大部分交互都发生在实时中，因此这是嵌入式系统开发者需要关注的重要主题。我已经在多个地方讨论了实时编程：在[*第17章*](Chapter_17.xhtml#_idTextAnchor542)中，我们研究了调度策略和优先级反转，在[*第18章*](Chapter_18.xhtml#_idTextAnchor581)中，我描述了页面错误的问题以及内存锁定的必要性。现在是时候将这些话题结合起来，深入探讨实时编程了。
- en: 'In this chapter, I will begin with a discussion about the characteristics of
    real-time systems, and then consider the implications for system design, at both
    the application and kernel levels. I will describe the real-time `PREEMPT_RT`
    kernel patch and show how to get it and apply it to a mainline kernel. The final
    sections will describe how to characterize system latencies using two tools: **cyclictest**
    and **Ftrace**.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将首先讨论实时系统的特性，然后考虑这些特性对系统设计的影响，涉及应用层和内核层。我将描述实时`PREEMPT_RT`内核补丁，并展示如何获取它并将其应用到主线内核中。最后的部分将描述如何使用两个工具**cyclictest**和**Ftrace**来表征系统延迟。
- en: There are other ways to achieve real-time behavior on an embedded Linux device,
    for instance, using a dedicated microcontroller or a separate real-time kernel
    alongside the Linux kernel in the way that Xenomai and RTAI do. I am not going
    to discuss these here because the focus of this book is on using Linux as the
    core for embedded systems.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他方法可以在嵌入式Linux设备上实现实时行为，例如，使用专用微控制器或在Linux内核旁边运行一个单独的实时内核，像Xenomai和RTAI那样。我在这里不讨论这些方法，因为本书的重点是使用Linux作为嵌入式系统的核心。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is real time?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是实时？
- en: Identifying sources of non-determinism
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别非确定性的来源
- en: Understanding scheduling latency
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解调度延迟
- en: Kernel preemption
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核抢占
- en: Preemptible kernel locks
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可抢占内核锁
- en: High-resolution timers
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高分辨率定时器
- en: Avoiding page faults
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免页面错误
- en: Interrupt shielding
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中断屏蔽
- en: Measuring scheduling latencies
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量调度延迟
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with the examples, make sure you have the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随示例进行操作，请确保您已经具备以下条件：
- en: An Ubuntu 24.04 or later LTS host system with at least 90 GB of free disk space
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Ubuntu 24.04或更高版本的LTS主机系统，至少有90 GB的空闲磁盘空间
- en: Yocto 5.0 (Scarthgap) LTS release
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Yocto 5.0（Scarthgap）LTS版本
- en: A microSD card reader and card
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个microSD卡读卡器和卡
- en: balenaEtcher for Linux
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于Linux的balenaEtcher
- en: An Ethernet cable and router with an available port for network connectivity
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一根以太网线和一个具有可用端口的路由器用于网络连接
- en: A BeaglePlay
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个BeaglePlay
- en: A 5 V USB-C power supply capable of delivering 3 A
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个能够提供3A电流的5V USB-C电源
- en: You should have already built the 5.0 (Scarthgap) LTS release of Yocto in [*Chapter
    6*](Chapter_04.xhtml#_idTextAnchor110). If you have not, then please refer to
    the *Compatible Linux Distribution* and *Build Host Packages* sections of the
    *Yocto Project Quick Build* guide ([https://docs.yoctoproject.org/brief-yoctoprojectqs/](https://docs.yoctoproject.org/brief-yoctoprojectqs/))
    before building Yocto on your Linux host according to the instructions in [*Chapter
    6*](Chapter_04.xhtml#_idTextAnchor110).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该已经构建了Yocto的5.0（Scarthgap）LTS版本，详见[*第6章*](Chapter_04.xhtml#_idTextAnchor110)。如果没有，请在按照[*第6章*](Chapter_04.xhtml#_idTextAnchor110)中的说明在Linux主机上构建Yocto之前，参考*兼容的Linux发行版*和*构建主机软件包*部分，内容请见*Yocto项目快速构建*指南([https://docs.yoctoproject.org/brief-yoctoprojectqs/](https://docs.yoctoproject.org/brief-yoctoprojectqs/))。
- en: What is real time?
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是实时？
- en: The nature of real-time programming is one of the subjects that software engineers
    love to discuss at length, often giving a range of contradictory definitions.
    I will begin by setting out what I think is important about real time.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 实时编程的性质是软件工程师们喜爱长篇讨论的主题之一，通常会给出一系列相互矛盾的定义。我将首先阐述我认为关于实时最重要的内容。
- en: A task is a real-time task if it has to be completed before a certain point
    in time, known as the **deadline**. The distinction between real-time and non-real-time
    tasks is shown by considering what happens when you play an audio stream on your
    computer while compiling the Linux kernel. The first is a real-time task because
    there is a constant stream of data arriving at the audio driver, and blocks of
    audio samples have to be written to the audio interface at the playback rate.
    Meanwhile, the compilation is not real time because there is no deadline. You
    simply want it to be completed as soon as possible; whether it takes 10 seconds
    or 10 minutes does not affect the quality of the kernel binaries.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一个任务是实时任务，如果它必须在某个特定时间点之前完成，这个时间点被称为**截止时间**。通过考虑在编译Linux内核时播放音频流的情况，可以区分实时任务和非实时任务。播放音频流是实时任务，因为有数据流不断到达音频驱动程序，必须按播放速率将音频样本块写入音频接口。而编译则不是实时的，因为没有截止时间。你只是希望它尽快完成；无论是10秒钟还是10分钟都不会影响内核二进制文件的质量。
- en: 'The other important thing to consider is the consequence of missing the deadline,
    which can range from mild annoyance to system failure or, in the most extreme
    cases, injury or death. Here are some examples:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要考虑的重要因素是错过截止时间的后果，这可能从轻微的烦恼到系统故障，甚至在极端情况下可能导致伤害或死亡。以下是一些例子：
- en: '**Playing an audio stream**: There is a deadline in the order of tens of milliseconds.
    If the audio buffer underruns, you will hear a click, which is annoying, but you
    will get over it.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**播放音频流**：截止时间大约在几十毫秒。如果音频缓冲区下溢，你会听到一个咔嚓声，这很烦人，但你很快就能适应。'
- en: '**Moving and clicking a mouse**: The deadline is also in the order of tens
    of milliseconds. If it is missed, the mouse moves erratically and button clicks
    will be lost. If the problem persists, the system will become unusable.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**移动和点击鼠标**：截止时间也是在毫秒级别的。如果错过了，鼠标会不规则移动，按钮点击会丢失。如果问题持续存在，系统将变得无法使用。'
- en: '**Printing a piece of paper**: The deadlines for the paper feed are in the
    millisecond range, which if missed may cause the printer to jam, and somebody
    will have to go and fix it. Occasional jams are acceptable, but nobody is going
    to buy a printer that keeps on jamming.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**打印纸张**：纸张进给的截止时间在毫秒级别，如果错过了，可能会导致打印机卡纸，需要有人去修复。偶尔的卡纸是可以接受的，但没有人会购买一台经常卡纸的打印机。'
- en: '**Printing sell-by dates on bottles on a production line**: If one bottle is
    not printed, the whole production line has to be halted, the bottle removed, and
    the line restarted, which is expensive.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在生产线瓶子上打印保质期**：如果某个瓶子没有打印，整个生产线必须停止，瓶子被移除，并重新启动生产线，这样会非常昂贵。'
- en: '**Baking a cake**: There is a deadline of 30 minutes or so. If you miss it
    by a few minutes, the cake might be ruined. If you miss it by a lot, the house
    may burn down.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**烤蛋糕**：大约有30分钟的截止时间。如果错过几分钟，蛋糕可能会烤坏。如果错过很长时间，房子可能会着火。'
- en: '**Power-surge detection system**: If the system detects a surge, a circuit
    breaker has to be triggered within 2 milliseconds. Failing to do so causes damage
    to the equipment and may injure or kill someone.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**电涌检测系统**：如果系统检测到电涌，必须在2毫秒内触发断路器。未能做到这一点会导致设备损坏，并可能造成伤害甚至死亡。'
- en: 'In other words, there are many consequences to missed deadlines. We often talk
    about these different categories:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，错过截止时间会带来很多后果。我们通常会谈论这些不同的类别：
- en: '**Soft real-time**: The deadline is desirable but is sometimes missed without
    the system being considered a failure. The first two examples in the previous
    list are examples of this.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**软实时**：截止时间是理想的，但有时会错过，而系统不会因此被认为是失败。前面列表中的前两个例子就是这种情况的例子。'
- en: '**Hard real-time**: Here, missing a deadline has a serious effect. We can further
    subdivide hard real-time into mission-critical systems, in which there is a cost
    to missing the deadline, such as the fourth example, and safety-critical systems,
    in which there is a danger to life and limb, such as the last two examples. I
    put in the baking example to show that not all hard real-time systems have deadlines
    measured in milliseconds or microseconds.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**硬实时**：在这种情况下，错过截止时间会产生严重后果。我们可以进一步将硬实时系统细分为任务关键型系统，其中错过截止时间会带来一定代价（如第四个例子），以及安全关键型系统，在这些系统中，错过截止时间可能会危及生命安全（如最后两个例子）。我加入烤蛋糕的例子是为了说明并非所有硬实时系统的截止时间都以毫秒或微秒为单位。'
- en: Software written for safety-critical systems has to conform to various standards
    that seek to ensure that it is capable of performing reliably. It is very difficult
    for a complex operating system such as Linux to meet those requirements.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为安全关键系统编写的软件必须符合各种标准，以确保其具备可靠执行的能力。对于像Linux这样复杂的操作系统来说，满足这些要求是非常困难的。
- en: When it comes to mission-critical systems, it is possible, and common, for Linux
    to be used for a wide range of control systems. The requirements of the software
    depend on the combination of the deadline and the confidence level, which can
    usually be determined through extensive testing.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任务关键系统，Linux常常被用于各种控制系统，并且这种做法是可行且常见的。软件的需求取决于截止时间和置信度的组合，通常可以通过广泛的测试来确定。
- en: Therefore, to say that a system is real-time, you have to measure its response
    times under the maximum anticipated load and show that it meets the deadline for
    an agreed proportion of the time. As a rule of thumb, a well-configured Linux
    system using a mainline kernel is good for soft real-time tasks with deadlines
    down to tens of milliseconds, and a kernel with the `PREEMPT_RT` patch is good
    for soft and hard real-time mission-critical systems with deadlines down to several
    hundreds of microseconds.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要说一个系统是实时的，必须在最大预期负载下测量其响应时间，并证明它在一定比例的时间内满足截止时间。作为经验法则，配置良好的使用主线内核的Linux系统适用于具有几十毫秒截止时间的软实时任务，而使用`PREEMPT_RT`补丁的内核适用于具有几百微秒截止时间的软硬实时任务关键系统。
- en: The key to creating a real-time system is to reduce the variability in response
    times so that you have greater confidence that the deadlines will not be missed;
    in other words, you need to make the system more deterministic. Often, this is
    done at the expense of performance. For example, caches make systems run faster
    by making the average time to access an item of data shorter, but the maximum
    time is longer in the case of a cache miss. Caches make a system faster but less
    deterministic, which is the opposite of what we want.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 创建实时系统的关键是减少响应时间的可变性，这样你就能更有信心确保不会错过截止时间；换句话说，你需要让系统变得更具确定性。通常，这会以牺牲性能为代价。例如，缓存通过缩短访问数据项的平均时间来加速系统运行，但在缓存未命中的情况下，最大时间会更长。缓存使系统变得更快，但确定性更差，这正是我们不希望的。
- en: '**TIP**'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: It is a myth of real-time computing that it is fast. This is not so; the more
    deterministic a system is, the lower the maximum throughput.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 实时计算的一个误区是认为它很快。事实并非如此；一个系统越是确定性，最大吞吐量就越低。
- en: The remainder of this chapter is concerned with identifying the causes of latency
    and the things you can do to reduce it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分将讨论识别延迟的原因以及可以采取的减少措施。
- en: Identifying sources of non-determinism
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定非确定性来源
- en: 'Fundamentally, real-time programming is about making sure that the threads
    controlling the output in real time are scheduled when needed and so can complete
    the job before the deadline. Anything that prevents this is a problem. Here are
    some problem areas:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 从根本上说，实时编程是确保控制实时输出的线程在需要时能够被调度，从而在截止时间前完成工作。任何阻止这一点的因素都是问题。以下是一些常见的问题领域：
- en: '**Scheduling**: Real-time threads must be scheduled before others, and so they
    must have a real-time policy, `SCHED_FIFO` or `SCHED_RR`. Additionally, they should
    have priorities assigned in descending order, starting with the one with the shortest
    deadline, according to the theory of rate monotonic analysis that I described
    in [*Chapter 17*](Chapter_17.xhtml#_idTextAnchor542).'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调度**：实时线程必须优先调度，因此它们必须采用实时策略，如`SCHED_FIFO`或`SCHED_RR`。此外，它们应该按优先级降序分配，首先是具有最短截止时间的线程，这符合我在[*第17章*](Chapter_17.xhtml#_idTextAnchor542)中描述的速率单调分析理论。'
- en: '**Scheduling latency**: The kernel must be able to reschedule as soon as an
    event such as an interrupt or timer occurs and not be subject to unbounded delays.
    Reducing scheduling latency is a key topic later on in this chapter.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调度延迟**：内核必须能够在事件发生时（如中断或定时器触发）立即重新调度，而不应受到无界延迟的影响。减少调度延迟是本章后续讨论的一个关键主题。'
- en: '**Priority inversion**: This is a consequence of priority-based scheduling,
    which leads to unbounded delays when a high-priority thread is blocked on a mutex
    held by a low-priority thread, as I described in [*Chapter 17*](Chapter_17.xhtml#_idTextAnchor542).
    User space has priority inheritance and priority ceiling mutexes; in kernel space,
    we have RT-mutexes, which implement priority inheritance, and I will talk about
    them in the section on the real-time kernel.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优先级倒置**：这是基于优先级调度的一个后果，当一个高优先级线程被低优先级线程持有的互斥锁阻塞时，会导致无界延迟，正如我在 [*第 17 章*](Chapter_17.xhtml#_idTextAnchor542)
    中所描述的那样。用户空间有优先级继承和优先级天花板互斥锁；在内核空间，我们有 RT-互斥锁，它实现了优先级继承，稍后我会在实时内核部分讨论它们。'
- en: '**Accurate timers**: If you want to manage deadlines in the region of low milliseconds
    or microseconds, you need timers that match. High-resolution timers are crucial
    and are a configuration option on almost all kernels.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**精确计时器**：如果你想管理低毫秒级或微秒级的截止时间，你需要相应的计时器。高分辨率计时器至关重要，几乎所有内核都提供这个配置选项。'
- en: '**Page faults**: A page fault while executing a critical section of code will
    upset all timing estimates. You can avoid them by locking memory, as I shall describe
    later.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**页面错误**：在执行代码的临界区时发生页面错误将打乱所有的时间估算。你可以通过锁定内存来避免它们，正如我稍后所描述的那样。'
- en: '**Interrupts**: They occur at unpredictable times and can result in an unexpected
    processing overhead if there is a sudden flood of them. There are two ways to
    avoid this. One is to run interrupts as kernel threads, and the other, on multi-core
    devices, is to shield one or more CPUs from interrupt handling. I will discuss
    both possibilities later.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中断**：中断发生在不可预测的时刻，如果中断突然大量涌入，可能会导致意外的处理开销。避免这种情况有两种方法。一种是将中断作为内核线程运行，另一种是在多核设备上，屏蔽一个或多个
    CPU 的中断处理。我将在后续部分讨论这两种可能性。'
- en: '**Processor caches**: These provide a buffer between the CPU and the main memory
    and, like all caches, are a source of non-determinism, especially on multi-core
    devices. Unfortunately, this is beyond the scope of this book, but you may want
    to refer to the references at the end of the chapter for more details.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理器缓存**：这些提供了 CPU 与主内存之间的缓冲区，像所有缓存一样，处理器缓存是非确定性的来源，尤其是在多核设备上。不幸的是，这超出了本书的范围，但你可以参考本章末尾的参考资料以获取更多详细信息。'
- en: '**Memory bus contention**: When peripherals access memory directly through
    a DMA channel, they use up a slice of memory bus bandwidth, which slows down access
    from the CPU core (or cores) and so contributes to the non-deterministic execution
    of the program. However, this is a hardware issue and is also beyond the scope
    of this book.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存总线争用**：当外设通过 DMA 通道直接访问内存时，它们会占用一部分内存总线带宽，这会导致 CPU 核心（或多个核心）访问变慢，从而增加程序执行的非确定性。然而，这是一个硬件问题，也超出了本书的范围。'
- en: I will expand on the most important problems and see what can be done about
    them in the next sections.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在接下来的部分扩展讨论最重要的问题，并探讨如何应对这些问题。
- en: Understanding scheduling latency
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解调度延迟
- en: 'Real-time threads need to be scheduled as soon as they have something to do.
    However, even if there are no other threads of the same or higher priority, there
    is always a delay from the point at which the wakeup event occurs—an interrupt
    or system timer—to the time that the thread starts to run. This is called scheduling
    latency. It can be broken down into several components, as shown in the following
    diagram:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 实时线程需要在有任务时立即调度。然而，即使没有其他同等或更高优先级的线程，从唤醒事件发生的时刻（中断或系统定时器）到线程开始运行之间，总是存在一定的延迟。这就是所谓的调度延迟。它可以分解成几个组成部分，如下图所示：
- en: '![Figure 21.1 – Scheduling latency](img/B18466_21_01.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图 21.1 – 调度延迟](img/B18466_21_01.png)'
- en: Figure 21.1 – Scheduling latency
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21.1 – 调度延迟
- en: Firstly, there is the hardware interrupt latency from the point at which an
    interrupt is asserted until the **interrupt service routine** (**ISR**) begins
    to run. A small part of this is the delay in the interrupt hardware itself, but
    the biggest problem is due to interrupts being disabled in software. Minimizing
    this *IRQ off time* is important.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，硬件中断延迟是指从中断发生到 **中断服务例程**（**ISR**）开始运行之间的时间延迟。这其中有一小部分是中断硬件本身的延迟，但最大的问题是由于中断在软件中被禁用。最小化这个
    *IRQ 关闭时间* 非常重要。
- en: The next is interrupt latency, which is the length of time until the ISR has
    serviced the interrupt and woken up any threads waiting on this event. It is mostly
    dependent on the way the ISR was written. Normally, it should take only a short
    time, measured in microseconds.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是中断延迟，这是从中断服务例程（ISR）处理完中断并唤醒等待该事件的线程的时间。它主要取决于 ISR 的编写方式。通常，它应该只需要很短的时间，单位为微秒。
- en: The final delay is the preemption latency, which is the time from the point
    that the kernel is notified that a thread is ready to run to that at which the
    scheduler actually runs the thread. It is determined by whether the kernel can
    be preempted or not. If it is running code in a critical section, then the rescheduling
    will have to wait. The length of the delay is dependent on the configuration of
    kernel preemption.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的延迟是抢占延迟，即从内核被通知线程准备好运行，到调度程序实际运行该线程的时间。它取决于内核是否可以被抢占。如果内核正在执行关键区段的代码，那么重新调度将不得不等待。延迟的长度取决于内核抢占的配置。
- en: Kernel preemption
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内核抢占
- en: 'Preemption latency occurs because it is not always safe or desirable to preempt
    the current thread of execution and call the scheduler. Mainline Linux has three
    settings for preemption, selected via the **Kernel Features** | **Preemption Mode**l
    menu:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 抢占延迟发生的原因是当前线程的执行并不总是安全或可取的去抢占，并调用调度程序。主线 Linux 提供了三种抢占设置，通过 **内核特性** | **抢占模式**
    菜单进行选择：
- en: '`CONFIG_PREEMPT_NONE`: No preemption.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONFIG_PREEMPT_NONE`：无抢占。'
- en: '`CONFIG_PREEMPT_VOLUNTARY`: Enables additional checks for requests for preemption.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONFIG_PREEMPT_VOLUNTARY`：启用对抢占请求的额外检查。'
- en: '`CONFIG_PREEMPT`: Allows the kernel to be preempted.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONFIG_PREEMPT`：允许内核被抢占。'
- en: With preemption set to `none`, kernel code will continue without rescheduling
    until it either returns via a `syscall` back to user space, where preemption is
    always allowed, or it encounters a sleeping wait that stops the current thread.
    Since it reduces the number of transitions between the kernel and user space and
    may reduce the total number of context switches, this option results in the highest
    throughput at the expense of large preemption latencies. It is the default for
    servers and some desktop kernels where throughput is more important than responsiveness.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当抢占设置为 `none` 时，内核代码将继续执行，直到通过 `syscall` 返回到用户空间，此时总是允许抢占，或者遇到一个使当前线程停止的睡眠等待。由于它减少了内核和用户空间之间的过渡次数，并且可能减少总的上下文切换次数，因此该选项在牺牲较大的抢占延迟的情况下，能获得最高的吞吐量。它是服务器和一些桌面内核的默认设置，在这些情况下吞吐量比响应性更为重要。
- en: The second option enables explicit preemption points, where the scheduler is
    called if the `need_resched` flag is set, which reduces the worst-case preemption
    latencies at the expense of slightly lower throughput. Some distributions set
    this option on desktops.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选项启用显式抢占点，如果设置了 `need_resched` 标志，调度程序将被调用，这减少了最坏情况下的抢占延迟，代价是吞吐量略微降低。一些发行版会在桌面上设置此选项。
- en: The third option makes the kernel preemptible, meaning that an interrupt can
    result in an immediate reschedule so long as the kernel is not executing in an
    atomic context, which I will describe in the following section. This reduces worst-case
    preemption latencies and, therefore, overall scheduling latencies to something
    in the order of a few milliseconds on typical embedded hardware.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个选项使内核可以被抢占，这意味着只要内核不在原子上下文中执行，外部中断就可以导致立即的调度。这减少了最坏情况下的抢占延迟，因此，在典型的嵌入式硬件上，总的调度延迟可以缩短至几毫秒左右。
- en: This is often described as a soft real-time option, and most embedded kernels
    are configured in this way. Of course, there is a small reduction in overall throughput,
    but that is usually less important than having more deterministic scheduling for
    embedded devices.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常被描述为软实时选项，大多数嵌入式内核都配置为这种方式。当然，这会导致总体吞吐量稍微降低，但相比于为嵌入式设备提供更具确定性的调度，这通常并不那么重要。
- en: Real-time Linux kernel (PREEMPT_RT)
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实时 Linux 内核（PREEMPT_RT）
- en: There was a long-standing effort to reduce latencies even further that goes
    by the name of the kernel configuration option for these features, **PREEMPT_RT**.
    The project was started by Ingo Molnar, Thomas Gleixner, and Steven Rostedt and
    has had contributions from many more developers over the years. The kernel patches
    are at [https://www.kernel.org/pub/linux/kernel/projects/rt](https://www.kernel.org/pub/linux/kernel/projects/rt),
    and there is a wiki at [https://wiki.linuxfoundation.org/realtime/start](https://wiki.linuxfoundation.org/realtime/start).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 长期以来，一项致力于进一步减少延迟的工作被称为内核配置选项**PREEMPT_RT**。该项目由Ingo Molnar、Thomas Gleixner和Steven
    Rostedt发起，多年来得到了更多开发者的贡献。内核补丁可以在[https://www.kernel.org/pub/linux/kernel/projects/rt](https://www.kernel.org/pub/linux/kernel/projects/rt)找到，同时也有一个维基页面：[https://wiki.linuxfoundation.org/realtime/start](https://wiki.linuxfoundation.org/realtime/start)。
- en: '**IMPORTANT NOTE**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: '`PREEMPT_RT` was fully merged and enabled in the mainline Linux kernel on September
    20, 2024\. `PREEMPT_RT` support for the x86, x86-64, arm64, and riscv architectures
    was included in the Linux 6.12 LTS release that happened on November 17, 2024.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`PREEMPT_RT`已于2024年9月20日完全合并并启用在主线Linux内核中。`PREEMPT_RT`对x86、x86-64、arm64和riscv架构的支持包含在2024年11月17日发布的Linux
    6.12 LTS版本中。'
- en: 'The central plan was to reduce the amount of time the kernel spends running
    in an **atomic context**, which is where it is not safe to call the scheduler
    and switch to a different thread. Typical atomic contexts are when the kernel
    is in the following states:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 中心计划是减少内核在**原子上下文**中运行的时间，在这种上下文中，调用调度程序并切换到其他线程是不安全的。典型的原子上下文包括内核处于以下状态时：
- en: Running an interrupt or trap handler.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正在运行中断或陷阱处理程序。
- en: Holding a spin lock or is in an RCU-critical section. Spin locks and RCU are
    kernel-locking primitives, the details of which are not relevant here.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持有自旋锁或处于RCU关键区段。自旋锁和RCU是内核锁原语，其细节在这里不做探讨。
- en: Between calls to `preempt_disable()` and `preempt_enable()`.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调用`preempt_disable()`和`preempt_enable()`之间。
- en: Hardware interrupts are disabled (**IRQs off**).
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件中断被禁用（**IRQs off**）。
- en: 'The changes that comprised `PREEMPT_RT` had two main goals: one is to reduce
    the impact of interrupt handlers by turning them into kernel threads, and the
    other is to make locks preemptible so that a thread can sleep while holding one.
    It is obvious that there is a large overhead in these changes, which makes average-case
    interrupt handling slower but much more deterministic, which is what we are striving
    for.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`PREEMPT_RT`所包含的更改有两个主要目标：一个是通过将中断处理程序转换为内核线程来减少中断处理的影响，另一个是使锁可抢占，以便线程在持有锁时能够休眠。显然，这些更改有较大的开销，这使得平均情况下的中断处理变得较慢，但却更加确定性，这正是我们所追求的。'
- en: Threaded interrupt handlers
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程化中断处理程序
- en: 'Not all interrupts are triggers for real-time tasks, but all interrupts steal
    cycles from real-time tasks. Threaded interrupt handlers allow a priority to be
    associated with the interrupt and for it to be scheduled at an appropriate time,
    as shown in the following diagram:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 不是所有的中断都会触发实时任务，但所有的中断都会从实时任务中窃取周期。线程化中断处理程序允许为中断分配优先级，并在适当的时间安排它，如下图所示：
- en: '![Figure 21.2 – In-line versus threaded interrupt handlers](img/B18466_21_02.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图21.2 – 内联与线程化中断处理程序](img/B18466_21_02.png)'
- en: Figure 21.2 – In-line versus threaded interrupt handlers
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.2 – 内联与线程化中断处理程序
- en: 'If the interrupt handler code is run as a kernel thread, there is no reason
    why it cannot be preempted by a user space thread of higher priority, and so the
    interrupt handler does not contribute toward scheduling latency of the user space
    thread. Threaded interrupt handlers have been a feature of mainline Linux since
    2.6.30\. You can request that an individual interrupt handler be threaded by registering
    it with `request_threaded_irq()` in place of the normal `request_irq()`. You can
    make threaded IRQs the default by configuring the kernel with `CONFIG_IRQ_FORCED_THREADING=y`,
    which makes all handlers into threads unless they have explicitly prevented this
    by setting the `IRQF_NO_THREAD` flag. When `PREEMPT_RT` is enabled, interrupts
    are, by default, configured as threads in this way. Here is an example of what
    you might see:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果中断处理程序代码以内核线程的形式运行，则没有理由不能被更高优先级的用户空间线程抢占，因此中断处理程序不会导致用户空间线程的调度延迟。线程化中断处理程序自2.6.30版本以来成为主线Linux的一个特性。你可以通过使用`request_threaded_irq()`来注册一个中断处理程序，从而将其线程化，取代普通的`request_irq()`。你还可以通过配置内核参数`CONFIG_IRQ_FORCED_THREADING=y`来使线程化的IRQ成为默认，这将使所有的中断处理程序变成线程，除非它们明确通过设置`IRQF_NO_THREAD`标志来防止这一点。当启用`PREEMPT_RT`时，中断默认被配置为以这种方式作为线程。下面是一个你可能会看到的示例：
- en: '[PRE0]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**IMPORTANT NOTE**'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: The interrupt threads have all been given the default `SCHED_FIFO` policy and
    a priority of `50`. It doesn’t make sense to leave them at the defaults, however;
    now is your chance to assign priorities according to the importance of the interrupts
    compared to real-time user space threads.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 中断线程都被赋予了默认的`SCHED_FIFO`策略，并且优先级为`50`。然而，将它们保持在默认值上没有意义；现在是你根据中断与实时用户空间线程的重要性来分配优先级的机会。
- en: 'Here is a suggested order of descending thread priorities:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个建议的线程优先级降序排列顺序：
- en: The POSIX timers thread, `posixcputmr`, should always have the highest priority.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POSIX计时器线程`posixcputmr`应该始终具有最高优先级。
- en: Hardware interrupts associated with the highest-priority real-time thread.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与最高优先级实时线程相关的硬件中断。
- en: The highest-priority real-time thread.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优先级最高的实时线程。
- en: Hardware interrupts for the progressively lower-priority real-time threads,
    followed by the thread itself.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逐渐较低优先级的实时线程的硬件中断，随后是线程本身。
- en: The next highest priority real-time thread.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个最高优先级的实时线程。
- en: Hardware interrupts for non-real-time interfaces.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非实时接口的硬件中断。
- en: The soft IRQ daemon, `ksoftirqd`, which on RT kernels is responsible for running
    delayed interrupt routines and, prior to Linux 3.6, was responsible for running
    the network stack, the block I/O layer, and other things.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件IRQ守护进程`ksoftirqd`，在RT内核中负责运行延迟的中断例程，并且在Linux 3.6之前，负责运行网络栈、块I/O层以及其他任务。
- en: 'You may need to experiment with different priority levels to achieve a balance.
    You can change the priorities using the `chrt` command as part of the boot script
    with a command like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要尝试不同的优先级级别以达到平衡。你可以在启动脚本中使用类似以下命令的`chrt`命令来更改优先级：
- en: '[PRE1]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `pgrep` command is part of the `procps` package.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`pgrep`命令是`procps`软件包的一部分。'
- en: Now that we’ve been introduced to the real-time Linux kernel by way of threaded
    interrupt handlers, let’s dig deeper into its implementation.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经通过线程化的中断处理程序了解了实时Linux内核，接下来让我们更深入地探讨其实现。
- en: Preemptible kernel locks
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可抢占内核锁
- en: Making the majority of kernel locks preemptible is the most intrusive change
    that `PREEMPT_RT` makes.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 将大多数内核锁设置为可抢占是`PREEMPT_RT`所做的最具侵入性的更改。
- en: The problem occurs with spin locks, which are used for much of the kernel locking.
    A spin lock is a busy-wait mutex that does not require a context switch in the
    contended case, and so it is very efficient as long as the lock is held for a
    short time. Ideally, they should be locked for less than the time it would take
    to reschedule twice.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 问题出现在自旋锁上，许多内核锁就是使用自旋锁的。自旋锁是一种忙等待互斥锁，在竞争的情况下不需要上下文切换，因此只要锁持有时间较短，它就非常高效。理想情况下，它们的锁持有时间应该小于两次重新调度所需的时间。
- en: 'The following diagram shows threads running on two different CPUs contending
    the same spin lock. **CPU 0** gets it first, forcing **CPU 1** to spin, waiting
    until it is unlocked:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了两个不同CPU上运行的线程在争用同一个自旋锁的情况。**CPU 0**先获得自旋锁，迫使**CPU 1**进入自旋状态，直到锁被解锁：
- en: '![Figure 21.3 – Spin lock](img/B18466_21_03.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图21.3 – 自旋锁](img/B18466_21_03.png)'
- en: Figure 21.3 – Spin lock
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.3 – 自旋锁
- en: The thread that holds the spin lock cannot be preempted since doing so may make
    the new thread enter the same code and deadlock when it tries to lock the same
    spin lock. Consequently, in mainline Linux, locking a spin lock disables kernel
    preemption, creating an atomic context. This means that a low-priority thread
    that holds a spin lock can prevent a high-priority thread from being scheduled,
    a condition otherwise known as **priority inversion**.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 持有自旋锁的线程无法被抢占，因为这样做可能导致新线程进入相同的代码，并在尝试锁定相同的自旋锁时发生死锁。因此，在主线Linux中，锁定自旋锁会禁用内核的抢占，创建一个原子上下文。这意味着持有自旋锁的低优先级线程可能会阻止高优先级线程被调度，这种情况通常被称为**优先级反转**。
- en: '**IMPORTANT NOTE**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要说明**'
- en: The solution adopted by `PREEMPT_RT` is to replace almost all spin locks with
    RT-mutexes. A mutex is slower than a spin lock, but it is fully preemptible. Not
    only that, but RT-mutexes implement priority inheritance and so are not susceptible
    to priority inversion.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`PREEMPT_RT`采用的解决方案是将几乎所有自旋锁替换为RT互斥锁。互斥锁比自旋锁慢，但它是完全可抢占的。不仅如此，RT互斥锁实现了优先级继承，因此不会受到优先级反转的影响。'
- en: We now have an idea of what’s in the `PREEMPT_RT` patches. So, how do we go
    about getting them?
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对`PREEMPT_RT`补丁的内容有了一些了解。那么，如何获得这些补丁呢？
- en: Getting the PREEMPT_RT patches
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取PREEMPT_RT补丁
- en: 'Historically, the RT developers did not create patch sets for every kernel
    version because of the amount of porting effort involved. On average, they created
    patches for every other kernel. This practice changed beginning with kernel version
    5.9, after which a patch was generated for every kernel version. The most recent
    kernels that are supported at the time of writing are as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上，RT开发者并没有为每个内核版本创建补丁集，因为这需要大量的移植工作。平均而言，他们为每隔一个内核版本创建补丁。从内核版本5.9开始，情况发生了变化，从那时起，每个内核版本都会生成一个补丁。本文写作时，支持的最新内核版本如下：
- en: '`6.13-rt`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`6.13-rt`'
- en: '`6.12-rt`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`6.12-rt`'
- en: '`6.11-rt`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`6.11-rt`'
- en: '`6.10-rt`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`6.10-rt`'
- en: '`6.9-rt`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`6.9-rt`'
- en: '`6.8-rt`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`6.8-rt`'
- en: '`6.7-rt`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`6.7-rt`'
- en: '`6.6-rt`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`6.6-rt`'
- en: '`6.5-rt`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`6.5-rt`'
- en: '`6.4-rt`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`6.4-rt`'
- en: '`6.3-rt`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`6.3-rt`'
- en: '`6.1-rt`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`6.1-rt`'
- en: '**IMPORTANT NOTE**'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**重要说明**'
- en: The patches are available at [https://www.kernel.org/pub/linux/kernel/projects/rt](https://www.kernel.org/pub/linux/kernel/projects/rt).
    From `6.12-rt` onward, the patches contain features and optimizations that have
    yet to be merged into the official kernel.
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些补丁可以在[https://www.kernel.org/pub/linux/kernel/projects/rt](https://www.kernel.org/pub/linux/kernel/projects/rt)获取。从`6.12-rt`版本开始，补丁包含了尚未合并到官方内核中的功能和优化。
- en: 'If you are using The Yocto Project, there is an RT version of the kernel already.
    Otherwise, it is possible that the place you got your kernel from already has
    the `PREEMPT_RT` patch applied. If not, you will have to apply the patch yourself.
    Firstly, make sure that the `PREEMPT_RT` patch version and your kernel version
    match exactly; otherwise, you will not be able to apply the patches cleanly. Then,
    you apply it in the normal way, as shown in the following command lines. You will
    then be able to configure the kernel with `CONFIG_PREEMPT_RT_FULL`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用Yocto项目，已经有RT版本的内核了。否则，你可能已经从获取内核的地方获得了包含`PREEMPT_RT`补丁的版本。如果没有，你就必须自己应用这个补丁。首先，确保`PREEMPT_RT`补丁的版本和你的内核版本完全匹配；否则，你将无法干净地应用这些补丁。然后，按正常方式应用它，如以下命令行所示。然后，你就可以通过`CONFIG_PREEMPT_RT_FULL`配置内核：
- en: '[PRE2]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: There is a problem in the previous paragraph. The `RT` patch will only apply
    if you are using a compatible mainline kernel. You are probably not, because that
    is the nature of embedded Linux kernels. Therefore, you will have to spend some
    time looking at failed patches and fixing them and then analyzing the board support
    for your target and adding any real-time support that is missing. These details
    are, once again, outside the scope of this book. If you are not sure what to do,
    you should request support from the kernel vendor that you are using and on kernel
    developer forums.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 前一段有个问题。`RT`补丁仅在你使用兼容的主线内核时才能应用。你可能没有使用，因为这正是嵌入式Linux内核的特点。因此，你需要花一些时间查看失败的补丁，修复它们，然后分析目标板的支持情况，并添加缺失的实时支持。这些细节再次超出了本书的范围。如果你不确定该怎么办，应该向你使用的内核供应商或内核开发者论坛寻求支持。
- en: The Yocto Project and PREEMPT_RT
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Yocto项目与PREEMPT_RT
- en: 'The Yocto Project supplies two standard kernel recipes: `linux-yocto` and `linux-yocto-rt`
    with the real-time patches already applied. Assuming that your target is supported
    by the Yocto kernels, you just need to select `linux-yocto-rt` as your preferred
    kernel and declare that your machine is compatible.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Yocto 项目提供了两个标准的内核食谱：`linux-yocto` 和 `linux-yocto-rt`，并且已经应用了实时补丁。假设你的目标硬件被
    Yocto 内核支持，你只需要选择 `linux-yocto-rt` 作为首选内核，并声明你的机器兼容。
- en: 'Since we are using the `meta-ti-bsp` layer to build a TI kernel for the BeaglePlay,
    add these two lines to your `conf/local.conf` to build a real-time kernel:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用 `meta-ti-bsp` 层为 BeaglePlay 构建 TI 内核，因此需要在 `conf/local.conf` 中添加以下两行，以构建实时内核：
- en: '[PRE3]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: So, now that we know where to get a real-time Linux kernel, let’s switch gears
    and talk about timing.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何获取实时 Linux 内核，让我们换个话题，聊一聊计时。
- en: High-resolution timers
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高分辨率计时器
- en: Timer resolution is important if you have precise timing requirements, which
    is typical for real-time applications. The default timer in Linux is a clock that
    runs at a configurable rate, typically 100 Hz for embedded systems and 250 Hz
    for servers and desktops. The interval between two timer ticks is known as a **jiffy**
    and, in the examples given previously, is 10 milliseconds on an embedded SoC and
    4 milliseconds on a server.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有精确的计时要求，计时器分辨率就非常重要，这对于实时应用程序来说是典型的。Linux 中的默认计时器是一个以可配置速率运行的时钟，嵌入式系统通常为
    100 Hz，服务器和桌面为 250 Hz。两个计时器滴答之间的间隔称为 **jiffy**，在之前给出的例子中，嵌入式 SoC 上是 10 毫秒，服务器上是
    4 毫秒。
- en: Linux gained more accurate timers from the real-time kernel project in version
    2.6.18, and now they are available on all platforms, provided that there is a
    high-resolution timer source and device driver for it—which is almost always the
    case. You need to configure the kernel with `CONFIG_HIGH_RES_TIMERS=y`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 从 2.6.18 版本开始，借助实时内核项目获得了更精确的计时器，现在只要有高分辨率计时器源和设备驱动，它们就可以在所有平台上使用——这几乎总是成立的。你需要通过配置内核
    `CONFIG_HIGH_RES_TIMERS=y` 来启用它。
- en: With this enabled, all the kernel and user space clocks will be accurate down
    to the granularity of the underlying hardware. Finding the actual clock granularity
    is difficult. The obvious answer is the value provided by `clock_getres(2)`, but
    that always claims a resolution of 1 nanosecond.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 启用此功能后，所有内核和用户空间的时钟将精确到底层硬件的粒度。找到实际的时钟粒度是困难的。显而易见的答案是通过 `clock_getres(2)` 提供的值，但它总是声称分辨率为
    1 纳秒。
- en: 'The `cyclictest` tool has an option to analyze the times reported by the clock
    to guess the resolution:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`cyclictest` 工具有一个选项可以分析时钟报告的时间，以猜测分辨率：'
- en: '[PRE4]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can also look at the kernel log messages for clock-related strings like
    this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以查看内核日志消息，查找与时钟相关的字符串，例如：
- en: '[PRE5]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The two methods provide noticeably different numbers, both of which are below
    1 microsecond. Kernel logs show the base resolution of a timer (e.g., jiffies,
    HPET, TSC) rather than the effective resolution after applying timekeeping adjustments.
    `cyclictest` measures actual wakeup latencies, which depend on scheduler wakeup
    delays, IRQ latencies, and the accuracy of the timer hardware.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法提供了明显不同的数字，且都低于 1 微秒。内核日志显示的是计时器的基础分辨率（例如，jiffies、HPET、TSC），而不是应用时间保持调整后的有效分辨率。`cyclictest`
    测量的是实际的唤醒延迟，这取决于调度器的唤醒延迟、IRQ 延迟和计时器硬件的准确性。
- en: High-resolution timers can measure variations in latency with sufficient accuracy.
    Now, let’s look at a couple of ways to mitigate such non-determinism.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 高分辨率计时器能够以足够的精度测量延迟的变化。现在，让我们来看几个减轻这种非确定性的方法。
- en: Avoiding page faults
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免页面错误
- en: A page fault occurs when an application reads or writes to memory that is not
    committed to physical memory. It is impossible (or very hard) to predict when
    a page fault will happen, so they are another source of non-determinism in computers.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 页面错误发生在应用程序读取或写入尚未提交到物理内存的内存时。页面错误的发生时间是不可预测的（或非常难以预测），因此它们是计算机中的另一个非确定性来源。
- en: 'Fortunately, there is a function that allows you to commit all the memory used
    by the process and lock it down so that it cannot cause a page fault. It is `mlockall(2)`.
    These are its two flags:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一个函数可以让你提交进程使用的所有内存并将其锁定，以确保它不会引发页面错误。这个函数是 `mlockall(2)`。它有两个标志：
- en: '`MCL_CURRENT`: Locks all pages currently mapped.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MCL_CURRENT`：锁定当前映射的所有页面。'
- en: '`MCL_FUTURE`: Locks pages that are mapped in later.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MCL_FUTURE`：锁定将来映射的页面。'
- en: You usually call `mlockall` during the startup of the application with both
    flags set to lock all current and future memory mappings.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在应用程序启动时调用 `mlockall`，并设置这两个标志以锁定所有当前和未来的内存映射。
- en: '**TIP**'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: '`MCL_FUTURE` is not magic, in that there will still be a non-deterministic
    delay when allocating or freeing heap memory using `malloc()/free()` or `mmap()`.
    Such operations are best done at startup and not in the main control loops.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`MCL_FUTURE` 不是魔法，分配或释放堆内存时，使用 `malloc()/free()` 或 `mmap()` 时仍然会有非确定性的延迟。这类操作最好在启动时完成，而不是在主控制循环中。'
- en: 'Memory allocated on the stack is trickier because it is done automatically,
    and if you call a function that makes the stack deeper than before, you will encounter
    more memory management delays. A simple fix is to grow the stack to a size larger
    than you think you will ever need at startup. The code would look like this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈上分配的内存更为棘手，因为它是自动完成的，如果你调用一个使堆栈比之前更深的函数，你会遇到更多的内存管理延迟。一个简单的解决方法是在启动时将堆栈增长到一个比你认为会需要的更大的大小。代码可能如下所示：
- en: '[PRE6]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `stack_grow()` function allocates a large variable on the stack and then
    zeroes it out to force those pages of memory to be committed to this process.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`stack_grow()` 函数在堆栈上分配一个大变量，然后将其清零，以强制这些内存页面提交给此进程。'
- en: Interrupts are another source of non-determinism we should guard against.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 中断是我们应该防范的另一种非确定性来源。
- en: Interrupt shielding
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中断屏蔽
- en: Using threaded interrupt handlers helps mitigate interrupt overhead by running
    some threads at a higher priority than interrupt handlers that do not impact real-time
    tasks. If you are using a multi-core processor, you can take a different approach
    and shield one or more cores from processing interrupts completely, allowing them
    to be dedicated to real-time tasks instead. This works either with a normal Linux
    kernel or a `PREEMPT_RT` kernel.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用线程化的中断处理程序有助于通过以比不影响实时任务的中断处理程序更高的优先级运行某些线程，从而减少中断开销。如果你使用的是多核处理器，你可以采取不同的方法，完全屏蔽一个或多个核心的中断处理，使它们专门用于实时任务。这在正常的
    Linux 内核或 `PREEMPT_RT` 内核中都有效。
- en: Achieving this is a question of pinning the real-time threads to one CPU and
    the interrupt handlers to a different one. You can set the CPU affinity of a thread
    or process using the taskset command-line tool, or you can use the `sched_setaffinity(2)`
    and `pthread_setaffinity_np(3)` functions.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一目标的问题在于将实时线程绑定到一个 CPU 上，并将中断处理程序绑定到另一个 CPU 上。你可以使用 taskset 命令行工具设置线程或进程的
    CPU 亲和性，或者使用 `sched_setaffinity(2)` 和 `pthread_setaffinity_np(3)` 函数。
- en: To set the affinity of an interrupt, first note that there is a subdirectory
    for each interrupt number in `/proc/irq/<IRQ number>`. The control files for the
    interrupt are in there, including a CPU mask in `smp_affinity`. Write a bitmask
    to that file with a bit set for each CPU that is allowed to handle that IRQ.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置中断的亲和性，首先注意在 `/proc/irq/<IRQ number>` 中，每个中断编号都有一个子目录。中断的控制文件在其中，包括 `smp_affinity`
    中的 CPU 掩码。将一个位掩码写入该文件，位设置为允许处理该 IRQ 的每个 CPU。
- en: Stack growing and interrupt shielding are nifty techniques for improving responsiveness,
    but how can you tell whether they are actually working?
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈增长和中断屏蔽是提高响应性的巧妙技术，但如何判断它们是否真的有效呢？
- en: Measuring scheduling latencies
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测量调度延迟
- en: 'All the configuration and tuning you may do will be pointless if you cannot
    show that your device meets the deadlines. You will need your own benchmarks for
    the final testing, but I will describe here two important measurement tools: `cyclictest`
    and `Ftrace`.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的配置和调优都将毫无意义，如果你不能证明你的设备能够满足截止时间。你将需要自己的基准测试进行最终测试，但我在这里将描述两个重要的测量工具：`cyclictest`
    和 `Ftrace`。
- en: cyclictest
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: cyclictest
- en: '`cyclictest` was originally written by Thomas Gleixner and is now available
    on most platforms in a package named `rt-tests`.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`cyclictest` 最初由 Thomas Gleixner 编写，现在在大多数平台上以名为 `rt-tests` 的软件包提供。'
- en: 'If you are building a Yocto real-time kernel, you can create a target image
    that includes `rt-tests` by building the real-time image recipe:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在构建 Yocto 实时内核，你可以通过构建实时镜像配方来创建一个包含 `rt-tests` 的目标镜像：
- en: '[PRE7]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you are building a TI real-time kernel for the BeaglePlay, then configure
    the kernel with `CONFIG_ARM_PSCI_IDLE=y` so that `cyclictest` can write to the
    `/dev/cpu_dma_latency` socket.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在为 BeaglePlay 构建 TI 实时内核，那么请使用 `CONFIG_ARM_PSCI_IDLE=y` 配置内核，以便 `cyclictest`
    可以写入 `/dev/cpu_dma_latency` 套接字。
- en: 'If you are building a TI real-time kernel for the BeaglePlay, then append `rt-tests`
    to your image by modifying `conf/local.conf`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在为BeaglePlay构建TI实时内核，然后通过修改`conf/local.conf`将`rt-tests`附加到您的镜像：
- en: '[PRE8]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Build the minimal image recipe to install `rt-tests` onto an image for the
    BeaglePlay:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 构建最小镜像配方以在BeaglePlay的镜像上安装`rt-tests`：
- en: '[PRE9]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you are using Buildroot, you need to add the `BR2_PACKAGE_RT_TESTS` package
    in the **Target packages** | **Debugging, profiling and benchmark** | **rt-tests**
    menu.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用Buildroot，则需要在**Target packages** | **Debugging, profiling and benchmark**
    | **rt-tests**菜单中添加`BR2_PACKAGE_RT_TESTS`包。
- en: '`cyclictest` measures scheduling latencies by comparing the actual time taken
    for sleeping to the requested time. If there was no latency, they would be the
    same, and the reported latency would be 0\. `cyclictest` assumes a timer resolution
    of less than 1 microsecond.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`cyclictest`通过比较休眠所需的实际时间和请求的时间来测量调度延迟。如果没有延迟，它们将相同，报告的延迟将为0。`cyclictest`假设定时器分辨率小于1微秒。'
- en: 'It has a large number of command-line options. To start with, you might try
    running this command as `root` on the target:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 它具有大量命令行选项。首先，您可以尝试在目标上以`root`身份运行此命令：
- en: '[PRE10]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The options selected are as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 所选选项如下：
- en: '`-l N`: Loops N times (the default is unlimited).'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-l N`: 循环N次（默认为无限次）。'
- en: '`-m`: Locks memory with `mlockall`.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-m`: 使用`mlockall`锁定内存。'
- en: '`-p N`: Uses the real-time priority N.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-p N`: 使用实时优先级N。'
- en: 'The result line shows the following, reading from left to right:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 结果行从左到右显示以下内容：
- en: '`T: 0`: This was thread 0, the only thread in this run. You can set the number
    of threads with parameter `-t`.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T: 0`: 这是线程0，本次运行中的唯一线程。您可以使用`-t`参数设置线程数。'
- en: '`( 422)`: This was PID 422.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( 422)`: 这是PID 422。'
- en: '`P:99`: The priority was 99.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`P:99`: 优先级为99。'
- en: '`I:1000`: The interval between loops was 1,000 microseconds. You can set the
    interval with the `-i N` parameter.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`I:1000`: 循环之间的间隔为1,000微秒。您可以使用`-i N`参数设置间隔。'
- en: '`C:100000`: The final loop count for this thread was 100,000.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`C:100000`: 此线程的最终循环计数为100,000。'
- en: '`Min: 5`: The minimum latency was 5 microseconds.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Min: 5`: 最小延迟为5微秒。'
- en: '`Act: 7`: The actual latency was 7 microseconds. The *actual latency* is the
    most recent latency measurement, which only makes sense if you are watching `cyclictest`
    as it runs.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Act: 7`: 实际延迟为7微秒。*实际延迟*是最近的延迟测量值，仅在您观察`cyclictest`运行时才有意义。'
- en: '`Avg: 7`: The average latency was 7 microseconds.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Avg: 7`: 平均延迟为7微秒。'
- en: '`Max: 48`: The maximum latency was 48 microseconds.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Max: 48`: 最大延迟为48微秒。'
- en: This was obtained on an idle system running a `linux-ti-staging-rt` kernel as
    a quick demonstration of the tool. To be of real use, you would run tests over
    a 24-hour period or longer while running a load representative of the maximum
    you expect. `cyclictest` is a standard metric for scheduling latencies. However,
    it cannot help you identify and resolve specific problems with kernel latency.
    To do that, you need Ftrace.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在运行`linux-ti-staging-rt`内核的空闲系统上进行的快速演示工具。要真正有用，您需要在运行预期的最大负载的同时至少24小时内运行测试。`cyclictest`是调度延迟的标准度量。但是，它不能帮助您识别和解决特定的内核延迟问题。为此，您需要使用Ftrace。
- en: Using Ftrace
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Ftrace
- en: The kernel function tracer has tracers to help track down kernel latencies—that
    is what it was originally written for, after all. These tracers capture the trace
    for the worst-case latency detected during a run, showing the functions that caused
    the delay.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 内核函数跟踪器有助于跟踪内核延迟，这也是它最初编写的目的。这些跟踪器捕获运行期间检测到的最坏情况延迟的跟踪，显示导致延迟的函数。
- en: 'The tracers of interest, together with the kernel configuration parameters,
    are as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 兴趣跟踪器以及内核配置参数如下：
- en: '`irqsoff`: `CONFIG_IRQSOFF_TRACER` traces code that disables interrupts, recording
    the worst case.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`irqsoff`: `CONFIG_IRQSOFF_TRACER`跟踪禁用中断的代码，记录最坏情况。'
- en: '`preemptoff`: `CONFIG_PREEMPT_TRACER` is similar to `irqsoff` but traces the
    longest time that kernel preemption is disabled (only available on preemptible
    kernels).'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`preemptoff`: `CONFIG_PREEMPT_TRACER`类似于`irqsoff`，但跟踪内核抢占被禁用的最长时间（仅适用于可抢占内核）。'
- en: '`preemptirqsoff`: Combines the previous two traces to record the longest time
    either `irqs` and/or preemption are disabled for.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`preemptirqsoff`: 结合前两个跟踪器，记录禁用`irqs`和/或抢占的最长时间。'
- en: '`wakeup`: Traces and records the maximum latency that it takes for the highest
    priority task to get scheduled after it has been woken up.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wakeup`: 跟踪并记录最高优先级任务在唤醒后调度所需的最大延迟。'
- en: '`wakeup_rt`: This is the same as wakeup but only for real-time threads with
    the `SCHED_FIFO`, `SCHED_RR`, or `SCHED_DEADLINE` policies.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wakeup_rt`: 这与wakeup相同，但仅适用于具有`SCHED_FIFO`、`SCHED_RR`或`SCHED_DEADLINE`策略的实时线程。'
- en: '`wakeup_dl`: This is the same but only for deadline-scheduled threads with
    the `SCHED_DEADLINE` policy.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wakeup_dl`: 这是相同的，但仅适用于具有`SCHED_DEADLINE`策略的期限调度线程。'
- en: Be aware that running Ftrace adds a lot of latency, in the order of tens of
    milliseconds, every time it captures a new maximum, which Ftrace itself can ignore.
    However, it skews the results of user space tracers such as `cyclictest`. In other
    words, ignore the results of `cyclictest` if you run it while capturing traces.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，运行Ftrace每次捕获新的最大值时都会增加大量延迟，通常在几十毫秒左右，而Ftrace本身可以忽略这些延迟。然而，这会扭曲`cyclictest`等用户空间追踪工具的结果。换句话说，如果你在捕获追踪时运行`cyclictest`，请忽略其结果。
- en: 'Selecting the tracer is the same as for the function tracer we looked at in
    [*Chapter 20*](Chapter_16.xhtml#_idTextAnchor538). Here is an example of capturing
    a trace for the maximum period with preemption disabled for a period of 60 seconds:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 选择追踪器的方法与我们在[*第20章*](Chapter_16.xhtml#_idTextAnchor538)中看到的函数追踪器相同。下面是一个示例，展示了在禁用抢占的情况下捕获最大时长的追踪，持续60秒：
- en: '[PRE11]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The resulting trace, heavily edited, looks like this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 结果追踪，经过大量编辑，类似这样：
- en: '[PRE12]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, you can see that the longest period with kernel preemption disabled while
    running the trace was `1160` microseconds. This simple fact is available by reading
    `/sys/kernel/debug/tracing/tracing_max_latency`, but the previous trace goes further
    and gives you the sequence of kernel function calls that led up to that measurement.
    The column marked `delay` shows the point on the trail where each function was
    called, ending with the call to `trace_preempt_on()` at `1162us`, at which point
    kernel preemption is once again enabled. With this information, you can look back
    through the call chain and (hopefully) work out whether this is a problem or not.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到在运行追踪时，禁用内核抢占的最长时间为`1160`微秒。这个简单的事实可以通过读取`/sys/kernel/debug/tracing/tracing_max_latency`得到，但之前的追踪进一步提供了导致该测量的内核函数调用序列。标记为`delay`的列显示了每个函数调用的点，最后是`trace_preempt_on()`在`1162us`时被调用，这时内核抢占重新启用。有了这些信息，你可以回溯调用链并（希望）弄清楚这是否是一个问题。
- en: The other tracers mentioned work in the same way.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 其他提到的追踪器工作原理相同。
- en: Combining cyclictest and Ftrace
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结合cyclictest和Ftrace
- en: If `cyclictest` reports unexpectedly long latencies, you can use the `breaktrace`
    option to abort the program and trigger Ftrace to obtain more information.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`cyclictest`报告了异常长的延迟，你可以使用`breaktrace`选项来中止程序，并触发Ftrace以获取更多信息。
- en: 'You invoke `breaktrace` using `-b<N>` or `--breaktrace=<N>`, where `N` is the
    number of microseconds of latency that will trigger the trace. You select the
    Ftrace tracer using `-T[tracer name]` or one of the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`-b<N>`或`--breaktrace=<N>`来调用`breaktrace`，其中`N`是触发追踪的延迟微秒数。你可以使用`-T[tracer
    name]`或以下选项选择Ftrace追踪器：
- en: '`-C`: Context switch'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-C`: 上下文切换'
- en: '`-E`: Event'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-E`: 事件'
- en: '`-f`: Function'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-f`: 函数'
- en: '`-w`: Wakeup'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-w`: 唤醒'
- en: '`-W`: Wakeup-RT'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-W`: 唤醒-实时'
- en: 'For example, this will trigger the Ftrace function tracer when a latency greater
    than `100` microseconds is measured:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当测量到大于`100`微秒的延迟时，这将触发Ftrace函数追踪器：
- en: '[PRE13]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We now have two complementary tools for debugging latency issues. `cyclictest`
    detects the pauses and Ftrace provides the details.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有两个互补的工具来调试延迟问题。`cyclictest`检测暂停，Ftrace提供详细信息。
- en: Summary
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: The term *real-time* is meaningless unless you qualify it with a deadline and
    an acceptable miss rate. When you have these two pieces of information, you can
    determine whether or not Linux is a suitable candidate for the operating system
    and, if so, begin to tune your system to meet the requirements. Tuning Linux and
    your application to handle real-time events means making it more deterministic
    so that the real-time threads can meet their deadlines reliably. Determinism usually
    comes at the price of total throughput, so a real-time system is not going to
    be able to process as much data as a non-real-time system.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '*实时*这个术语没有意义，除非你用一个截止时间和可接受的丢失率来限定它。当你拥有这两项信息时，你可以判断Linux是否适合作为操作系统，如果适合，接下来就可以开始调优你的系统以满足这些要求。调整Linux和你的应用程序以处理实时事件意味着使其更加确定性，从而保证实时线程能够可靠地按时完成任务。确定性通常是以总吞吐量为代价的，因此实时系统无法处理像非实时系统那样多的数据。'
- en: It is not possible to provide mathematical proof that a complex operating system
    such as Linux will always meet a given deadline, so the only approach is through
    extensive testing using tools such as `cyclictest` and Ftrace and, more importantly,
    using your own benchmarks for your own application.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 不能提供数学证明来表明像 Linux 这样的复杂操作系统总能满足给定的截止日期，因此唯一的做法是通过使用如`cyclictest`和 Ftrace 等工具进行广泛测试，更重要的是，使用您自己针对自己应用程序的基准测试。
- en: To improve determinism, you need to consider both the application and the kernel.
    When writing real-time applications, you should follow the guidelines given in
    this chapter about scheduling, locking, and memory.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高确定性，您需要同时考虑应用程序和内核。在编写实时应用程序时，您应遵循本章关于调度、锁定和内存的指导方针。
- en: The kernel has a large impact on the determinism of your system. Thankfully,
    there has been a lot of work on this over the years. Enabling kernel preemption
    is a good first step. If you still find that it is missing deadlines more often
    than you would like, then you might want to consider `PREEMPT_RT`. It can certainly
    produce low latencies, but you may have problems integrating the `PREEMPT_RT`
    kernel patch with an older (pre 6.12) vendor kernel for your particular board.
    You may instead, or in addition, need to embark on the exercise of finding the
    cause of the latencies using Ftrace and similar tools.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 内核对系统的确定性有很大影响。幸运的是，这些年来在这方面做了很多工作。启用内核抢占是一个很好的第一步。如果你仍然发现它比你希望的更频繁地错过截止日期，那么你可能需要考虑`PREEMPT_RT`。它确实可以产生低延迟，但你可能会遇到将
    `PREEMPT_RT` 内核补丁与旧版（6.12 之前）供应商内核集成到特定板上的问题。你可能还需要，或者需要额外，使用 Ftrace 和类似工具来寻找延迟的原因。
- en: 'That brings me to the end of this dissection of embedded Linux. Being an engineer
    of embedded systems requires a very wide range of skills, which includes a low-level
    knowledge of hardware and how the kernel interacts with it. You need to be an
    excellent system engineer who can configure user applications and tune them to
    work in an efficient manner. All of this has to be done with hardware that is,
    often, only just capable of carrying out the task. There is a quotation that sums
    this up: *An engineer can do for a dollar what anyone else can do for two*. I
    hope that you will be able to achieve this with the information I have presented
    during the course of this book.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我来到了嵌入式 Linux 解剖的结尾。作为嵌入式系统工程师需要具备非常广泛的技能，其中包括对硬件的低级了解以及内核如何与硬件交互。你需要成为一名出色的系统工程师，能够配置用户应用程序并调整它们以高效运行。所有这些都必须在硬件上完成，而这些硬件往往只是勉强能完成任务。这里有一句话总结了这一点：*一个工程师能用一美元做别人用两美元做的事*。希望你能通过本书中提供的信息实现这一点。
- en: Further study
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步学习
- en: '*Hard Real-Time Computing Systems: Predictable Scheduling Algorithms and Applications*,
    by Giorgio Buttazzo'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*硬实时计算系统：可预测的调度算法与应用*，作者：Giorgio Buttazzo'
- en: '*Multicore Application Programming: for Windows, Linux, and Oracle Solaris*,
    by Darryl Gove'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*多核应用程序编程：适用于 Windows、Linux 和 Oracle Solaris*，作者：Darryl Gove'
- en: Join our community on Discord
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers: [https://packt.link/embeddedsystems](https://packt.link/embeddedsystems)'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者讨论：[https://packt.link/embeddedsystems](https://packt.link/embeddedsystems)
- en: '![](img/QR_Code12308107448340296.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code12308107448340296.png)'
- en: '![](img/Packt_Logo_New1.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Packt_Logo_New1.png)'
- en: '[packt.com](https://www.packt.com)'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '[packt.com](https://www.packt.com)'
- en: Subscribe to our online digital library for full access to over 7,000 books
    and videos, as well as industry leading tools to help you plan your personal development
    and advance your career. For more information, please visit our website.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅我们的在线数字图书馆，全面访问超过7,000本书籍和视频，以及帮助您规划个人发展并推动职业生涯的行业领先工具。欲了解更多信息，请访问我们的网站。
- en: Why subscribe?
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么订阅？
- en: Spend less time learning and more time coding with practical eBooks and Videos
    from over 4,000 industry professionals
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过来自超过4,000名行业专业人士的实用电子书和视频，将学习时间减少，编程时间增加
- en: Improve your learning with Skill Plans built especially for you
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用特别为您定制的技能计划提高您的学习效率
- en: Get a free eBook or video every month
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每月获得一本免费的电子书或视频
- en: Fully searchable for easy access to vital information
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全可搜索，轻松访问重要信息
- en: Copy and paste, print, and bookmark content
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制粘贴、打印和书签内容
- en: At [www.packt.com](https://www.packt.com), you can also read a collection of
    free technical articles, sign up for a range of free newsletters, and receive
    exclusive discounts and offers on Packt books and eBooks.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [www.packt.com](https://www.packt.com)，你还可以阅读一系列免费的技术文章，注册各种免费的新闻通讯，并获得 Packt
    图书和电子书的独家折扣和优惠。
- en: Other Books You May Enjoy
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你可能会喜欢的其他书籍
- en: 'If you enjoyed this book, you may be interested in these other books by Packt:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢本书，可能也对 Packt 出版的其他书籍感兴趣：
- en: '[![](img/B22104_Mockup_Cover_High_Res.png)](https://www.packtpub.com/en-us/product/mastering-pytorch-9781801074308)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](img/B22104_Mockup_Cover_High_Res.png)](https://www.packtpub.com/en-us/product/mastering-pytorch-9781801074308)'
- en: '**The Embedded Linux Security Handbook**'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**嵌入式 Linux 安全手册**'
- en: Matt St. Onge
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Matt St. Onge
- en: 'ISBN: 978-1-83588-564-2'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 'ISBN: 978-1-83588-564-2'
- en: Understand how to determine the optimal hardware platform based on design criteria
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解如何根据设计标准确定最优硬件平台
- en: Recognize the importance of security by design in embedded systems
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认识到安全设计在嵌入式系统中的重要性
- en: Implement advanced security measures such as TPM, LUKS encryption, and Secure
    Boot processes
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现先进的安全措施，如 TPM、LUKS 加密和安全启动过程
- en: Discover best practices for secure life cycle management, including appliance
    update and upgrade mechanisms
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现安全生命周期管理的最佳实践，包括设备更新和升级机制
- en: Create a secure software supply chain efficiently
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高效创建安全的软件供应链
- en: Implement childproofing by controlling access and resources on the appliance
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过控制设备上的访问和资源来实现防篡改功能
- en: '[![](img/B17934.png)](https://www.packtpub.com/en-us/product/building-llm-powered-applications-9781835462317)'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](img/B17934.png)](https://www.packtpub.com/en-us/product/building-llm-powered-applications-9781835462317)'
- en: '**Linux Device Driver Development, Second Edition**'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '**Linux 设备驱动开发（第二版）**'
- en: John Madieu
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: John Madieu
- en: 'ISBN: 978-1-80324-006-0'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 'ISBN: 978-1-80324-006-0'
- en: Download, configure, build, and tailor the Linux kernel
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载、配置、构建并定制 Linux 内核
- en: Describe the hardware using a device tree
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用设备树描述硬件
- en: Write feature-rich platform drivers and leverage I2C and SPI buses
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写功能丰富的平台驱动程序，并利用 I2C 和 SPI 总线
- en: Get the most out of the new concurrency managed workqueue infrastructure
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 充分利用新并发管理的工作队列基础设施
- en: Understand the Linux kernel timekeeping mechanism and use time-related APIs
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Linux 内核时间管理机制并使用与时间相关的 API
- en: Use the regmap framework to factor the code and make it generic
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 regmap 框架来提取代码并使其通用
- en: Offload CPU for memory copies using DMA
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 DMA 卸载 CPU 进行内存拷贝
- en: Interact with the real world using GPIO, IIO, and input subsystems
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 GPIO、IIO 和输入子系统与现实世界进行交互
- en: Packt is searching for authors like you
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Packt 正在寻找像你这样的作者
- en: If you’re interested in becoming an author for Packt, please visit [authors.packtpub.com](https://authors.packtpub.com)
    and apply today. We have worked with thousands of developers and tech professionals,
    just like you, to help them share their insight with the global tech community.
    You can make a general application, apply for a specific hot topic that we are
    recruiting an author for, or submit your own idea.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有兴趣成为 Packt 的作者，请访问 [authors.packtpub.com](https://authors.packtpub.com)
    并立即申请。我们与成千上万的开发者和技术专业人士合作，帮助他们与全球技术社区分享他们的见解。你可以提交一般申请，申请我们正在招募作者的特定热门话题，或者提交你自己的想法。
- en: Share your thoughts
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分享你的想法
- en: Now you’ve finished *Mastering Embedded Linux Development, Fourth Edition*,
    we’d love to hear your thoughts! If you purchased the book from Amazon, please
    [click here to go straight to the Amazon review page](https://packt.link/r/1803232595)
    for this book and share your feedback or leave a review on the site that you purchased
    it from.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经完成了 *《深入掌握嵌入式 Linux 开发（第四版）》*，我们非常期待听到你的想法！如果你是在亚马逊购买的本书，请 [点击这里直接前往亚马逊的评论页面](https://packt.link/r/1803232595)，分享你的反馈或留下评论。
- en: Your review is important to us and the tech community and will help us make
    sure we’re delivering excellent quality content.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 你的评论对我们和技术社区都很重要，能够帮助我们确保提供高质量的内容。
