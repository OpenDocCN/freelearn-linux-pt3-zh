# 20

# 使用 Terraform 自动化云部署

上一章尤为有趣：我们能够在云中部署 Ubuntu，利用**亚马逊网络服务**（**AWS**）。在云中部署基础设施非常强大，允许我们完成通常无法实现（或非常繁琐）的事情。我们可以在几分钟内启动 Ubuntu 实例，甚至设置自动恢复，以应对通常会导致完全服务中断的情况。

这一次，我们将再次处理云部署，并了解一个名为**Terraform**的强大工具，它将允许我们自动化我们的云资源的配置。在*第十五章*，*使用 Ansible 自动化服务器配置*中，我们已经探讨了自动化的概念，并了解了 Ansible 的基础知识。Terraform 使我们能够将我们的自动化提升到一个新的水平，甚至可以直接与 AWS 等服务提供商进行交互。

在本章中，我们将探讨以下概念：

+   为什么自动化基础设施很重要

+   简介 Terraform 及其如何在您的工作流中适用

+   安装 Terraform

+   自动化 EC2 实例部署

+   使用 Terraform 管理安全组

+   使用 Terraform 销毁未使用的资源

+   将 Ansible 与 Terraform 结合以实现完整的部署解决方案

为什么自动化基础设施的构建如此重要？这样做有许多好处，我们将在下一节中看到其中一些好处。

# 为什么自动化基础设施很重要

关于基础设施自动化的话题非常广泛，它很容易就能值得一本书来讲述。事实上，不仅有专门的书籍，还有整个在线课程也是专门讲这个的。您可以使用许多不同的实用程序，每个都有其优缺点。我们有配置管理工具，如 Ansible、Chef 和 Puppet。我们在本书的早期已经看过 Ansible，并通过一些示例来了解其强大之处。当我们早些时候使用它时，我相信您立即看到了好处——不必手动构建解决方案是一件美妙的事情。

不得不强调不需要手动构建解决方案的重要性。也许最明显的好处是它可以节省你数小时甚至数天的工作时间。当我刚开始从事 IT 工作时，设置服务器总是一个手动任务。当然，你可以创建一个 Bash 脚本并通过这种方式自动化一些任务，但专门设计用于自动化的工具将更有效地处理任务。一个通常会因为设置大量服务器而感到不知所措的 IT 员工，通过自动化可以更快地完成相同的任务。并且通过节省的所有时间，IT 员工可以专注于其他任务，而不是将大部分时间花在一个任务上。

自动化的另一个好处是人为错误的可能性大大降低。当你构建自动化解决方案时，犯错误是不可避免的。你在编写脚本时可能会输入错误，导致语法错误，或者某些东西没有按照你预期的方式创建。但在你花时间构建并验证自动化脚本没有错误后，你可以反复运行它们，每次基础设施都会以相同的方式创建。对比每次手动设置服务器以实施新解决方案时，错误可能会发生的频率，你可以想象有多少次可能需要修正的错误，其中一些甚至可能直到后期才被发现。

自动化还有一个你可能没有预料到的好处——**灾难恢复**。虽然我们将在*第二十三章*《防止灾难》中详细讨论灾难恢复，但现在值得一提的是，制定一个有效的自动化解决方案将使恢复过程更加迅速。作为管理员，最糟糕的噩梦之一就是想象对组织至关重要的服务器某天可能会出现故障，但这却是生活的一个事实。

我们的组织可能有一个非常复杂的应用程序，包含一个或多个 Web 服务器、负载均衡器、安全设置等。手动重建这样的解决方案可能需要几个小时。但通过自动化，你只需要运行你的脚本，就能在几分钟内重建相同的解决方案。自动化本身无法保护你免于丢失数据（这将是一个更可怕的问题），但至少它可以帮助你比手动操作更快地配置替代资源。不仅如此，我推测你的客户（以及你的上司）会更希望你的组织的应用程序在几分钟内恢复上线，而不是几个小时或几天。

此外，你的自动化脚本可以作为一种活文档形式存在。即使你不打算重新配置你的服务器和相关基础设施，其他管理员也可以查看你的自动化脚本，更好地理解整体解决方案中包含哪些组件，这样如果他们接管了基础设施的管理工作，也能更快地上手。

自动化是那种我可能不需要费力推销的东西，因为如果你已经有过 IT 工作经验，你自然知道手动重建服务器是多么繁琐。

有时候，可能会感觉我们要完成的任务比工作日里的小时数还多。但是通过自动化，我们可以找回一些时间，甚至可能稍微降低一点压力。而且这并不是我们第一次使用自动化；我们在本书的早些章节已经看过 Ansible，所以你大概已经非常清楚它的好处。不过，在本章中，我们将实现比 Ansible 更低层次的自动化，我们将使用一个叫做**Terraform**的解决方案。你可能会问，Terraform 是什么？在科学领域，地球化学是一项令人惊叹的过程，它将一个无法居住的星球转变为一个能够支持我们已知生命的星球。但在我们的用途中，Terraform 是一个我们可以用来自动化整个云计算实现的强大工具。接下来的部分，我们会更详细地定义它。

# Terraform 介绍以及它如何融入你的工作流

Terraform 是由一家名为 Hashicorp 的公司创建的一个令人惊叹的工具，它可以在比 Ansible、Puppet 或其他配置管理解决方案更低的层次上自动化你的基础设施。事实上，Terraform 通常不会替代这些工具，而是与它们互补。使用配置管理工具时，我们通常需要首先创建初始服务器并设置操作系统，然后才能实现它们。虽然 Ansible 实际上有方法可以用来创建基础设施组件，但这超出了本书的范围。

不仅如此，虽然 Ansible 可以创建某些类型的基础设施，但这并不是它最擅长的。为了理解像 Terraform 这样的工具的作用，最好将 Terraform 看作是用来创建事物的存在，而 Ansible 则是用来处理已经存在的事物，确保它们的配置正确。

在 Terraform 本身方面，它让你能够利用一个非常棒的概念——**基础设施即代码**。在上一章，我们在 AWS 中设置了一个完整的负载均衡应用。我们创建了一个 EC2 实例，以及一个 AMI，然后建立了负载均衡器和自动扩展功能。尽管这个过程非常有趣，但它是手动的。如果在过程中犯了错误，你必须去修复它们。完成后，你的解决方案已经创建并正常运行。Terraform 让我们能够编写代码，表示我们想要的最终状态。当它运行时，它会检查云提供商并进行库存检查。如果我们在脚本中添加的内容在云提供商处不存在，它会确保当前状态与我们代码中的最终状态一致。我们甚至可以在首次登录 AWS 后，不再登录，直接提供整个云解决方案。

在选择自动化工具时，一个重要的考虑因素是工具是否**跨平台**。许多云服务提供商都有内置工具，可以实现 Terraform 所做的相同功能。例如，AWS 有一个叫做 **CloudFormation** 的功能，允许你像使用 Terraform 一样脚本化基础设施的构建。但问题在于，CloudFormation 只针对 AWS 特定设计。你无法使用该服务在微软 Azure 或 Google Cloud 中构建基础设施。跨平台工具可以在任何环境中运行。我们之前在本书中已经看到过 Ansible：Ansible 不在乎你配置的服务器是位于 AWS，还是即使它们是机架中的物理机器。对 Ansible 来说，Ubuntu 就是 Ubuntu，无论它运行在哪个环境中。这让你可以在多个环境中使用相同的工具，而无需为每个环境重新创建一套自动化脚本。Terraform 同样也是一个跨平台工具。

为什么工具是否跨平台很重要？如果你需要维护多个完全不同的工具来执行相同的任务，那就是浪费时间。如果你能够学会使用一个工具，并且能够在你支持的每个环境中使用它，那么维护负担会小得多。这也是我一直建议避免使用平台特定工具的原因，比如 AWS 中的 CloudFormation。AWS 里甚至还有一个名为 **OpsWorks** 的工具，它用于与 Ansible 相同的目的（配置管理），但同样只限于 AWS。

一个典型的组织会在公司发展的不同阶段多次进行调整。一个 100%使用 AWS 基础设施的组织，有一天可能会决定支持其他云服务提供商。有时候，正是因为遇到了合适的客户或情况，才会促使公司考虑在一个通常不考虑的项目中使用其他云服务提供商。

也有可能是因为当前平台发生了变动导致成本增加，或者其他原因，企业可能会更换主要的服务提供商。如果你使用跨平台工具，那么在更换服务提供商时，你大部分的工具仍然可以带走。此外，能够支持多个服务提供商不仅使你成为一个更强大的管理员，还能为你的组织提供额外的价值。

不过，Terraform 在不同云平台之间并不会 100% 一致。其语法会根据云服务提供商的不同而有所变化。目前，似乎还没有一个可以在不同环境之间 100% 可移植的基础设施即代码（IaC）解决方案。但考虑到像 CloudFormation 这样的解决方案在其他平台间是完全不可转移的，Terraform 相比之下仍然占优，因为它是一个可以在多个服务提供商间使用的工具。Terraform 的通用工作原理在每个提供商之间都保持一致，因此即便你更换服务提供商，使用它依然能够节省时间。

Terraform 是如何工作的？我们将在下一节安装 Terraform，并在随后的节中使用它来部署 EC2 实例。但简而言之，Terraform 是一个你可以下载到本地笔记本电脑或台式机的工具，使用它将脚本文件转化为实际的基础设施。它支持许多不同的云平台，如 AWS、GCP 等。它甚至支持虚拟私人服务器（VPS）提供商，如 Digital Ocean 和 Linode。Terraform 将每个平台称为提供商，并允许你在 Terraform 中下载适当的插件，以支持你选择的提供商。

正如本章后面所提到的，Terraform 允许你先测试配置，并预览它将进行的更改。然后，如果你接受这些更改，它将连接到你的服务提供商，并根据你在代码中定义的方式创建基础设施。尽管我们本章不会涉及版本控制，但典型的组织会将其 Terraform 代码存储在 Git 仓库或其他版本控制系统中，以防止代码被意外删除。在典型的组织中，一个或多个管理员将与 Terraform 代码一起工作，并将他们的更改推送到仓库中。

在下一节中，我们将详细介绍安装 Terraform 的过程，这样我们就可以准备好一切，开始围绕我们的基础设施构建自动化。

# 安装 Terraform

运行 Terraform 并使用它来配置云资源的过程通常是在本地笔记本电脑或台式机上启动的。Terraform 本身是从其官方网站下载的，并且适用于所有主流操作系统。

与大多数应用程序不同，Terraform 没有安装程序。Terraform 是直接从你下载的文件运行的；没有需要经过的安装过程。如果你愿意，你可以将其安装到系统范围内，但你也可以从任何你希望的目录中运行它。Terraform 的下载文件位于以下网址：[`www.terraform.io/`](https://www.terraform.io/)。

到达该网站后，你应该能看到一个 **下载** 按钮：

![](img/B18425_20_01.png)

图 20.1：Terraform 网站

点击 **下载** 按钮后，你会看到一个新页面，提供适用于六种不同操作系统的 Terraform，包括常见的 Linux、macOS 和 Windows。大多数情况下，它会自动选择你访问该网站时使用的操作系统。例如，以下是下载 macOS 版本时页面的样子：

![](img/B18425_20_02.png)

图 20.2：Terraform 网站，macOS 下载页面

此时，你只需下载适合你操作系统的 Terraform 版本。如今大多数电脑都是 64 位的，所以选择要下载的版本应该很简单。如果你想在树莓派上运行 Terraform，请选择适用于 Linux 的 Arm 版本。下载后，你将得到一个本地的 ZIP 文件，解压后，你会找到一个名为`terraform`的二进制文件，这就是你实际需要的全部。

你将能够直接在操作系统的命令提示符中运行`terraform`：

![](img/B18425_20_03.png)

图 20.3：在终端窗口中运行 terraform，无任何选项

在截图中，我输入了下载并解压后的`terraform`文件的完整路径，该文件保存在我的主目录下的`downloads`文件夹中。我没有使用任何选项运行它，因此它打印出了帮助页面。

如果你想系统范围内安装它，可以将`terraform`移到`/usr/local/bin`目录下，如果你使用的是 Linux 或 macOS：

```
sudo mv terraform /usr/local/bin 
```

`/usr/local/bin`目录被 Linux 和 macOS 都识别为会搜索二进制文件的目录。这个概念被称为你的`$PATH`，它是一个特殊的变量，包含了你个人资料设置中定义的所有目录，用于执行命令时查找。这种将新目录添加到`$PATH`的方法在不同操作系统间有所不同，但对于 macOS 和 Linux 来说，`/usr/local/bin`已经被识别，因此当你将`terraform`复制到该目录时，你应该能够直接在终端中输入`terraform`，而不需要每次都输入完整的路径。这个操作是可选的，但它使得操作更简便。

为了让 Terraform 能够与 AWS 配合使用，我们需要为它生成一个 API 密钥。这是在 AWS 管理控制台中完成的，你现在应该登录到控制台，以便我们创建所需的内容。在上一章中，我们讨论了 IAM，这是 AWS 中的一项服务，它不仅允许你为其他管理员创建用户账户，还能为程序化访问创建密钥。后者将是我们允许 Terraform 连接到我们的 AWS 账户，并代表我们执行任务的方式。

在 AWS 管理控制台的 IAM 部分，点击左侧菜单中的**用户**链接，然后点击该页面上你应该能看到的蓝色**添加用户**按钮。接下来会出现如下表单：

![](img/B18425_20_04.png)

图 20.4：创建用于运行 Terraform 的 IAM 用户

在我的情况下，我决定将用户命名为`terraform-provisioner`，但你可以使用任何你喜欢的名称。我勾选了**程序访问**旁边的框，并且没有勾选第二个框，因为我不希望该用户能够登录到控制台。点击**下一步：权限**继续。在接下来的页面中，我们将设置用户能够访问的策略：

![](img/B18425_20_05.png)

图 20.5：为 Terraform 创建 IAM 用户（继续）

在这个界面中，点击**直接附加现有策略**的框以选中它，并勾选下面的框来为该对象添加**AdministratorAccess**策略。这是授予 Terraform 与 AWS 交互权限的策略。

点击**下一步：标签**继续，然后在下一个界面，你可以跳过添加标签（除非你想添加它们），接着点击**下一步：审查**，然后点击**创建用户**完成该过程。

最终显示的界面应该会报告过程成功，并且**下载 .csv**按钮可以让你下载密钥。你也可以通过点击**显示**按钮查看密钥，如我在*图 20.6*中所做的那样：

![](img/B18425_20_06.png)

图 20.6：为 Terraform 创建 IAM 用户（最终界面）

不过，我想先提醒你一些关于密钥的注意事项。首先，无论你是下载密钥还是点击**显示**按钮查看密钥，这是你唯一一次看到它的机会。你将不会再有机会下载完整的密钥。我建议你下载密钥并将其存储在一个安全的地方。你应该保护密钥，不让任何人访问它，绝对不要将它上传到版本控制仓库或任何其他公开资源中。你也绝对不要在书中以明文形式展示密钥，让很多人都能看到。如果这个密钥落入不法分子之手，那么任何拥有它的人都能与你的 AWS 账户交互。请小心保管这个密钥。我之所以在这里展示它，是因为我想让你看到整个过程的实际情况。在这本书的出版过程完成之前，我会从我的 AWS 账户中删除它。至于你，绝对不要让这个密钥泄漏！

现在我们有了一切所需的资源，可以继续使用 Terraform 构建 AWS 资源了。在下一节中，我们将创建一个 EC2 实例。

# 自动化 EC2 实例部署

让我们来看一个示例 Terraform 配置文件，它将帮助我们构建一个 EC2 实例：

```
provider "aws" {
    region = "us-east-1"
}
resource "aws_instance" "my-server-1" {
    ami                                   = "ami-09d56f8956ab235b3"
    associate_public_ip_address = "true"
    instance_type                         = "t2.micro"
    key_name                              = "jay_ssh"
    vpc_security_group_ids                = [ "sg-0597d57383be308b0" ]
    tags = {
        Name = "Web Server 1"
    }
} 
```

Terraform 文件以 `.tf` 文件扩展名保存，至于文件名，你可以随意命名。我将它命名为 `terraform_example_1.tf`。文件名中的下划线并不是必须的，但它能使命令行操作更方便，因为你不需要对空格进行转义。我将我的 `terraform_example_1.tf` 文件放在一个专门的目录中，这是推荐的做法。你的 Terraform 配置文件应该与其他文件分开，因此为这些文件创建一个专门的目录是理想的。

至于实际的代码，让我们一节一节地来看：

```
provider "aws" {
    region = "us-east-1"
} 
```

`provider` 块告诉 Terraform 我们将使用的提供程序类型。我们在这里设置为 `aws`。 正如前面提到的，Terraform 能够与各种云提供商合作，其中 AWS 只是其中之一。在此之下，我们将 `region` 变量设置为 `us-east-1`。建议您设置与上一章节使用的区域相同，这将使我们的过程更加简单，因为我们已经有一些可以重复使用的资源。

```
resource "aws_instance" "my-server-1" { 
```

在这里，我们开始一个新的资源块。每个提供程序都有自己的构建块（资源），特别是针对 AWS，我们可以使用 `aws_instance`。在这一行中，我们还给实例命名，并称其为 `my-server-1`。

请注意，这是我们在 Terraform 中提供的名称，而不是在 AWS 中实际使用的名称。在 Terraform 中，我们希望有一些名称来引用此特定的 AWS 实例，以便在其他地方需要引用时使用。

```
 ami                         = "ami-09d56f8956ab235b3" 
```

接下来，我们选择要用于我们实例的 AMI。如前一章节讨论的，AMI 是我们可以用来在 AWS 中构建服务器的映像。我在这里使用的实例 ID 是与 AWS 默认提供的官方 Ubuntu 22.04 AMI 相关联的。AMI 是特定于创建它们的区域，因此这里的实例 ID 是特定于 `us-east-1` 的。

如果您也在使用 `us-east-1`，则可以直接使用上述的 AMI ID（只要未来 AWS 没有用新的替换它）。如果有疑问，您可以进入 AWS 控制台，然后导航到 EC2 控制台，并按照手动创建基于 Ubuntu 的 EC2 实例的过程，从那里复制 AMI ID。甚至更简单的方法是，您可以使用由 Canonical 直接提供的 Amazon EC2 AMI Locator 来查找要使用的 AMI ID：[`cloud-images.ubuntu.com/locator/ec2/`](https://cloud-images.ubuntu.com/locator/ec2/)。

您可以按 Ubuntu 版本和位置过滤该列表。这样，您可以找到符合您选择区域的 Ubuntu 22.04 AMI 的 AMI ID。将示例代码中的 AMI ID 更改为您希望使用的 AMI ID。

您可能会注意到 `ami` 和 `=` `"ami-09d56f8956ab235b3"` 之间有很多空格。在 Terraform 语法中，将每行的等号对齐是一种常见的做法，这样可以使代码看起来更整洁。虽然不是必需的，如果您不完全对齐，也不会出现问题，但有些人可能会认为整体脚本看起来更清晰。

```
 associate_public_ip_address = "true" 
```

通过这行，我们决定在我们的实例中使用公共 IP 地址，如果我们希望能够远程访问它，则需要这样做。

```
 instance_type                          = "t2.micro" 
```

在这里，我们设置了我们新创建的服务器的所需实例类型。如前一章节讨论的，有多种实例类型可用，每种类型都有不同的成本。`t2.micro` 实例类型符合免费层条件，这就是我选择它的原因。

```
 key_name                                = "jay_ssh" 
```

在前一章中，当我们手动创建 EC2 实例时，其中的一部分过程是创建 OpenSSH 密钥。你创建的密钥已经注册到你的 AWS 账户，因此你可以通过你给它命名的名称来引用它。我将它命名为`jay_ssh`，但你需要将其更改为你为自己的密钥起的名字。你可以在 AWS 的 EC2 控制台中查看你的 OpenSSH 密钥列表；在菜单中有一个叫做**密钥对**的部分，如果你忘记了密钥的名字，可以在那里找到它。

```
 vpc_security_group_ids         = [ "sg-0597d57383be308b0" ] 
```

在上一章中，我们创建了一个安全组，允许 Apache 和 OpenSSH 与我们的实例通信。当你创建安全组时，它会被指定一个安全组 ID。我在示例中使用的安全组 ID 是系统为我生成的，因此对你无效。如果你访问 EC2 控制台中的**安全组**部分，你可以找到你创建的安全组的 ID。它的 ID 应该以`sg-`开头，后面跟着一串字符。将你的 ID 替换我示例中的 ID。

```
 tags = {
    Name = "Web Server 1"
  } 
```

在示例的最后部分，我们正在设置一个标签。如前一章所述，AWS 允许你创建标签，这些标签可以附加到实例上，提供关于其预期用途的附加信息。`Name`标签是一个特殊的标签，它会更改你在 AWS EC2 列表中看到的实例名称。你可以将其命名为任何你喜欢的名字。

此时，我们应该已经准备好运行 Terraform，使用我们的 Terraform 文件作为蓝图来创建实例。首先，我们需要为 Terraform 设置访问密钥和秘密访问密钥。在你的终端中，你可以输入以下命令来完成此操作：

```
export AWS_ACCESS_KEY_ID="AKIAVNXBZU2OBNWQQ7ET"
export AWS_SECRET_ACCESS_KEY="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" 
```

这些命令只是从你的终端运行，并创建包含所需密钥的环境变量。当 Terraform 运行时，它会查找`AWS_ACCESS_KEY_ID`和`AWS_SECRET_ACCESS_KEY`变量的存在，通过导出它们，我们让它们在当前会话中可用。实际上，你也可以将密钥直接添加到 Terraform 文件中，但我们不建议这么做，因为如果我们将整个文件上传到公共场所，密钥可能会被泄露。你也可以在 Terraform 文件中设置变量来包含这些密钥，但那超出了本章的讨论范围。

导出变量后，我们需要初始化 Terraform，以确保它拥有与 AWS 交互所需的所有组件：

```
terraform init 
```

使用这个示例，如果`terraform`工具不在共享的 `$PATH` 路径中，你可以添加完整路径，例如 `/usr/local/bin`，这是我之前提到的推荐位置。如果你将它复制到`/usr/local/bin`，那么你应该可以直接输入 `terraform`，而不需要完整路径。

`terraform init` 命令指示 Terraform 进行初始化。它会查看您当前工作目录中的所有 Terraform 文件，并查找 `provider` 行。在我们的案例中，这一行位于文件的开头。我们设置为 `aws`。这将触发 Terraform 下载 AWS 的提供程序插件：

![](img/B18425_20_07.png)

图 20.7：初始化 Terraform

从*图 20.7*中可以看到，当我在本地运行该命令时，它下载了 AWS 提供程序，以便进行后续使用。

接下来，我们应该运行一个叫做**Terraform 计划**的命令。运行该命令会指示 Terraform *不*进行任何更改，而是检查您的语法并确保您没有输入错误：

```
terraform plan 
```

`terraform plan` 命令不仅仅是检查语法，它还会连接到您的提供者，在我们这个例子中是 AWS，进行清单盘点，并将配置文件中的更改与提供者的当前状态进行比较。如果无法连接到提供者，则会返回错误。如果连接成功，Terraform 会列出它本来会做出的所有更改，前提是您指示它执行这些任务。在 `plan` 模式下，它永远不会实际执行任何指令，而只是为您提供预览。

如果由于某种原因 Terraform 无法连接到您的 AWS 账户，您应确保之前已运行过两个 `export` 命令，并且使用了正确的值。如果您关闭了终端窗口，您需要重新运行这些 `export` 命令，因为这些环境变量不会在终端会话之间持久化。如果成功，Terraform 计划将会运行：

![](img/B18425_20_08.png)

图 20.8：运行 Terraform 计划

在*图 20.8*中，我已经省略了大量输出。如果您的计划运行成功，Terraform 会提供有关所有更改的概览，这些更改本来会在您实际指示它来配置基础设施时发生。

如果您想要实际执行这些更改，您可以运行 Terraform `apply` 命令。然而，在执行之前，始终养成先查看计划输出的习惯。请注意输出中的以下一行：

```
Plan: 1 to add, 0 to change, 0 to destroy 
```

在我们的例子中，它不会销毁或更改任何内容，但如果运行，它会添加一些内容。如果您向上滚动，您可以找到更多关于它可能会做出的更改的详细信息，特别是如果我们运行 `apply` 的话。特别注意它可能想要销毁的内容。对于某些更改，Terraform 可能认为有必要删除某些内容并从头开始重新创建。如果您使用 Terraform 更新现有服务器，您很可能不希望删除该服务器。在这种情况下，请不要继续运行 `apply`。在您继续并实际让它执行任务之前，始终仔细审查 Terraform 想要做的更改*before*。

接下来，假设我们对更改已经感到满意，我们将继续执行 `apply`。请记住，虽然通过 Terraform 运行计划时，它会查找并报告语法错误，但计划过程通过且没有报告语法错误并不意味着没有错误。在实际运行之前，Terraform 能做的检查有限，因此可能存在它只能在 `apply` 过程中捕捉到的错误。正如你可以猜到的，运行 `apply` 的命令非常显而易见：

```
terraform apply 
```

当运行时，`terraform apply` 命令会再次进行健康检查，重新显示更改的数量，并询问你是否希望继续：

![](img/B18425_20_09.png)

图 20.9：运行 terraform apply 命令

接下来，输入 `yes` 并按 *Enter*。在运行过程中，你实际上可以看到正在创建的资源出现在 AWS 控制台中，随着它们的配置完成。在这里，以创建 EC2 实例为例，我们可以看到新的实例出现在列表中：

![](img/B18425_20_10.png)

图 20.10：由 Terraform 创建的 EC2 实例在 AWS 中的实例列表中显示

如果一切顺利，Terraform 本身会报告进程成功：

![](img/B18425_20_11.png)

图 20.11：成功的 terraform apply 过程

现在我们已经在 AWS 中创建了一个 EC2 实例，并且是通过自动化实现的。虽然目前它对我们帮助不大，但这只是一个概念验证。我们可以通过 Terraform 做很多事情。

不过，缺少了一样东西——安全性！我们还应该自动化将安全组添加到实例的过程，这样我们就能获取连接并管理实例所需的访问权限。现在我们能够访问该实例，但很可能它还没有外部互联网访问权限。在下一节中，我们将为实例配置安全组，这样我们就可以配置哪些端口是开放的，哪些 IP 地址能够与我们的实例进行通信。

# 使用 Terraform 管理安全组

安全组，如你在前一章中学到的，允许你控制哪些资源可以与其他资源进行通信。在上一节中，我们复用了上次创建的安全组，但理解如何从头开始创建一个安全组也是很有用的。

这是更新后的示例 Terraform 文件，添加了一些新的代码：

```
provider "aws" {
    region = "us-east-1"
}
resource "aws_instance" "my-server-1" {
    ami                                   = "ami-09d56f8956ab235b3"
    associate_public_ip_address = "true"
    instance_type                         = "t2.micro"
    key_name                              = "jay_ssh"
    vpc_security_group_ids        = [   "${aws_security_group.external_access.id}" ]
    tags = {
        Name = "Web Server 1"
    }
}
  resource "aws_security_group" "external_access" {
        name          = "my_sg"
        description = "Allow OpenSSH and Apache"
        ingress {
        from_port   = 22
        to_port        = 22
        protocol       = "tcp"
        cidr_blocks  = [ "172.11.59.105/32" ]
        description   = "Home Office IP"
    }
    ingress {
        from_port   = 80
        to_port        = 80
        protocol       = "tcp"
        cidr_blocks  = [ "172.11.59.105/32" ]
        description   = "Home Office IP"
    }
    egress {
        from_port = 0
        to_port = 0
        protocol = "-1"
        cidr_blocks = ["0.0.0.0/0"]
    }
} 
```

我在文件中添加了一个全新的章节，但在进入这一部分之前，我还修改了之前示例中的一行。它是第十行：

```
vpc_security_group_ids        = [ "${aws_security_group.external_access.id}" ] 
```

之前，我们将文件中的这一行的安全组 ID 设置为已经存在的安全组 ID，也就是我们在上一章创建的那个安全组 ID。接下来我所添加的配置将在文件的后面创建一个新的安全组，并且这里我将安全组 ID 设置为一个变量。`${aws_security_group.external_access.id}`变量在这里被 Terraform 视为**输出变量**。我们使用输出变量来表示安全组 ID，因为我们无法预知安全组 ID 是什么，因为新的安全组还没有创建。所以，我们在这里使用输出变量，并通过`.id`来引用我们将要创建的安全组（`external_access`）的 ID，这样一旦安全组创建完成，我们就可以引用它的 ID。这样，我们就可以在这里引用一个安全组并将其分配给实例，而不需要事先知道它的 ID。

在文件的后面，我们开始了一个新部分：

```
resource "aws_security_group" "external_access" { 
```

通过这一行，我们告诉 Terraform 我们希望创建另一个新的资源，这次是一个安全组。我们给这个安全组起了一个名为`external_access`的名字，这只是 Terraform 中的一个引用名称，并不是它在 AWS 中实际使用的名字。

```
 name          = "my_sg" 
```

这里，我们为安全组指定了它的实际名称，这是我们在 AWS 中看到的名称，而不是 Terraform 内部的名称。

```
 description = "Allow OpenSSH and Apache" 
```

对于`description`行，这里没有什么令人惊讶的地方：我们给它一个描述，用来解释其用途和安全组将要执行的功能。与我们在上一章手动创建的安全组类似，我们将通过这个安全组打开 OpenSSH 和 Apache。

```
 ingress {
      from_port   = 22
      to_port        = 22
      protocol       = "tcp"
      cidr_blocks  = [ "172.11.59.105/32" ]
      description   = "Home Office IP"
  } 
```

`ingress`块允许我们设置一个端口，允许从该端口接收连接；在这种情况下，我们允许从`22`端口接收连接，正如你可能已经知道的，`22`端口是 OpenSSH 的默认端口。我们不希望将此端口对所有公开互联网开放，因此我们只允许来自`172.11.59.105/32` IP 地址的流量进入该端口。

在你的情况下，你可以将其替换为你家庭办公室或组织的公共 IP 地址。

第二个`ingress`块与第一个相同，只是这次它允许连接到`80`端口用于 Apache：

```
 ingress {
      from_port   = 80
      to_port        = 80
      protocol       = "tcp"
      cidr_blocks  = [ "172.11.59.105/32" ]
      description   = "Home Office IP"
  } 
```

我们还添加了一个`egress`安全组规则，因为如果没有这个规则，我们的实例将无法访问互联网：

```
 egress {
      from_port = 0
      to_port = 0
      protocol = "-1"
      cidr_blocks = ["0.0.0.0/0"]
  } 
```

和之前的示例一样，我们需要先运行一个计划，然后再运行 `apply`，将我们的新代码变成现实。具体的操作我交给你来完成；只要没有输入错误，它应该会应用更改并添加新的安全组。在 AWS 中，你应该能在控制台看到新的安全组，并且它应该已应用到你的 EC2 实例上。除非你重复使用了上一章节中带有 Apache 的 AMI，否则你无法通过端口 `80` 连接到该实例，因为 Apache 很可能没有安装，但我添加了它来给你一个示例。

在这个阶段，我建议你先尝试一下我们目前的 Terraform 脚本，熟悉它的语法。你可以随意增加一些额外内容；可以参考 Terraform 文档，了解你可以使用 Terraform 创建的其他资源。

恭喜你成功使用 Terraform 来配置基础设施。现在，让我们用 Terraform 来销毁资源。

# 使用 Terraform 销毁未使用的资源

尽管 Terraform 的主要目的是创建基础设施，但它也可以用于删除基础设施。这一功能被称为**Terraform destroy**。使用 `destroy` 命令时，Terraform 会尝试删除配置文件中定义的所有基础设施。在此阶段，我们的配置文件创建了一个 EC2 实例以及一个安全组。如果我们运行 `destroy`，这两个资源都将被删除。

使用 Terraform 删除基础设施可能不会像创建资源那样频繁。但是，`destroy` 功能的一个价值在于，你可以通过删除文件中定义的所有内容来“重置”一个测试环境。然后，你可以使用同一脚本重新创建所有资源。在我这里，我通过不断打破和修复事物来加速学习。你真的不应该在生产环境中运行 `destroy`，尤其是对于那些你关心的基础设施，但如果你只是在一个没有重要实例的测试账户中使用 Terraform，那么你可以在学习过程中反复构建和拆解你的测试资源。另一个好处是，一个组织可以先在测试账户中为客户测试 Terraform 构建，然后再将其实施到生产环境中，你可以在为客户执行实际工作之前验证一切是否能够正确构建。

在 Terraform 中执行 `destroy` 和之前的示例一样简单：

```
terraform destroy 
```

就像之前一样，我们首先会获得确认，然后它会告诉我们当运行 `destroy` 任务时，Terraform 想要删除哪些内容：

![](img/B18425_20_12.png)

图 20.12：准备运行 terraform destroy 来删除资源

当你使用 `destroy` 选项运行 Terraform 时，请特别注意它想要删除的内容。截图没有显示完整的输出；它相当长。与 `apply` 类似，如果你向上滚动，你会看到输出中会包含有关如果我们同意继续，哪些内容将被删除的详细信息。如果你输入 `yes` 并按下 *Enter* 键，标识出的资源将被销毁，并且你会收到一条确认消息，确认任务已完成：

![](img/B18425_20_13.png)

图 20.13：销毁之前预配置资源后的最终确认

`terraform` 命令的基本用法结构清晰；我们了解了如何运行 `plan` 和 `apply`，现在也知道如何销毁资源，以便从一个干净的状态重新开始。学习 Terraform 时的大部分时间将花在学习其配置文件的语法上，但这会随着时间的推移而掌握。在我们旅程的这一阶段，我们应该已经打下了一个坚实的基础，能够在此基础上进行构建。

然而，我们还没有完成！在本章中我多次提到 Ansible，提醒你我们曾经用它来配置服务器。但如果我告诉你我们可以将 Terraform 和 Ansible 结合使用呢？我们当然可以，并且将在下一节中做到这一点。

# 将 Ansible 与 Terraform 结合使用，提供完整的部署解决方案

自动化工具的最大优点之一是它们通常可以结合使用，从而提供共享的好处。Ansible 是我最喜欢的工具之一：你可以自动化安装软件包、创建用户、复制文件或任何其他你能想到的任务。如果你能够在命令行上执行某个任务，Ansible 很可能能够自动化这个过程。Terraform，如你刚才看到的，非常擅长创建新的基础设施并自动化服务器、网络以及 AWS 和其他平台的初始设置。如果我们将这两者结合起来，效果会更好。

我发现 Terraform 和 Ansible 的组合非常合适。根据我的经验，结合这两种解决方案效果很好；我们可以使用 Terraform 创建初始的服务器和基础设施，然后用 Ansible 自动化未来的增强功能。但实际上，比这更好的是；我们可以配置 Terraform 来实际启动初始的 Ansible 运行，这样我们只需运行一个脚本。在 Terraform 创建基础设施后，额外的设置配置将交给 Ansible 来处理。这是一个很棒的组合。

它是如何工作的？在上一章中，我们探讨了用户数据的概念，它是 AWS 中的一项功能，允许你在实例创建时运行一个脚本。我们用它来安装所有补丁，然后继续安装 Apache。我们讲解的示例是一个简单的 Bash 脚本，本身并不算很令人兴奋。当然，它确实有效，但我们可以实现更好的解决方案。你知道吗？我们已经做到了。在*第十五章*，*使用 Ansible 自动化服务器配置*中，我们能够利用 Ansible Pull，这是一种特殊的 Ansible 模式，允许我们从仓库中拉取代码，并在我们的实例上本地运行。我们编写的 Ansible playbook 为我们安装了 Apache，就像我们在上一章中的 Bash 脚本做的一样。作为回顾，我们可以运行以下命令来触发 Ansible Pull：

```
ansible-pull -U https://github.com/myusername/ansible.git 
```

当然，这要求已经安装了 Ansible，而且仓库需要已经存在。如果你已经跟随这一章的内容并且仍然拥有我们创建的仓库，那么你已经具备了将 Ansible 与 Terraform 结合使用所需的一切。

为了避免你需要翻回*第十五章*，*使用 Ansible 自动化服务器配置*，这里是我们最终得到的 `local.yml` 文件：

```
---
- hosts: localhost
  become: true
  tasks:
  - name: Install Apache
    apt: name=apache2
  - name: Start the apache2 services
    service:
      name: apache2
      state: started
  - name: Copy index.xhtml
    copy:
      src: index.xhtml
      dest: /var/www/html/index.xhtml 
```

如你所见，这个 playbook 正在安装 Apache，启动它，并且将 `index.xhtml` 文件复制过去，以替换默认的网页。用 Terraform 实现这一点相当简单。以下是我们的 Terraform 脚本，新增的一行已加粗显示：

```
provider "aws" {
    region = "us-east-1"
}
resource "aws_instance" "my-server-1" {
    ami                                   = "ami-0dba2cb6798deb6d8"
    associate_public_ip_address = "true"
    instance_type                         = "t2.micro"
    key_name                              = "jay_ssh"
    vpc_security_group_ids         = [ "${aws_security_group.external_access.id}" ]
    user_data = file("bootstrap.sh")
    tags = {
        Name = "Web Server 1"
    }
}
resource "aws_security_group" "external_access" {
    name = "my_sg"
    description = "Allow OpenSSH and Apache"
    ingress {
      from_port   = 22
      to_port     = 22
      protocol    = "tcp"
      cidr_blocks = [ "173.10.59.105/32" ]
      description = "Home Office IP"
  }
  ingress {
      from_port   = 80
      to_port     = 80
      protocol    = "tcp"
      cidr_blocks = [ "173.10.59.105/32" ]
      description = "Home Office IP"
  }
  egress {
      from_port = 0
      to_port = 0
      protocol = "-1"
      cidr_blocks = ["0.0.0.0/0"]
  }
} 
```

文件的新内容在第 #11 行。我们引用了一个启动脚本，在这个脚本中，我们将添加任何我们希望在新创建的实例上运行的命令：

```
 user_data = file("bootstrap.sh") 
```

`bootstrap.sh` 文件需要与 Terraform 配置文件位于同一目录下。不过该文件尚未创建，所以请创建它，并在其中放入以下内容：

```
#!/bin/bash
sudo apt update
sudo apt install -y ansible
sudo ansible-pull -U https://github.com/myusername/ansible.git 
```

我们没有对文件进行过于复杂的修改，但我们所做的新增内容带来了巨大的好处。`user_data` 选项允许我们利用 AWS 内置的相同用户数据功能，并安排在实例首次创建时运行命令。在这个示例中，我们利用 `user_data` 选项对新实例运行一系列命令，安装 Ansible，然后启动 `ansible-pull` 来下载包含 Ansible playbook 的仓库并在本地运行。这个 playbook 本身是在*第十五章*，*使用 Ansible 自动化服务器配置*中设置的，所以我们只是利用我们以前已经创建的内容，让 Terraform 在启动实例时为我们触发 Ansible 作业。

这就带我们来到了本章的结束。我希望使用 Terraform 设置自动化的过程是一次有趣的体验；我自己确实很享受与它一起工作。

# 总结

有许多配置管理和资源提供工具可用于自动化我们的基础设施构建。在这一章中，我们介绍了 Terraform，并且将其与我们已经在使用的 Ansible 结合起来。通过使用 Terraform，我们能够自动化在 AWS 中创建一个 EC2 实例，并设置一个安全组来控制如何访问它。Terraform 是一个非常庞大的话题，本章中的概念只是一个开始。你可以用 Terraform 做很多事情，我强烈推荐你继续练习，尽快掌握它。

在下一章中，我们将学习一些可以用来为我们的 Ubuntu 服务器添加额外安全性的方式。虽然没有任何服务器是百分百安全的，但我们可以实施一些基本的安全措施，使服务器被攻破的可能性降低。这将是一个非常重要的章节，你一定不想错过。

# 加入我们在 Discord 的社区

加入我们社区的 Discord 空间，与作者和其他读者进行讨论：

[`packt.link/LWaZ0`](https://packt.link/LWaZ0)

![](img/QR_Code50046724-1955875156.png)
