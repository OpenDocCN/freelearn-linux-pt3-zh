- en: '*Chapter 17*: Advanced Shell Script Examples'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have done all we could to show you different ways scripts can be
    written, and we went through a lot of examples of how different tasks can be accomplished.
    In this chapter, we are going to implement all this in a much more complex way
    in **scripts** that can be used in real life.
  prefs: []
  type: TYPE_NORMAL
- en: The scripts we are going to show you in this chapter solve everyday problems
    for system administrators, from dealing with creating new users to working with
    **virtual machines** (**VMs**). By walking you through these examples, our aim
    is not only to show you how scripts should work but also what they should look
    like and how to approach writing them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following shell script examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a web server service and security settings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating users and groups from a standardized input file and a standardized
    password and forcing users to change them on the next login
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating users and groups from a standardized input file and a random password
    for every user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scripted VM installation on **Kernel-based Virtual Machine** (**KVM**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A shell script to provision `sudo` configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A shell script for VM administration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In almost all the other chapters, we were working with a generic setup that
    simply required any Linux distribution, as long as it could run a Bash shell.
    In this chapter, we are going to change things a bit—by necessity, these scripts
    will have to run on Ubuntu or any other Debian-based distribution. We are going
    to mention the reasons for this in the following recipes when something has to
    be done differently in order to make it happen on any other Linux distribution.
    So, in order to run scripts in this chapter, you need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A VM with Linux installed—we are using *Ubuntu 20.10*, but any Debian-based
    distribution will work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding of all the things we did in the previous chapters since we are
    going to presume you understand how Bash scripting works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, start your VM for us to start doing many useful things!
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a web server service and security settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this particular recipe, the idea is to use a small `shell` script to help
    us configure an already installed web server. We are going to enable our script
    to change where the web pages served by the server are located, but you will quickly
    see that changing any other option is easily added to this script.
  prefs: []
  type: TYPE_NORMAL
- en: 'By using this script, all users would have to do to get the system running
    is this:'
  prefs: []
  type: TYPE_NORMAL
- en: Install the web server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run the script to change where website files are located
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As always, the main problem when preparing something that will be a simple operation
    for the user is understanding and hiding all the complexity while making it reasonably
    easy for the administrator to add new features. How do we do this? Read on.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is our scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: A user has installed an Apache web server on their Ubuntu machine. They want
    to change the location of files that make up their website.
  prefs: []
  type: TYPE_NORMAL
- en: Before we go into this, we must work on our presumptions for this task, as is
    usual with almost any script.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we expect the web server to be already installed before we run the script,
    and we expect it to be Apache. The simplest way to do it is to use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now, we wait for the package manager to do its job.
  prefs: []
  type: TYPE_NORMAL
- en: Our script will not work with nginx or `lighttpd` nor any other web server since
    the configuration is parsed directly and there is no common way to set the parameters
    we require. Having said that, since the parsing we are using to change the configuration
    is pretty basic, if you need to modify this script to work with another server,
    it will probably take just a few minutes.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we are presuming that the user is changing the default website, one called
    `000-default.conf` in the configuration directory. This value is hardcoded in
    our script, which means that if you have multiple websites on the same server,
    this script will only change the one configured as default.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, administrators just add websites directly into this part of the configuration
    instead of creating new files for every site, as it should be done. Our script
    accomplishes its task by finding and replacing any mention of the `DocumentRoot`
    directive in the file. If we specify multiple `DocumentRoot` directives, the script
    is going to change all of them to the same value.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing we must think about is error checking. Inside the script itself,
    we are trying to catch if there was an error in the configuration, but the way
    we do it leaves a lot to be desired. Although our script will try to restore files
    to the state that it was before we changed their content, we are not trying to
    do any real syntax checking in the values that we are changing. This can prove
    to be a problem if the user makes an error when specifying the path they want
    to use, but there is no easy way to solve this; implementing a check that will
    be smart enough to scan for a valid path is too complicated for a task such as
    this.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the recipes in this chapter, we are going to first give you our version of
    the script and then explain the details we think are important. All the scripts
    are going to have plenty of comments inside them, and we strongly advise you to
    do the same if possible. Comments can also be used when creating a script to define
    a rough outline of all the things you want to do before you type out a single
    command.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s start with the script itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We need to note a few things here. Apache as a web server is right now the most
    used web server in all the distributions by default, but nginx is slowly becoming
    more and more popular. The thing to remember is that depending on the distribution
    package containing `apache`, this is called either `apache2` (on Debian-based
    distributions such as Ubuntu) or `httpd` (on Red Hat-based distributions such
    as **Red Hat Enterprise Linux** (**RHEL**) or CentOS). Other than the package
    name, there is a small difference in the placement of the configuration files
    for the server itself, although the syntax is exactly the same.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing is the firewall. Ubuntu uses `ufw` while CentOS uses `firewalld`.
    The third big thing to note is `apparmor` (Ubuntu) and `SELinux` (CentOS).
  prefs: []
  type: TYPE_NORMAL
- en: Our version of the script works on Debian-based machines. Slight modifications
    are needed if we want to use it on, for example, CentOS.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: https://www.digitalocean.com/community/questions/which-ufw-service-to-use-for-apache2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: https://www.tecmint.com/setup-ufw-firewall-on-ubuntu-and-debian/
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating users and groups and forcing users to change them on the next login
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most common things you are going to do on Linux machines is create
    a lot of users. There is a way to avoid this by using a centralized database for
    user authentication, but in reality, this is used only on machines in large deployments,
    so local users are still prevalent in most cases.
  prefs: []
  type: TYPE_NORMAL
- en: Having a way to deploy users and assign them passwords is something every admin
    needs whenever deploying a new server or desktop.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe calls for two things.
  prefs: []
  type: TYPE_NORMAL
- en: The `script` has to be used with administrative privileges since it changes
    users on the system. Also, we need to prepare a file containing a user list in
    advance.
  prefs: []
  type: TYPE_NORMAL
- en: Before we show you our script, we must also mention that there is more than
    one way to read and parse a file when getting values for our scripts. It makes
    sense to try to understand different ways of doing this in order to up your scripting
    game. For this exact reason, in this recipe and the next one, we decided to avoid
    using a `for` loop but instead opted to parse a file using arrays and delimiters.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we have become accustomed to, we are starting with our script before we
    note things to remember:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: There are a couple of concepts that we need to mention here. The first is dealing
    with passwords. Having any password readable in plaintext for any amount of time
    is a security risk, so the idea of making the user change their password as soon
    as possible is wise.
  prefs: []
  type: TYPE_NORMAL
- en: When creating passwords for new users, we basically have two choices—one is
    to create a list of users and passwords in advance, as we did in this example,
    and the other is to create a list of users and then assign them random passwords,
    as we will do in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you are dealing with any password, always remember that once a single
    user is compromised, you have a big security problem because a lot of ways to
    break into the system are depending on being able to run an application locally.
    Minimize the time anybody other than the user knows the password for the account,
    and never store passwords in a plain, readable format.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: https://linuxconfig.org/linux-reset-password-expiration-age-and-history
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.tecmint.com/force-user-to-change-password-next-login-in-linux/](https://www.tecmint.com/force-user-to-change-password-next-login-in-linux/%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating users and groups from a standardized input file and a random password
    for each user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we dealt with a way of creating new users. In this one,
    we are going to expand on this using a similar script to not only create new users
    but also assign them groups provided with the user, giving the administrator information
    on new user passwords.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are creating users, so this script has to be run under an administrator account.
    In this particular case, we also probably want to redirect the output of the script
    to some file since passwords for new users are created when the script is run,
    and passwords are not stored anywhere. If we don't save them somewhere, they are
    going to be lost and recreated.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous recipe, we mentioned that passwords should never be stored
    anywhere, but when creating new users, this is completely inevitable. We feel
    that the way we deal with passwords in this recipe is better than having them
    ready in advance since passwords in this script are created while the script is
    running so that the administrator can establish more control over them from the
    start:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'One thing to note in this script is that we are relying on a lot of messages
    from the commands we are using instead of checking things by ourselves. For example,
    if the user is already created, an error message is going to be created by `useradd`
    instead of us:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.1 – Error messages provided by commands inside the script'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_17.1_B16269.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.1 – Error messages provided by commands inside the script
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[https://superuser.com/questions/533126/how-to-execute-command-and-if-it-fails-execute-another-command-and-return-1](https://superuser.com/questions/533126/how-to-execute-command-and-if-it-fails-execute-another-command-and-return-1)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://linux.die.net/man/4/urandom](https://linux.die.net/man/4/urandom)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scripted VM installation on KVM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another common task done in some environments is creating new VMs from the command
    line. The reason we do this is usually flexibility and speed—using a **graphical
    user interface** (**GUI**) can be an **order of magnitude** (**OOM**) slower than
    using a **command-line interface** (**CLI**).
  prefs: []
  type: TYPE_NORMAL
- en: KVM provides a very simple solution for creating machines in the command line.
    All the user needs to know are some basic parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We, of course, need a functioning KVM on the server we are running this script
    on. Other than that, our script presumes the user understands all the different
    options that KVM requires to be able to create a machine. Before trying to understand
    how the script works, be sure to go through as much information as possible about
    creating VMs from the command line in order to be sure what the different options
    do. Also, refresh your knowledge about using the `dialog` toolkit for graphical
    interfaces since this script relies on this for input.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The only big thing in this small script is the way we are assigning values
    using `dialog`. As always, there are a couple of ways to do it. We are using the
    most logical one, for us at least:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: When using `dialog`, you must handle the way input from the user is redirected.
    In this example, we are using `–output-fd 1` in order to tell `dialog` to get
    everything redirected to **standard output** (**stdout**) where we can directly
    assign the values to variables.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[https://linux.die.net/man/1/dialog](https://linux.die.net/man/1/dialog)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.geeksforgeeks.org/creating-dialog-boxes-with-the-dialog-tool-in-linux/](https://www.geeksforgeeks.org/creating-dialog-boxes-with-the-dialog-tool-in-linux/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a shell script to provision SSH keys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The safest way to deal with passwords is to not use them at all. Using SSH keys
    is a great way of avoiding passwords completely if we are able to get a public
    key connected to a user account that the user can log in to without using the
    password, and since only their private key enables login, this makes the whole
    transaction much safer.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe deals with just such a task, installing a new machine that is going
    to serve as a LAMP server and that will enable users to log in using no passwords
    at all.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In reality, a script such as this will be used if we have a few servers to install
    and not too much time. An alternative to something like this would be to use a
    proper orchestration tool such as Ansible, but although it is an enormously powerful
    tool, Ansible is too complicated for small deployments.
  prefs: []
  type: TYPE_NORMAL
- en: In any case, this script presumes only that our server has a working internet
    connection to be able to get the packages that need to be installed and that we
    have acquired a public SSH key from the user we plan on creating.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are transferring the key by using a regular plaintext file. This is completely
    fine since it actually contains no information that can pose a security problem—in
    order to use SSH to connect, a user has to have a private key that corresponds
    to the public key we are using.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since this key is—or should be—controlled by only one particular user, we are
    not worried about safety here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[https://www.hostinger.com/tutorials/ssh-tutorial-how-does-ssh-work](https://www.hostinger.com/tutorials/ssh-tutorial-how-does-ssh-work)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.digitalocean.com/community/tutorials/how-to-install-linux-apache-mysql-php-lamp-stack-on-ubuntu-20-04](https://www.digitalocean.com/community/tutorials/how-to-install-linux-apache-mysql-php-lamp-stack-on-ubuntu-20-04)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A shell script for VM administration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some tasks are complicated to do from the command line, simply because we have
    a lot of commands that we have to repeat over and over again and then reuse the
    values that we got in one step in the step that follows it.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to deal with such a task, doing basic maintenance
    on a VM. What we plan to do is create a script that will enable the user to do
    a couple of standard tasks on VMs running on the local server, simplifying administration
    tasks and removing the need to remember long commands. Our plan is to enable the
    user to start, stop, check status, and revert a VM running on the local server.
    The script is going to provide the user with the list of machines and give them
    the opportunity to choose any available machines or apply the command to all of
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see what is needed for this task.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By this point, you have become accustomed to our disclaimers and requirements
    that we have to enable our script to run. This one is no different. First, this
    script requires one important thing—the server has to have support for KVM installed
    on it before we even begin to do anything. In the script itself, we are using
    a single command to accomplish all the tasks, but in reality, all of KVM needs
    to be installed and configured.
  prefs: []
  type: TYPE_NORMAL
- en: Another option is that this script can be, with minor modifications, used to
    perform tasks on other KVM hosts, but we will leave this as an exercise for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, before you start the script, do a small check if everything works, with
    a simple command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This should return a list of all the VMs running on your server. If there is
    any error, it needs to be sorted out before you even try to run the script itself
    since the script is based on this command working.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we are going to start with the script itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In this particular script, the main thing that we needed to decide on is how
    to handle two different conditions. The first condition is: *Are we dealing with
    a particular VM or all of them?* The second condition is: *What operation is needed?*'
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple of ways we can do this—we chose this one because it looks
    the most logical. We first give the user a list of all the machines on the host,
    and after they have decided which machine they want to run the command on, we
    ask them to select what they want to do.
  prefs: []
  type: TYPE_NORMAL
- en: We could have easily done this the other way around and let them choose the
    command first and then let them select the VM they want to perform it on.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing that we decided on was how to display the names of the machines.
    We are leaving it to the user to get the machine name right, and we are not doing
    any checks. One thing that could be done is to try to compare user input to the
    list of actual machine names. This way, if a user makes a mistake, we can catch
    it before the script tries to perform an operation on the invalid machine.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing that can be done in this, and in pretty much any script that has
    a lot of logical decisions and not enough checks, is to do a `try`-`catch` loop
    for the entire script so that we can deal with any possible errors without the
    script breaking completely and leaving us in an unknown state.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/virtualization_administration_guide/chap-virtualization_administration_guide-managing_guests_with_virsh
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://help.ubuntu.com/community/KVM/Virsh](https://help.ubuntu.com/community/KVM/Virsh)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
