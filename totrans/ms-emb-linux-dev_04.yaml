- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: All about Bootloaders
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 所有关于引导加载程序的内容
- en: The bootloader is the second element of embedded Linux. It is the part that
    starts the system and loads the operating system kernel. In this chapter, we will
    look at the role of the bootloader and how it passes control from itself to the
    kernel using a data structure called a **device tree**, also known as a **flattened
    device tree** or **FDT**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 引导加载程序是嵌入式 Linux 的第二个元素。它是启动系统并加载操作系统内核的部分。在本章中，我们将探讨引导加载程序的作用，以及它如何通过一个名为**设备树**的数据结构将控制权从自己传递给内核，设备树也称为**扁平设备树**或**FDT**。
- en: I will cover the basics of device trees so that you will be able to follow the
    connections described in a device tree and relate them to real hardware. I will
    focus on a popular open source bootloader known as U-Boot and show you how to
    use it to boot a target device. I will also show you how to customize U-Boot to
    run on a new device using BeaglePlay as an example.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我将介绍设备树的基础知识，以便您能够理解设备树中描述的连接并将其与实际硬件关联起来。我将重点介绍一个流行的开源引导加载程序 U-Boot，并展示如何使用它启动目标设备。我还将展示如何使用
    BeaglePlay 作为示例，自定义 U-Boot 以便在新设备上运行。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: What does a bootloader do?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引导加载程序的作用是什么？
- en: Boot sequence
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动顺序
- en: Moving from the bootloader to the kernel
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从引导加载程序到内核的过渡
- en: Introducing device trees
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍设备树
- en: U-Boot
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: U-Boot
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To work through the examples, make sure you have the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行示例操作，请确保您拥有以下内容：
- en: An Ubuntu 24.04 or later LTS host system with `device-tree-compiler`, `git`,
    `make`, `patch`, and `u-boot-tools` installed
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台安装有 `device-tree-compiler`、`git`、`make`、`patch` 和 `u-boot-tools` 的 Ubuntu
    24.04 或更高版本 LTS 主机系统
- en: A Bootlin toolchain for BeaglePlay from [*Chapter 2*](Chapter_01.xhtml#_idTextAnchor028)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个来自[*第二章*](Chapter_01.xhtml#_idTextAnchor028)的 BeaglePlay Bootlin 工具链
- en: A microSD card reader and card
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 microSD 卡读卡器和卡片
- en: A USB-to-TTL serial cable with a 3.3 V logic level
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一条 3.3 V 逻辑电平的 USB 到 TTL 串口电缆
- en: BeaglePlay
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BeaglePlay
- en: A 5 V USB-C power supply capable of delivering 3 A
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一款能够提供 3 A 电流的 5 V USB-C 电源
- en: 'All of the code for this chapter can be found in the `Chapter03` folder from
    the book’s GitHub repository: [https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter03](https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter03).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码可以在书籍的 GitHub 仓库中的 `Chapter03` 文件夹中找到：[https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter03](https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter03)。
- en: What does a bootloader do?
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引导加载程序的作用是什么？
- en: 'In an embedded Linux system, the bootloader has two main jobs: initializing
    the system to a basic level and loading the kernel. In fact, the first job is
    somewhat subsidiary to the second in that it is only necessary to get as much
    of the system working as is needed to load the kernel.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌入式 Linux 系统中，引导加载程序有两个主要任务：将系统初始化到基本状态并加载内核。实际上，第一个任务在某种程度上是从属于第二个任务的，因为它只需要将系统启动到足以加载内核的程度。
- en: When the first lines of the bootloader code are executed, following a power-on
    or reset, the system is in a very minimal state. The **Dynamic Random Access Memory**
    (**DRAM**) controller is not set up, so the main memory is not accessible. Likewise,
    other interfaces are not configured, so storage that’s accessed via **NAND** (**NOT
    AND**) **flash** controllers, **MultiMediaCard** (**MMC**) controllers, and so
    on is unavailable. Typically, the only resources that are operational at the beginning
    are a single CPU core, some on-chip **Static Random Access Memory** (**SRAM**),
    and the boot **Read-Only Memory** (**ROM**).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当引导加载程序的第一行代码在开机或重启后执行时，系统处于非常简化的状态。**动态随机存取内存**（**DRAM**）控制器尚未设置，因此主内存不可访问。同样，其他接口也没有配置，因此通过**NAND**（**非与**）**闪存**控制器、**多媒体卡**（**MMC**）控制器等访问的存储也不可用。通常，开始时唯一可用的资源是一个
    CPU 核心、一些片上**静态随机存取内存**（**SRAM**）和引导**只读存储器**（**ROM**）。
- en: A system bootstrap consists of several phases of code, each bringing more of
    the system into operation. The final act of the bootloader is to load the kernel
    into RAM and create an execution environment for it. The details of the interface
    between the bootloader and the kernel are architecture-specific, but in each case,
    it has to do two things. First, the bootloader has to pass a pointer to a structure
    containing information about the hardware configuration. Second, it has to pass
    a pointer to the kernel command line.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 系统启动包括几个阶段的代码，每个阶段使系统的更多部分投入运行。引导加载程序的最后一步是将内核加载到RAM中，并为其创建一个执行环境。引导加载程序与内核之间的接口细节是架构特定的，但在每种情况下，它需要做两件事。首先，引导加载程序必须传递一个指针，指向包含硬件配置相关信息的结构。其次，它必须传递一个指针，指向内核命令行。
- en: The kernel command line is a text string that controls the behavior of Linux.
    Once the kernel has begun executing, the bootloader is no longer needed and all
    the memory it was using can be reclaimed.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 内核命令行是一个文本字符串，用于控制Linux的行为。一旦内核开始执行，引导加载程序就不再需要，所有它所占用的内存可以被回收。
- en: A subsidiary job of the bootloader is to provide a maintenance mode for updating
    boot configurations, loading new boot images into memory, and maybe running diagnostics.
    This is usually controlled by a simple command-line user interface, commonly over
    a serial console.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 引导加载程序的一个辅助任务是提供一个维护模式，用于更新引导配置、将新的引导映像加载到内存中，甚至可能执行诊断。通常通过一个简单的命令行用户界面来控制，通常是通过串行控制台。
- en: Boot sequence
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动序列
- en: 'Some years ago, we only needed to place the bootloader in non-volatile memory
    at the reset vector of the processor. **NOR** (**NOT OR**) **flash** memory was
    common at that time and, since it can be mapped directly into the address space,
    it was the ideal method of storage. The following diagram shows such a configuration
    with the **reset vector** at `0xfffffffc` at the top end of an area of flash memory:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 几年前，我们只需要将引导加载程序放置在处理器的复位矢量处的非易失性存储器中。当时**NOR**（**非或**）**闪存**存储器很常见，并且由于它可以直接映射到地址空间，因此是理想的存储方法。以下图示展示了这样一种配置，其中**复位矢量**位于`0xfffffffc`，位于闪存区域的顶部：
- en: '![Figure 3.1 – NOR flash](img/B18466_03_01.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – NOR闪存](img/B18466_03_01.png)'
- en: Figure 3.1 – NOR flash
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – NOR闪存
- en: The bootloader is linked so that there is a jump instruction at that location
    that points to the start of the bootloader code. From that point on, the bootloader
    code running in NOR flash memory can initialize the DRAM controller so that the
    main memory – the **DRAM** – becomes available, and then it copies itself into
    the DRAM. Once fully operational, the bootloader can load the kernel from flash
    memory into DRAM and transfer control to it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 引导加载程序被链接，以便在该位置有一个跳转指令，指向引导加载程序代码的起始位置。从那时起，运行在NOR闪存中的引导加载程序代码可以初始化DRAM控制器，使得主内存——**DRAM**——变得可用，然后它将自己复制到DRAM中。引导加载程序完全运行后，可以将内核从闪存加载到DRAM中，并将控制权转交给内核。
- en: However, once you move away from a simple linearly addressable storage medium
    such as NOR flash, the boot sequence becomes a complex, multi-stage procedure.
    The details are very specific to each SoC, but they generally go through the following
    phases.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一旦你远离像NOR闪存这样简单的线性可寻址存储介质，启动序列就会变成一个复杂的多阶段过程。具体细节因每个SoC而异，但它们通常会经过以下几个阶段。
- en: Phase 1 – ROM code
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阶段1 – ROM代码
- en: In the absence of reliable external memory, the code that runs immediately after
    a reset or power-on is stored on-chip in the SoC. This is known as **ROM code**.
    It is loaded into the chip when it is manufactured, and hence the ROM code is
    proprietary and cannot be replaced by an open source equivalent.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有可靠外部存储器的情况下，复位或开机后立即运行的代码存储在SoC芯片上。这被称为**ROM代码**。它在芯片制造时就被加载，因此ROM代码是专有的，不能被开源等效物替代。
- en: ROM code does not include code to initialize the memory controller because DRAM
    configurations are highly device-specific, and so it can only use SRAM, which
    does not require a memory controller. Most embedded SoC designs have a small amount
    of SRAM on chip, varying in size from as little as 4 KB to several hundred KB.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ROM代码不包括初始化内存控制器的代码，因为DRAM的配置高度依赖于设备，因此只能使用不需要内存控制器的SRAM。大多数嵌入式SoC设计在芯片上都有少量的SRAM，大小从最小的4
    KB到几百KB不等。
- en: '![Figure 3.2 – Phase 1 – ROM code](img/B18466_03_02.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2 – 阶段1 – ROM代码](img/B18466_03_02.png)'
- en: Figure 3.2 – Phase 1 – ROM code
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – 阶段1 – ROM代码
- en: The ROM code can load a small chunk of code from one of several pre-programmed
    locations into SRAM. As an example, TI Sitara chips try to load code from the
    first few pages of NAND flash memory, or from flash memory connected through a
    **Serial Peripheral Interface** (**SPI**). They also try to load code from the
    first sectors of an MMC device like an eMMC chip or SD card, or from a file named
    **MLO** (**Memory Loader**) on the first partition of an MMC device. If reading
    from all these memory devices fails, then it tries reading a byte stream from
    Ethernet, USB, or UART. The latter is provided mainly as a way to load code into
    flash memory at production rather than for use in normal operation.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ROM代码可以从多个预编程位置之一加载一小段代码到SRAM中。例如，TI Sitara芯片尝试从NAND闪存的前几页或通过**串行外设接口**（**SPI**）连接的闪存加载代码。它们还尝试从像eMMC芯片或SD卡这样的MMC设备的第一个分区中名为**MLO**（**Memory
    Loader**）的文件中加载代码。如果从所有这些存储设备读取失败，则尝试从以太网、USB或UART读取字节流。后者主要用于在生产中将代码加载到闪存中，而不是用于正常操作。
- en: Most embedded SoCs have ROM code that works in a similar way. In SoCs where
    the SRAM is not large enough to load a full bootloader such as U-Boot, there needs
    to be an intermediate loader called the **Secondary Program Loader** (**SPL**).
    At the end of the ROM code phase, the SPL is present in the SRAM and the ROM code
    jumps to the beginning of that code.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数嵌入式SoC都有类似方式工作的ROM代码。在SRAM不足以加载诸如U-Boot之类的完整引导加载程序的SoC中，需要有一个称为**次级程序加载器**（**SPL**）的中间加载器。在ROM代码阶段结束时，SPL存在于SRAM中，并且ROM代码跳转到该代码的开头。
- en: Phase 2 – Secondary Program Loader
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第2阶段 – 次级程序加载器
- en: The SPL must set up the memory controller and other essential parts of the system
    in preparation for loading the **Tertiary Program Loader** (**TPL**) into DRAM.
    The functionality of the SPL is limited by the size of the SRAM. It can read a
    program from a list of storage devices, as can the ROM code, once again using
    pre-programmed offsets from the start of a flash device.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: SPL必须设置内存控制器和系统的其他重要部分，以准备将**第三级程序加载器**（**TPL**）加载到DRAM中。SPL的功能受SRAM大小的限制。它可以像ROM代码一样从存储设备列表中读取程序，再次使用从闪存设备起始处的预编程偏移量。
- en: 'If the SPL has filesystem drivers built into it, it can read well-known filenames
    such as `u-boot.img` from a disk partition. The SPL usually doesn’t allow any
    user interaction, but it may print version information and progress messages that
    you can see on the console. The following diagram displays the phase 2 architecture:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果SPL内置文件系统驱动程序，它可以从磁盘分区读取像`u-boot.img`这样的众所周知的文件名。通常SPL不允许用户交互，但它可能会打印版本信息和进度消息，您可以在控制台上看到。以下图显示了第2阶段的架构：
- en: '![Figure 3.3 – Phase 2 – SPL](img/B18466_03_03.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图3.3 – 第2阶段 – SPL](img/B18466_03_03.png)'
- en: Figure 3.3 – Phase 2 – SPL
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – 第2阶段 – SPL
- en: The preceding diagram shows the jump from ROM code to SPL. As the SPL executes
    within SRAM, it loads the TPL into DRAM. At the end of the second phase, the TPL
    is present in DRAM and the SPL can make a jump to that area.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图显示了从ROM代码到SPL的跳转。当SPL在SRAM中执行时，它将TPL加载到DRAM中。第二阶段结束时，TPL存在于DRAM中，SPL可以跳转到该区域。
- en: The SPL may be open source, as is the case with Atmel AT91Bootstrap, but it
    is quite common for it to contain proprietary code that is supplied by the manufacturer
    as a binary blob.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: SPL可能是开源的，例如Atmel AT91Bootstrap就是如此，但它通常包含供应商提供的作为二进制blob的专有代码。
- en: Phase 3 – Tertiary Program Loader
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3阶段 – 第三级程序加载器
- en: 'At this point, we are running a full bootloader, such as U-Boot, which we will
    learn about a bit later in this chapter. Usually, there is a simple command-line
    user interface that lets you perform maintenance tasks such as loading new boot
    and kernel images into flash storage, as well as a way to load the kernel automatically
    without user intervention. The following diagram explains the phase 3 architecture:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们正在运行一个完整的引导加载程序，例如U-Boot，稍后我们将在本章中详细了解。通常，有一个简单的命令行用户界面，可以让您执行维护任务，例如将新的引导和内核映像加载到闪存中，以及自动加载内核而无需用户干预。以下图解释了第3阶段的架构：
- en: '![Figure 3.4 – Phase 3 – TPL](img/B18466_03_04.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图3.4 – 第3阶段 – TPL](img/B18466_03_04.png)'
- en: Figure 3.4 – Phase 3 – TPL
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 – 第3阶段 – TPL
- en: The preceding diagram shows the jump from SPL in SRAM to TPL in DRAM. As the
    TPL executes, it loads the kernel into DRAM. We also have the choice of appending
    an FDT and/or initial RAM disk to the image in DRAM if we want. Either way, at
    the end of the third phase, there is a kernel in memory waiting to be started.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的图示展示了从SRAM中的SPL到DRAM中的TPL的跳转。当TPL执行时，它将内核加载到DRAM中。如果需要，我们还可以选择将FDT和/或初始RAM磁盘附加到DRAM中的镜像中。无论哪种方式，在第三阶段结束时，内存中都有一个等待启动的内核。
- en: Embedded bootloaders usually disappear from memory once the kernel is running
    and have no further part in the operation of the system. Before that happens,
    the TPL needs to hand off control of the boot process to the kernel.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式引导加载程序通常在内核运行后从内存中消失，不再参与系统的操作。在此之前，TPL需要将引导过程的控制权交给内核。
- en: Moving from the bootloader to the kernel
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从引导加载程序到内核的过渡
- en: 'When the bootloader passes control to the kernel, it has to pass some basic
    information, which includes the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当引导加载程序将控制权交给内核时，它必须传递一些基本信息，包括以下内容：
- en: The machine number, which is used on PowerPC and Arm platforms without support
    for a device tree, to identify the type of the SoC
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器号，在没有设备树支持的PowerPC和Arm平台上，用来标识SoC的类型
- en: Basic details of the hardware that’s been detected so far, including (at the
    very least) the size and location of the physical RAM and the CPU’s clock speed
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目前已检测到的硬件的基本信息，包括（至少）物理RAM的大小和位置以及CPU的时钟速度
- en: The kernel command line
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核命令行
- en: Optionally, the location and size of a device tree binary
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选地，设备树二进制文件的位置和大小
- en: Optionally, the location and size of an initial RAM disk, called the **initial
    RAM file system** (**initramfs**)
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选地，初始RAM磁盘的位置和大小，称为**初始RAM文件系统**（**initramfs**）
- en: The kernel command line is a plain ASCII string that controls the behavior of
    Linux by giving it, for example, the name of the device that contains the root
    filesystem. We will look at the kernel command line in detail in the next chapter.
    It is common to provide the root filesystem as a RAM disk, in which case it is
    the responsibility of the bootloader to load the RAM disk image into memory. We
    will cover how to create initial RAM disks in [*Chapter 5*](Chapter_05.xhtml#_idTextAnchor138).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 内核命令行是一个纯ASCII字符串，通过它可以控制Linux的行为，例如，指定包含根文件系统的设备名称。我们将在下一章详细介绍内核命令行。通常会提供根文件系统作为RAM磁盘，在这种情况下，引导加载程序的责任是将RAM磁盘镜像加载到内存中。我们将在[*第5章*](Chapter_05.xhtml#_idTextAnchor138)中介绍如何创建初始RAM磁盘。
- en: The way this information is passed is dependent on the architecture and has
    changed in recent years. For instance, with PowerPC, the bootloader simply used
    to pass a pointer to a board information structure, whereas with Arm, it passed
    a pointer to a list of A tags. There is a good description of the format of A
    tags in the kernel source tree at `Documentation/arch/arm/booting.rst`. Browse
    the kernel source tree at [https://github.com/torvalds/linux](https://github.com/torvalds/linux).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这种信息传递方式取决于架构，并且近年来发生了变化。例如，在PowerPC中，引导加载程序通常只会传递指向板级信息结构的指针，而在Arm中，它传递指向A标签列表的指针。关于A标签格式的详细描述可以在内核源代码树中的`Documentation/arch/arm/booting.rst`找到。你可以浏览内核源代码树：[https://github.com/torvalds/linux](https://github.com/torvalds/linux)。
- en: In both cases, the amount of information being passed is very limited, leaving
    the bulk to be discovered at runtime or hard-coded into the kernel as **platform
    data**. The widespread use of platform data meant that each board had to have
    a kernel configured and modified for that platform. A better way was needed, and
    that way is the device tree.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，传递的信息量都非常有限，剩下的部分要么在运行时发现，要么作为**平台数据**硬编码到内核中。平台数据的广泛使用意味着每块开发板都必须有一个为该平台配置和修改过的内核。需要一种更好的方法，而这种方法就是设备树。
- en: In the Arm world, the move away from A tags began in earnest in February 2013
    with the release of Linux 3.8\. Today, almost all Arm systems use device trees
    to gather information about the specifics of the hardware platform. This allows
    a single kernel binary to run on a wide range of Arm platforms.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在Arm领域，摆脱A标签的转变始于2013年2月，当时Linux 3.8发布。今天，几乎所有Arm系统都使用设备树来收集硬件平台的具体信息。这使得单一内核二进制文件可以在多种Arm平台上运行。
- en: Now that we’ve learned what a bootloader does, what the stages of the boot sequence
    are, and how it passes control to the kernel, let’s learn how to configure a bootloader
    so that it runs on popular embedded SoCs.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了引导加载程序的作用、引导序列的各个阶段以及它如何将控制权交给内核，接下来让我们学习如何配置一个引导加载程序，以便它能够在流行的嵌入式
    SoC 上运行。
- en: Introducing device trees
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍设备树
- en: If you are working with Arm or PowerPC SoCs, you are almost certainly going
    to encounter device trees at some point. This section aims to give you a quick
    overview of what they are and how they work. We will revisit the topic of device
    trees repeatedly throughout the course of this book.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用 Arm 或 PowerPC SoC，您几乎可以肯定在某个时刻会遇到设备树。本节旨在为您提供一个快速概述，了解设备树是什么以及它们如何工作。我们将在本书的后续章节中反复讨论设备树的话题。
- en: A device tree is a flexible way of defining the hardware components of a computer
    system. Bear in mind that a device tree is just static data, not executable code.
    Usually, the device tree is loaded by the bootloader and passed to the kernel,
    although it is possible to bundle the device tree with the kernel image itself
    to cater to bootloaders that are not capable of loading them separately.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 设备树是一种灵活的定义计算机系统硬件组件的方式。请记住，设备树只是静态数据，而不是可执行代码。通常，设备树由引导加载程序加载并传递给内核，尽管也可以将设备树与内核镜像捆绑在一起，以便支持那些无法单独加载设备树的引导加载程序。
- en: The format is derived from a Sun Microsystems bootloader known as **OpenBoot**,
    which was formalized as the Open Firmware specification (IEEE standard IEEE1275-1994).
    It was used in PowerPC-based Macintosh computers and so was a logical choice for
    the PowerPC Linux port. Since then, it has been adopted at a large scale by the
    many Arm Linux implementations and, to a lesser extent, by MIPS, MicroBlaze, ARC,
    and other architectures.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 该格式源自 Sun Microsystems 的引导加载程序 **OpenBoot**，并被正式化为 Open Firmware 规范（IEEE 标准
    IEEE1275-1994）。它曾被用于基于 PowerPC 的 Macintosh 计算机，因此是 PowerPC Linux 移植的一个合乎逻辑的选择。从那时起，它已被大量采用，广泛用于许多
    Arm Linux 实现，并在较小范围内应用于 MIPS、MicroBlaze、ARC 和其他架构。
- en: I recommend visiting [https://www.devicetree.org](https://www.devicetree.org)
    for more information.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议访问 [https://www.devicetree.org](https://www.devicetree.org) 获取更多信息。
- en: Device tree basics
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设备树基础
- en: The Linux kernel contains a large number of device tree source files in `arch/$ARCH/boot/dts`,
    and this is a good starting point for learning about device trees. Additionally,
    the U-Boot source code contains a smaller number of sources in `arch/$ARCH/dts`.
    If you acquired your hardware from a third party, the `dts` file forms part of
    the board support package, so you should expect to receive one along with the
    other source files.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 内核包含大量的设备树源文件，位于 `arch/$ARCH/boot/dts` 目录下，这里是学习设备树的一个很好的起点。此外，U-Boot
    源代码包含较少的源文件，位于 `arch/$ARCH/dts` 目录下。如果您从第三方获得了硬件，`dts` 文件是板卡支持包的一部分，因此您应该预期会收到它以及其他源文件。
- en: 'The device tree represents a computer system as a collection of components
    joined together in a hierarchy. Every device tree begins with a root node represented
    by a forward slash, `/`, which contains subsequent child nodes describing the
    hardware of the system. Each node has a name and contains several properties in
    the form `name = "value"`. Here is a simple example:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 设备树将计算机系统表示为一个层次结构中连接在一起的组件集合。每个设备树以一个根节点开始，该根节点由一个斜杠（`/`）表示，后续的子节点描述了系统的硬件。每个节点都有一个名称，并包含多个以
    `name = "value"` 形式的属性。以下是一个简单的示例：
- en: '[PRE0]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we have a root node that contains a `cpus` node and a `memory` node. The
    `cpus` node contains a single CPU node named `cpu@0`. The names of these nodes
    often include an `@` followed by an address that distinguishes the node from other
    nodes of the same type. `@` is required if the node has a `reg` property.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个根节点，它包含一个 `cpus` 节点和一个 `memory` 节点。`cpus` 节点包含一个名为 `cpu@0` 的单一 CPU
    节点。这些节点的名称通常包括一个 `@`，后面跟着一个地址，用以区分同类型的其他节点。如果节点有 `reg` 属性，则必须使用 `@`。
- en: Both the root and CPU nodes have a `compatible` property. The Linux kernel uses
    this property to find a matching device driver by comparing it with the strings
    that are exported by each device driver in an `of_device_id` structure (more on
    this in [*Chapter 11*](Chapter_11.xhtml#_idTextAnchor373)).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 根节点和 CPU 节点都有一个 `compatible` 属性。Linux 内核使用这个属性通过将其与每个设备驱动程序在 `of_device_id`
    结构中导出的字符串进行比较，从而找到匹配的设备驱动程序（更多内容请参见 [*第 11 章*](Chapter_11.xhtml#_idTextAnchor373)）。
- en: '**IMPORTANT NOTE**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: It is a convention that the value of the `compatible` property is composed of
    a manufacturer name and a component name to reduce confusion between similar devices
    made by different manufacturers, hence `ti,am33xx` and `arm,cortex-a8`. It is
    also quite common to have more than one value for the `compatible` property when
    there is more than one driver that can handle this device. They are listed with
    the most suitable mentioned first.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，`compatible` 属性的值由制造商名称和组件名称组成，以减少由不同制造商制造的类似设备之间的混淆，因此有 `ti,am33xx` 和 `arm,cortex-a8`。当有多个驱动程序可以处理此设备时，`compatible`
    属性具有多个值是非常常见的。它们按照最适合的顺序列出。
- en: The CPU node and the memory node have a `device_type` property that describes
    the class of the device. The node name is often derived from `device_type`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: CPU 节点和内存节点都有一个 `device_type` 属性，用于描述设备的类别。节点名称通常来源于 `device_type`。
- en: reg property
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`reg` 属性'
- en: The `memory` and `cpu` nodes shown earlier have a `reg` property, which refers
    to a range of units in a register space. A `reg` property consists of two values
    representing the real physical address and the size (length) of the range. Both
    are written as zero or more 32-bit integers called cells. Hence, the previous
    `memory` node refers to a single bank of memory that begins at `0x80000000` and
    is `0x20000000` bytes long.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 先前显示的 `memory` 和 `cpu` 节点具有 `reg` 属性，该属性引用寄存器空间中的一系列单元。`reg` 属性由两个值组成，表示实际物理地址和范围的大小（长度）。两者都写成零或多个称为单元的
    32 位整数。因此，先前的 `memory` 节点引用了从 `0x80000000` 开始、长度为 `0x20000000` 字节的内存单元。
- en: 'Understanding `reg` properties becomes more complex when the address or size
    values cannot be represented in 32 bits. For example, on a device with 64-bit
    addressing, you need two cells for each:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当地址或大小值无法用 32 位表示时，理解 `reg` 属性变得更加复杂。例如，在具有 64 位寻址的设备上，每个地址或大小值需要两个单元：
- en: '[PRE1]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The information about the number of cells required is held in the `#address-cells`
    and `#size_cells` properties in an ancestor node. In other words, to understand
    a `reg` property, you have to look backward down the node hierarchy until you
    find `#address-cells` and `#size_cells`. If there are none, the default values
    are `1` for each – but it is bad practice for device tree writers to depend on
    defaults. Default values may or may not be obvious, so being explicit prevents
    any misunderstandings.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 关于所需单元数的信息存储在祖先节点的 `#address-cells` 和 `#size_cells` 属性中。换句话说，要理解 `reg` 属性，你必须向节点层次结构向后查找，直到找到
    `#address-cells` 和 `#size_cells`。如果没有，则默认值为每个都是 `1` —— 但依赖默认值是设备树编写者的不良实践。默认值可能明显，也可能不明显，因此明确表示可以避免任何误解。
- en: Now, let’s return to the `cpu` and `cpus` nodes. CPUs have addresses as well.
    In a quadcore device, they might be addressed as `0`, `1`, `2`, and `3`. That
    can be thought of as a one-dimensional array without any depth, so the size is
    zero. Therefore, you can see that we have `#address-cells = <1>` and `#size-cells
    = <0>` in the `cpus` node. And in the child node, `cpu@0`, we assign a single
    value to the `reg` property with `reg = <0>`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到 `cpu` 和 `cpus` 节点。CPU 也有地址。在四核设备中，它们可能被寻址为 `0`、`1`、`2` 和 `3`。可以将其视为一个没有深度的一维数组，因此大小为零。因此，你可以看到在
    `cpus` 节点中我们有 `#address-cells = <1>` 和 `#size-cells = <0>`。在子节点 `cpu@0` 中，我们通过
    `reg = <0>` 为 `reg` 属性分配了一个单一值。
- en: Labels and interrupts
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标签和中断
- en: The structure of the device tree described so far assumes that there is a single
    hierarchy of components when there are, in fact, several. Besides the obvious
    data connection between a component and other parts of the system, a node might
    also be connected to an interrupt controller, to a clock source, and to a voltage
    regulator.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止描述的设备树结构假设存在单一的组件层次结构，实际上可能有几个。除了组件与系统其他部分之间的明显数据连接外，节点还可能连接到中断控制器、时钟源和电压调节器。
- en: To express these connections, we can add a label to a node and reference the
    label from other nodes. These labels are sometimes referred to as **phandles**
    because when the device tree is compiled, nodes with a reference from another
    node are assigned a unique numerical value in a property called `phandle`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表达这些连接，我们可以向节点添加标签，并从其他节点引用该标签。这些标签有时被称为**phandles**，因为在编译设备树时，具有从另一个节点引用的节点会在称为
    `phandle` 的属性中被分配一个唯一的数值。
- en: 'You can see phandles if you decompile the device tree binary. Take as an example
    a system containing an LCD controller that can generate `interrupts` and an `interrupt-controller`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你反编译设备树二进制文件，你可以看到phandle。以包含一个可以生成`interrupts`和`interrupt-controller`的LCD控制器的系统为例：
- en: '[PRE2]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we have the `interrupt-controller@48200000` node with a label of `intc`.
    The `interrupt-controller` property identifies it as an interrupt controller.
    Like all interrupt controllers, it has an `#interrupt-cells` property, which tells
    us how many cells are needed to represent an interrupt source. In this case, there
    is only one that represents the **Interrupt Request** (**IRQ**) number.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有一个`interrupt-controller@48200000`节点，标签为`intc`。`interrupt-controller`属性将其标识为一个中断控制器。像所有中断控制器一样，它有一个`#interrupt-cells`属性，告诉我们表示中断源需要多少个单元。在这个例子中，只有一个单元表示**中断请求**（**IRQ**）编号。
- en: Other interrupt controllers may use additional cells to characterize the interrupt,
    for example, to indicate whether it is edge or level triggered. The number of
    interrupt cells and their meanings are described in the bindings for each interrupt
    controller. The device tree bindings can be found in the Linux kernel source in
    the `Documentation/devicetree/bindings` directory.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 其他中断控制器可能会使用附加的单元来表征中断，例如，指示它是边沿触发还是电平触发。中断单元的数量及其含义在每个中断控制器的绑定文件中有所描述。设备树绑定可以在Linux内核源代码中的`Documentation/devicetree/bindings`目录下找到。
- en: Looking at the `lcdc@4830e000` node, it has an `interrupt-parent` property,
    which references the interrupt controller it is connected to using the label.
    It also has an `interrupts` property, which is `36` in this case. Note that this
    node has its own label, `lcdc`, which is used elsewhere. Any node can have a label.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`lcdc@4830e000`节点，它有一个`interrupt-parent`属性，引用了它所连接的中断控制器，并使用标签。它还有一个`interrupts`属性，这里为`36`。注意，这个节点有自己的标签`lcdc`，该标签在其他地方也会使用。任何节点都可以有标签。
- en: Device tree include files
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设备树包含文件
- en: '[PRE3]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Look through the `.dts` files in the kernel and you will find an alternative
    `include` statement that is borrowed from C; for example, this is in `am335x-boneblack.dts`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览内核中的`.dts`文件，你会发现一个借用自C语言的替代`include`语句；例如，这在`am335x-boneblack.dts`中：
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here is another example from `am33xx.dtsi`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是来自`am33xx.dtsi`的另一个例子：
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Lastly, `include/dt-bindings/pinctrl/am33xx.h` contains normal C macros:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`include/dt-bindings/pinctrl/am33xx.h`包含了普通的C宏：
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: All of this is resolved if the device tree sources are built using the Kbuild
    system, which runs them through the C preprocessor, CPP. CPP processes the `#include`
    and `#define` statements into text that is suitable for the device tree compiler.
    The motivation is illustrated by the previous example. It means that the device
    tree sources can use the same definitions of constants as the kernel code.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用Kbuild系统构建设备树源文件，所有这些问题都可以得到解决，Kbuild系统会通过C预处理器（CPP）处理它们。CPP将`#include`和`#define`语句处理成适合设备树编译器的文本。动机通过之前的例子进行了说明。这意味着设备树源文件可以使用与内核代码相同的常量定义。
- en: 'When we include files using either syntax, the nodes are overlaid on top of
    one another to create a composite tree in which the outer layers extend or modify
    the inner ones. For example, `am33xx.dtsi`, which is general to all `am33xx` SoCs,
    defines the first MMC controller interface like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用任何语法包含文件时，节点会彼此重叠，创建一个复合树，其中外层扩展或修改内层。例如，`am33xx.dtsi`是针对所有`am33xx` SoC的通用文件，它像这样定义了第一个MMC控制器接口：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that `status` is `disabled`, meaning that no device driver should be bound
    to it, and that it has a label of `mmc1`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`status`为`disabled`，这意味着没有设备驱动程序应该绑定到它，而且它的标签为`mmc1`。
- en: 'Both BeagleBone and BeagleBone Black have a microSD card interface attached
    to `mmc1`. This is why, in `am335x-bone-common.dtsi`, the same node is referenced
    by an ampersand and its label, `&mmc1`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: BeagleBone和BeagleBone Black都有一个连接到`mmc1`的microSD卡接口。这就是为什么在`am335x-bone-common.dtsi`中，通过与符号`&`一起使用它的标签`&mmc1`来引用相同的节点：
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Referencing a node by an ampersand and its label lets us overwrite properties
    from previous `mmc1` entries. Here, the `status` property is set to `okay`, which
    causes the MMC device driver to bind with this interface at runtime on both variants
    of BeagleBone. Also, a reference to a label is added to the pin control configuration,
    `mmc1_pins`. Alas, there is not sufficient space here to describe pin control
    and pin multiplexing. The Linux kernel source contains some information in the
    `Documentation/devicetree/bindings/pinctrl` directory.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用与标签关联的符号（&）来引用节点，可以覆盖之前 `mmc1` 条目的属性。在这里，`status` 属性被设置为 `okay`，这使得 MMC
    设备驱动程序在 BeagleBone 的两个变种上都在运行时与该接口绑定。此外，还在引脚控制配置 `mmc1_pins` 中添加了对标签的引用。遗憾的是，本文没有足够的篇幅来描述引脚控制和引脚复用。有关更多信息，可以参考
    Linux 内核源代码中 `Documentation/devicetree/bindings/pinctrl` 目录下的文档。
- en: 'However, the `mmc1` interface is connected to a different voltage regulator
    on BeagleBone Black. This is expressed in `am335x-boneblack.dts`, where you will
    see another reference to `mmc1`, which associates it with the voltage regulator
    via the `vmmcsd_fixed` label:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，BeagleBone Black 上的 `mmc1` 接口连接到一个不同的电压调节器。这在 `am335x-boneblack.dts` 文件中有所体现，你会看到另一个对
    `mmc1` 的引用，它通过 `vmmcsd_fixed` 标签将其与电压调节器关联：
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: So, layering the device tree source files like this gives us flexibility and
    reduces the need for duplicated code.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，以这种方式分层设备树源文件为我们提供了灵活性，并减少了重复代码的需要。
- en: Compiling a device tree
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译设备树
- en: The bootloader and kernel require a binary representation of the device tree,
    so it has to be compiled using the device tree compiler, that is, `dtc`. The result
    is a file ending with `.dtb`, which is referred to as a device tree binary or
    a device tree blob.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 引导加载程序和内核需要设备树的二进制表示形式，因此必须使用设备树编译器 `dtc` 来编译。编译后的结果是一个以 `.dtb` 结尾的文件，这被称为设备树二进制文件或设备树
    Blob。
- en: 'There is a copy of `dtc` in the Linux source in `scripts/dtc/dtc`, and it is
    also available as a package on many Linux distributions. You can use it to compile
    a simple device tree (one that does not use `#include`) like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 源代码中的 `scripts/dtc/dtc` 目录里有 `dtc` 的副本，而且它也可以作为包在许多 Linux 发行版中使用。你可以用它来编译一个简单的设备树（不使用
    `#include`）：
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Be wary of the fact that `dtc` does not give helpful error messages and makes
    no checks other than on the basic syntax of the language. This means that debugging
    a typing error in a device tree source file can be a lengthy process.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`dtc` 并不会提供有用的错误信息，只会检查语言的基本语法。因此，调试设备树源文件中的输入错误可能是一个漫长的过程。
- en: To build more complex examples, you will have to use the Kbuild kernel as shown
    in [*Chapter 4*](Chapter_04.xhtml#_idTextAnchor096).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建更复杂的示例，您必须使用 Kbuild 内核，如 [*第4章*](Chapter_04.xhtml#_idTextAnchor096) 所示。
- en: Like the kernel, the bootloader can use a device tree to initialize an embedded
    SoC and its peripherals. This device tree is critical when you’re loading the
    kernel from a mass storage device such as a QSPI flash. While embedded Linux offers
    a choice of bootloaders, we will only cover one. Let’s dig deep into that bootloader
    next.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 与内核类似，引导加载程序可以使用设备树来初始化嵌入式 SoC 及其外设。当你从如 QSPI 闪存等大容量存储设备加载内核时，设备树至关重要。虽然嵌入式
    Linux 提供了多种引导加载程序的选择，但我们这里只讨论其中一个。接下来我们将深入研究这个引导加载程序。
- en: U-Boot
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: U-Boot
- en: We are going to focus on U-Boot exclusively because it supports a good number
    of processor architectures and most individual boards and devices. U-Boot, or
    to give its full name, **Das U-Boot**, began life as an open source bootloader
    for embedded PowerPC boards. Then, it was ported to Arm-based boards and later
    to other architectures, including **Microprocessor without Interlocked Pipeline
    Stages** (**MIPS**) and **SuperH** (**SH**).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将专注于 U-Boot，因为它支持多种处理器架构以及大多数单板和设备。U-Boot，或其全名 **Das U-Boot**，最初作为一个开源的嵌入式
    PowerPC 板的引导加载程序诞生。随后，它被移植到基于 Arm 的板子，后来又移植到其他架构，包括 **无锁管道阶段的微处理器**（**MIPS**）和
    **SuperH**（**SH**）。
- en: U-Boot has been around for a long time and has a good community. The project
    is hosted and maintained by DENX Software Engineering. There is plenty of information
    available on it, and a good place to start is [https://u-boot.readthedocs.io](https://u-boot.readthedocs.io).
    There is also a mailing list at [u-boot@lists.denx.de](https://u-boot@lists.denx.de)
    that you can subscribe to by filling out and submitting the form provided at [https://lists.denx.de/listinfo/u-boot](https://lists.denx.de/listinfo/u-boot).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Building U-Boot
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Begin by getting the source code. As with most projects, the recommended way
    is to clone the Git repository and check out the tag you intend to use:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Alternatively, you can download a tarball from [https://ftp.denx.de/pub/u-boot/](https://ftp.denx.de/pub/u-boot/).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: There are more than 1,000 configuration files for common development boards
    and devices in the `configs` directory. In most cases, you can take a good guess
    regarding which to use based on the filename. But you can get more detailed information
    by looking through the `.rst` files in the `doc/board` directory. Or you can find
    information in an appropriate web tutorial or forum.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking BeaglePlay as an example, we will find that there is a configuration
    file named `am62x_evm_a53_defconfig` in the `configs` directory. In that same
    directory, there is another configuration file named `am62x_evm_r5_defconfig`
    that is for BeaglePlay’s Arm Cortex-R5F microcontroller. The ROM code runs on
    the Arm Cortex-R5F microcontroller and the TPL runs on the main Arm Cortex-A53
    CPU. There are two U-Boot SPLs: one that runs on the R5 and another that runs
    on the main CPU. There is a sequence diagram explaining BeaglePlay’s unique boot
    flow in detail inside `doc/board/beagle/am62x_beagleplay.rst`. Take a close look
    at this sequence diagram and make sure you understand it. As you progress through
    the remainder of this chapter, refer to this diagram for clarification.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Building U-Boot for BeaglePlay is a multi-stage process. The Arm Cortex-M4F
    and Cortex-R5F in BeaglePlay’s `am62x` SoC are 32-bit processors, so they require
    a 32-bit toolchain. A software component called **TI Foundational Security** (**TIFS**)
    runs on the M4\. TIFS starts the R5 and asks it to load a firmware image to the
    TIFS core. That means we need to bundle a TIFS binary firmware image for the M4
    together with a U-Boot SPL when generating a bootloader image for the R5\. Next,
    we need to build **Trusted Firmware-A** (**TF-A**) for the main A53 CPU using
    a 64-bit toolchain. Lastly, we configure and build a U-Boot SPL and TPL for the
    main CPU.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining a 32-bit toolchain
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Point your web browser at [https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads](https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads).
    Search for **Downloads: 13.2.Rel1** and click on the plus sign in front to expand
    that section. Then click on the `arm-gnu-toolchain-13.2.rel1-x86_64-arm-none-eabi.tar.xz`
    file under x86_64 Linux hosted cross toolchains **AArch32 bare-metal target**(**arm-none-eabi**)
    to download the toolchain.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: The following R5 exercises were successfully performed with that version of
    the Arm GNU toolchain. I recommend downloading the same version from that web
    page (if it is still available) to prevent any problems.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the 32-bit toolchain in your home directory:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add the 32-bit toolchain to your `PATH` environment variable:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You are now ready to build U-Boot for the R5\. Make sure to replace `13.2.rel1`
    and `13.2.Rel1` in the preceding commands with the actual version of the 32-bit
    toolchain you downloaded.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Building U-Boot SPL for R5
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Support for BeaglePlay in mainline U-Boot was very new back in November 2023
    when I wrote this. For this reason, I have instead opted to use BeagleBoard.org’s
    U-Boot fork for BeaglePlay. I suggest building the U-Boot source from the same
    Git repo (if it is still available) to prevent any problems.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'Clone the U-Boot fork to your home directory and check out a stable commit:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Install the packages needed to build U-Boot for BeaglePlay:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Configure and build U-Boot for the R5:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a build directory for the R5 one level up to share build artifacts
    across builds:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, set the `ARCH` and `CROSS_COMPILE` environment variables for 32-bit Arm:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Select `am62x_evm_r5_defconfig` for building:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Run `make menuconfig` to configure U-Boot further for building:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Drill down into the **Environment** submenu.
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Select **Environment is in a EXT4 filesystem**.
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Selecting Environment is in a EXT4 fileystem](img/B18466_03_05.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – Selecting Environment is in a EXT4 fileystem
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Deselect any other options (e.g., MMC, NAND, and SPI) for environment storage
    on that menu page.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `mmc` in the **Name of the block device for the environment** text field.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Name of the block device for the environment](img/B18466_03_06.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – Name of the block device for the environment
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Enter `1:2` in the **Device and partition for where to store the environment
    in EXT4** text field.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.7 – Device and partition for where to store the environment in EXT4](img/B18466_03_07.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – Device and partition for where to store the environment in EXT4
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Ensure `/uboot.env` is the **Name of the EXT4 file to use for the environment**
    text field.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.8 – Environment](img/B18466_03_08.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 – Environment
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Back out of the **Environment** submenu.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drill down into the **SPL/TPL** submenu.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Support EXT filesystems**.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.9 – Select Support EXT4 filesystems](img/B18466_03_09.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 – Select Support EXT4 filesystems
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Back out of the **SPL/TPL** submenu.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drill down into the **Boot Options** submenu.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Enable a default value for bootcmd**.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.10 – Select Enable a default value for bootcmd](img/B18466_03_10.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
- en: Figure 3.10 – Select Enable a default value for bootcmd
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Enter `echo 'no bootcmd yet'` in the **bootcmd value** text field.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.11 – bootcmd value](img/B18466_03_11.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
- en: Figure 3.11 – bootcmd value
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12 – Boot options](img/B18466_03_12.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
- en: Figure 3.12 – Boot options
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Exit out of `menuconfig` and choose **Yes** when asked to save your new configuration.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Lastly, build the U-Boot for the R5:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When U-Boot is done building, there should be an SPL binary for the R5 in `../build_uboot/r5/spl`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the boot flow sequence diagram in `doc/board/beagle/am62x_beagleplay.rst`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Generating an image for the R5
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Recall that the TIFS firmware image that gets loaded into the M4 needs to be
    bundled together with the U-Boot SPL for the R5\. We obtain the binary TIFS firmware
    image directly from TI.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'Clone the TI firmware repo to your home directory:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Bundling the TIFS firmware image for the M4 together with the U-Boot SPL for
    the R5 requires a tool named `k3-image-gen`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'Clone the `k3-image-gen` repo to your home directory:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Generate the combined image for the R5 by running `make` in the `k3-image-gen`
    directory with paths to the U-Boot SPL and TIFS firmware image passed in as arguments:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: There should now be a `tiboot3.bin` file in the `k3-image-gen` directory.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the boot flow sequence diagram in `doc/board/beagle/am62x_beagleplay.rst`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Building TF-A for the main A53 CPU
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The A53 in BeaglePlay’s `am62x` SoC is a 64-bit CPU, so we must switch to a
    64-bit toolchain to cross-compile source code for it. We will use the same 64-bit
    Bootlin toolchain from [*Chapter 2*](Chapter_01.xhtml#_idTextAnchor028) that you
    installed in your home directory.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'Add that 64-bit Bootlin toolchain to your `PATH` environment variable:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Make sure to replace `2024.02-1` in the preceding commands with the actual version
    of the 64-bit toolchain you downloaded.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'Clone the TF-A source code to your home directory and check out a stable release
    tag:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Configure and build TF-A for the A53:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the `ARCH` and `CROSS_COMPILE` environment variables for 64-bit Arm:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Build TF-A for the A53 specifying `k3` as the platform and `lite` as the target
    board:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When TF-A is done building, there should be a `bl31.bin` for the A53 in `./build/k3/lite/release`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the boot flow sequence diagram in `doc/board/beagle/am62x_beagleplay.rst`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Building U-Boot for the main A53 CPU
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All the build steps performed up until now are unique to the `am62x` SoC in
    BeaglePlay. Building U-Boot for most targets only requires compiling an SPL and
    TPL for the main CPU. We will use the same 64-bit Bootlin toolchain from [*Chapter
    2*](Chapter_01.xhtml#_idTextAnchor028)that you installed in your home directory.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'Add that 64-bit Bootlin toolchain to your `PATH` environment variable:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Make sure to replace `2024.02-1` in the preceding commands with the actual version
    of the 64-bit toolchain you downloaded.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'Configure and build U-Boot for the A53:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'First, navigate back to the `u-boot` source tree for BeaglePlay:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, create a build directory for the A53 one level up:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Set the `ARCH` and `CROSS_COMPILE` environment variables for 64-bit Arm:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Select `am62x_evm_a53_defconfig` for building:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Run `make menuconfig` to configure U-Boot further for building:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Drill down into the **Environment** submenu.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Environment is in a EXT4 filesystem**.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deselect any other options (e.g., MMC, NAND, and SPI) for environment storage
    on that menu page.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `mmc` in the **Name of the block device for the environment** text field.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `1:2` in the **Device and partition for where to store the environment
    in EXT4** text field.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure `/uboot.env` is entered in the **Name of the EXT4 file to use for the
    environment** text field.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Back out of the **Environment** submenu.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drill down into the **SPL/TPL** submenu.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Support EXT filesystems**.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Back out of the **SPL/TPL** submenu.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drill down into the **Boot Options** submenu.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Enable a default value for bootcmd**.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `echo 'no bootcmd yet'` in the **bootcmd value** text field.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exit out of `menuconfig` and choose **Yes** when asked to save your new configuration.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Lastly, build U-Boot for the A53 passing paths to TI’s TF-A and DM firmware
    as arguments to `make`:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '**IMPORTANT NOTE**'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Always use absolute paths as opposed to relative `./` paths to point to the
    `ATF` and `DM` firmware in your `make` command. Otherwise, the resulting SPL and
    U-Boot binaries will be incorrect in size and content.
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The results of the compilation are as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '`u-boot`: U-Boot in ELF format, suitable for use with a debugger'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`u-boot.map`: The symbol table'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`u-boot.bin`: U-Boot in raw binary format, suitable for running on your device'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`u-boot.img`: `u-boot.bin` with a U-Boot header added, suitable for uploading
    to a running copy of U-Boot'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`u-boot.srec`: U-Boot in Motorola S-record (**SRECORD** or **SRE**) format,
    suitable for transferring over a serial connection'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'BeaglePlay also requires an SPL, as described earlier. This is built at the
    same time and is named `tispl.bin` (the boot flow sequence diagram in `doc/board/beagle/am62x_beagleplay.rst`):'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The procedure is similar for other targets.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Installing U-Boot
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Installing a bootloader on a board for the first time requires some manual intervention.
    If the board has a hardware debug interface, such as a **Joint Test Action Group**
    (**JTAG**), it is usually possible to load a copy of U-Boot directly into RAM
    and get it running. From that point, you can use U-Boot commands so that it copies
    itself into flash memory. The details are very board-specific and outside the
    scope of this book.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Many SoC designs have a boot ROM built in that can be used to read boot code
    from various external sources, such as SD cards, serial interfaces, or USB mass
    storage. This is the case with the `am62x` chip in the Beagle, which makes it
    easy to try out new software.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need a microSD card reader to write the images to a card. There are
    two types: external readers that plug into a USB port and the internal SD readers
    that are present on many laptops. A device name is assigned by Linux when a card
    is plugged into the reader. The `lsblk` command is a useful tool for finding out
    which device has been allocated. For example, this is what I see when I plug a
    nominal 32 GB microSD card into my card reader:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this case, `nvme0n1` is my 512 GB hard drive and `sda` is the microSD card.
    It has a single partition, `sda1`, which is mounted as the `/media/frank/6662-6262`
    directory.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'If I use the built-in SD card slot, I see this:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this case, the microSD card appears as `mmcblk0`, and the partition is `mmcblk0p1`.
    Note that the microSD card you use may have been formatted differently than this
    one, so you may see a different number of partitions with different mount points.
    When formatting an SD card, it is very important to be sure of its device name.
    You really don’t want to mistake your hard drive for an SD card and format that
    instead.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'This has happened to me more than once. So, I have provided a shell script
    in this book’s code repo named `MELD/format-sdcard.sh`, which has a reasonable
    number of checks to prevent you (and me) from using the wrong device name. The
    parameter is the device name of the microSD card, which would be `sda` in the
    first example and `mmcblk0` in the second. Here is an example of its use:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The script creates two partitions. The first is 128 MB and formatted as FAT32,
    and it will contain the bootloader, while the second is 1 GB and formatted as
    ext4, which you will use in [*Chapter 5*](Chapter_05.xhtml#_idTextAnchor138).
    The script aborts when it’s applied to any drive greater than 128 GB so be prepared
    to modify it if you are using larger microSD cards.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Once you have formatted the microSD card, remove it from the card reader and
    then reinsert it. Roll over and click on one of the USB stick icons that appears
    to the left of the Ubuntu desktop so that a window opens for the `boot` partition.
    On current versions of Ubuntu, the two partitions are mounted as `/media/<user>/boot`
    and `/media/<user>/rootfs`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy `tiboot3.bin`, `tispl.bin` and `u-boot.img` to the `boot` partition like
    this:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Right-click on either of the two USB stick icons and select **Eject** to unmount
    the microSD card. Lastly, remove the microSD card from your host machine’s card
    reader.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 'To boot BeaglePlay from your newly prepared microSD card:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: With no power on BeaglePlay, insert the microSD card into BeaglePlay’s reader.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Plug the USB side of your USB-to-TTL serial cable into your host machine. Make
    sure your cable has a 3.3 V logic level.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The three-pin UART connector is right next to the USB-C connector on BeaglePlay.
    Do not connect a fourth red wire from your cable. A red wire typically indicates
    power, which is unnecessary in this instance and could damage the board.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the TX wire from the cable to the RX pin on BeaglePlay.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the RX wire from the cable to the TX pin on BeaglePlay.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the GND (black) wire from the cable to the GND pin on BeaglePlay.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A serial port should appear on your PC as `/dev/ttyUSB0`.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start a suitable terminal program, like `gtkterm`, `minicom`, or `picocom`,
    and attach it to the port at 115,200 **bits per second** (**bps**) with no flow
    control. `gtkterm` is probably the easiest to set up and use:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: If you get a permissions error, then you may need to add yourself to the `dialout`
    group to use this port or launch `gtkterm` with `sudo`. If garbled or no output
    appears on the serial console, then swap the wires connected to the RX and TX
    pins on BeaglePlay.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press and hold the USR button on BeaglePlay.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Power up the board using USB-C.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Release the button after about 5 seconds.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should see some output followed by a U-Boot prompt on the serial console:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Hit any key on your keyboard to stop U-Boot from autobooting with the default
    environment. Now that we have a U-Boot prompt in front of us, let’s put U-Boot
    through its paces.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Using U-Boot
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, I describe some of the common tasks that can be performed with
    U-Boot.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: U-Boot provides a command-line interface over a serial port. It provides a command
    prompt that is customized for each board. In these examples, I use `=>` for the
    command prompt. Typing `help` prints out all the commands that have been configured
    in this version of U-Boot. Typing `help <command>` prints out more information
    about a particular command.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: The default command interpreter for BeaglePlay is quite simple. You cannot do
    command-line editing by pressing the left or right keys. There is no command completion
    by pressing the *Tab* key, and there is no command history by pressing the up
    arrow key. Pressing any of these keys will disrupt the command you are currently
    trying to type, and you will have to type *Ctrl + C* and start all over again.
    The only line editing key you can safely use is the backspace.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: As an option, you can configure a different command shell called **Hush**, which
    has more sophisticated interactive support, including command-line editing.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 'The default number format is hexadecimal. Consider the following command:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This will read `0x200000` bytes from offset `0x400000` from the start of the
    NAND flash memory into RAM address `0x82000000`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Environment variables
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'U-Boot uses environment variables extensively to store and pass information
    between functions and even to create scripts. Environment variables are simple
    `name=value` pairs that are stored in an area of memory. The initial population
    of variables may be coded in the board configuration header file like this:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: You can create and modify variables from the U-Boot command line using `setenv`.
    For example, `setenv foo bar` creates the `foo` variable with the `bar` value.
    Note that there is no `=` sign between the variable name and the value. You can
    delete a variable by setting it to a null string using `setenv foo`. You can print
    all the variables to the console using `printenv`, or you can print a single variable
    using `printenv foo`.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: If U-Boot has been configured with space to store the environment, you can use
    the `saveenv` command to save it. If there is raw NAND or NOR flash, then an erase
    block can be reserved for this purpose, often with another erase block being used
    as a redundant copy to guard against corruption. If there is eMMC or SD card storage,
    it can be stored in a reserved array of sectors, or in a file named `uboot.env`
    in a partition of the disk. Other options include storing it in serial **Electrical
    Erasable Programmable Read Only Memory** (**EEPROM**) connected via an I2C or
    SPI interface or non-volatile RAM.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Boot image format
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'U-Boot doesn’t have a filesystem. Instead, it tags blocks of information with
    a 64-byte header so that it can track the contents. We prepare files for U-Boot
    using the `mkimage` command-line tool, which comes bundled with the `u-boot-tools`
    package on Ubuntu. You can also get `mkimage` by running `make tools` from within
    the U-Boot source tree and then invoke it as `tools/mkimage`. Here is a summary
    of the command’s usage:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'For example, to prepare a kernel image for a 32-bit Arm processor, you can
    use the following command:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In this instance, the architecture is `arm`, the operating system is `linux`,
    and the image type is `kernel`. Additionally, the compression scheme is `gzip`,
    the load address is `0x80008000`, and the entry point is the same as the load
    address. Lastly, the image name is `Linux`, the image datafile is named `zImage`,
    and the image being generated is named `uImage`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Loading images
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Usually, you load images from removable storage such as an SD card or over
    a network. SD cards are handled in U-Boot by the MMC driver. Here is an example
    of loading a file from a microSD card into memory:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `mmc rescan` command re-initializes the MMC driver, perhaps to detect that
    an SD card has recently been inserted. Next, `fatload` is used to read a file
    from a FAT-formatted partition on the SD card. Note that `tiboot3.bin` is the
    firmware image for the R5, not a Linux kernel image, so it cannot be executed
    at this point in the boot sequence. The format for the `fatload` command is as
    follows:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: If `<interface>` is `mmc`, as in our case, then `<dev:part>` is the device number
    of the MMC interface counting from zero and the partition number counting from
    one. Hence, `<1:1>` is the first partition on the second device, which is `mmc
    1` for the microSD card on BeaglePlay (the onboard eMMC is `mmc 0`). The chosen
    memory location of `0x80000000` is in an area of RAM that is not being used at
    this moment.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: To load kernel image files over a network, you must use the **Trivial File Transfer
    Protocol** (**TFTP**). This requires you to install `tftpd` (a TFTP daemon) on
    your development system and start running it. You must also configure any firewalls
    between your PC and the target board to allow the TFTP protocol on UDP port `69`
    to pass through.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: 'The default configuration of TFTP only allows access to the `/var/lib/tftpboot`
    directory. The next step is to copy the files you want to transfer to the target
    into that directory. Then, assuming that you are using a pair of static IP addresses,
    which removes the need for further network administration, the sequence of commands
    to load a kernel image file looks like this:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally, let’s look at how to program images into NAND flash memory and read
    them back. This is handled by the `nand` command. This example loads a kernel
    image via TFTP and programs it into flash:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, you can load the kernel from flash memory using the `nand read` command:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Once the kernel has been loaded into RAM, we can boot it.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: Booting Linux
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `bootm` command starts a kernel image running. The syntax is as follows:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The address of the kernel image is necessary, but the addresses of the `ramdisk`
    and `dtb` can be omitted if the kernel configuration does not need them. If there
    is a `dtb` but no `initramfs`, then the second address can be replaced with a
    dash. That would look like this:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Typing a long series of commands to boot your board each time it is powered
    up is clearly not acceptable. Let’s look at how to automate the boot process.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Automating the boot with U-Boot scripts
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: U-Boot stores a sequence of commands in environment variables. If a special
    variable named `bootcmd` contains a script, then it is run at power-up after a
    delay of `bootdelay` seconds. If you watch this on the serial console, you will
    see the delay counting down to zero. You can press any key during this period
    to terminate the countdown and enter an interactive session with U-Boot.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: 'The way that you create scripts is simple, though it’s not easy to read. You
    simply append commands separated by semicolons, which must be preceded by a *\*
    escape character. For example, to load a kernel image from an offset in flash
    memory and boot it, you might use the following command:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We now know how to boot a kernel on BeaglePlay using U-Boot. But how do we port
    U-Boot to a new board that has no BSP? We’ll cover that in the remainder of this
    chapter.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Porting U-Boot to a new board
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s assume that your hardware department has created a new board called **Nova**
    that is based on BeaglePlay and that you need to port U-Boot to it. You will need
    to understand the layout of the U-Boot code and how the board configuration mechanism
    works. In this section, I will show you how to create a variant of an existing
    board – BeaglePlay – which you could go on to use as the basis for further customizations.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 'There are quite a few files that need to be changed. I have put them together
    into a patch file at `MELD/Chapter03/0001-BSP-for-Nova.patch` in the book’s code
    repo. You can simply apply that patch to a clean copy of the U-Boot fork for BeaglePlay
    and rebuild it like this:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'If you want to use a different version of U-Boot, you will have to regenerate
    the patch yourself for it to apply cleanly. The remainder of this section describes
    how the patch was created. To skip these details, run the preceding commands and
    jump to the end of the *Building and testing* portion of this section. To follow
    along step by step, you will need a clean copy of the U-Boot fork for BeaglePlay
    without the Nova BSP patch applied. The main directories we will be dealing with
    are as follows:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '`arch`: Contains code that’s specific to each supported architecture in the
    `arm`, `mips`, and `powerpc` directories. Within each architecture, there is a
    subdirectory for each member of the family. For example, in `arch/arm/cpu` there
    are directories for the various architecture variants, including `arm926ejs`,
    `armv7`, and `armv8`.'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`board`: Contains code that’s specific to a board. Where there are several
    boards from the same vendor, they are collected into a subdirectory. Hence, the
    code for the `am62x` EVM board, which BeaglePlay is based on, is in `board/ti/am62x`.'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`common`: Contains core functions including the command shells and the commands
    that can be called from them each in a file named `cmd_<command name>.c`.'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`doc`: Contains several `.rst` files describing various aspects of U-Boot.
    If you are wondering how to proceed with your U-Boot port, this is a good place
    to start.'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`include`: In addition to many shared header files, this contains the important
    `include/configs` subdirectory, where you will find the majority of the board
    configuration settings.'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The way that `Kconfig` extracts configuration information from `Kconfig` files
    and stores the total system configuration in a file named `.config` will be described
    in some detail in [*Chapter 4*](Chapter_04.xhtml#_idTextAnchor096). Each board
    has a default configuration stored in `configs/<board name>_defconfig`. For the
    Nova board, we can begin by making a copy of the configuration for the EVM:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, edit `configs/nova_defconfig` and replace `CONFIG_TARGET_AM625_A53_EVM=y`
    with `CONFIG_TARGET_NOVA=y` as shown here:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Note that `CONFIG_ARM=y` causes the contents of `arch/arm/Kconfig` to be included.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: We are now done modifying `configs/nova_defconfig`.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: Board-specific files
  id: totrans-345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Each board has a subdirectory named `board/<board name>` or `board/<vendor>/<board
    name>` that should contain the following:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '`Kconfig`: Contains the configuration options for the board.'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MAINTAINERS`: Contains a record of whether the board is currently maintained
    and, if so, by whom.'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Makefile`: Used to build the board-specific code.'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, there may be source files for board-specific functions.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: 'Our Nova board is based on BeaglePlay, which in turn is based on a TI `am62x`
    EVM. So, we should make copies of the `am62x` board files:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'First, modify `board/ti/nova/Makefile` so that `nova.c` is compiled instead
    of `evm.c`:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Duplicating `evm.c` as `nova.c` lets you change how U-Boot interacts with your
    custom board.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, edit `board/ti/nova/Kconfig`:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: Change the `"TI K3 AM62x based boards"` string under `prompt` to say `"TI K3
    AM62x based Nova! board"`.
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rename `TARGET_AM625_A53_EVM` to `TARGET_NOVA`.
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete `TARGET_AM625_R5_EVM` along with all its items.
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set `SYS_BOARD` to `"nova"` so that it will build the files in `board/ti/nova`.
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set `SYS_CONFIG_NAME` to `"nova"` so that it will use `include/configs/nova.h`
    as the configuration file.
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The modified `board/ti/nova/Konfig` should look as follows:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now we need to link the `Kconfig` file for Nova into the chain of `Kconfig`
    files. First, edit `arch/arm/Kconfig` and insert `source "board/ti/nova/Kconfig"`
    after `source "board/tcl/sl50/Kconfig"`, as shown here:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Now that we have copied and modified the board-specific files for our Nova board,
    let’s move on to the header files.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: Configuring header files
  id: totrans-367
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Each board has a header file in `include/configs` that contains most of the
    configuration information. The file is named by the `SYS_CONFIG_NAME` identifier
    in the board’s `Kconfig` file. The format of this file is described in detail
    in the `README` file at the top level of the U-Boot source tree. For the purposes
    of our Nova board, simply copy `include/configs/am62x_evm.h` into `include/configs/nova.h`
    and make a few changes, as shown here:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: First, replace `__CONFIG_AM625_EVM_H` with `__CONFIG_NOVA_H`. Next, redefine
    `CONFIG_SYS_PROMPT` so that we can identify this bootloader at runtime. Lastly,
    replace `CONFIG_TARGET_AM625_A53_EVM` with `CONFIG_TARGET_NOVA` so that `CONFIG_SPL_MAX_SIZE`
    and `CONFIG_SYS_INIT_SP_ADDR` are defined correctly.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: With the source tree fully modified, we are now ready to build U-Boot for our
    custom board.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: Building and testing
  id: totrans-372
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To build U-Boot for the Nova board:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: 'First, navigate back to the U-Boot source tree for BeaglePlay:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Next, set the `ARCH` and `CROSS_COMPILE` environment variables for 64-bit Arm:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Clean out any previous build artifacts:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Select `nova_defconfig` for building:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Run `make menuconfig` to configure U-Boot further for building:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Drill down into the **Environment** submenu.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Environment is in a EXT4 filesystem**.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deselect any other options (e.g., MMC, NAND, and SPI) for environment storage
    on that menu page.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `mmc` in the **Name of the block device for the environment** text field.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `1:2` in the **Device and partition for where to store the environment
    in EXT4** text field.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure `/uboot.env` is entered in the **Name of the EXT4 file to use for the
    environment** text field.
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Back out of the **Environment** submenu.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drill down into the **SPL/TPL** submenu.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Support EXT filesystems**.
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Back out of the **SPL/TPL** submenu.
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drill down into the **Boot Options** submenu.
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Enable a default value for bootcmd**.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `echo 'no bootcmd yet'` in the **bootcmd value** text field.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exit out of `menuconfig` and choose **Yes** when asked to save your new configuration.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Save the modified `defconfig`:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Update `nova_defconfig` with your changes:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Lastly, build U-Boot for the A53, passing paths to TI’s TF-A and DM firmware
    as arguments to `make`:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Copy `tispl.bin` and `u-boot.img` to the `boot` partition of the microSD card
    you created earlier:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Reinsert the microSD card into BeaglePlay and reapply power while holding down
    the USR button. You should see output like this (note the custom command prompt)
    on the serial console:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'You can create a patch for all these changes by checking them into Git and
    using the `git format-patch` command:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Generating this patch concludes our coverage of U-Boot as a TPL. U-Boot can
    also be configured to bypass the TPL stage of the boot process altogether. Next,
    let’s examine this alternate approach to booting Linux.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: Falcon mode
  id: totrans-411
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are used to the idea that booting a modern embedded processor involves the
    boot ROM loading an SPL, which loads `u-boot.bin`, which then loads a Linux kernel.
    You may be wondering if there is a way to reduce the number of steps, thereby
    simplifying and speeding up the boot process. The answer is U-Boot Falcon mode.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea is simple: have the SPL load a kernel image directly skipping over
    `u-boot.bin`. There is no user interaction and there are no scripts. It just loads
    a kernel from a known location in flash memory or eMMC into memory, passes it
    a pre-prepared parameter block, and starts running it. The details of configuring
    Falcon mode are beyond the scope of this book.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '**IMPORTANT NOTE**'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: Falcon mode is named after the peregrine falcon, which is the fastest bird of
    all, capable of reaching speeds of more than 200 miles per hour in a dive.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-416
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every system needs a bootloader to bring the hardware to life and to load a
    kernel. U-Boot has found favor with many developers because it supports a useful
    range of hardware, and it is fairly easy to port to a new device.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we learned how to inspect and drive U-Boot interactively from
    the command line over a serial console. These command-line exercises included
    loading a kernel over a network using TFTP for rapid iteration. Lastly, we learned
    how to port U-Boot to a new device by generating a patch for our Nova board.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: Over the last few years, the complexity and ever-increasing variety of embedded
    hardware has led to the introduction of the device tree as a way of describing
    hardware. The device tree is simply a textual representation of a system that
    is compiled into a device tree binary, which is passed to the kernel when it loads.
    It is up to the kernel to interpret the device tree and to load and initialize
    drivers for the devices it finds there.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: U-Boot is very flexible, allowing images to be loaded from mass storage, flash
    memory, or a network and then booted. Having covered some of the intricacies of
    booting Linux, in the next chapter, we will cover the next stage of the process.
    This is the third element of your embedded project – the kernel.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
