<html><head></head><body>
		<div id="_idContainer249">
			<h1 id="_idParaDest-124" class="chapter-number"><a id="_idTextAnchor134"/>12</h1>
			<h1 id="_idParaDest-125"><a id="_idTextAnchor135"/>Exploring Linux Security</h1>
			<p>In the ever-evolving landscape of information technology, the security of systems and data stands as an unwavering priority. As the backbone of countless infrastructures, Linux operating systems have solidified their presence in various domains, from servers to embedded devices. Within this realm, this chapter embarks on a comprehensive journey, delving into the realm of Linux security. This exploration isn’t just an exercise in fortifying digital fortresses; it’s a pivotal pursuit that safeguards sensitive information, guarantees operational integrity, and upholds user trust. In the contemporary digital era, where interconnectedness dominates, the importance of Linux security cannot be overstated. Organizations of all sizes rely on Linux-based systems to manage databases, power websites, and orchestrate complex networks. These systems contain troves of sensitive information, from proprietary algorithms to personal user data. Ensuring the security of this data is imperative not only to maintain the competitive edge but also to safeguard the reputation of the entity in question. Breaches in security can lead to dire consequences, including financial losses, legal ramifications, and the erosion of <span class="No-Break">customer confidence.</span></p>
			<p>The purpose of this exploration transcends the realm of routine system administration. It’s a proactive stance against potential threats that could exploit vulnerabilities and wreak havoc. Linux administrators, armed with a profound understanding of security mechanisms, can erect potent defenses against a multitude of cyber threats, from malware and ransomware to data breaches and denial-of-service attacks. By comprehending the intricacies of Linux security, administrators can effectively mitigate risks, respond swiftly to emerging threats, and prevent security incidents that could otherwise <span class="No-Break">cripple operations.</span></p>
			<p>Linux security isn’t just a technical checklist – it’s an integral component of responsible administration. First and foremost, Linux is an open source ecosystem, meaning that its source code is publicly accessible. While this fosters collaboration and rapid development, it also exposes the system to potential scrutiny and exploitation. Hence, understanding Linux security is paramount to identify and rectify vulnerabilities that might otherwise go unnoticed. Moreover, the diverse applications of Linux, from personal computing to corporate servers, demand a nuanced approach to security. Administrators must navigate this spectrum while factoring in the unique security requirements of each scenario. This necessitates a deep comprehension of Linux security mechanisms, such as access controls, encryption, authentication protocols, and intrusion detection systems. By harnessing these tools effectively, administrators can customize security strategies that align with <span class="No-Break">specific needs.</span></p>
			<p>In essence, this chapter serves as a compass in the labyrinth of Linux administration. It equips administrators with the knowledge and strategies needed to uphold the resilience and integrity of Linux-based systems, fostering a digital landscape where security stands as an unwavering pillar of <span class="No-Break">operational success.</span></p>
			<p>In this chapter, we will delve into the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Utilizing enforcing and <span class="No-Break">permissive modes</span></li>
				<li>Enabling or disabling SELinux <span class="No-Break">Boolean values</span></li>
				<li>Locking <span class="No-Break">user accounts</span></li>
				<li><span class="No-Break">Securing SSH</span></li>
			</ul>
			<h1 id="_idParaDest-126"><a id="_idTextAnchor136"/>Utilizing enforcing and permissive modes</h1>
			<p>In the realm of <a id="_idIndexMarker566"/>access control and security management, the concepts of <strong class="bold">enforcing</strong> and <strong class="bold">permissive</strong> modes assume crucial roles, particularly within the context of operating systems such as Linux. These modes pertain to the behavior <a id="_idIndexMarker567"/>of security mechanisms, such as <strong class="bold">Mandatory Access Control</strong> (<strong class="bold">MAC</strong>) frameworks. For instance, RHEL and Fedora Linux use <strong class="bold">Security-Enhanced Linux</strong> (<strong class="bold">SELinux</strong>) as their MAC framework, while Ubuntu employs <a id="_idIndexMarker568"/>AppArmor for similar purposes. Enforcing <a id="_idIndexMarker569"/>mode signifies a state where strict adherence to security policies is upheld, disallowing any actions that contravene these rules. On the other hand, permissive mode adopts a more lenient stance, allowing actions that would typically be denied under “enforcing.” The purpose of these modes lies in striking a balance between maintaining system integrity and facilitating essential operations without undue hindrance. These modes are essential for system administrators aiming to enhance system security while ensuring the smooth operation of their systems. By utilizing enforcing mode, administrators can ensure that all actions, whether initiated by users or applications, adhere rigidly to established security policies. This prevents unauthorized access, reduces the potential attack surface, and mitigates the risks associated with breaches, malware infiltration, and unauthorized data manipulation. Conversely, permissive mode proves invaluable in scenarios where the immediate implementation of strict security measures might disrupt critical operations or lead to unintended consequences. Administrators can temporarily <a id="_idIndexMarker570"/>switch to the permissive mode to identify potential issues that would arise under enforcing mode. This approach aids in fine-tuning security <a id="_idIndexMarker571"/>policies without causing system-wide disruptions. Additionally, permissive mode allows administrators to understand the scope and impact of security policy changes before fully committing <span class="No-Break">to them.</span></p>
			<h2 id="_idParaDest-127"><a id="_idTextAnchor137"/>A short introduction to Linux hardening and the role of SELinux’s enforcing and passive modes</h2>
			<p>In the ever-evolving landscape of cybersecurity, the term <strong class="bold">Linux hardening</strong> emerges as a critical practice <a id="_idIndexMarker572"/>to enhance the security posture of Linux-based systems. Linux hardening refers to the systematic process of fortifying the security of a Linux operating system by minimizing vulnerabilities, reducing attack surfaces, and implementing <a id="_idIndexMarker573"/>robust defense mechanisms. At its core, Linux hardening seeks to create an environment that withstands a broad spectrum of threats, ranging <a id="_idIndexMarker574"/>from cyberattacks to unauthorized data breaches. In this intricate dance between technology and security, the roles of SELinux’s enforcing and permissive modes stand out as pivotal players, shaping the defense strategies adopted by <span class="No-Break">system administrators.</span></p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor138"/>The role of enforcing mode</h2>
			<p>In the realm of MAC, SELinux stands as a pioneering framework that enforces fine-grained security policies within a Linux system. SELinux’s enforcing mode assumes a role akin to an <a id="_idIndexMarker575"/>unyielding guardian, allowing only actions that align with meticulously defined security rules. When operating in enforcing mode, SELinux rigidly enforces access controls and security contexts, thereby confining potentially malicious actions and reducing the likelihood of unauthorized intrusion. This mode ensures that even if an attacker gains access, their ability to maneuver and exploit vulnerabilities is severely curtailed, thereby enhancing the overall resilience of the system to enable <span class="No-Break">enforcing mode:</span></p>
			<div>
				<div id="_idContainer234" class="IMG---Figure">
					<img src="image/B18212_12_1.jpg" alt="Figure 12.1 – SELinux’s enforcing mode"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1 – SELinux’s enforcing mode</p>
			<p>Let’s take <a id="_idIndexMarker576"/>a <span class="No-Break">closer look:</span></p>
			<ul>
				<li>The <strong class="source-inline">setenforce</strong> command is used to modify SELinux’s enforcing mode. By running <strong class="source-inline">sudo setenforce 1</strong>, you are instructing SELinux to switch to enforcing mode. In this mode, SELinux will strictly enforce the defined security policies, denying actions that violate <span class="No-Break">those policies.</span></li>
				<li>To verify that SELinux is in enforcing mode, you can use the <strong class="source-inline">getenforce</strong> command. The <strong class="source-inline">getenforce</strong> command provides a simple way to query the status of SELinux and determine whether it’s currently operating in enforcing mode or <span class="No-Break">permissive mode.</span></li>
			</ul>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor139"/>The role of permissive mode</h2>
			<p>In contrast, SELinux’s permissive mode serves as an insightful observer in the security landscape. When switched to permissive mode, SELinux refrains from blocking actions that breach <a id="_idIndexMarker577"/>security policies, but it actively logs these incidents. This mode serves as an essential tool for system administrators seeking to fine-tune their security policies without abruptly disrupting operations. By analyzing the logs generated in permissive mode, administrators can identify potential issues that would arise if the system were operating in enforcing mode. This invaluable feedback loop empowers administrators to iteratively refine security policies, ensuring they strike an optimal balance between stringent security and operational functionality to enable SELinux’s <span class="No-Break">permissive mode:</span></p>
			<div>
				<div id="_idContainer235" class="IMG---Figure">
					<img src="image/B18212_12_2.jpg" alt="Figure 12.2 – SELinux’s permissive mode"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2 – SELinux’s permissive mode</p>
			<p>Let’s take a <span class="No-Break">closer look:</span></p>
			<ul>
				<li>This time, by running <strong class="source-inline">sudo setenforce 0</strong>, you are instructing SELinux to switch to permissive mode. In permissive mode, SELinux does not actively block actions that violate security policies. Instead, it logs these actions for <span class="No-Break">later analysis.</span></li>
				<li>To verify that SELinux is in enforcing mode, you can use the <strong class="source-inline">getenforce</strong> command to verify whether it’s switched to <span class="No-Break">permissive mode.</span></li>
			</ul>
			<p>To summarize, the dynamic <a id="_idIndexMarker578"/>interplay of SELinux’s enforcing and permissive modes exemplifies the delicate art of Linux hardening. These modes offer administrators a granular approach to security, allowing them to choose between airtight enforcement and pragmatic observation. By judiciously deploying these modes, administrators can navigate the labyrinthine world of Linux security, creating fortified environments that confidently withstand the evolving landscape of <span class="No-Break">cyber threats.</span></p>
			<h1 id="_idParaDest-130"><a id="_idTextAnchor140"/>Enabling or disabling SELinux Boolean values</h1>
			<p>In the intricate landscape of Linux security, SELinux emerges as a dynamic framework that empowers <a id="_idIndexMarker579"/>administrators to finely tune access controls and enforce security policies. At the heart of SELinux’s configurational arsenal lie <a id="_idIndexMarker580"/>Boolean values, encapsulating binary settings that enable or disable specific security features. These Boolean values serve as cryptographic keys that can unlock a multitude of security configurations, allowing administrators to sculpt the behavior of the system with precision. From enabling network connectivity for web servers to permitting specific user interactions, Boolean values offer a nuanced approach to tailoring security protocols, ensuring that the system operates within the desired security boundaries. The importance of enabling or disabling SELinux Boolean values transcends the realm of mere customization. It plays a pivotal role in aligning system security with the ever-evolving operational demands of the digital landscape. A tangible example of their significance is found in web server scenarios. When deploying a web application, certain functionalities might require network connectivity, such as sending emails or accessing remote databases. By manipulating Boolean values, administrators can enable specific network-related permissions for the web server process while keeping other potentially vulnerable actions locked down. This granular control not only mitigates risks but also ensures that security is an enabler, not an inhibitor, <span class="No-Break">of functionality.</span></p>
			<p>The use of SELinux Boolean values extends to scenarios where system administrators need to balance security and usability. For instance, when introducing a new software package, it might demand unconventional access rights to function optimally. Rather than compromising <a id="_idIndexMarker581"/>the overall system security, administrators <a id="_idIndexMarker582"/>can modify Boolean values to grant temporary permissions. This empowers administrators to evaluate the software’s behavior in a controlled environment while preserving the integrity of the larger system. Moreover, the ability to enable or disable specific Boolean values facilitates the implementation of security policies that are congruent with organizational policies and regulatory requirements. This not only enhances security posture but also streamlines compliance efforts by allowing administrators to cater to unique operational needs. Now, let’s take a look at the current values for all SELinux Boolean settings and understand <span class="No-Break">the output:</span></p>
			<div>
				<div id="_idContainer236" class="IMG---Figure">
					<img src="image/B18212_12_3.jpg" alt="Figure 12.3 – Output of current Boolean values"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.3 – Output of current Boolean values</p>
			<p>The provided outputs are the results of running the <strong class="source-inline">getsebool -a</strong> command. This command is used to display the current values of all SELinux Boolean settings. SELinux Boolean values are binary settings that determine whether a specific security feature or permission is <a id="_idIndexMarker583"/>enabled (on) or disabled (off). These Boolean <a id="_idIndexMarker584"/>values allow administrators to finely control the behavior and security policies enforced by SELinux. Let’s break down the output and explain <span class="No-Break">each line:</span></p>
			<ul>
				<li><strong class="source-inline">abrt_anon_write --&gt; off</strong>: This indicates that the SELinux Boolean value for <a id="_idIndexMarker585"/>allowing the <strong class="bold">Automatic Bug Reporting Tool</strong> (<strong class="bold">ABRT</strong>) to write to anonymous memory is <span class="No-Break">currently disabled.</span></li>
				<li><strong class="source-inline">abrt_handle_event --&gt; off</strong>: This Boolean value controls whether ABRT can handle events is disabled. ABRT handles system events such as crashes or <span class="No-Break">abnormal terminations.</span></li>
				<li><strong class="source-inline">abrt_upload_watch_anon_write --&gt; on</strong>: This means that the Boolean value that allows ABRT to watch for uploads with anonymous write access <span class="No-Break">is enabled.</span></li>
				<li><strong class="source-inline">antivirus_can_scan_system --&gt; off</strong>: This states that the Boolean value that permits antivirus software to scan the entire system is <span class="No-Break">currently disabled.</span></li>
				<li><strong class="source-inline">antivirus_use_jit --&gt; off</strong>: The Boolean value controlling whether antivirus software <a id="_idIndexMarker586"/>can use <strong class="bold">Just-In-Time</strong> (<strong class="bold">JIT</strong>) scanning <span class="No-Break">is disabled.</span></li>
				<li><strong class="source-inline">auditadm_exec_content --&gt; on</strong>: This indicates that the Boolean value allowing the <strong class="source-inline">auditadm</strong> user to execute content <span class="No-Break">is enabled.</span></li>
				<li><strong class="source-inline">authlogin_nsswitch_use_ldap --&gt; off</strong>: The Boolean value that determines <a id="_idIndexMarker587"/>whether the <strong class="source-inline">authlogin</strong> program should use the <strong class="bold">Network Security Services</strong> (<strong class="bold">NSS</strong>) LDAP module <span class="No-Break">is disabled.</span></li>
				<li><strong class="source-inline">authlogin_radius --&gt; off</strong>: The Boolean value that controls whether the <strong class="source-inline">authlogin</strong> program can use the <strong class="source-inline">radius</strong> protocol for authentication <span class="No-Break">is disabled.</span></li>
				<li><strong class="source-inline">authlogin_yubikey --&gt; off</strong>: This means that the Boolean value permitting the <strong class="source-inline">authlogin</strong> program to use YubiKey for authentication <span class="No-Break">is disabled.</span></li>
				<li><strong class="source-inline">awstats_purge_apache_log_files --&gt; off</strong>: The Boolean value that decides whether <strong class="source-inline">awstats</strong> should be allowed to purge Apache log files <span class="No-Break">is disabled.</span></li>
			</ul>
			<p>Each of these <a id="_idIndexMarker588"/>lines represents a specific SELinux Boolean value and its current status. The value next to the arrow (that is, <strong class="source-inline">on</strong> or <strong class="source-inline">off</strong>) indicates whether <a id="_idIndexMarker589"/>the Boolean is enabled or disabled. These Boolean values allow system administrators to tailor the security policies of their systems to match their specific operational requirements while maintaining a robust <span class="No-Break">security posture.</span></p>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor141"/>Searching for a Boolean and getting its information</h2>
			<p>Follow <a id="_idIndexMarker590"/><span class="No-Break">these steps:</span></p>
			<ol>
				<li>If you’re not sure about the exact name of a Boolean but want to search for it, you can use the <strong class="source-inline">semanage boolean -</strong><span class="No-Break"><strong class="source-inline">l</strong></span><span class="No-Break"> command:</span></li>
			</ol>
			<div>
				<div id="_idContainer237" class="IMG---Figure">
					<img src="image/B18212_12_4.jpg" alt="Figure 12.4 – Searching for Booleans"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.4 – Searching for Booleans</p>
			<ol>
				<li value="2">To check the <a id="_idIndexMarker591"/>status of a specific SELinux Boolean, use the <strong class="source-inline">getsebool</strong> command followed by the name of the Boolean. For example, to check its status, you can run the <span class="No-Break">following command:</span></li>
			</ol>
			<div>
				<div id="_idContainer238" class="IMG---Figure">
					<img src="image/B18212_12_5.jpg" alt="Figure 12.5 – Checking a specific Boolean’s status"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.5 – Checking a specific Boolean’s status</p>
			<ol>
				<li value="3">Now, let’s run a command to get information about <span class="No-Break">a Boolean:</span></li>
			</ol>
			<div>
				<div id="_idContainer239" class="IMG---Figure">
					<img src="image/B18212_12_6.jpg" alt="Figure 12.6 – Getting information about a Boolean"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.6 – Getting information about a Boolean</p>
			<p class="list-inset">The preceding command searches through the list of SELinux Booleans, finds the one named <strong class="source-inline">xguest_connect_network</strong>, and displays its current status as <strong class="source-inline">on</strong>, indicating <a id="_idIndexMarker592"/>that network connections are allowed for the <strong class="source-inline">xguest</strong> user or process. The comment provides additional context about why this particular Boolean exists and what <span class="No-Break">it controls.</span></p>
			<p>Now, let’s enable and disable a <span class="No-Break">Boolean value.</span></p>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor142"/>Enabling a SELinux Boolean value</h2>
			<p>To enable a <a id="_idIndexMarker593"/>SELinux Boolean value, you can use the <strong class="source-inline">setsebool</strong> command with the <strong class="source-inline">-P</strong> option (which makes the change permanent), followed by the name of the Boolean and <strong class="source-inline">1</strong> to indicate <strong class="source-inline">on</strong>. For instance, if you want to enable the <strong class="source-inline">xguest_use_bluetooth</strong> Boolean, you can run the <span class="No-Break">following code:</span></p>
			<div>
				<div id="_idContainer240" class="IMG---Figure">
					<img src="image/B18212_12_7.jpg" alt="Figure 12.7 – Enabling Boolean values"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.7 – Enabling Boolean values</p>
			<p>After executing this command, we used the <strong class="source-inline">semanage</strong> command to get information about the changes that were made. This command sets the <strong class="source-inline">xguest_use_bluetooth</strong> Boolean to <strong class="source-inline">on</strong> and makes the change permanent across <span class="No-Break">system reboots.</span></p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor143"/>Disabling a SELinux Boolean value</h2>
			<p>To disable <a id="_idIndexMarker594"/>an SELinux Boolean value, use the <strong class="source-inline">setsebool</strong> command with the <strong class="source-inline">-P</strong> option, followed by the name of the Boolean and <strong class="source-inline">0</strong> to indicate <strong class="source-inline">off</strong>. For example, to disable the <strong class="source-inline">mount_anyfile</strong> boolean, follow <span class="No-Break">these steps:</span></p>
			<ol>
				<li>Query the <span class="No-Break">current state:</span><p class="list-inset"><strong class="source-inline">semanage boolean -l | grep mount_anyfile</strong>: This command lists all SELinux Boolean values and filters the output using <strong class="source-inline">grep</strong> to find the line containing <strong class="source-inline">mount_anyfile</strong>. This line shows that the <strong class="source-inline">mount_anyfile</strong> Boolean is currently enabled, as indicated by (<strong class="source-inline">on, on</strong>). Additionally, it provides a description, <strong class="source-inline">Allow mount to anyfile</strong>, which explains the purpose of <span class="No-Break">this Boolean.</span></p></li>
				<li>Disable <span class="No-Break">the Boolean:</span><p class="list-inset"><strong class="source-inline">setsebool -P mount_anyfile 0</strong>: This command uses <strong class="source-inline">setsebool</strong> to change the status of the <strong class="source-inline">mount_anyfile</strong> Boolean. The <strong class="source-inline">-P</strong> flag makes this change <a id="_idIndexMarker595"/>permanent (persisting across reboots), and <strong class="source-inline">0</strong> signifies <strong class="source-inline">off</strong>. After running this command, SELinux is configured to disallow the <strong class="source-inline">mount</strong> command to mount any file as <span class="No-Break">a filesystem.</span></p></li>
				<li>Verify <span class="No-Break">the change:</span><p class="list-inset"><strong class="source-inline">semanage boolean -l | grep mount_anyfile</strong>: This command is used to query the status of the <strong class="source-inline">mount_anyfile</strong> Boolean after it has been modified. Now, it shows (<strong class="source-inline">off, off</strong>) for this Boolean, confirming that it has been disabled. The description remains the same, indicating that the <strong class="source-inline">mount</strong> command is not allowed to mount any file as <span class="No-Break">a filesystem:</span></p></li>
			</ol>
			<div>
				<div id="_idContainer241" class="IMG---Figure">
					<img src="image/B18212_12_8.jpg" alt="Figure 12.8 – Disabling Boolean values"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.8 – Disabling Boolean values</p>
			<p class="list-inset">This command sets the <strong class="source-inline">mount_anyfile</strong> Boolean to <strong class="source-inline">off</strong> and ensures that the change persists after the <span class="No-Break">system reboots.</span></p>
			<p>In summary, the command checks the status of the <strong class="source-inline">mount_anyfile</strong> SELinux Boolean, disables it, and verifies that the change took effect. SELinux Booleans allow administrators <a id="_idIndexMarker596"/>to finely control access and permissions within the system, and modifying them should be done with a clear understanding of the security implications for the <span class="No-Break">system’s operation.</span></p>
			<h1 id="_idParaDest-134"><a id="_idTextAnchor144"/>Locking user accounts</h1>
			<p>In SELinux, the concept of locking user accounts is often associated with standard Linux account management practices, such as using the <strong class="source-inline">passwd</strong> command. SELinux itself does not directly <a id="_idIndexMarker597"/>handle account locking; rather, it relies on Linux’s account management tools to lock and unlock user accounts. Here are some Terminal examples of how to lock and unlock a <span class="No-Break">user account:</span></p>
			<ul>
				<li>Locking a <span class="No-Break">user account:</span><p class="list-inset">To lock a user account, you typically disable the account by changing the account’s password. This can be achieved by using the <strong class="source-inline">passwd</strong> command with the <strong class="source-inline">-l</strong> (<span class="No-Break">lock) option:</span></p></li>
			</ul>
			<div>
				<div id="_idContainer242" class="IMG---Figure">
					<img src="image/B18212_12_9.jpg" alt="Figure 12.9 – Locking a user account"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.9 – Locking a user account</p>
			<ul>
				<li>Unlocking a <span class="No-Break">user account:</span><p class="list-inset">To unlock a user account that has been locked, you can use the <strong class="source-inline">passwd</strong> command again, with <strong class="source-inline">-u</strong> to unlock and <strong class="source-inline">f</strong> for the <span class="No-Break">force option:</span></p></li>
			</ul>
			<div>
				<div id="_idContainer243" class="IMG---Figure">
					<img src="image/B18212_12_10.jpg" alt="Figure 12.10 – Unlocking a user account"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.10 – Unlocking a user account</p>
			<p class="list-inset">The first command unlocks the password for the <strong class="source-inline">intruder</strong> user, and the output confirms <a id="_idIndexMarker598"/>that the account was unlocked successfully. The second command provides information about the user’s current password status, indicating that they have a password set and it is securely encrypted using SHA-512. This scenario ensures that the <strong class="source-inline">intruder</strong> user can now access their account with <span class="No-Break">their password.</span></p>
			<h1 id="_idParaDest-135"><a id="_idTextAnchor145"/>Securing SSH</h1>
			<p><strong class="bold">Secure Shell</strong> (<strong class="bold">SSH</strong>) is a widely used protocol for secure remote access and secure file transfers over <a id="_idIndexMarker599"/>an insecure network. It plays a pivotal role in modern IT infrastructures, enabling administrators, developers, and users to access remote systems securely. However, to harness the full potential of SSH and maintain the confidentiality and integrity of data during remote connections, it’s paramount to implement robust <span class="No-Break">security measures.</span></p>
			<p>The primary <a id="_idIndexMarker600"/>purpose of securing SSH is to protect sensitive information and prevent unauthorized access to remote systems. SSH achieves this by encrypting data during transmission and employing strong authentication mechanisms. By utilizing cryptographic protocols, SSH ensures that data that’s exchanged between the client and server remains confidential and is not susceptible to eavesdropping by malicious actors. Furthermore, SSH’s public-key authentication and password-based authentication mechanisms enhance the security of remote access, reducing the risk of unauthorized logins. The ability to securely tunnel various network services through SSH, known as SSH tunneling, also extends its use beyond remote access, making it a versatile tool for secure data transfer and network management. In essence, securing SSH is integral to safeguarding sensitive data, protecting against malicious intrusions, and ensuring the trustworthiness of remote connections. The importance of SSH security is underscored by its ubiquity in enterprise environments and the critical role it plays in securing remote access to servers, networking devices, and cloud infrastructure. Inadequate SSH security can lead to devastating consequences, including data breaches, unauthorized system access, and exposure to confidential information. This underscores the necessity of implementing best practices, such as enforcing <a id="_idIndexMarker601"/>strong password policies, using multi-factor authentication, and configuring SSH servers to allow only trusted users and hosts. SSH security also aligns with compliance requirements and regulatory standards, making it indispensable for organizations subject to data protection regulations such as GDPR or HIPAA. Here are <span class="No-Break">some examples:</span></p>
			<ul>
				<li>Change the default <span class="No-Break">SSH port:</span><p class="list-inset">Changing the default SSH port (<strong class="source-inline">22</strong>) to a non-standard port can help deter automated scanning and <span class="No-Break">brute-force attacks.</span></p><p class="list-inset">To change the SSH port to <strong class="source-inline">2222</strong>, edit the SSH configuration file, <strong class="source-inline">/etc/ssh/sshd_config</strong>, located in the corner of the shell, as shown in the <span class="No-Break">following screenshot:</span></p></li>
			</ul>
			<div>
				<div id="_idContainer244" class="IMG---Figure">
					<img src="image/B18212_12_11.jpg" alt="Figure 12.11 – Changing the default port"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.11 – Changing the default port</p>
			<p class="list-inset">Inside the file, locate the line with <strong class="source-inline">Port 22</strong> and change it to <strong class="source-inline">Port 2222</strong> or any other port number of your choice. Save <span class="No-Break">the file.</span></p>
			<ul>
				<li>Update <span class="No-Break">SELinux rules:</span><p class="list-inset">When SELinux is enabled, it’s important to note that SELinux policies are designed to enhance system security by enforcing strict rules and restrictions on various system resources, including network ports. These policies might initially prevent SSH traffic on a new port that <span class="No-Break">you’ve configured.</span></p><p class="list-inset">To ensure that SSH traffic can flow smoothly on the new port, you’ll need to update the SELinux policy to allow it. You can achieve this using the <strong class="source-inline">semanage</strong> command, which is a powerful tool for managing SELinux policies. Specifically, you’ll need to use <strong class="source-inline">semanage</strong> to modify the SELinux port policy to permit SSH communication on the <span class="No-Break">new port.</span></p><p class="list-inset">Once you’ve made the necessary policy adjustments, it’s crucial to apply these changes and <a id="_idIndexMarker602"/>then restart the SSH service to put the new configuration into effect. This ensures that SSH connections on the modified port are allowed as per the updated SELinux policy. Here’s how you can <span class="No-Break">accomplish this:</span></p></li>
			</ul>
			<div>
				<div id="_idContainer245" class="IMG---Figure">
					<img src="image/B18212_12_12.jpg" alt="Figure 12.12 – Updating SELinux rules and restarting sshd"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.12 – Updating SELinux rules and restarting sshd</p>
			<p class="list-inset">We can verify this by running the <span class="No-Break">following command:</span></p>
			<div>
				<div id="_idContainer246" class="IMG---Figure">
					<img src="image/B18212_12_13.jpg" alt="Figure 12.13 – Verifying the changes"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.13 – Verifying the changes</p>
			<ul>
				<li>Disable <a id="_idIndexMarker603"/><span class="No-Break">password authentication:</span><p class="list-inset">Disabling password-based authentication in favor of public key authentication enhances security by eliminating the risk of <span class="No-Break">password-guessing attacks.</span></p><p class="list-inset">Edit the SSH configuration file, <strong class="source-inline">/etc/ssh/sshd_config</strong>, located in the corner of the shell, as shown in the <span class="No-Break">following screenshot:</span></p></li>
			</ul>
			<div>
				<div id="_idContainer247" class="IMG---Figure">
					<img src="image/B18212_12_14.jpg" alt="Figure 12.14 – Disabling password authentication"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.14 – Disabling password authentication</p>
			<p class="list-inset">Find the line with <strong class="source-inline">PasswordAuthentication yes</strong> and change it <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">Password</strong></span><strong class="source-inline">
Authentication no</strong>. Save the file and <span class="No-Break">restart SSH:</span></p>
			<div>
				<div id="_idContainer248" class="IMG---Figure">
					<img src="image/B18212_12_15.jpg" alt="Figure 12.15 – Restarting sshd"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.15 – Restarting sshd</p>
			<p>Ultimately, securing SSH <a id="_idIndexMarker604"/>is not only a matter of technological implementation but a fundamental component of comprehensive cybersecurity strategies, contributing to the resilience and trustworthiness of <span class="No-Break">IT systems.</span></p>
			<h1 id="_idParaDest-136"><a id="_idTextAnchor146"/>Summary</h1>
			<p>This chapter provided Linux administrators with a deep understanding of SELinux modes and how they influence system security. We explored the concepts of enforcing and permissive modes and their significance in the context of Linux administration. Administrators need to learn to leverage these modes to strike a balance between security and system functionality, ensuring that SELinux policies are effectively enforced. This chapter also covered the crucial topic of <em class="italic">enabling or disabling SELinux Boolean values</em>. We delved into the reasons, importance, and practical use of SELinux Boolean values, demonstrating how they allow administrators to fine-tune security policies to meet specific system requirements. By enabling or disabling Boolean values, administrators gain flexibility in tailoring SELinux policies to their system’s needs while maintaining a high level of security. Another essential aspect of system security that we explored in this chapter was <em class="italic">locking user accounts in SELinux security</em>. Here, you discovered the reasons for locking user accounts, the importance of doing so, and the methods to achieve it within the SELinux framework. This knowledge should have equipped you to effectively manage user access and enhance the overall security posture of <span class="No-Break">your system.</span></p>
			<p>Finally, we delved into securing SSH, a critical component of remote system administration. Administrators learn best practices for securing SSH, including changing the default SSH port, disabling password authentication in favor of public key authentication, and limiting SSH access to specific users or groups. By implementing these security measures, administrators bolster the security of remote access to their <span class="No-Break">Linux systems.</span></p>
			<p>In the next chapter, we’ll explore the world of cloud computing and how Linux plays a pivotal role in it. This chapter will take you on a journey through running Linux machines on the cloud, creating Linux instances, and various administrative tasks within a cloud-based Linux environment. By the end, you will have the knowledge and skills to thrive in the cloud <span class="No-Break">computing era.</span></p>
		</div>
	</body></html>