- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: PowerShell and Files – Reading, Writing, and Manipulating Data
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PowerShell 和文件 – 读取、写入和操作数据
- en: So far, our PowerShell journey has been on the screen. Wouldn’t it be neat to
    be able to write the output of our cmdlets to a file somewhere so that we could
    save it for later or send it to other people? That’s what we’re going to do in
    this chapter. First, we’re going to look at formatting output for the screen so
    that we can just focus on the things we’re interested in or present output in
    a more useful manner. Next, we’re going to look at writing the output to a text
    file using `Out-File`. I do this multiple times a day and it’s an incredibly useful
    technique, but it is very limited, so we’re also going to look at creating **Comma-Separated
    Value** (**CSV**) files for consumption by another program, such as Microsoft
    Excel, and HTML files so that we can display our output as a web page.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的 PowerShell 之旅都在屏幕上进行。如果能够将 cmdlet 的输出写入某个文件，以便稍后保存或发送给其他人，那该多好呢？这就是我们在本章要做的。首先，我们将查看如何格式化屏幕上的输出，以便我们可以只专注于感兴趣的内容，或以更有用的方式呈现输出。接下来，我们将探讨如何使用
    `Out-File` 将输出写入文本文件。我每天都会做这件事，它是一个非常有用的技巧，但它有很大的局限性，因此我们还将讨论如何创建**逗号分隔值**（**CSV**）文件，以供其他程序（例如
    Microsoft Excel）使用，以及如何创建 HTML 文件，以便我们能够以网页的形式展示输出。
- en: Once we’re comfortable with the output, we’re going to dive into a short section
    that will help us understand how PowerShell interacts with filesystems, before
    looking at how we can use PowerShell to read and manipulate data in common file
    types, such as text and CSV files. Finally, we’ll wrap the chapter up with a short
    walkthrough of a fun project and leave you with a challenge.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们熟悉了输出，我们将深入了解一个简短的部分，帮助我们理解 PowerShell 如何与文件系统交互，之后再看看我们如何使用 PowerShell
    读取和操作常见文件类型中的数据，如文本文件和 CSV 文件。最后，我们将通过一个有趣项目的简短演练来结束本章，并留给你一个挑战。
- en: 'In this chapter, we are going to cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将覆盖以下主题：
- en: Understanding formatting
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解格式化
- en: Writing to a text file
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入文本文件
- en: Using `ConvertTo-` and `Export-` cmdlets
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `ConvertTo-` 和 `Export-` cmdlet
- en: Handling files
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理文件
- en: Working with file
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作文件
- en: Let’s have some fun!
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们来点乐趣吧！
- en: Understanding formatting
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解格式化
- en: Let’s think about our old friend, `Get-Process`. We know that when we run it,
    it displays a list of the running processes on our machine. For each process,
    it displays some of the properties. We know from running `Get-Process | Get-Member`
    that there are many more that it doesn’t display unless we ask for them explicitly.
    This is the case for pretty much every PowerShell cmdlet; the output we see is
    rarely the complete output of every property the objects in the pipeline possess.
    How does that happen? Welcome to the **default format**.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来想想我们的老朋友 `Get-Process`。我们知道，当我们运行它时，它会显示我们机器上正在运行的进程列表。对于每个进程，它会显示一些属性。我们通过运行
    `Get-Process | Get-Member` 知道，还有许多属性不会显示，除非我们明确请求显示。这几乎是每个 PowerShell cmdlet 的情况；我们看到的输出通常不是管道中对象所有属性的完整输出。这是怎么发生的呢？欢迎来到**默认格式**。
- en: PowerShell decides on the format for displaying output based on the `TypeName`
    of the object in the pipeline. If the `TypeName` has an associated `PSCustomObject`,
    then the shell will determine whether there is a **default property set** and,
    if so, display that. If there are fewer than five default properties, they will
    be displayed in a table; if there are more than five, then they will be displayed
    as a list. Finally, if the object has neither a default formatting view nor a
    default property set, then all the properties will be displayed.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 根据管道中对象的 `TypeName` 来决定显示输出的格式。如果 `TypeName` 有关联的 `PSCustomObject`，那么
    shell 会判断是否有**默认属性集**，如果有，就会显示这些属性。如果默认属性少于五个，它们将以表格形式显示；如果超过五个，它们将以列表形式显示。最后，如果对象既没有默认格式化视图，也没有默认属性集，那么所有属性将会显示。
- en: 'We can see part of the default formatting view for `Get-Process` in the following
    screenshot:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下截图中看到 `Get-Process` 的默认格式化视图的一部分：
- en: '![Figure 6.1 – Part of the default formatting view for System.Diagnostics.Process
    objects](img/B17600_06_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1 – System.Diagnostics.Process 对象的默认格式化视图的一部分](img/B17600_06_01.jpg)'
- en: Figure 6.1 – Part of the default formatting view for System.Diagnostics.Process
    objects
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – System.Diagnostics.Process 对象的默认格式化视图的一部分
- en: 'It is possible to redefine the properties that are displayed by default, but
    I’ve never found it necessary to do so, so it’s beyond the scope of this book.
    If it’s something you think you might like to do, then have a look at the help
    files for the `FormatData` cmdlets by running the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 可以重新定义默认显示的属性，但我从未觉得有必要这么做，因此超出了本书的讨论范围。如果你觉得自己可能需要这么做，可以通过运行以下命令查看`FormatData`命令的帮助文件：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We don’t need to do anything as drastic as updating `FormatData` to change the
    way our output is formatted, though. In the rest of this section, we’re going
    to look at three common ways of changing the way our data is displayed using `Format`
    cmdlets. First, let’s look at my favorite, `Format-List`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，我们并不需要像更新`FormatData`那样进行剧烈的修改来改变输出格式。在本节剩余部分，我们将讨论三种常见的使用`Format`命令更改数据展示方式的方法。首先，让我们来看一下我最喜欢的`Format-List`。
- en: Format-List
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Format-List
- en: 'Most cmdlets we use will display output as a table with the object name and
    a few well-chosen properties. `Format-List` allows us to display the object properties
    and values as a list. Note that `Format-List` displays the properties in the default
    property set, not the ones in the default format view if a view exists. Have a
    look at the following screenshot to see what we mean:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的大多数命令会以表格形式显示对象名称及几个精选的属性。`Format-List`允许我们以列表形式显示对象的属性和值。请注意，`Format-List`会显示默认属性集中的属性，而不是默认格式视图中的属性（如果有视图的话）。查看以下截图以了解我们所指：
- en: '![Figure 6.2 – The default format and the list format](img/B17600_06_02.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.2 – 默认格式和列表格式](img/B17600_06_02.jpg)'
- en: Figure 6.2 – The default format and the list format
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 – 默认格式和列表格式
- en: 'We can see that running `Get-Process` on its own produces some very different
    information from what we get when we pipe it into `Format-List`. In fact, `Format-List`
    doesn’t look very good at all, there – so why do I use it so much? Try getting
    the information for a single process and using `Format-List` with the wildcard
    operator, (`*`), as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，单独运行`Get-Process`所得到的信息与将其通过管道传递给`Format-List`后得到的信息有很大不同。实际上，`Format-List`看起来并不好，因此我为什么会这么常用它呢？试着获取某个进程的信息，并结合通配符操作符（`*`）使用`Format-List`，如下所示：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'There! Lots of information. We can also just select certain properties to display
    by passing a comma-separated list to the `-Property` parameter of `Format-List`,
    as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 看！很多信息。我们也可以通过传递以逗号分隔的属性列表给`Format-List`的`-Property`参数来选择只显示特定的属性，如下所示：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`Format-List` has the `fl` alias, so an awful lot of the stuff I ask people
    for when I’m troubleshooting their servers has `|fl *` somewhere near the end.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`Format-List`有一个别名`fl`，所以当我在故障排除服务器时，经常要求别人提供的许多信息都会在末尾加上`|fl *`。'
- en: Format-Table
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Format-Table
- en: 'If we want a subset of data for a number of objects, then the table format
    is convenient. If we want different data to the default format view, then we can
    use `Format-Table`. Try this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要获取多个对象的数据子集，那么表格格式非常方便。如果我们希望不同于默认格式视图的数据展示，则可以使用`Format-Table`。试试这个：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This will get us a subset of properties for each process in a convenient table
    format.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这将以方便的表格格式为每个进程获取一部分属性。
- en: 'Quite often, when we run `Format-Table`, we don’t actually see all the data
    we’ve asked for; instead, the output is truncated with an ellipsis (`…`). Happily,
    there are two other parameters of `Format-Table` that can help us out. Firstly,
    we can use the `-AutoSize` parameter to remove white space between columns and
    set each column to the width of its largest entry. However, if that still doesn’t
    get everything, then we can use the `-Wrap` parameter to display each entry across
    multiple lines. Try this to see the difference:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行`Format-Table`时，往往不会看到我们请求的所有数据；相反，输出会被省略号（`…`）截断。幸运的是，`Format-Table`有两个其他参数可以帮助我们。首先，我们可以使用`-AutoSize`参数去除列间的空白，并将每列设置为其最大条目的宽度。如果仍然无法显示所有内容，我们可以使用`-Wrap`参数将每个条目显示为多行。试试这个，看看效果的不同：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: That’s quite handy. Let’s look at our last format cmdlet, `Format-Wide`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常方便。接下来我们来看一下最后一个格式化命令`Format-Wide`。
- en: Format-Wide
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Format-Wide
- en: 'The `Format-Wide` cmdlet allows us to show data in a wide list format, which
    makes it easier to read on a screen. It resembles the standard Linux list output
    (`ls`), but without the coloring rules that make the list command so useful. It
    will only display a single property of each object and defaults to a `Name` property
    unless we specify something else using the `-Property` parameter. It has two parameters
    that allow us to control the display – `-Column`, which specifies a set number
    of columns, and `-AutoSize`, which tries to fit in as many as possible without
    truncating the data. Try this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`Format-Wide` cmdlet 允许我们以宽列表格式显示数据，这使得在屏幕上阅读更加方便。它类似于标准的 Linux 列表输出（`ls`），但没有使列表命令如此有用的颜色规则。它只会显示每个对象的一个属性，默认显示
    `Name` 属性，除非我们使用 `-Property` 参数指定其他属性。它有两个参数可以控制显示方式——`-Column`，指定列数，以及 `-AutoSize`，尽可能不截断数据地显示更多内容。试试看：'
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Personally, I don’t find I use the `Format-Wide` cmdlet anything as much as
    I should. It’s useful for concisely seeing a list of objects and saves scrolling
    up and down looking for an item.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 就个人而言，我发现自己并没有像应该那样多使用 `Format-Wide` cmdlet。它对于简洁地查看对象列表非常有用，可以避免上下滚动寻找某个项目。
- en: Formatting gotchas
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 格式化陷阱
- en: 'In [*Chapter 3*](B17600_03.xhtml#_idTextAnchor049), *The PowerShell Pipeline
    – How to String Cmdlets Together*, we discussed a very important rule: `Format-`
    cmdlets produce readable text on the screen, that’s because the formatting data
    objects they produce are processed by the shell. We really can’t use the output
    from a `Format-` cmdlet anywhere else in the pipeline, except to feed it into
    one of the specialized `Out-` cmdlets, such as the `Out-Default | Out-Host` pair
    that is implicit on the end of every PowerShell pipeline.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第3章*](B17600_03.xhtml#_idTextAnchor049)，*PowerShell 管道 – 如何将 cmdlet 串联在一起*，我们讨论了一个非常重要的规则：`Format-`
    cmdlet 会在屏幕上输出可读文本，这是因为它们生成的格式化数据对象由 shell 处理。除了将输出传递给一些专用的 `Out-` cmdlet（例如，`Out-Default
    | Out-Host`，它隐式地出现在每个 PowerShell 管道的末尾）之外，我们实际上无法在管道的其他地方使用 `Format-` cmdlet 的输出。
- en: There is, however, a very useful `Out-` cmdlet that we haven’t looked at yet,
    and we’ll cover it in the next section.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们还有一个非常有用的 `Out-` cmdlet 尚未介绍，我们将在下一节讲解它。
- en: Writing a text file
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 写入文本文件
- en: We started this chapter by promising to cover writing PowerShell output to a
    file. Let’s do that. We have learned that we can feed the output of the `Format-`
    cmdlets into an `Out-` cmdlet and there is a specific cmdlet for writing data
    to a file; `Out-File`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章开始时承诺会讲解如何将 PowerShell 输出写入文件。现在我们来实现这个目标。我们已经了解到，我们可以将 `Format-` cmdlet
    的输出传递给一个 `Out-` cmdlet，而用于将数据写入文件的特定 cmdlet 是 `Out-File`。
- en: '`Out-File` will write the output from any cmdlet to a text file. We can format
    the output first using a `Format-` cmdlet if we want to, but we don’t have to;
    if we don’t, we get the default output of the cmdlet. Let’s try it:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`Out-File` 会将任何 cmdlet 的输出写入文本文件。如果我们想的话，可以先使用 `Format-` cmdlet 格式化输出，但也不一定需要这么做；如果不格式化，我们将得到
    cmdlet 的默认输出。我们来试试看：'
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As we can see, the content of the text files looks exactly the same as the screen
    outputs; all we’ve done is redirect the output to a file instead of the screen.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，文本文件的内容与屏幕输出完全相同；我们所做的只是将输出重定向到文件，而不是屏幕。
- en: 'There are a few parameters we can use with `Out-File`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以与 `Out-File` 一起使用的一些参数如下：
- en: '`-FilePath` specifies the path and name of the file we want to create. By default,
    `Out-File` will overwrite any pre-existing file with the same name, unless that
    file is read-only.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-FilePath` 指定我们要创建的文件的路径和名称。默认情况下，`Out-File` 会覆盖任何具有相同名称的已存在文件，除非该文件是只读的。'
- en: '`-Append` will add the output to an existing file, again, if it is not set
    to read-only.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Append` 将输出添加到现有文件中，再次提醒，如果文件不是只读的。'
- en: '`-NoClobber` will check whether a file already exists and prevent it from being
    overwritten. We’ll see an error message saying that the file already exists.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-NoClobber` 将检查文件是否已存在，并防止其被覆盖。如果文件已经存在，我们将看到一个错误信息。'
- en: '`-Force` will allow us to ignore the read-only attribute on existing files.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Force` 将允许我们忽略现有文件的只读属性。'
- en: '`-Encoding` can change the default encoding of the file from ASCII to a range
    of other formats; a popular one is UTF-8.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Encoding` 可以将文件的默认编码从 ASCII 更改为其他多种格式；一种常用的格式是 UTF-8。'
- en: '`Out-File` also has a couple of aliases that we might see quite often. The
    greater-than symbol (`>`) is an alias for `Out-File -FilePath`, and we just need
    to type a path and file name after it. A double greater-than symbol (`>>`) is
    an alias for `Out-File -Append -FilePath` and again, just needs a path and filename.
    We can’t use any other parameters with these aliases. For example, `Get-Process
    > C:\temp\processes.txt` will take the output of `Get-Process` and save it to
    `C:\temp.txt` – if we then run `Get-Date >> C:\temp\processes.txt`, it will append
    the output of `Get-Date` to the same file.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`Out-File` 还有几个别名，我们可能经常看到。大于符号（`>`）是 `Out-File -FilePath` 的别名，我们只需要在后面输入路径和文件名。双大于符号（`>>`）是
    `Out-File -Append -FilePath` 的别名，同样只需要路径和文件名。我们不能使用其他参数与这些别名一起使用。例如，`Get-Process
    > C:\temp\processes.txt` 会将 `Get-Process` 的输出保存到 `C:\temp\processes.txt`，如果我们接着运行
    `Get-Date >> C:\temp\processes.txt`，它会将 `Get-Date` 的输出追加到同一个文件中。'
- en: '`Out-File` only produces a file. It doesn’t put any object in the pipeline,
    so must be the last cmdlet in a pipeline.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`Out-File` 只会生成一个文件。它不会将任何对象放入管道，因此必须是管道中的最后一个 cmdlet。'
- en: The first important thing to remember is that what gets written to the file
    is *exactly* what we would see on the screen.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要记住的一个重要事情是，写入文件的内容是*完全*与我们在屏幕上看到的一样的。
- en: 'The other important thing to remember is that a file we create with `Out-File`
    is a text file. We can call it a CSV file if we want, but it won’t be. The data
    won’t be converted; no commas will be inserted. Let’s demonstrate:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的事情是，我们用 `Out-File` 创建的文件是文本文件。我们可以把它称作 CSV 文件，但它并不是。数据不会被转换，也不会插入逗号。我们来演示一下：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As expected, the contents of the CSV file created in the last line look horrible.
    Here’s what it looks like if I try to open it in MS Excel, my usual app for manipulating
    CSV files:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，上一行创建的 CSV 文件的内容看起来非常糟糕。如果我尝试在 MS Excel 中打开它，这是我的常用应用程序来处理 CSV 文件，它看起来就是这样：
- en: '![Figure 6.3 – This is not a CSV file](img/B17600_06_03.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.3 – 这不是一个 CSV 文件](img/B17600_06_03.jpg)'
- en: Figure 6.3 – This is not a CSV file
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 – 这不是一个 CSV 文件
- en: We’ll have a look at how we can produce different types of files in the next
    section, using the `ConvertTo-` and `Export-` cmdlets.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将看看如何使用 `ConvertTo-` 和 `Export-` cmdlet 生成不同类型的文件。
- en: Using ConvertTo- and Export- cmdlets
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ConvertTo- 和 Export- cmdlet
- en: If we want our PowerShell objects in a format other than text, we’re going to
    need to process them somehow. There are two groups of cmdlets that let us do that.
    The `ConvertTo-` cmdlets convert the objects in our pipeline into data of a particular
    type, such as CSV or HTML data. The `Export-` cmdlets combine the equivalent `ConvertTo-`
    cmdlet with an `Out-File` function to produce a file of the relevant type. In
    this chapter, we’re going to cover three common file types; CSV, XML, and HTML.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望我们的 PowerShell 对象以文本以外的格式出现，我们需要以某种方式处理它们。这里有两个 cmdlet 组可以让我们做到这一点。`ConvertTo-`
    cmdlet 会将我们管道中的对象转换为某种特定类型的数据，比如 CSV 或 HTML 数据。`Export-` cmdlet 则将等效的 `ConvertTo-`
    cmdlet 与 `Out-File` 功能结合，生成相关类型的文件。在本章中，我们将介绍三种常见的文件类型：CSV、XML 和 HTML。
- en: CSV
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CSV
- en: 'Let’s look at the `ConvertTo-CSV` cmdlet first. With this cmdlet, we can take
    the output of another cmdlet and turn it into a CSV datastream. Try this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看看 `ConvertTo-CSV` cmdlet。通过这个 cmdlet，我们可以将另一个 cmdlet 的输出转换成 CSV 数据流。试试看：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You’ll see something like the following screenshot:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到类似下面的截图：
- en: '![Figure 6.4 – Nasty](img/B17600_06_04.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.4 – 丑陋](img/B17600_06_04.jpg)'
- en: Figure 6.4 – Nasty
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 – 丑陋
- en: 'Ugh. Horrible, right? However, we can then pipe that into `Out-File` as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 呜，糟糕吧？不过，我们可以将其通过管道传递给`Out-File`，如下所示：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It will produce a real CSV file of all the processes starting with `w` that
    we can open in an application that reads CSV, such as MS Excel or Google Sheets.
    Not only that but it also ignores the default format information and just dumps
    everything.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 它会生成一个真实的 CSV 文件，包含所有以 `w` 开头的进程，可以在支持 CSV 格式的应用程序中打开，比如 MS Excel 或 Google Sheets。不仅如此，它还会忽略默认的格式信息，直接将所有内容输出。
- en: 'Even better, there is a cmdlet that will do the whole thing in one operation
    – `Export-Csv`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的是，有一个 cmdlet 可以在一个操作中完成整个过程——`Export-Csv`：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Let’s take a closer look.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再仔细看看。
- en: ConvertTo-Csv
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ConvertTo-Csv
- en: 'This cmdlet has a few parameters we will be interested in:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 cmdlet 有一些我们可能感兴趣的参数：
- en: '`-NoTypeInformation`: A lot of the scripts we might see on the internet will
    include this parameter, but we don’t need it anymore. Prior to PowerShell 6.0,
    by default, the `ConvertTo-Csv` cmdlet included an introductory line that detailed
    the object type that had been converted, so any scripts that were written for
    earlier versions of PowerShell almost always included this parameter to remove
    that line. Since PowerShell 6.0, the default is to *not* include type information.
    Including the parameter won’t cause a problem, but we don’t need it in PowerShell
    7.x.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-NoTypeInformation`：我们在互联网上看到的很多脚本会包含此参数，但现在不再需要它。早于 PowerShell 6.0 时，`ConvertTo-Csv`
    cmdlet 默认会包含一行介绍，详细说明已转换的对象类型，因此为旧版本 PowerShell 编写的脚本几乎总是会包含此参数来移除该行。自 PowerShell
    6.0 起，默认设置是不包括类型信息。包含此参数不会造成问题，但在 PowerShell 7.x 中我们不再需要它。'
- en: '`-IncludeTypeInformation`: Use this if you *do* want to know the type of the
    object in the first line of the CSV stream.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-IncludeTypeInformation`：如果你*确实*希望在 CSV 流的第一行了解对象类型，可以使用此参数。'
- en: '`-Delimiter`: We usually want our CSV file to use a comma as the field delimiter
    character, but sometimes we might need to produce a `` `t ``, or perhaps use a
    colon or semicolon. We can use this parameter to specify a different delimiter
    character – for example, in the following:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Delimiter`：我们通常希望 CSV 文件使用逗号作为字段分隔符字符，但有时可能需要使用 `` `t ``，或者使用冒号或分号。我们可以使用此参数来指定不同的分隔符字符—例如，在以下情况下：'
- en: '[PRE11]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`-UseQuotes`: This parameter controls how the cmdlet applies double-quote characters.
    By default, every value is double-quoted, turning it into a string, but sometimes
    we might want to keep the values as integers or floating point numbers. We can
    use this parameter to control the quoting behavior.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-UseQuotes`：此参数控制 cmdlet 如何应用双引号字符。默认情况下，每个值都会被双引号包围，将其转化为字符串，但有时我们可能希望将值保留为整数或浮动点数。我们可以使用此参数来控制引用行为。'
- en: '`-QuoteFields`: If we need even finer control over quoting behavior, we can
    specify the fields in which we want the values to be double-quoted. The first
    line of the CSV file is the field names and it may take a bit of experimentation
    to get this right.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-QuoteFields`：如果我们需要更精细的控制引用行为，可以指定要双引号包围的字段。CSV 文件的第一行是字段名称，可能需要一些试验才能正确设置。'
- en: Once we’ve converted our objects into a CSV datastream, we can either pipe it
    to `Out-File` or consume it in some other way; for instance, we might want to
    create a number of CSV objects and then aggregate and manipulate them before outputting
    a single file.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将对象转换为 CSV 数据流，可以将其通过管道传递给 `Out-File` 或以其他方式使用；例如，我们可能希望创建多个 CSV 对象，然后聚合和操作它们，最后输出一个单一的文件。
- en: Export-Csv
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Export-Csv
- en: 'The `Export-Csv` cmdlet combines `ConvertTo-Csv` with `Out-File` in a single
    cmdlet. It has the same interesting parameters that we’ve already discussed for
    those cmdlets. Here are the matching `Out-File` parameters:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`Export-Csv` cmdlet 将 `ConvertTo-Csv` 与 `Out-File` 合并为一个 cmdlet。它具有我们已经讨论过的与这些
    cmdlet 相匹配的参数。以下是与 `Out-File` 匹配的参数：'
- en: '`-Path (instead` `of -FilePath)`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Path`（代替 `-FilePath`）'
- en: '`-``Force`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-``Force`'
- en: '`-``NoClobber`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-``NoClobber`'
- en: '`-``Encoding`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-``编码`'
- en: '`-``Append`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-``Append`'
- en: 'Here are the parameters from `ConvertTo-Csv`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `ConvertTo-Csv` 的参数：
- en: '`-``Delimiter`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-``Delimiter`'
- en: '`-``NoTypeInformation`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-``NoTypeInformation`'
- en: '`-``IncludeTypeInformation`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-``IncludeTypeInformation`'
- en: '`-``QuoteFields`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-``QuoteFields`'
- en: '`-``UseQuotes`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-``UseQuotes`'
- en: The parameters for `Export-Csv` work the same as the equivalent parameters in
    `ConvertTo-Csv` and `Out-File`. There are no aliases for `Export-Csv`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`Export-Csv` 的参数与 `ConvertTo-Csv` 和 `Out-File` 中的对应参数一样，`Export-Csv` 没有别名。'
- en: XML
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XML
- en: '`ConvertTo-Xml` and `Export-Clixml`.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConvertTo-Xml` 和 `Export-Clixml`。'
- en: ConvertTo-Xml
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ConvertTo-Xml
- en: 'This cmdlet only has a handful of parameters:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 此 cmdlet 只有少量的参数：
- en: '`-As`: This parameter allows us to specify the output format; whether it’s
    a single string, an array of strings, or an `XmlDocument` object.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-As`：此参数允许我们指定输出格式；无论是单个字符串、字符串数组，还是 `XmlDocument` 对象。'
- en: '`-Depth`: We can use this to limit the number of levels and sublevels the document
    can contain. By default, this isn’t specified.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Depth`：我们可以使用此参数限制文档可以包含的层级和子层级的数量。默认情况下，未指定此参数。'
- en: '`-NoTypeInformation`: This stops the object type information from being written.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-NoTypeInformation`：这会阻止对象类型信息被写入。'
- en: Export-Clixml
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Export-Clixml
- en: '`Export-Clixml` cmdlet is pretty simple. It has one of the `ConvertTo-Xml`
    parameters, `-Depth`, and then the following `Out-File` parameters:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`Export-Clixml` cmdlet 非常简单。它有一个 `ConvertTo-Xml` 参数 `-Depth`，然后是以下 `Out-File`
    参数：'
- en: '`-Path (instead` `of -FilePath)`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Path (而不是` `-FilePath)`'
- en: '`-``Force`'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-``Force`'
- en: '`-``NoClobber`'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-``NoClobber`'
- en: '`-``Encoding`'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-``编码`'
- en: 'Let’s create an XML file we can use later:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个可以稍后使用的XML文件：
- en: '[PRE12]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Try opening that in an editor such as notepad or VS Code. You should see something
    like the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在记事本或VS Code中打开它。你应该会看到类似以下内容：
- en: '![Figure 6.5 – A date represented in XML](img/B17600_06_05.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图6.5 – 作为XML表示的日期](img/B17600_06_05.jpg)'
- en: Figure 6.5 – A date represented in XML
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5 – 作为XML表示的日期
- en: The important bit is line 3\. That’s the actual data; the rest is formatting
    information and information about the type of object. Keep this file and we’ll
    use it later in the chapter.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 关键部分是第3行。那才是实际的数据，其余的是格式信息和对象类型的信息。保留这个文件，稍后我们将在本章中使用它。
- en: HTML
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTML
- en: 'It is really useful to be able to convert our PowerShell output into HTML,
    as we can display it in a web browser. This is a popular technique for writing
    reports in system administration. We can use it to produce dashboards and other
    online reports. There are better techniques for creating data that can be consumed
    by web APIs and we’ll be looking at those in the next chapter. There is only one
    cmdlet for creating HTML code; `ConvertTo-Html`. If we want to write it to a file,
    we’ll need to use `Out-File`. Try this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 能够将我们的PowerShell输出转换为HTML非常有用，因为我们可以在网页浏览器中显示它。这是系统管理中编写报告的流行技术。我们可以用它来生成仪表板和其他在线报告。虽然有更好的方法可以创建可以被Web
    API使用的数据，但我们将在下一章中讨论这些方法。创建HTML代码的cmdlet只有一个；`ConvertTo-Html`。如果我们想将其写入文件，我们需要使用`Out-File`。试试这个：
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you then open `Date.html` in your web browser, you should see something
    like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在浏览器中打开`Date.html`，你应该会看到类似这样的内容：
- en: '![Figure 6.6 – A date as HTML](img/B17600_06_06.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图6.6 – 作为HTML的日期](img/B17600_06_06.jpg)'
- en: Figure 6.6 – A date as HTML
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6 – 作为HTML的日期
- en: That’s not particularly inspiring. Let’s take a closer look at the cmdlet to
    see whether we can make it more interesting
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不特别有启发性。让我们仔细看看这个cmdlet，看看是否能让它更有趣。
- en: ConvertTo-Html
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ConvertTo-Html
- en: 'The `ConvertTo-Html` cmdlet has quite a few interesting parameters that we
    can use to format our output:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConvertTo-Html` cmdlet有几个有趣的参数，我们可以用来格式化输出：'
- en: '`-As`: This parameter allows us to format the output as a table or as a list.
    By default, we get a table.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-As`：这个参数允许我们将输出格式化为表格或列表。默认情况下，我们得到的是表格。'
- en: '`-Body`: This allows us to add text after the opening `<body>` tag. This is
    the main part of any web page. We’re not going to explain how HTML works here
    – if you would like a refresher on HTML, then [https://www.w3schools.com/](https://www.w3schools.com/)
    is an excellent and free online resource.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Body`：这允许我们在打开的`<body>`标签后添加文本。这是任何网页的主体部分。我们这里不会解释HTML的工作原理——如果你想复习HTML，可以参考[https://www.w3schools.com/](https://www.w3schools.com/)这个优秀且免费的在线资源。'
- en: '`-Head`: This allows us to write text in the `<``head>` section.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Head`：这允许我们在`<head>`部分写入文本。'
- en: '`-Title`: This allows us to give the page a title. Unlike `-Body` and `-Head`,
    it only takes a single string.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Title`：这允许我们为页面指定一个标题。与`-Body`和`-Head`不同，它只接受一个字符串。'
- en: '`-PreContent`: This allows us to write text before the table we create.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-PreContent`：这允许我们在创建的表格之前写入文本。'
- en: '`-PostContent`: This allows us to add text after the table.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-PostContent`：这允许我们在表格后添加文本。'
- en: '`-Meta`: This allows us to add metatags to the head.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Meta`：这允许我们向`<head>`部分添加元标签。'
- en: '`-Fragment`: This omits the `<head>` and `<body >` tags and just writes the
    HTML to produce the table. This is handy if we are going to concatenate a bunch
    of fragments into one single web page.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Fragment`：这会省略`<head>`和`<body>`标签，仅编写HTML以生成表格。如果我们将多个片段合并为一个网页，这非常有用。'
- en: '`-CssUri`: This allows us to specify a CSS file to provide additional formatting,
    such as different fonts, background colors, and so on. I encourage you to have
    a look at [http://www.csszengarden.com/](http://www.csszengarden.com/) to see
    some of the amazing things we can do with CSS.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-CssUri`：这允许我们指定一个CSS文件，以提供额外的格式设置，如不同的字体、背景颜色等。我建议你访问[http://www.csszengarden.com/](http://www.csszengarden.com/)来看看我们可以用CSS做的一些惊人事情。'
- en: 'Let’s have a play. Open a new file in VS Code, select CSS as the language,
    and type the following exactly as written:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来玩一下。打开VS Code中新建一个文件，选择CSS作为语言，并严格按照以下内容输入：
- en: '[PRE14]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Save it as `style.css` in your working directory, `C:\temp\poshbook`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 将它保存为`style.css`，存放在你的工作目录`C:\temp\poshbook`中。
- en: 'Create a new PowerShell file in the same directory and try this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一目录下创建一个新的PowerShell文件并试试这个：
- en: '[PRE15]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you select and run your code, you should see the following output:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择并运行你的代码，你应该会看到以下输出：
- en: '![Figure 6.7 – A date as fancy HTML](img/B17600_06_07.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.7 – 一个漂亮的 HTML 日期](img/B17600_06_07.jpg)'
- en: Figure 6.7 – A date as fancy HTML
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.7 – 一个漂亮的 HTML 日期
- en: 'There is a great article on how to write HTML documents in PowerShell here:
    [https://leanpub.com/creatinghtmlreportsinwindowspowershell/read](https://leanpub.com/creatinghtmlreportsinwindowspowershell/read).'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一篇关于如何在 PowerShell 中编写 HTML 文档的精彩文章：[https://leanpub.com/creatinghtmlreportsinwindowspowershell/read](https://leanpub.com/creatinghtmlreportsinwindowspowershell/read)。
- en: That’s a good start on how to create files. Next, let’s briefly divert to `PSProviders`,
    `PSDrives`, and the `New-Item` cmdlet.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这是创建文件的一个良好开端。接下来，我们简要介绍一下 `PSProviders`、`PSDrives` 和 `New-Item` cmdlet。
- en: Handling files
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理文件
- en: Before we can work with files, we need to be able to find them, and understand
    how PowerShell works with hierarchical data structures such as filesystems.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能处理文件之前，我们需要能够找到它们，并了解 PowerShell 如何处理诸如文件系统之类的层次结构数据结构。
- en: A brief note about PSProviders and PSDrives
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于 PSProviders 和 PSDrives 的简要说明
- en: 'PowerShell connects to data structures through software called **providers**.
    These allow PowerShell to present a data structure as a filesystem (including
    the filesystem). On Windows, this allows us to search for and manipulate objects
    in the Registry and the Certificate Store as if they were files. Arguably, it
    is less useful on Linux. Let’s have a look. Run this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 通过名为 **提供程序** 的软件连接到数据结构。这些提供程序使 PowerShell 能够将数据结构呈现为文件系统（包括文件系统本身）。在
    Windows 上，这使得我们可以像操作文件一样搜索和操作注册表和证书存储中的对象。可以说，在 Linux 上它的用途较小。让我们来看一下。运行以下命令：
- en: '[PRE16]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You should see a list of providers and associated drives. We can connect to
    the associated drive with the `Set-Location` cmdlet:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能看到提供程序及其关联驱动器的列表。我们可以使用 `Set-Location` cmdlet 连接到关联驱动器：
- en: '[PRE17]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note we have to use the name of the drive, not the name of the provider, and
    we need to follow it with a colon.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们必须使用驱动器的名称，而不是提供程序的名称，并且需要在后面加上冒号。
- en: 'Once in the data structure, we can use `Get-ChildItem` to search for objects,
    as in the following screenshot, which lists out the environment variables as if
    they were filesystem objects:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进入数据结构，我们可以使用 `Get-ChildItem` 来搜索对象，如下图所示，这列出了环境变量，就像它们是文件系统对象一样：
- en: '![Figure 6.8 – The environment provider](img/B17600_06_08.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.8 – 环境提供程序](img/B17600_06_08.jpg)'
- en: Figure 6.8 – The environment provider
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.8 – 环境提供程序
- en: Providers are dynamic; that is, they don’t need to know what is in the store
    before connecting to it and so they are popular as a way of providing access to
    data structures. While there are only a few included in PowerShell by default,
    you will find that some modules will add new providers, especially in Windows.
    For instance, if we install the `ActiveDirectory` module, then we will have access
    to an `AD:` drive containing the Active Directory data.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 提供程序是动态的；也就是说，它们不需要在连接之前知道存储中的内容，因此它们作为提供访问数据结构的方式非常流行。虽然默认情况下 PowerShell 只包含少数几个提供程序，但你会发现一些模块会添加新的提供程序，特别是在
    Windows 上。例如，如果我们安装了 `ActiveDirectory` 模块，那么我们将可以访问一个包含 Active Directory 数据的 `AD:`
    驱动器。
- en: 'Note that just installing the provider is not enough. We also need to have
    a drive object before we can browse it. The drive is the thing we work with; the
    provider is the software that lets us access it. Most modules will create the
    required drive as well as install the provider. We can create our own drives quite
    easily. In my home directory on my Ubuntu machine, I have a directory called `MyFiles`.
    I can make this a drive by running the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，仅仅安装提供程序是不够的。我们还需要有一个驱动器对象才能浏览它。驱动器是我们工作的对象，而提供程序是让我们访问它的软件。大多数模块会创建所需的驱动器并安装提供程序。我们可以非常容易地创建自己的驱动器。在我的
    Ubuntu 机器的主目录中，我有一个名为 `MyFiles` 的目录。我可以通过运行以下命令将其创建为驱动器：
- en: '[PRE18]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, I can browse the `MyFiles:` drive, like so:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我可以像这样浏览 `MyFiles:` 驱动器：
- en: '![Figure 6.9 – Creating a new drive](img/B17600_06_09.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.9 – 创建一个新的驱动器](img/B17600_06_09.jpg)'
- en: Figure 6.9 – Creating a new drive
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.9 – 创建一个新的驱动器
- en: Item- cmdlets
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目 cmdlet
- en: 'We use the `-Item` and `-Childitem` cmdlets to move around the filesystem and
    find items. We’re not going to cover them in detail here, as they are self-explanatory.
    Read the associated help files to understand their simple syntax:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `-Item` 和 `-Childitem` cmdlet 在文件系统中移动并查找项。这里不做详细介绍，因为它们是自解释的。阅读相关帮助文件以了解它们简单的语法：
- en: '`Get-ChildItem` lists the items found in a location:'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Get-ChildItem` 列出位置中找到的项目：'
- en: '[PRE19]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Move-Item lets us move an item to a different location:'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Move-Item 允许我们将项目移动到不同的位置：
- en: '[PRE20]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Remove-Item lets us delete an item:'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Remove-Item` 允许我们删除一个项目：'
- en: '[PRE21]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Get-Item has returned the properties of the C:\temp\poshbook folder, whereas
    Get-ChildItem has returned the folder and its contents.
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Get-Item` 返回了 C:\temp\poshbook 文件夹的属性，而 `Get-ChildItem` 返回了该文件夹及其内容。'
- en: '[PRE22]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`Set-Item`: Again, this is not hugely useful in the filesystem. However, if
    we wanted to change the value of an environment variable or an alias, then we
    would use this cmdlet.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Set-Item`：同样，在文件系统中这不是特别有用。然而，如果我们想要更改环境变量或别名的值，则需要使用此 cmdlet。'
- en: '`New-Item`: We can use this to create files and folders, as well as create
    new aliases and variables:'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`New-Item`：我们可以用它来创建文件和文件夹，以及创建新的别名和变量：'
- en: '[PRE25]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Invoke-Item -Path C:\temp\poshbook\FancyDate.html
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Invoke-Item -Path C:\temp\poshbook\FancyDate.html
- en: '[PRE26]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: There are also two cmdlets for moving around in and between drives; `Get-Location`
    and `Set-Location`. Many of these cmdlets have aliases associated with them that
    echo the equivalent bash and Windows commands – for instance, `Get-ChildItem`
    can be called by using `ls` or `dir`. Note, however, that the parameters are still
    those for PowerShell, not for the bash or Windows command. For example, `Dir /p`
    will not produce a paginated directory listing – it will produce an error.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 还有两个 cmdlet 用于在驱动器之间和驱动器内部移动；`Get-Location` 和 `Set-Location`。许多这些 cmdlet 都有与之关联的别名，模拟等效的
    bash 和 Windows 命令——例如，`Get-ChildItem` 可以通过 `ls` 或 `dir` 调用。不过请注意，参数仍然是 PowerShell
    的，而不是 bash 或 Windows 命令的。例如，`Dir /p` 并不会生成分页目录列表，而是会产生一个错误。
- en: Now that we know how to find our files and move them around, let’s look at what
    is inside them.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何找到文件并移动它们了，让我们看看文件里面有什么内容。
- en: Working with files
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作文件
- en: Using PowerShell to read the contents of files and manipulate that data is a
    common task. We’re going to look at three cmdlets in this section. First, let’s
    explore the generic `Get-Content` cmdlet.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 PowerShell 读取文件内容并操作数据是一个常见任务。在这一部分中，我们将介绍三个 cmdlet。首先，我们来了解一下通用的 `Get-Content`
    cmdlet。
- en: Get-Content
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Get-Content
- en: 'The `Get-Content` cmdlet can get any type of data in a file and store it as
    an array of strings or bytes (as a bytestream). By default, each line in the file
    will be interpreted as a single string. We will only get meaningful content if
    the file can be interpreted as an array of strings; otherwise, we must fetch it
    as a bytestream. This is useful if we are getting the contents of an executable
    file, for example. It’s got a few parameters. Here are the more interesting ones:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`Get-Content` cmdlet 可以获取文件中的任何类型数据，并将其存储为字符串或字节的数组（字节流）。默认情况下，文件中的每一行将被解释为单个字符串。只有当文件可以被解释为字符串数组时，我们才能获得有意义的内容；否则，我们必须将其作为字节流获取。这在我们获取可执行文件的内容时非常有用。它有几个参数，下面是一些较为重要的：'
- en: '`-Path` specifies the item we want. This accepts an array of string values
    so that we can concatenate multiple files into a single array.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Path` 指定了我们想要的项目。它接受一个字符串数组，这样我们就可以将多个文件连接成一个单一的数组。'
- en: '`-TotalCount` is the total number of lines to read from the file. The default
    is `-1`, which will read to the last line, but we can check just the first few
    lines of a file to make sure that it is as we expect it to be without loading
    the whole thing.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-TotalCount` 是从文件中读取的总行数。默认值是 `-1`，表示读取到最后一行，但我们可以只检查文件的前几行，以确保文件内容符合预期，而不需要加载整个文件。'
- en: '`-ReadCount` is the number of lines that can be sent through the pipeline at
    a time.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-ReadCount` 是每次通过管道发送的行数。'
- en: '`-AsByteStream` allows us to get the content as bytes rather than as strings.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-AsByteStream` 允许我们将内容作为字节而非字符串获取。'
- en: '`-Credential` allows us to supply alternative credentials to open the file.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Credential` 允许我们提供替代凭据以打开文件。'
- en: '`-Delimiter` allows us to specify the character that is used to separate strings.
    By default, it is the newline character (`` `n ``), but we can use anything we
    like.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Delimiter` 允许我们指定用于分隔字符串的字符。默认情况下，它是换行符（`` `n ``），但我们可以使用任何字符。'
- en: '`-Encoding` can be used to specify that the contents are encoded in a different
    format to the default; **UTF-8 with no Byte Order** **Mark** (**utf8NoBOM**).'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Encoding` 可用于指定内容使用与默认格式不同的编码；**没有字节顺序标记的 UTF-8 编码** (**utf8NoBOM**)。'
- en: '`-Raw` will return the entire contents as a single string.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Raw` 将返回整个内容作为一个单一字符串。'
- en: '`-Tail` is like `-TotalCount`, but works backward and gets lines from the end.
    We can’t use it with `-TotalCount`.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Tail` 类似于 `-TotalCount`，但它是从文件的末尾向回读取行。不能与 `-TotalCount` 一起使用。'
- en: '`Get-Content` is similar in function to the `cat` command in Linux and, unsurprisingly,
    `cat` is an alias for it.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`Get-Content` 的功能类似于 Linux 中的 `cat` 命令，毫不意外的是，`cat` 是它的别名。'
- en: '`Get-content` is one of the most common ways of bringing data into PowerShell
    so that we can work with it, but it’s not very flexible. For instance, if we try
    to get a CSV file, then it will interpret the file as text, rather than a specially
    formatted file. Let’s have a look at how we can import information in a structured
    way.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`Get-content` 是将数据导入 PowerShell 以便我们操作的最常见方法之一，但它的灵活性较差。例如，如果我们尝试获取一个 CSV 文件，它会将该文件作为文本文件解释，而不是作为一个特殊格式化的文件。让我们看看如何以结构化的方式导入信息。'
- en: Import- cmdlets
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Import- cmdlet
- en: Like the `Export-` cmdlets, the `Import-` cmdlets perform two operations at
    once. They combine `Get-Content` with a specialist parser that will interpret
    the information and format it correctly for the original file type, allowing us
    to manipulate something that looks like the original objects. Let’s look at `Import-Csv`
    first.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `Export-` cmdlet 一样，`Import-` cmdlet 同时执行两个操作。它们将 `Get-Content` 与专门的解析器结合，解析器会解释信息并根据原始文件类型正确地格式化它，使我们能够操作看起来像原始对象的内容。让我们先来看看
    `Import-Csv`。
- en: Import-Csv
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Import-Csv
- en: 'The `Import-Csv` cmdlet only has a few parameters:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`Import-Csv` cmdlet 只有几个参数：'
- en: '`-Delimiter`: Just in case the file is using something other than a comma to
    separate values'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Delimiter`：以防文件使用除逗号以外的其他字符分隔值。'
- en: '`-Path`: To identify the file to be imported'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Path`：用于标识要导入的文件。'
- en: '`-Header`: To specify manual column name information if your CSV file doesn’t
    have it'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Header`：如果你的 CSV 文件没有列名，可以手动指定列名信息。'
- en: '`-Encoding`: If your file has come from a system that didn’t output it as `utf8NoBOM`.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Encoding`：如果文件来自一个没有输出为 `utf8NoBOM` 的系统。'
- en: 'The cmdlet expects the file to contain string objects and outputs `PSCustomObjects`
    with note properties that match the column headers in the original file. Let’s
    have a play:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 该 cmdlet 期望文件包含字符串对象，并输出带有与原始文件中列标题匹配的注释属性的 `PSCustomObjects`。我们来试试看：
- en: '[PRE27]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This will output the name values of each object in the array. The next command
    will show us that we haven’t recreated process objects, we’ve created new `PSCustomObjects`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出数组中每个对象的名称值。接下来的命令将展示我们没有重建进程对象，而是创建了新的 `PSCustomObjects`：
- en: '[PRE28]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following command will retrieve the second element in the array. Because
    there is no default view or default properties list, all properties will be displayed:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将检索数组中的第二个元素。由于没有默认视图或默认属性列表，所有属性将会显示：
- en: '[PRE29]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You should see something like this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到类似这样的内容：
- en: '![Figure 6.10 – Importing a CSV file](img/B17600_06_10.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.10 – 导入 CSV 文件](img/B17600_06_10.jpg)'
- en: Figure 6.10 – Importing a CSV file
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.10 – 导入 CSV 文件
- en: Importing CSVs into PowerShell is great if you have, for instance, a list of
    users and you need to pipe them through a loop to get their home drive size, or
    you want to create a lookup table.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 将 CSV 文件导入 PowerShell 非常方便，例如，当你有一份用户列表，并且需要通过循环获取他们的主驱动器大小，或者你想创建一个查找表时。
- en: Import-Clixml
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Import-Clixml
- en: 'If you have an XML file that was generated by PowerShell, then you can use
    the `Import-Clixml` cmdlet to recreate something that looks much more like the
    original objects. There aren’t many parameters to this cmdlet. Here are the most
    interesting ones:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个 PowerShell 生成的 XML 文件，你可以使用 `Import-Clixml` cmdlet 来重建看起来更像原始对象的内容。这个
    cmdlet 并没有太多参数。以下是一些最有趣的参数：
- en: '`-Path` specifies the file to be imported.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Path` 指定要导入的文件。'
- en: '`-Skip` allows us to skip a specified number of objects in the file.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Skip` 允许我们跳过文件中的指定数量的对象。'
- en: '`-First` gets only a specified number of objects from the start of the file.
    Clixml files can be huge, so this is handy if we want to check what’s inside.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-First` 只获取文件开头指定数量的对象。Clixml 文件可能非常大，因此如果我们想检查文件中的内容，这个参数非常有用。'
- en: '`-IncludeTotalCount` tells us how many objects are in the file. Interestingly,
    it has an accuracy property that tells us how reliable the estimate is.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-IncludeTotalCount` 告诉我们文件中有多少个对象。有趣的是，它有一个精度属性，告诉我们估算值的可靠性。'
- en: 'Let’s have a play with it. Try this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们玩一下。试试这个：
- en: '[PRE30]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can see that what we get back is a date object. Let’s try another one:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到返回的是一个日期对象。再试一个例子：
- en: '[PRE31]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If we then call `$XmlProcs`, we can see that the output displays exactly as
    we’d expect for the `Get-Process` cmdlet:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们调用 `$XmlProcs`，可以看到输出显示与我们期望的 `Get-Process` cmdlet 完全一致：
- en: '![Figure 6.11 – Recreating objects with Import-Clixml](img/B17600_06_11.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.11 – 使用 Import-Clixml 重建对象](img/B17600_06_11.jpg)'
- en: Figure 6.11 – Recreating objects with Import-Clixml
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'However, they’re not quite the objects we exported. Let’s run the following:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We can see that they are `Deserialized.System.Diagnostics.Process` objects.
    This tells us that they have been turned into a data object and then retrieved
    from a file, and they are not live objects.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most common uses for this is to store credentials securely. Try
    this:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We’re asked to enter a username and password.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'We can pipe the credential variable into an XML file:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: That file can now be stored on a disk somewhere. It is encrypted by the `Export-Clixml`
    cmdlet.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then import it back using `Import-Clixml`:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We get a credential object. You can see in the following screenshot what the
    XML file looks like. The password is the encrypted hex string:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.12 – Storing encrypted credentials](img/B17600_06_12.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
- en: Figure 6.12 – Storing encrypted credentials
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Note that the encryption uses our login credentials for the machine we were
    using when we encrypted the file. No other user can decrypt that easily and we
    can’t then decrypt those credentials on another machine.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'We can’t use just import any XML file with `Import-Clixml`. If we try it with
    something that hasn’t been correctly formatted for the cmdlet, we’ll get an error,
    like this:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.13 – We can’t import just anything](img/B17600_06_13.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
- en: Figure 6.13 – We can’t import just anything
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the schema of the XML file is incorrect for the `Import-Clixml`
    cmdlet; there are important lines missing, as we can see from the error message.
    Don’t try running this code – you may well not have the DISM file referenced in
    the cmdlet.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: That’s about it for this chapter. Before we summarize, though, let’s play around
    and consolidate some learning from this chapter and earlier chapters.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Let’s have some fun – measuring the most frequent words in a text file
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of my favorite programming books is *Exercises in Programming Style* by
    Cristina Videira Lopes. It is inspired by the 1947 book by Raymond Queneau, *Exercices
    de Style*, in which the author tells the same story in 99 different styles. Lopes’s
    book contains 41 Python programs that accomplish the same task with different
    programming styles. This book is truly mind-expanding and really changed the way
    I saw writing code; it is as much an art as any other form of creative writing.
    The book itself is not cheap, but all the programs are available on GitHub: [https://github.com/crista/exercises-in-programming-style](https://github.com/crista/exercises-in-programming-style).
    I’d encourage you to have a quick look, even if you don’t know any Python.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem each program solves is to determine the frequency of the words
    in a text file and sort them in descending order; this is an example of a **term
    frequency** problem, and it is a fairly common exercise given to computer science
    students. Let’s have a go at it:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: First, create a new folder in VS Code, and then create a new PowerShell file
    in your new folder called `wordcountBasic.ps1`
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The file I’m going to use is an English translation of Franz Kafka’s classic,
    *The Trial*, but any large text file will do. I downloaded it from here: [https://www.gutenberg.org/ebooks/7849.txt.utf-8](https://www.gutenberg.org/ebooks/7849.txt.utf-8)'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Go ahead and download it and save it in your new folder as `thetrial.txt`.
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we have our data, the next thing to do is to putt the contents of
    the file into a variable. That’s easy. We’ll need to get it as a single huge string,
    rather than an array of strings:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, we can use one of the methods available for string objects to split the
    text into an array of single-word strings:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Notice that there’s a space inside the pair of double quotes.
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s see how many words we’ve got:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: I get 79,978 words. This code may take a while to run.
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now… the next bit is tricky. We need to count how many times each word appears
    in the text. This is where the power of the shell really shines. Doing the next
    bit in Python would require a few lines of string manipulation, but PowerShell
    comes with a built-in cmdlet, `Group-Object`:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The trouble with that line is it will group the objects alphabetically, which
    is not what we want. We want them grouped by frequency, so we need a `Sort-Object`
    cmdlet in the pipeline as well:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We also don’t want to see all the words; we just want the most frequent words.
    Let’s get the most frequent 10\. We can use a formula of `[-1..-10]` to get them
    from the array. We’re using `[-1..-10]` because by default, the sort order is
    ascending and we want it descending. We could run `$GroupedWords[-1..-10]`.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'And that’s it! Here’s my whole program and the output:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.14 – The ten most frequent words in any English book (written by
    a man)](img/B17600_06_14.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
- en: Figure 6.14 – The ten most frequent words in any English book (written by a
    man)
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: We’ve achieved something here, although it’s probably not what we wanted to
    achieve. It looks to me like the list of the 10 most frequent words in any book
    in English, written by a man. What can we do about that?
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: The computer science discipline of **Natural Language Processing** involves
    the concept of **stop words**. These are common words in a language that shouldn’t
    be counted when analyzing the text. There are plenty of lists of stop words available
    on the internet for free. What we need to do is build a loop that compares each
    word in the array to a list of stop words and only adds them to a new array if
    they are *not* in the list.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Activity
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Rewrite the program using a loop to compare each word in the `$TrialWords` array
    to the words in a list of stop words. Use the stop words file at [https://raw.githubusercontent.com/stopwords-iso/stopwords-en/master/stopwords-en.txt](https://raw.githubusercontent.com/stopwords-iso/stopwords-en/master/stopwords-en.txt).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint 1:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'You won’t want to use a PowerShell array for this – why? It’s probably best
    to use an array list. Construct it like this:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '**$Words = [****System.Collections.ArrayList]@()**'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint 2:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need to split the array on more characters than just a space because
    of words that have full stops and other punctuation immediately after them. For
    some characters, you’ll need to use an escape character – the backtick (`` ` ``)
    – for them to be interpreted properly. I found replacing the second line in the
    preceding code with this line to be effective:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '**$TestWords = $TheTrial.Split(“ “, “`t”, “`n”, “,”,”`””,”.”, [****System.StringSplitOptions]::RemoveEmptyEntries)**'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '`RemoveEmptyEntries` prevents null strings from being counted.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '`''t` is the tab character.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '`` `n `` is the newline character.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '`` `" `` allows us to use a double quote mark as a delimiter.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint 3:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Is `That` the same word as `that`? You will want to make sure that all the characters
    in your words are in the same case.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Have fun! I’ve written one way to do it at the end.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is quite a long chapter and it is really only an introduction. We will
    cover more ways of ingesting data with PowerShell as we go through the book. We’ve
    come a long way, though.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 'We started out by looking at how we can format output for the screen using
    three common formatting cmdlets: `Format-List`, `Format-Table`, and `Format-Wide`.
    We then looked at how we could output that formatted data to a text file with
    `Out-File`. We took some time to understand the limitations of this approach before
    we explored two families of cmdlets: `ConvertTo-` and `Export-`.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: We took quite a deep look at the cmdlets for handling CSV files, `ConvertTo-Csv`
    and `Export-Csv`, and understood how the `ExportTo-Csv` cmdlet combines the `ConvertTo-Csv`
    and `Out-File` cmdlets. We then looked at `ConvertTo-Xml` and `Export-Clixml`.
    Finally, we looked at `ConvertTo-Html` and experimented with how we can use it
    to produce interestingly formatted documents by referencing a CSS file.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: We then briefly discussed `PSProviders` and `PSdrives` and understood that these
    are more useful in a Windows environment, but are still relevant for Linux and
    macOS.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'We looked at `Get-Content`, the most common way of bringing data into PowerShell,
    and learned that it produces either an array of strings or bytes – to import data
    in a more structured way, we would need to use something else: the `Import-` cmdlets.
    We looked at `Import-Csv` and `Import-Clixml` and saw how they can be used to
    construct PowerShell objects from structured data.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we did some programming and looked at how we can analyze text files
    using PowerShell.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be looking at how we can use PowerShell to interact
    with systems on the internet and the common file formats we will need.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How would you produce a wide list of the names of all the files in your temp
    directory, with three columns?
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What will happen if we run this code?
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Add a “`Sooo much"` string to the file from *question 3*.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向*问题 3*中的文件添加一个字符串“`Sooo much`”。
- en: Write a statement to create a file containing all the items in your working
    directory to a CSV file, but separated with semicolons rather than commas.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写一条语句，将工作目录中的所有项目创建为一个 CSV 文件，但用分号而非逗号分隔。
- en: How many functions are defined in your PowerShell session?
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 PowerShell 会话中定义了多少个函数？
- en: How would you import the text file from *question 4* using a space as a string
    separator?
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何使用空格作为字符串分隔符来导入*问题 4*中的文本文件？
- en: How would you import the file you created in *question 5* and what sort of objects
    would you get?
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何导入你在*问题 5*中创建的文件，你会得到什么类型的对象？
- en: What does the following error tell us?
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下错误告诉我们什么？
- en: '[PRE42]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Further reading
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: We really should read all the help files for the cmdlets we’ve used in this
    chapter. We know how to find them, so we’re not going to list them here.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真的应该阅读本章中使用的所有 cmdlet 的帮助文件。我们知道如何找到它们，因此这里不再列出。
- en: 'To learn about HTML and CSS, go to the W3Schools website: [https://www.w3schools.com/](https://www.w3schools.com/)'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解 HTML 和 CSS，请访问 W3Schools 网站：[https://www.w3schools.com/](https://www.w3schools.com/)
- en: 'To learn more about Serialization, have a look here: [https://docs.microsoft.com/en-us/dotnet/standard/serialization/introducing-xml-serialization](https://docs.microsoft.com/en-us/dotnet/standard/serialization/introducing-xml-serialization)'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解更多关于序列化的信息，请查看这里：[https://docs.microsoft.com/en-us/dotnet/standard/serialization/introducing-xml-serialization](https://docs.microsoft.com/en-us/dotnet/standard/serialization/introducing-xml-serialization)
