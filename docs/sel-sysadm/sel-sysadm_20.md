# 第十七章：评估

# 第一章

1.  最主要的区别在于，使用 DAC 系统时，用户可以完全控制谁可以访问用户的数据及其访问权限。这由用户自由决定，因此得名。对于 MAC 系统，系统管理员（或安全管理员）定义如何处理和执行访问控制。访问权限由策略强制执行，如果管理员不允许，用户无法绕过该策略。

1.  Linux 在其内核代码中引入了钩子，开发人员可以通过自己的代码订阅这些钩子。这些钩子是**Linux 安全模块**（**LSM**）框架的一部分，LSM 框架是 Linux 内核的原生扩展框架。

    SELinux 是使用此 LSM 框架（及其提供的钩子）来为 Linux 内核及其应用程序提供强制访问控制功能的 MAC 技术之一。还有其他技术存在，包括 AppArmor。

    SELinux 子系统的代码本身也成为了主 Linux 内核的一部分，与其他主要的 LSM 实现一样，尽管这对于支持 LSM 的技术不是强制性要求。然而，这支持了 SELinux 作为一种成熟的开源技术的概念。

1.  SELinux 上下文的四个字段如下：SELinux 用户、SELinux 角色、SELinux 类型和敏感度级别（或敏感度范围）。敏感度级别可能并不总是存在：Linux 发行版可能选择在其策略中禁用敏感度的支持。在这种情况下，SELinux 上下文将只有前三个字段。

1.  SELinux 具有角色的概念，SELinux 类型可以与角色相关联。由于 SELinux 主要关注类型来执行强制控制（SELinux 主要是类型强制系统），基于角色的访问控制通过限制角色可以关联的类型来实现。

    拥有与 DBA 相关角色的用户只能在 DBA 关联的类型内与系统进行交互。由于该角色与其他类型没有任何关联，因此用户也无法获得这些其他类型的权限。

1.  虽然有一个叫做参考策略的项目，但大多数 Linux 发行版会因多种原因偏离该策略。没有一个统一的 SELinux 策略存在的主要原因是，SELinux 是一个精细化的系统，因此可以根据 Linux 发行版的设计和使用原则进行调整和优化。

    问为什么没有一个适用于所有 Linux 发行版的 SELinux 策略，几乎等同于问为什么会有多个 Linux 发行版。每个发行版都有自己的重点、设计、原则和背后的决策，SELinux 策略需要与这些相一致，才能取得成功。

# 第二章

1.  管理员应首先分析情况，找出问题触发的原因。问题可能是由于分配的上下文不正确，或进程未使用正确的方法启动。

    如果拒绝本身被允许，管理员应更新 SELinux 策略（就像他们需要时更新防火墙规则一样）。

    如果这不可行，则管理员应考虑将 SELinux 设置为宽容模式，但仅针对导致问题的特定应用程序。

    如果这也不可行，则管理员应将系统设置为宽容模式，但要确保组织和环境的安全原则接受此做法。

    只有在这些方法都不可行或不能解决问题时，管理员才应该摇头，咒骂更高的力量，并禁用 SELinux。

1.  如果系统运行了审计守护进程，则 SELinux 日志将成为审计日志的一部分。可以使用像 `ausearch` 这样的工具显示它们，或者直接从系统的 `/var/log/audit` 中读取。

    如果没有运行审计守护进程，则 SELinux 日志事件将由系统日志记录器接收，或者通过内核环形缓冲区获取。可以使用`dmesg`命令读取内核环形缓冲区。如果系统日志记录器接收到事件，它们很可能会存储在`/var/log/messages`中。

1.  主动查询 SELinux 策略或 SELinux 系统的应用程序将链接到 `libselinux` 库。如果是这种情况，可以使用 `readelf`、`ldd` 或 `objdump` 查看，显示使用了 `/lib64/libselinux.so.1`（或类似文件）：

    ```
    libselinux library), this is more the exception than the rule for most Linux systems.
    ```

1.  AVC（访问向量缓存）是一个缓存，包含最近和最常用的强制检查，允许 SELinux 子系统更快速地查询是否可以授予某个操作。如果没有 AVC，SELinux 子系统将需要一遍又一遍地遍历整个策略，检查系统上每个操作的权限。

    仅此而已，这会极大地拖慢系统速度。

1.  不，还有一些其他日志事件，管理员在处理 SELinux 时需要注意。一个是 `USER_AVC`，它用于类似 AVC 的事件，但由使用 SELinux 策略的应用程序触发，并且由应用程序自己执行强制（而不是通过 Linux 内核）。另一个是 `SELINUX_ERR`，当触发与常规类型强制无关的内部错误或违规时使用。

    还有其他与 SELinux 密切相关，但并不专属于 SELinux 的事件类型。例如，`MAC_POLICY_LOAD`、`MAC_POLICY_CHANGE` 和 `MAC_STATUS` 是每当 MAC 系统状态或策略更改时触发的事件。

# 第三章

1.  需要一个中间步骤来将角色与 Linux 账户关联，那就是 SELinux 用户。一个 Linux 账户（或登录）被映射到一个 SELinux 用户。然后，SELinux 用户被映射到一个或多个 SELinux 角色，SELinux 用户可以属于这些角色。

    如果我们想为 Linux 用户分配额外的角色，我们需要将其添加到该 Linux 账户所映射的 SELinux 角色中。然而，如果多个 Linux 账户映射到相同的 SELinux 用户，则我们首先需要确保所有这些账户确实被允许使用此角色。如果不允许，则必须为该 Linux 账户创建一个专用的 SELinux 用户。

1.  是的，当用户通过特定服务登录时，会考虑这些映射。管理员可以调整映射，使其依赖于服务，如在 *定制服务登录* 部分所示。

1.  大多数 SELinux 域不允许更改上下文的 SELinux 用户。这使得可以根据 SELinux 用户跟踪活动，即使常规 Linux 用户已更改其用户 ID。需要注意的是，这不仅限于 SELinux，Linux 也支持区分真实用户 ID（尽可能保持静态）和有效用户 ID（例如，在执行 setuid 应用程序时可能会变化）。

    SELinux 用户还允许针对 SELinux 策略的粒度控制，例如，当使用基于用户的访问控制时。在这种情况下，SELinux 用户无法访问由其他 SELinux 用户拥有的资源。

1.  PAM 是一个灵活、模块化的系统，Linux 用于用户认证。系统上的各种技术和服务并不重复实现认证，而是通过 PAM 来处理认证流程。管理员只需关注 PAM 或与 PAM 相关的配置，以确保系统的正确访问。

    对于 SELinux，PAM 是必需的，它允许认证检查映射（在 Linux 用户和 SELinux 用户之间），这通过 `pam_selinux.so` 得到支持。

# 第四章

1.  最常用的选项是-Z，支持的工具包括 ls、mv 和 ps。相同的字符也被 systemd 的 tmpfiles 应用程序用来显式设置资源的 SELinux 上下文。然而，虽然这是最常用的选项，并不是所有工具都遵循这个约定，因此我们建议始终查阅工具的帮助文档或手册页。

1.  在大多数情况下，上下文作为文件或目录在文件系统中的扩展属性进行存储。这个扩展属性是 `security.selinux` 属性，可以通过 `getfattr` 或 `stat` 等工具查询。

    然而，并不是所有文件系统都支持扩展属性。在这种情况下，SELinux 上下文是通过该文件系统的挂载选项获得的，所有文件系统上的资源都将使用相同的上下文。

1.  `chcon` 应用程序直接更改文件的 SELinux 上下文，但不会调整系统的文件上下文定义。如果系统或管理员在任何时候重新标记该文件或整个文件系统（这是 SELinux 问题的常见修复方式），文件的 SELinux 上下文将被恢复。

    因此，`chcon` 仅推荐用于临时的 SELinux 上下文变更或验证上下文变更是否解决了问题。一旦确定新上下文是必要的，应通过 `semanage fcontext` 在系统的文件上下文定义中注册。

1.  是的。虽然 SELinux 工具对 Linux 发行版提供的上下文定义有 *最具体规则优先* 的概念，但这个概念不适用于系统本地的文件上下文定义（换句话说，由系统管理员执行）。

    对于本地定义的文件上下文，匹配到的第一个规则将被使用，而不管后续的上下文定义是什么。

1.  如果只想重新标记选定的一组文件，例如递归应用于某个目录，应使用 `restorecon` 命令。如果需要重新标记整个文件系统，可以使用 `fixfiles`（CentOS 及相关发行版）或 `rlpkg`（Gentoo）。

    另一种方法是创建一个空文件，命名为 `/.autorelabel`，然后重启系统。系统会检测到该文件，对整个文件系统进行重新标签化，删除该文件后再重新启动系统。

1.  源域需要具备针对目标域的过渡权限。它还需要对可执行文件具备执行权限。该可执行文件必须被标记为目标域的入口点。最后，进行过渡的角色必须允许使用目标域作为类型。

1.  可以将多个 SELinux 类型分配给一个 SELinux 属性，之后 SELinux 策略可以将此属性作为规则的源或目标。基于属性的规则将自动应用于所有分配该属性的类型。

# 第五章

1.  用于将类型应用于 TCP 端口的命令是通过 `semanage` 创建的。例如，要将 `ssh_port_t` 类型应用于 TCP 端口 `10122`，执行以下命令：

    ```
    # semanage port -a -t ssh_port_t -p tcp 10122
    # sepolicy network -p 10122
    ```

    如果端口属于一个未保留的范围，则可以进行修改。

1.  不，SECMARK 是本地于系统的。一旦网络数据包被 Linux 主机接收，SECMARK 规则将为该数据包关联一个标签，但这个标签只会保留在系统内存中。一旦数据包离开 Linux 系统，它将不再显示 SECMARK 标签的任何痕迹。

1.  `semanage` 使用的子命令有 `ibendport`（将标签或敏感性应用于 InfiniBand 网络端口）和 `ibpkey`（将标签或敏感性应用于分区密钥）。

1.  虽然标记的 IPsec 本身不需要专用设备，但它确实要求所有参与的主机对每个标签的含义有相同的理解。这意味着，在基于 SELinux 标记的情况下，所有主机需要启用 SELinux，并且最好具有完全相同的 SELinux 策略。

# 第六章

1.  Ansible（在文件模块中使用 `setype`）和 Puppet（在其文件模块中使用 `seltype`）是唯一两个原生支持显式设置资源的 SELinux 上下文的工具。然而，Chef 会根据定义的文件上下文规则自动重新标记资源，但你无法原生覆盖此行为。

1.  除了 SaltStack，所有的编排工具都支持由社区构建和支持的模块，这些模块扩展了工具的原生支持。Ansible 的 Galaxy、Puppet 的 Forge 和 Chef 的 Supermarket 是这些自定义模块的主要社区。

    所有编排工具（包括 SaltStack）都足够灵活，可以使用命令和简单的检查来检查状态并进行更改，从而有效地允许管理员根据自己的喜好自定义定义。

1.  所有工具都有自己处理问题的视角和设计。例如，Ansible 将其更改推送到远程节点，而其他工具通常使用远程代理连接到中央系统以获取最新的更改。SaltStack 甚至支持这两种方法。

    虽然所有工具都包含了一些 SELinux 支持，但有些工具启用了更多的 SELinux 特性。幸运的是，通过使用社区支持的附加模块，几乎所有编排工具的 SELinux 支持都可以轻松扩展。

# 第七章

1.  `/usr/lib/systemd/system` 中的单元文件由 Linux 发行版本身管理。每当系统上部署了新的软件更新时，这些文件就会被覆盖。

    单元文件的修改应当放置在 `/etc/systemd/system` 中，因为它们会覆盖 `/usr/lib/systemd` 中的设置，并且软件部署不应将其单元文件放在该位置。

1.  应用程序是 tmpfiles，它是 systemd 套件的一部分。要让它重置上下文，必须创建一个配置文件（对于本地定义的更改，位于 `/etc/tmpfiles.d` 中），并使用 `z` 指令（重置单个文件的上下文）或 `Z` 指令（递归地设置整个目录的上下文）。

1.  `journalctl` 命令允许基于从事件本身获取的变量进行筛选。这些变量之一是生成该事件的服务的 SELinux 上下文。

    ```
    _SELINUX_CONTEXT= in the preceding command, and then press *Tab* twice to see all the valid values.
    ```

1.  如果 SELinux 策略本身没有合适的命名文件转换规则（该规则会自动创建带有正确 SELinux 上下文的节点），那么你可以告诉 udev 为你执行此操作。

    ```
    /etc/udev/rules.d rather than /usr/lib/udev/rules.d as the latter location is managed by the distribution, and new installations or updates will overwrite the files located therein.
    ```

1.  不行。只有当 D-Bus 策略文件本身引用了 SELinux 上下文（使用`busconfig` > `selinux` > `associate` XML 实体）时，D-Bus 才会检查 SELinux 策略。如果策略中未定义 SELinux 映射，则 D-Bus 无法知道要验证哪个关联。

    然而，这与消息流不同，消息流直接受 D-Bus 通过 SELinux 策略的管理。

1.  Apache 可以使其支持 SELinux，因为它具有模块化设计，并允许将第三方模块应用到其自身环境中。虽然核心 Apache 代码中没有启用 SELinux 支持，但可以添加额外的模块（如`mod_selinux`），这些模块会启用 SELinux 支持。

# 第八章

1.  是的，尽管它默认没有启用。SEPostgreSQL 通过 PostgreSQL 中附加的一个模块提供，该模块名为`sepgsql`。因此，它是默认技术的一部分，但默认情况下并未启用。

1.  由于`sepgsql`模块需要一个会话上下文，PostgreSQL 数据库需要仅从本地系统访问（使用 Unix 域套接字），或者需要在网络中启用并设置标签网络。

    如果没有标签网络，任何远程连接到数据库的尝试将无法提供任何上下文信息，`sepgsql`将拒绝该连接。

1.  当在 PostgreSQL 中创建数据库对象时，它将自动接收一个 SELinux 标签。管理员或数据库所有者可以使用 PostgreSQL 中的`SECURITY LABEL`语句更改标签：

    ```
    LIKE and use % as a glob character.
    ```

1.  `sepgsql`模块不与 Linux 审计子系统交互，而是依赖 PostgreSQL 使用的日志功能和接口。因此，`sepgsql`进行的任何决策日志都将记录在 PostgreSQL 系统日志中。

# 第九章

1.  sVirt 与更标准的 SELinux 配置不同的独特之处在于，它将 SELinux 的 MCS 支持提升到了一个新的层次。通过随机为每个虚拟机分配两个类别，sVirt 即使在可用类别数量较少时，也能处理隔离成千上万的虚拟机。

1.  SELinux 在虚拟化层之上实施的两项主要安全措施如下：

    - 客户机内部隔离，确保客户机之间不能相互攻击或泄露信息

    - 客户机/主机隔离，确保客户机只能访问并与主机上需要的资源进行交互

    尽管这两者当然也在虚拟化监控程序代码中实现，但任何设计缺陷都可能导致重大问题。通过在 SELinux 中实施这些隔离，我们利用 SELinux 子系统作为独立（且更灵活）访问控制系统的优势。

1.  `virt_image_t`标签用于客户机镜像，当客户机未运行时。运行后，镜像会重新标记为`svirt_image_t`并分配正确的类别集合。另一方面，`virt_content_t`标签用于只读媒体，如 CD 镜像。

1.  可以通过编辑客户机的 XML 信息来更改标签：

    ```
    seclabel tags can be added to define target labels. 
    ```

1.  Vagrant 默认不支持 sVirt，但通过其插件模型，我们可以为 Vagrant 安装 libvirt 插件。安装后，Vagrant 将使用 libvirt 作为虚拟化层，自动允许我们在 Vagrant 中使用 sVirt。

# 第十章

1.  SELinux 在 Linux 内核中工作。而 Xen 是一个位于硬件和操作系统之间的虚拟机监控器，并不像 QEMU 和 KVM 那样使用完整的操作系统作为基础。

    当我们通过 Linux 与 Xen 交互时，实际上是通过 dom0 客户机与 Xen 进行交互。在这个客户机中，SELinux 可以运行（我们甚至推荐这样做），但 SELinux 将保持在虚拟化客户机内。

    然而，Xen 借鉴了 SELinux 的做法，并在其 Xen 安全模块框架中实现了这一方法。

1.  你可以通过编辑 Xen 客户机的配置文件（位于`/etc/xen`目录）并添加`seclabel`参数来为其分配标签，格式如下：

    ```
    seclabel = 'system_u:system_r:prot_domU_t'
    ```

    你需要重新启动客户机才能使更改生效。一旦客户机重新启动（使用`xl create`），你可以通过`xl list -Z`查看其活动标签。

    处理 XSM 标签的常见 Xen 命令有哪些？

    常用的命令如下：

    使用`xl list -Z`，我们可以列出客户机及其当前分配的标签。

    使用`xl getenforce`，我们可以查询 XSM 的当前执行状态。

    使用`xl setenforce`，我们可以设置 XSM 的新执行状态。

    使用`xl dmesg`，我们可以查看 Xen 日志，包括 XSM AVC 日志条目。

    使用`flask-get-bool`，我们可以查询当前的 XSM-FLASK 布尔值及其值。

    使用`flask-set-bool`，我们可以为 XSM-FLASK 布尔值设置一个新的值。

    使用`flask-label-pci`，我们可以为 PCI 设备分配一个新的 XSM-FLASK 类型。

    我们还可以使用 SELinux 工具来分析策略文件，如`seinfo`或`sesearch`。

1.  加载自定义策略的命令是`xl loadpolicy`，或者`flask-loadpolicy`。只要新策略文件没有放在`/boot`目录中以便自动加载，这个加载的策略将在重启或加载新策略之前一直处于活动状态。

# 第十一章

1.  `machinectl`命令不允许管理员更改正在运行的容器的 SELinux 类型。这导致所有容器默认在未受限制的域中运行，而我们希望使用受限域——最好还能启用 sVirt 支持，这样容器就不能相互影响了。

1.  当容器启动并进行位置映射时，应使用 `:Z` 选项（如果是私有映射）或 `:z` 选项（如果是共享映射），以确保资源被重新标记为容器可访问的 SELinux 类型：

    ```
    # podman run -dit --name postgresql-test -v /srv/db/postgresql-test:/bitnami/postgresql:Z -p 5432:5432 postgresql
    ```

    如果没有此选项，资源的标签将保持不变，这通常意味着容器运行时根本无法访问该资源。

1.  我们可以使用 `udica` 应用程序生成自定义策略。该应用程序使用 `podman inspect`（或 `docker inspect`）命令提供的信息，该命令显示当前的容器定义，并为该容器构建特定的自定义策略。

    策略一旦加载，容器就可以通过 `--security-opt` 参数使用它。

1.  SELinux 设置的主要位置是在清单中的 `spec` 配置参数下。在那里，我们可以创建 `securityContext` 定义，通过 `seLinuxOptions` 对象支持 SELinux 选项。

# 第十二章

1.  当 SELinux 布尔值通过 `/sys/fs/selinux/booleans` 文件系统进行更改时，更改不会自动提交。为了实现这一点，还需要将值 `1` 写入 `/sys/fs/selinux/commit_pending_bools`。

1.  `sesearch` 命令用于查询活动策略，也可以用于查询 SELinux 布尔值的影响。添加 `-b <boolean>` 参数可以将查询限制为受 SELinux 布尔值影响的规则。

1.  当 SELinux 策略模块加载时，它会被分配一个优先级，告诉系统是否应为活动模块。管理员可以以更高的优先级加载新模块进行测试，并再次删除它们，而不会冒着系统上没有有效 SELinux 规则的风险。

    同样，管理员可以以较低的优先级加载策略，确保它尚未激活，稍后再以较高优先级移除模块，使得新加载的策略变为活跃。

    这不同于启用或禁用模块，这会影响所有优先级。

1.  SELinux 工具 `audit2allow` 将所有与 SELinux 相关的审计事件转换为 SELinux 策略代码。该代码可以使用传统样式（使用 `-M`）或参考策略样式（使用 `-R -M`）。无论选择哪种样式，都将创建一个可加载的 SELinux 策略模块（后缀为 `.pp`）：

    ```
    custom_staff_su_faillog.pp) can be loaded using semodule -i.
    ```

# 第十三章

1.  `seinfo` 应用程序用于查询策略的类型内容，但不查询其规则。例如，您可以使用 `seinfo` 列出策略中的类型，但不会查询这些类型可以做什么。

    另一方面，`sesearch` 应用程序用于查询策略中的规则，但不会显示策略中不是真正规则的各种定义（如属性定义和支持的类别）。

    因此，主要的区别在于 `seinfo` 侧重于策略的结构，而 `sesearch` 侧重于策略中定义的强制执行内容。

1.  达到一个域意味着域转换。因此，我们要寻找的是你如何从当前域（例如 `staff_t`）转换到目标域（例如 `unconfined_t`），以及通过何种方式—通常，这是通过执行触发类型转换的二进制文件或脚本来完成的。

    分析域转换可以使用 `apol`（图形用户界面）、`sedta` 或 `sepolicy transition` 来完成。然而，后者可能无法揭示正确的路径，因此推荐使用 `sedta` 或 `apol` 进行分析。

1.  信息流分析必须涵盖比域转换更多的路径。域转换发生在进程域之间，只有少数操作可以触发转换。另一方面，信息流可以通过许多许多操作来实现。

    这样的分析不仅需要考虑读写语句，还要考虑文件描述符使用、套接字使用、信号传递、资源的锁定与解锁等。结果是，信息流分析使用权限映射来识别要检查的各种权限，以及一个权限在信息流分析会话中的重要性（权重）。

1.  当前没有使用手头的工具。用于比较策略的工具 `sediff` 显示策略之间的差异，但它本身不能生成包含策略差异的 SELinux 策略。

    此外，SELinux 策略模块只能向活动策略添加额外的规则，而不能删除它们。因此，即使 `sediff` 生成了兼容的输出，它仍然无法生成任何删除活动策略中现有规则的语句。

# 第十四章

1.  非限制性域仍然完全由 SELinux 控制并强制执行。之所以称为非限制性，是因为这些域在 SELinux 策略中被赋予了广泛的权限。然而，尽管名字中如此表示，它们仍然在某种程度上是受限的。

    相反，宽容域不受限制。SELinux 只会记录违反策略的行为，但不会强制执行这些行为。

1.  SELinux 沙箱工具可以用来在一个非常受限的域中运行应用程序。该工具将强制应用程序在非常受限的域中运行（对于常规非图形终端用户应用程序为 `sandbox_t`，对于图形应用程序为 `sandbox_xserver_t`），并通过使用 Linux 的命名空间功能，隔离或隐藏对其他系统资源的访问。

1.  当初始化系统（如 systemd）启动一个守护进程时，它会为该守护进程执行一个特定的二进制文件或脚本。该二进制文件或脚本的标签通常会定义目标域。例如，如果资源的标签为`bin_t`，那么 systemd 将确保目标服务以`unconfined_service_t`身份运行。如果它被标记为`postgresql_exec_t`，则目标服务将以`postgresql_t`类型运行。

    尽管也涉及到其他权限（如源上下文要求过渡权限到目标），除非我们从头开始构建新策略，否则切换域将像更改其可执行资源的标签，并重新标记其在文件系统中的主要位置（如日志位置和运行时信息）一样简单。

1.  `sepolicy generate`生成的默认骨架应用程序包含`permissive`语句，这意味着策略将在宽松模式下运行。由于这意味着 SELinux 不会执行任何控制，因此启用此策略时，应用程序很可能会完美运行。

    然而，这并不是目标状态，管理员需要从策略中移除`permissive`设置并根据需要进行调整。

# 第十五章

1.  许多 Linux 发行版增加了符合发行版目的和原则的服务和工具，但这些可能与参考策略所描述的内容相矛盾。例如，Red Hat Enterprise Linux 及其衍生的 Linux 发行版会为许多应用启用未限制域，而参考策略则会力求限制所有应用程序。

    因此，许多 Linux 发行版基于参考策略制定其策略，但会根据特定目的进行增强和调整。

1.  三个主要的策略文件如下：

    - 一个类型强制文件，后缀为`.te`，它包含 SELinux 策略模块的规则，专注于其拥有的域。

    - 一个接口文件，后缀为`.if`，它暴露了与该 SELinux 策略模块所拥有的域和资源之间的交互模式和权限。这些接口随后会被其他 SELinux 策略模块使用。

    - 一个上下文文件，后缀为`.fc`，它包含与此 SELinux 策略模块相关的各种路径的文件上下文。

    策略模块可以通过单个文件创建。在这种情况下，构建系统将假定其他文件为空。

1.  使用权限集允许策略开发人员在需要时轻松调整和扩展权限集，而无需更改所有可能的 SELinux 策略模块代码条目。

    当 Linux（及 SELinux 子系统）添加新权限时，这一点尤其重要。例如，假设内存映射系统调用（`map`）尚不存在，并在之后被引入。我们需要将 map 权限添加到所有执行调用中。通过使用权限集，我们可以仅将其添加到适当的权限集中。

1.  接口将授予领域或角色特权。它们不会向策略中添加或删除 SELinux 对象。而模板则会生成新的 SELinux 类型、角色、布尔值或其他对象。因此，不允许从任何布尔触发块内调用模板。

1.  数据库管理角色不使用 `userdom_admin_user_template`，因为它不是一个系统范围的管理角色，而是非常特定于数据库的。`userdom_admin_user_template` 会授予该角色比管理数据库所需的更多权限。

# 第十六章

1.  SELinux 的**通用中间语言**（**CIL**）不是一个可以轻易删除的 SELinux 扩展。它是 SELinux 策略开发和支持的核心，尽管主要处于幕后：所有加载到系统中的 SELinux 策略模块都会先转换为 CIL，然后才会被加载到内存中。

    CIL 格式是与 Linux 内核和 SELinux 子系统交互的唯一格式。由于它作为 SELinux 用户空间工具的一部分使用，因此管理员或开发人员不总是能立即察觉，但它绝对是 SELinux 的核心组件。

1.  不是强制性的，但建议使用。该属性用于以模块化的方式引用类型和角色，并确保这些引用是有效的。CIL 内部要求在使用之前先定义类型和角色，若不使用属性强制此类声明，则模块加载顺序可能会导致失败。

    虽然可以声明其他属性或引入其他方法来实现此目的，但通过 SELinux 用户空间工具支持使用 `cil_gen_require` 属性。因此，建议遵循这一做法。

1.  使用 CIL，开发人员可以创建额外的端口映射，声明一个新类型并将其分配给一个可用端口。使用其他 SELinux 语言风格时，这只能在重建整个策略时实现，而不是通过模块来实现。

    另一个例子是引入约束。SELinux 约束不支持通过其他语言风格在 SELinux 模块中加载。然而，尽管约束是 SELinux 中强大的构造，它们可能会让管理员感到困惑，因为与约束相关的失败不会产生明显的消息，而查询当前策略中的允许规则的管理员可能会发现即使出现失败，仍然存在允许规则。

1.  CIL 支持宏，这些宏成为 SELinux 模块（和命名空间）的一部分，可以通过 SELinux 策略中的 `call` 语句从其他地方调用。我们可以将宏作为模块的一部分创建，类似于参考策略中的接口，同时将宏作为全局命名空间的一部分创建，类似于参考策略中的支持宏。
