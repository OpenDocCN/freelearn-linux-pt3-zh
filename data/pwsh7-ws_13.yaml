- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Working with PowerShell 7 and Windows
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 PowerShell 7 和 Windows
- en: 'Welcome to the final section of the book, where over the next four chapters
    we’ll look at using PowerShell 7 in different environments. In this chapter, we’ll
    be looking at the peculiarities of Windows-based systems, and the various workarounds
    that exist to allow us to use PowerShell 7 effectively. We’ll also look at when
    we absolutely need to use native Windows PowerShell instead. It’s important to
    remember that PowerShell 7 is an open source product and is subject to fast-paced
    change. The examples in this and subsequent chapters are true at the time of writing,
    but may not be true at the time of reading. Also; there are bugs. The PowerShell
    GitHub pages are a powerful source of information regarding recent changes, and
    also things that don’t work the way they should: [https://github.com/PowerShell/PowerShell](https://github.com/PowerShell/PowerShell).'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到本书的最后一部分，在接下来的四个章节中，我们将讨论如何在不同的环境中使用 PowerShell 7。在本章中，我们将重点介绍基于 Windows
    系统的特殊性，并探讨现有的各种解决方法，以便我们能够有效地使用 PowerShell 7。我们还将讨论何时必须使用原生的 Windows PowerShell。需要记住的是，PowerShell
    7 是一个开源产品，并且会快速变化。本章及随后的示例在写作时是准确的，但在阅读时可能不再适用。另外，PowerShell 7 也存在一些 bug。PowerShell
    GitHub 页面是一个强大的信息来源，可以提供有关最新变化的信息，同时也有一些功能不按预期工作的情况：[https://github.com/PowerShell/PowerShell](https://github.com/PowerShell/PowerShell)。
- en: As we covered in [*Chapter 1*](B17600_01.xhtml#_idTextAnchor013), *Introduction
    to PowerShell 7 – What It Is and How to Get It*, PowerShell 7.2 and later are
    built on the .NET 6 platform, the latest version of .NET Core. However, Windows
    PowerShell and many Windows applications are built using the .NET 4.5 framework,
    which is not open source, and contains much proprietary code. This has led to
    some incompatibilities, where things that work in Windows PowerShell won’t work
    in PowerShell 7\. We’ll be covering them in this chapter, and then look at how
    we can use the **Common Information Model** (**CIM**) and **Windows Management
    Instrumentation (WMI)** to work with our Windows machines.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 [*第1章*](B17600_01.xhtml#_idTextAnchor013)中介绍的那样，*PowerShell 7 简介——它是什么以及如何获取*，PowerShell
    7.2 及之后的版本是基于 .NET 6 平台，这是 .NET Core 的最新版本。然而，Windows PowerShell 和许多 Windows 应用程序是使用
    .NET 4.5 框架构建的，后者并非开源，且包含许多专有代码。这导致了一些不兼容的情况，某些在 Windows PowerShell 中有效的内容在 PowerShell
    7 中无法工作。我们将在本章中讨论这些问题，然后探讨如何使用**通用信息模型**（**CIM**）和**Windows 管理工具（WMI）**来管理我们的
    Windows 机器。
- en: 'The main topics we will cover in this chapter are the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖的主要主题如下：
- en: Understanding PowerShell 7 and Windows PowerShell
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 PowerShell 7 和 Windows PowerShell
- en: Exploring compatibility
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索兼容性
- en: What doesn’t work with PowerShell 7
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PowerShell 7 不兼容的内容
- en: Managing machines with CIM and WMI
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理带有 CIM 和 WMI 的机器
- en: Understanding PowerShell 7 and Windows PowerShell
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 PowerShell 7 和 Windows PowerShell
- en: The key to understanding how we can use PowerShell 7 on Windows is to understand
    that PowerShell 7 is built on a fundamentally different platform; PowerShell 7
    is built on an open source, stripped-down version of .NET, whereas Windows PowerShell
    is built on the full proprietary .NET Framework. This means that Windows PowerShell
    has a greater degree of native compatibility with the Windows operating system
    and many of the applications that run on it and can make use of elements of .NET
    Framework that are not accessible to PowerShell 7\. Microsoft uses the terminology
    **Desktop edition** for PowerShell running on .NET Framework, and **Core edition**
    for PowerShell running on open source .NET.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 理解如何在 Windows 上使用 PowerShell 7 的关键，是要知道 PowerShell 7 是建立在一个完全不同的平台上的；PowerShell
    7 基于开源的、简化版的 .NET，而 Windows PowerShell 是建立在完整的专有 .NET 框架上的。这意味着 Windows PowerShell
    与 Windows 操作系统及其上运行的许多应用程序具有更高程度的原生兼容性，并且可以使用 .NET 框架中 PowerShell 7 无法访问的元素。微软用术语**桌面版**来指代运行在
    .NET 框架上的 PowerShell，而用术语**核心版**来指代运行在开源 .NET 上的 PowerShell。
- en: In [*Chapter 11*](B17600_11.xhtml#_idTextAnchor218), *Creating Our First Module*,
    we learned that most PowerShell functionality comes from using extensible libraries
    called modules, and looked at how modules are put together. To run a command in
    a module, PowerShell must first load that module. Microsoft has done a pretty
    good job of rewriting the core PowerShell modules and the more heavily used ones,
    such as the Active Directory module, but not all modules are compatible with PowerShell
    7; sometimes the authors haven’t got around to it yet, but sometimes the incompatibility
    is because key functionality in the module relies on features of .NET Framework
    that just aren’t in the open source .NET Core. If we attempt to load these incompatible
    modules, they will generally either cause an error or just not work. In the next
    section, we’ll see how we can get around this. Sometimes, however, we will find
    that things just don’t work, and we need to use Windows PowerShell. We’ll examine
    some of those cases in the third section of this chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第 11 章*](B17600_11.xhtml#_idTextAnchor218)，*创建我们的第一个模块*中，我们学到了大多数 PowerShell
    功能来自使用可扩展的库，称为模块，并了解了模块是如何组合的。要在模块中运行命令，PowerShell 必须首先加载该模块。微软已经做了相当不错的工作，重写了核心
    PowerShell 模块以及一些使用较多的模块，如 Active Directory 模块，但并非所有模块都与 PowerShell 7 兼容；有时作者还没有做这方面的工作，但有时不兼容的原因是模块中的关键功能依赖于
    .NET Framework 中的一些特性，而这些特性在开源的 .NET Core 中并没有。如果我们尝试加载这些不兼容的模块，它们通常会导致错误，或者根本无法工作。在下一节中，我们将看到如何解决这个问题。然而，有时我们会发现某些事情根本无法工作，这时我们需要使用
    Windows PowerShell。我们将在本章的第三节中探讨一些这样的情况。
- en: Exploring compatibility
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索兼容性
- en: It’s all very well saying that some modules aren’t compatible with PowerShell
    7, but how do we know which ones are OK to use, and what happens when they aren’t?
    The good news is that most of this process is automated and transparent to the
    casual user; we need to know about it however so we can understand why bad things
    happen sometimes. To understand compatibility, we’ll need to remember what we
    learned about modules and module manifests from [*Chapter 11*](B17600_11.xhtml#_idTextAnchor218),
    *Creating Our First Module*, and the section on PowerShell remoting that we did
    in the last chapter, [*Chapter 12*](B17600_12.xhtml#_idTextAnchor236), *Securing
    PowerShell*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 说一些模块与 PowerShell 7 不兼容倒是很容易，但我们怎么知道哪些模块可以使用，哪些不能使用呢？好消息是，大多数这个过程是自动化的，并且对普通用户来说是透明的；然而我们需要了解这些，以便理解为什么有时会出现问题。为了理解兼容性，我们需要记住我们在[*第
    11 章*](B17600_11.xhtml#_idTextAnchor218)，*创建我们的第一个模块*中学到的关于模块和模块清单的知识，以及在上一章[*第
    12 章*](B17600_12.xhtml#_idTextAnchor236)，*保护 PowerShell*中涉及的 PowerShell 远程操作部分。
- en: Which modules are compatible with PowerShell 7?
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 哪些模块与 PowerShell 7 兼容？
- en: 'Let’s have a look at some modules to see how we can tell whether they are compatible
    with PowerShell 7\. Run this cmdlet in Windows PowerShell:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些模块，了解如何判断它们是否与 PowerShell 7 兼容。在 Windows PowerShell 中运行此命令：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We should see something like the following output:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该看到类似以下的输出：
- en: '![Figure 13.1 – Uncovering compatible editions](img/B17600_13_001.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.1 – 揭示兼容的版本](img/B17600_13_001.jpg)'
- en: Figure 13.1 – Uncovering compatible editions
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1 – 揭示兼容的版本
- en: We can see that we have seven modules loaded. Four of them have compatibility
    information; `Microsoft.PowerShell.Management` says it is compatible with Desktop
    and Core editions. `Microsoft.Powershell.Utility`, `Microsoft.PowerShell.Security`,
    and `Microsoft.WSMan.Management` are only compatible with the Desktop edition.
    We could have run the command in PowerShell 7, but of course then it would generally
    only show modules that were compatible with the Core edition.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，已经加载了七个模块。其中四个模块有兼容性信息；`Microsoft.PowerShell.Management`表示它与桌面版和核心版兼容。`Microsoft.Powershell.Utility`、`Microsoft.PowerShell.Security`和`Microsoft.WSMan.Management`仅与桌面版兼容。我们本可以在
    PowerShell 7 中运行该命令，但当然那时它通常只会显示与核心版兼容的模块。
- en: 'Three of the modules have no compatibility information available; this may
    mean that they were written before PowerShell Core was released, and are therefore
    only compatible with the Desktop edition, or it may be that they are the wrong
    type of module to have compatibility information. Recall that there are four types
    of modules; script modules, manifest modules, binary modules, and dynamic modules.
    Manifest modules contain a manifest file with a `.Psd1` extension. We can check
    what the type of the module is by running `Get-Module <modulename>`, like so:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个模块没有提供兼容性信息；这可能意味着它们是在PowerShell Core发布之前编写的，因此仅与桌面版兼容，或者它们可能是错误类型的模块，无法提供兼容性信息。回想一下，模块有四种类型；脚本模块、清单模块、二进制模块和动态模块。清单模块包含一个扩展名为`.Psd1`的清单文件。我们可以通过运行`Get-Module
    <modulename>`来检查模块的类型，像这样：
- en: '![Figure 13.2 – Checking the module type](img/B17600_13_002.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图13.2 – 检查模块类型](img/B17600_13_002.jpg)'
- en: Figure 13.2 – Checking the module type
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2 – 检查模块类型
- en: In this case, we can see that `PSReadline` is a script module, and so doesn’t
    have an associated manifest file that could contain compatibility information.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以看到`PSReadline`是一个脚本模块，因此没有与其关联的清单文件，无法包含兼容性信息。
- en: 'So, what can we do when we need some functionality, but the module isn’t listed
    as compatible with PowerShell 7? We have three choices:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，当我们需要某些功能，但该模块未列出与PowerShell 7兼容时，我们该怎么办？我们有三个选择：
- en: Find a compatible version
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找兼容版本
- en: Load it anyway
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论如何加载它
- en: Use Compatibility mode
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用兼容性模式
- en: Let’s take a look at these methods.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下这些方法。
- en: Finding a compatible version
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找兼容版本
- en: 'The `Microsoft.PowerShell.Utility` module shown previously in *Figure 13**.1*
    is really useful; for a start, it provides the `ConvertTo-*` cmdlets. We know
    that these work in PowerShell 7, because we’ve been using them throughout the
    book. Look at the following figure:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示的`Microsoft.PowerShell.Utility`模块在*图13.1*中非常有用；首先，它提供了`ConvertTo-*` cmdlet。我们知道这些在PowerShell
    7中可以使用，因为我们在整本书中都在使用它们。请看下面的图示：
- en: '![Figure 13.3 – Microsoft.PowerShell.Utility in PowerShell 7](img/B17600_13_003.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图13.3 – PowerShell 7中的Microsoft.PowerShell.Utility](img/B17600_13_003.jpg)'
- en: Figure 13.3 – Microsoft.PowerShell.Utility in PowerShell 7
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3 – PowerShell 7中的Microsoft.PowerShell.Utility
- en: 'As we can see, the `Microsoft.PowerShell.Utility` module is loaded in our PowerShell
    7 session. How is that? Check the version numbers shown in the different screenshots.
    PowerShell 7 loads `Microsoft.PowerShell.Utility 7.0.0.0`, whereas Windows PowerShell
    loads `Microsoft.PowerShell.Utility 3.1.0.0`. Different versions of core PowerShell
    modules have been supplied with PowerShell 7, and are installed in `C:\program
    files\powershell\7\Modules`. Some third-party modules will have specific versions
    that are compatible with PowerShell 7, even if the one we currently have is not,
    and it’s worth checking on the repository if this is the case. For instance, in
    the PowerShell gallery, we can include the search term `Tags:"core"` to find modules
    that are compatible with PowerShell 7, like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`Microsoft.PowerShell.Utility`模块已经加载到我们的PowerShell 7会话中。怎么做到的？检查不同截图中显示的版本号。PowerShell
    7加载的是`Microsoft.PowerShell.Utility 7.0.0.0`，而Windows PowerShell加载的是`Microsoft.PowerShell.Utility
    3.1.0.0`。PowerShell 7提供了不同版本的核心PowerShell模块，并安装在`C:\program files\powershell\7\Modules`中。一些第三方模块会有与PowerShell
    7兼容的特定版本，即使我们当前的版本不兼容，值得在库中检查是否存在这种情况。例如，在PowerShell Gallery中，我们可以使用搜索词`Tags:"core"`来查找与PowerShell
    7兼容的模块，如下所示：
- en: '![Figure 13.4 – Searching the PowerShell gallery for a module that is compatible](img/B17600_13_004.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图13.4 – 在PowerShell gallery中搜索兼容模块](img/B17600_13_004.jpg)'
- en: Figure 13.4 – Searching the PowerShell gallery for a module that is compatible
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.4 – 在PowerShell gallery中搜索兼容模块
- en: As you can see, I’ve included two search terms; the first is the string `databases`
    and the second is `Tags:"core"`. This has found me a module for manipulating databases
    that will run on PowerShell 7\. Let’s see what we can do if there is no compatible
    version.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我包含了两个搜索词；第一个是字符串`databases`，第二个是`Tags:"core"`。这找到了一个可以在PowerShell 7中运行的数据库操作模块。让我们看看如果没有兼容版本该怎么办。
- en: Loading it anyway
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无论如何加载它
- en: If we don’t find a version of the module compatible with PowerShell 7, we can
    attempt to load it anyway. This might work, although quite often the module will
    load but then not work as expected when we come to use it. I include this method
    as a last resort and a sort of warning; there are articles on the internet that
    recommend doing this. Personally, I wouldn’t.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们找不到与 PowerShell 7 兼容的模块版本，我们仍然可以尝试加载它。虽然这可能有效，但往往模块会加载成功，但在使用时并不会按预期工作。我将这种方法作为最后的手段，并作为一种警告；网上有些文章推荐这样做。就个人而言，我不会这么做。
- en: 'That said, how do you load a module that doesn’t have a compatible version?
    We can use the `-SkipEditionCheck` parameter of `Import-Module` like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，如何加载没有兼容版本的模块呢？我们可以像这样使用 `Import-Module` 的 `-SkipEditionCheck` 参数：
- en: '![Figure 13.5 – Forcing a module to load](img/B17600_13_005.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图13.5 – 强制加载模块](img/B17600_13_005.jpg)'
- en: Figure 13.5 – Forcing a module to load
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.5 – 强制加载模块
- en: In this example, I’ve used the `-SkipEditionCheck` parameter to try to force
    PowerShell 7 to load the `RemoteDesktop` module in a PowerShell 7 session with
    admin privileges. As we can see, this hasn’t worked very well. The problem is
    that with some modules it does work, while with others it doesn’t, but it doesn’t
    produce an error like `RemoteDesktop` does. So, what is the right way to do this?
    We use Compatibility mode.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我使用了`-SkipEditionCheck`参数，试图强制 PowerShell 7 在管理员权限下加载 `RemoteDesktop`
    模块。正如我们所见，这并没有很好地工作。问题在于，某些模块可以正常工作，而有些模块则不能，但它们不会像`RemoteDesktop`那样产生错误。那么，正确的方法是什么呢？我们使用兼容模式。
- en: Using Compatibility mode
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用兼容模式
- en: 'Using Compatibility mode in recent versions of PowerShell 7 is easy. Just import
    the module you want to load, like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在最新版本的 PowerShell 7 中使用兼容模式很简单。只需导入您想加载的模块，如下所示：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As we can see in the following figure, something magical happens:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在下面的图中看到的，发生了一些奇妙的事情：
- en: '![Figure 13.6 – Using Compatibility mode](img/B17600_13_006.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图13.6 – 使用兼容模式](img/B17600_13_006.jpg)'
- en: Figure 13.6 – Using Compatibility mode
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.6 – 使用兼容模式
- en: In the first command, all I’ve done is use `Import-Module` with no parameters.
    PowerShell checks for a compatible module, and when it doesn’t find one it creates
    a remote session to run Windows PowerShell in the background. The module is loaded
    into this remote session, which is running on the local machine. It warns us that
    this is what it has done. In the second command, I check what remote sessions
    are running, and we can see that there is a session called `WinPSCompatSession`
    created. We saw remote sessions in [*Chapter 12*](B17600_12.xhtml#_idTextAnchor236),
    *Securing PowerShell*. In that chapter, though, we explicitly created the sessions.
    The `WinPSCompatSession` is an example of implicit remoting.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个命令中，我所做的就是使用`Import-Module`命令没有任何参数。PowerShell 会检查是否有兼容的模块，如果没有找到，它就会创建一个远程会话，在后台运行
    Windows PowerShell。该模块被加载到这个在本地机器上运行的远程会话中。它会警告我们这是它所做的操作。在第二个命令中，我检查了正在运行的远程会话，我们可以看到创建了一个名为`WinPSCompatSession`的会话。我们在[*第12章*](B17600_12.xhtml#_idTextAnchor236)《保护
    PowerShell》中看到过远程会话。虽然在那一章中，我们明确地创建了会话。`WinPSCompatSession`是隐式远程处理的一个示例。
- en: 'There are two important things to remember about Compatibility mode. The first
    important thing is that `WinPSCompatSession` is running Windows PowerShell, not
    PowerShell 7\. Look at this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 关于兼容模式，有两件重要的事情需要记住。第一件事是`WinPSCompatSession`运行的是 Windows PowerShell，而不是 PowerShell
    7。看看这个：
- en: '![Figure 13.7 – Demonstrating the PowerShell version running in WinPSCompatSession](img/B17600_13_007.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图13.7 – 演示在 WinPSCompatSession 中运行的 PowerShell 版本](img/B17600_13_007.jpg)'
- en: Figure 13.7 – Demonstrating the PowerShell version running in WinPSCompatSession
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.7 – 演示在 WinPSCompatSession 中运行的 PowerShell 版本
- en: In the first command, I’m putting `WinPSCompatSession` into a variable called
    `$session` so I can easily use it. On the second line, I pass the `$session` variable
    to `Invoke-Command` and call the `PSVersion` property of the `$PSVersionTable`
    automatic variable from within that session. We can see from the result that the
    session is running PowerShell version 5.1 – Windows PowerShell. In the third command,
    I get the same information for the local terminal session, where I’m running PowerShell
    7.3.8.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个命令中，我将`WinPSCompatSession`放入名为`$session`的变量中，以便可以方便地使用它。在第二行，我将`$session`变量传递给`Invoke-Command`，并从该会话中调用`$PSVersionTable`自动变量的`PSVersion`属性。我们从结果中可以看到该会话正在运行
    PowerShell 版本 5.1——Windows PowerShell。在第三个命令中，我获取了本地终端会话中的相同信息，在该会话中我正在运行 PowerShell
    7.3.8。
- en: 'The second important thing is that this is a remote session, and therefore
    behaves differently to directly running commands. The most important difference
    is that the output has been deserialized, which we can see in the warning in *Figure
    13**.6*. Recall that the output of a command is a PowerShell object. To pass a
    PowerShell object from a remote computer to the local computer, the object is
    converted to CliXML (the specialized form of XML that PowerShell uses to serialize
    objects) on the remote end of the session, and then converted back to a PowerShell
    object at the local end. This has implications for what we can do with the object,
    as it now has different methods and properties. Let’s see what this looks like:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个重要的事情是这是一个远程会话，因此其行为与直接运行命令不同。最重要的区别在于输出已反序列化，我们可以在 *图 13**.6* 的警告中看到。请记住，命令的输出是一个
    PowerShell 对象。要将 PowerShell 对象从远程计算机传递到本地计算机，对象在会话的远程端被转换为 CliXML（PowerShell 用于序列化对象的专门形式的
    XML），然后在本地端被转换回 PowerShell 对象。这影响了我们可以对对象执行的操作，因为它现在具有不同的方法和属性。让我们看看这是什么样子的：
- en: '![Figure 13.8 – Deserialized objects](img/B17600_13_008.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.8 – 反序列化对象](img/B17600_13_008.jpg)'
- en: Figure 13.8 – Deserialized objects
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.8 – 反序列化对象
- en: 'In the top pane I am using Windows PowerShell to run the `Get-WmiObject win32_bios
    | gm` command to get the `TypeName` and members of the object that the `Get-WmiObject`
    command generates: `System.Management.ManagementObject`. Note it has no methods,
    and `PSComputerName` is an `AliasProperty`, so if we call `PSComputerName`, we
    actually get the value of the `__SERVER` property.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部窗格中，我正在使用 Windows PowerShell 运行 `Get-WmiObject win32_bios | gm` 命令来获取 `TypeName`
    和 `Get-WmiObject` 命令生成的对象 `System.Management.ManagementObject` 的成员。请注意它没有方法，而
    `PSComputerName` 是一个 `AliasProperty`，因此如果我们调用 `PSComputerName`，实际上会获取 `__SERVER`
    属性的值。
- en: 'In the lower pane, I am using PowerShell 7 to run `Get-WmiObject` inside the
    `WinPSCompatSession` session using `Invoke-Command`, and then getting the members
    of the returned object. As we can see, this is now a `Deserialized.System.Management.ManagementObject`,
    and the methods and properties are subtly changed. For example, `PSComputerName`
    is now a `NoteProperty` that contains a string: `PSComputerName=localhost`.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在底部窗格中，我正在使用 PowerShell 7 在 `WinPSCompatSession` 会话内部运行 `Get-WmiObject` 命令，并获取返回对象的成员。正如我们所看到的，现在这是一个
    `Deserialized.System.Management.ManagementObject`，方法和属性已经微妙地改变了。例如，`PSComputerName`
    现在是一个 `NoteProperty`，包含一个字符串：`PSComputerName=localhost`。
- en: 'Now, this is fairly easy to remember when we are explicitly using `Invoke-Command`.
    We know that what we get back is running in a remote session and will be a deserialized
    object. However, because this can happen transparently in the background, it is
    easy to accidentally load a module in Compatibility mode, and then be surprised
    that the objects we are working with aren’t behaving quite the way we expect them
    to. Some administrators like to prevent implicit imports in PowerShell compatibility
    by editing the `powershell.config.json` file to include the JSON line:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们明确使用 `Invoke-Command` 时，这相当容易记住。我们知道返回的内容在远程会话中运行，并且会是一个反序列化对象。然而，由于这可能在后台透明地发生，所以很容易意外加载一个兼容性模式的模块，然后惊讶地发现我们正在处理的对象的行为并不完全符合我们的预期。一些管理员喜欢通过编辑
    `powershell.config.json` 文件来防止 PowerShell 兼容性中的隐式导入，包括 JSON 行：
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This doesn’t disable Compatibility mode altogether, however, it just makes
    us more mindful of when we are using it. We can still explicitly use Compatibility
    mode by adding the `-UseWindowsPowerShell` parameter of the `Import-Module` cmdlet,
    like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不完全禁用兼容性模式，只是让我们更加注意何时使用它。我们仍然可以通过在 `Import-Module` cmdlet 中添加 `-UseWindowsPowerShell`
    参数来显式使用兼容性模式，如下所示：
- en: '![Figure 13.9 – Explicitly using PowerShell Compatibility](img/B17600_13_009.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.9 – 明确使用 PowerShell 兼容性](img/B17600_13_009.jpg)'
- en: Figure 13.9 – Explicitly using PowerShell Compatibility
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.9 – 明确使用 PowerShell 兼容性
- en: In the command on the first line, I import the `ScheduledTasks` module as normal,
    with no parameters. In the second line, I test for the presence of the compatibility
    session – as we can see, no remote session has been opened. In the third line,
    I remove the module, and in the fourth line I reload it, this time adding the
    `-UseWindowsPowershell` parameter. In the fifth line, I again test for the compatibility
    session, and there it is.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行的命令中，我正常导入了 `ScheduledTasks` 模块，没有使用任何参数。在第二行，我测试是否存在兼容性会话——正如我们所见，并未打开远程会话。在第三行，我移除了该模块，在第四行重新加载它，这次添加了
    `-UseWindowsPowershell` 参数。在第五行，我再次测试兼容性会话，结果它存在。
- en: 'We can also prevent specific modules from loading in Compatibility mode altogether
    by editing the deny list in the `powershell.config.json` file:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过编辑 `powershell.config.json` 文件中的拒绝列表，完全阻止特定模块在兼容性模式下加载：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If we try and load a module on that list, then we will see an error similar
    to the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试加载该列表上的模块，那么我们将看到类似以下的错误：
- en: '![Figure 13.10 – No, you can’t load the PSScheduledJob module](img/B17600_13_010.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.10 – 不，您不能加载 PSScheduledJob 模块](img/B17600_13_010.jpg)'
- en: Figure 13.10 – No, you can’t load the PSScheduledJob module
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.10 – 不，您不能加载 PSScheduledJob 模块
- en: 'It’s important to understand the limitations of Compatibility mode. There are
    four main ones:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 理解兼容性模式的限制非常重要。主要有四个限制：
- en: It only works on local computers – you can’t call Compatibility mode while already
    in a remote session on another machine
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它仅在本地计算机上有效——无法在已经处于远程会话中的另一台机器上调用兼容性模式
- en: It requires Windows PowerShell 5.1 to be installed on the local machine – older
    machines might still have only Windows PowerShell 3.0 or 4.0 installed
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它要求在本地机器上安装 Windows PowerShell 5.1——较旧的机器可能仍然只安装了 Windows PowerShell 3.0 或 4.0
- en: It returns deserialized objects based on values – not live objects that can
    be manipulated
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它返回基于值的反序列化对象——而非可以操作的实时对象
- en: There can be only one compatibility session running on a machine at any one
    time, so all modules that use Compatibility will share a runspace
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任何一台机器上，同一时间只能运行一个兼容性会话，因此所有使用兼容性的模块将共享一个运行空间
- en: It’s also important to remember that this area of PowerShell 7 is one that lots
    of people are actively working on, and each new version of PowerShell is better
    than the last, and each new version of Windows is more compatible with PowerShell
    7\. Lots of the instructions and tutorials on the internet date very quickly,
    and so will this chapter.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 同样重要的是要记住，PowerShell 7 的这一领域有许多人在积极工作，每个新版本的 PowerShell 都比上一个版本更好，每个新版本的 Windows
    也与 PowerShell 7 更兼容。互联网上的许多指令和教程会迅速过时，这一章也是如此。
- en: What doesn’t work with PowerShell 7
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么在 PowerShell 7 中无法使用
- en: However, there are some things on Windows that just don’t work with PowerShell
    7 and aren’t likely to either. In this section we’ll cover a few of them, which
    will set us up nicely for the final section of the chapter, *Managing machines
    with CIM* *and WMI*.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Windows 上有些东西与 PowerShell 7 不兼容，而且也不太可能兼容。在本节中，我们将介绍其中的一些，这将为本章最后一节的内容，*使用
    CIM* *和 WMI 管理机器*，做好铺垫。
- en: The `-ComputerName` parameter had been ported from Windows PowerShell to PowerShell
    7; unfortunately, some of the protocols and models that this parameter uses in
    Windows are not compatible with PowerShell 7, and so the parameter didn’t work.
    In the most recent releases of PowerShell 7, such as 7.3, the parameter has finally
    been removed from the non-working cmdlets. For people moving from Windows PowerShell
    to PowerShell 7, however, it can still cause confusion. The workaround is to use
    `Invoke-Command` instead.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`-ComputerName` 参数已经从 Windows PowerShell 移植到 PowerShell 7；不幸的是，该参数在 Windows
    中使用的一些协议和模型与 PowerShell 7 不兼容，因此该参数无法使用。在 PowerShell 7 的最新版本中，如 7.3，该参数终于从无法工作的
    cmdlet 中移除。然而，对于从 Windows PowerShell 转向 PowerShell 7 的用户来说，这仍然可能会导致混淆。解决方法是改为使用
    `Invoke-Command`。'
- en: Some important administration modules like `UpdateServices` for managing **Windows
    Server Update Services** (**WSUS**) won’t work in Compatibility mode as they rely
    on manipulating the objects that are returned through their methods, which don’t
    survive the deserialization process.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一些重要的管理模块，如用于管理 **Windows Server 更新服务**（**WSUS**）的 `UpdateServices`，在兼容性模式下无法使用，因为它们依赖于操作通过其方法返回的对象，而这些对象无法在反序列化过程中保留下来。
- en: '**Windows Management Instrumentation** (**WMI**) commands aren’t included in
    PowerShell 7, as Microsoft has been trying to deprecate them since PowerShell
    3.0, preferring people to use the more lightweight CIM commands. They remain popular,
    however, and many people still use WMI over CIM. We’ll be discussing these CIM
    commands and how to use them in the next section, as it is an important topic.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**Windows 管理工具**（**WMI**）命令不包括在 PowerShell 7 中，因为微软自 PowerShell 3.0 起就开始尝试弃用它们，更倾向于让用户使用更轻量级的
    CIM 命令。然而，WMI 依然很受欢迎，许多人仍然使用 WMI 而非 CIM。我们将在下一节讨论这些 CIM 命令及其使用方法，这是一个重要话题。'
- en: Managing machines with CIM and WMI
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 CIM 和 WMI 管理机器
- en: CIM and WMI are related technologies for managing local and remote machines.
    In this section, we will look at the basics of each and discuss their similarities
    and differences.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: CIM 和 WMI 是用于管理本地和远程机器的相关技术。在本节中，我们将介绍它们的基础知识，并讨论它们的相似性和差异。
- en: Introduction to CIM and WMI
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CIM 和 WMI 简介
- en: CIM and WMI are based on the **Web-Based Enterprise Management** (**WBEM**)
    standard introduced by the **Distributed Management Task Force** (**DMTF**) in
    1996\. WMI is Microsoft’s implementation of a set of tools based on WBEM, released
    in 1998, and CIM is an open standard from the DMTF that defines how the entities
    in an environment are represented and related. It was released in 1999\. In a
    Windows environment, CIM uses elements of WMI but uses a different set of protocols
    to access them; WMI uses the **Distributed Common Object Model** (**DCOM**) protocol,
    which is proprietary, and CIM uses the **Web Services for Management** (**WS-MAN**)
    protocol over HTTP, which we saw in [*Chapter 12*](B17600_12.xhtml#_idTextAnchor236),
    *Securing PowerShell*.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: CIM 和 WMI 基于 **Web-Based Enterprise Management**（**WBEM**）标准，该标准由 **分布式管理工作组**（**DMTF**）于
    1996 年提出。WMI 是微软基于 WBEM 的工具集实现，发布于 1998 年，而 CIM 是 DMTF 提出的开放标准，定义了环境中实体的表示和相互关系。该标准于
    1999 年发布。在 Windows 环境中，CIM 使用 WMI 的元素，但使用不同的协议集来访问它们；WMI 使用 **分布式公共对象模型**（**DCOM**）协议，这是专有的，而
    CIM 使用 **Web 服务管理**（**WS-MAN**）协议通过 HTTP 进行访问，我们在 [*第 12 章*](B17600_12.xhtml#_idTextAnchor236)
    中讨论了这个问题，*保护 PowerShell*。
- en: Both technologies link to a common repository – the WMI repository, which we’ll
    look at shortly. This repository holds information about the type of objects we
    might want to manage, such as printers, clients, network adapters, and so on,
    and instances of those objects.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种技术都链接到一个公共存储库——WMI 存储库，我们稍后将查看它。这个存储库包含有关我们可能想要管理的对象类型的信息，例如打印机、客户端、网络适配器等，以及这些对象的实例。
- en: The PowerShell CIM commands allow us to connect to local and remote machines
    via WS-MAN to the **Windows Remote Management** (**WinRM**) endpoint that we use
    for remote sessions. We can do this either as an ad hoc connection or via a CIM
    session, similar to remoting.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell CIM 命令允许我们通过 WS-MAN 连接到本地和远程机器，连接到我们用于远程会话的 **Windows 远程管理**（**WinRM**）端点。我们可以通过临时连接或通过
    CIM 会话进行连接，类似于远程连接。
- en: WMI only supports ad hoc connections over DCOM. This means WinRM doesn’t need
    to be enabled on the remote machine.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: WMI 仅支持通过 DCOM 进行临时连接。这意味着远程机器上不需要启用 WinRM。
- en: Why CIM is better than WMI
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么 CIM 比 WMI 更好
- en: CIM is slightly newer, but crucially uses an open connection protocol – WS-MAN.
    This requires a pair of static network ports to be available on machines and any
    devices in the network. DCOM uses the **Remote Procedure Call** (**RPC**) protocol,
    which relies heavily on ephemeral TCP/IP ports; it’s much easier to run WS-MAN
    over a network than it is to run DCOM because of this difference. There are lots
    of other reasons why WS-MAN is better than DCOM, but the biggest stumbling block
    in my experience is DCOM’s requirement for ephemeral ports.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: CIM 稍微更新一些，但关键在于它使用了开放连接协议——WS-MAN。这要求机器和网络中的任何设备都必须提供一对静态网络端口。DCOM 使用 **远程过程调用**（**RPC**）协议，依赖于临时
    TCP/IP 端口；由于这个差异，WS-MAN 更容易在网络上运行，而 DCOM 则较为困难。还有许多其他原因说明 WS-MAN 比 DCOM 更好，但根据我的经验，最大的障碍是
    DCOM 对临时端口的依赖。
- en: Microsoft has been trying since PowerShell 3.0 in 2012 to deprecate the WMI
    cmdlets and persuade people to use the CIM cmdlets instead, as CIM uses a lighter
    protocol with less of a network footprint; RPC has many disadvantages, and I’ve
    spent a good chunk of my career identifying and fixing problems that have resulted
    from RPC. However, plenty of people still use the WMI cmdlets, and there are lots
    of popular scripts available on the internet that use them.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 微软自 2012 年 PowerShell 3.0 以来，一直在努力弃用 WMI cmdlet，并说服人们改用 CIM cmdlet，因为 CIM 使用更轻的协议，网络占用更少；RPC
    有许多缺点，而我也花了大量时间在职业生涯中识别并修复由于 RPC 导致的问题。然而，仍然有许多人使用 WMI cmdlet，互联网上也有许多流行的脚本使用它们。
- en: The WMI cmdlets are not available within PowerShell 7, but we will see many
    workarounds on the internet involving `Invoke-Command` that enable us to use them
    via Compatibility mode.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: WMI cmdlet 在 PowerShell 7 中不可用，但我们会在互联网上看到许多涉及`Invoke-Command`的变通方法，使我们能够通过兼容模式使用它们。
- en: Commands that use CIM and WMI
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 CIM 和 WMI 的命令
- en: 'The WMI repository is huge and confusing, as we shall see. Therefore, it’s
    better, where possible, to use a dedicated cmdlet rather than a CIM or WMI cmdlet.
    What does that look like? For instance, we might use `Get-CimInstance Win32_Printer`
    to query the printers on a machine, but it’s quicker and more intuitive to use
    the `Get-Printer` cmdlet, demonstrated as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: WMI 仓库庞大且令人困惑，正如我们将看到的那样。因此，尽可能使用专用 cmdlet 而不是 CIM 或 WMI cmdlet 会更好。这看起来像什么？例如，我们可能使用`Get-CimInstance
    Win32_Printer`查询机器上的打印机，但使用`Get-Printer` cmdlet 会更快速且直观，如下所示：
- en: '![Figure 13.11 – Looking for printers](img/B17600_13_011.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.11 – 查找打印机](img/B17600_13_011.jpg)'
- en: Figure 13.11 – Looking for printers
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.11 – 查找打印机
- en: Both commands are looking for the HP printer on my local machine. They both
    use CIM to query the WMI repository. Arguably, the second command is easier to
    run and remember, and is generally faster too. `Get-Printer` supports the `-ComputerName`
    parameter for remote machines and even supports using CIM sessions. Before digging
    around for hours to work out how to do something using a CIM cmdlet, check there
    isn’t already a handy pre-written cmdlet that does what we want. Of course, `Get-Printer`
    is a Windows PowerShell cmdlet, and therefore we need to be running on a Windows
    client and use Compatibility.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个命令都在查找我本地机器上的 HP 打印机。它们都使用 CIM 查询 WMI 仓库。可以说，第二个命令更容易运行和记住，通常也更快。`Get-Printer`支持`-ComputerName`参数用于远程机器，甚至支持使用
    CIM 会话。在深入研究几个小时，尝试弄清楚如何使用 CIM cmdlet 做某事之前，先检查一下是否已经有现成的方便的 cmdlet 完成了我们想要的操作。当然，`Get-Printer`是一个
    Windows PowerShell cmdlet，因此我们需要在 Windows 客户端上运行，并使用兼容模式。
- en: Repository
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 仓库
- en: The WMI repository is a hierarchical database – a tree structure. At the top
    level are namespaces – essentially containers. Namespaces contain classes. A class
    represents a type of object, such as a printer, and contains instances of that
    type of object. Each instance of a class has the same set of properties and methods
    as other instances of a class – although they may not all be populated or enabled.
    There is a class called `__NAMESPACE`, with two underscores (`_`), that contains
    namespaces, so a namespace may contain other namespaces as well.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: WMI 仓库是一个层次化的数据库——一种树形结构。在最顶层是命名空间——本质上是容器。命名空间包含类。类表示一种对象类型，例如打印机，并包含该类型对象的实例。类的每个实例具有与其他实例相同的属性和方法——尽管它们可能并不全都被填充或启用。还有一个名为`__NAMESPACE`的类（带有两个下划线`_`），它包含命名空间，因此一个命名空间也可能包含其他命名空间。
- en: 'The root namespace is called, unimaginatively, `root`. We can see the contents
    of this with the following command:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 根命名空间被称为毫无创意的`root`。我们可以通过以下命令查看其内容：
- en: '[PRE4]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And we can see the instances of the `__NAMESPACE` class with the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式查看`__NAMESPACE`类的实例：
- en: '[PRE5]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The contents of the namespaces and classes may vary on each machine, as hardware
    and software will create their own namespaces and classes when installed. The
    important namespace for most people though is `root/CIMV2`, shown in the following
    figure.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 每台机器上的命名空间和类的内容可能有所不同，因为硬件和软件在安装时会创建它们自己的命名空间和类。然而，大多数人的重要命名空间是`root/CIMV2`，如下图所示。
- en: '![Figure 13.12 – Finding the CIMV2 namespace](img/B17600_13_012.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.12 – 查找 CIMV2 命名空间](img/B17600_13_012.jpg)'
- en: Figure 13.12 – Finding the CIMV2 namespace
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.12 – 查找 CIMV2 命名空间
- en: In the first command, I’m listing out the first 10 returned classes in the `root`
    namespace. There are 75 classes in the root namespace on my client so I’m only
    listing the first 10 – this number will likely differ on yours. In the second
    command, I’m listing the instances of the `__NAMESPACE` class on my machine –
    again, there is quite a large number, and yours may be different. The `CIMV2`
    namespace is highlighted.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个命令中，我列出了`root`命名空间中返回的前10个类。我的客户端中`root`命名空间下有75个类，因此我只列出了前10个——这个数字在你的系统中可能不同。在第二个命令中，我列出了我计算机上`__NAMESPACE`类的实例——同样，这里数量较多，你的数量可能不同。`CIMV2`命名空间已被突出显示。
- en: The `CIMV2` namespace contains the Microsoft Windows classes. We can use `Get-CimClass`
    to list them out, but there are over 1,200 classes in this namespace on my machine;
    most of them called either `MSFT_*` or `Win32_*`. With so many classes, we can
    see that finding things in the repository can be a challenge. Microsoft has done
    a reasonable job of documenting the contents of the `root/CIMV2` namespace online,
    but the contents of other namespaces are typically not well documented, and finding
    out what things do and how to use them can be a bit of an exercise.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`CIMV2`命名空间包含Microsoft Windows类。我们可以使用`Get-CimClass`列出它们，但我的计算机上该命名空间中有超过1200个类；大多数类名以`MSFT_*`或`Win32_*`开头。由于类的数量庞大，我们可以看到在这个存储库中查找内容可能会是一个挑战。微软在线上对`root/CIMV2`命名空间的内容进行了合理的文档记录，但其他命名空间的内容通常文档化得不太好，了解这些内容的作用及如何使用它们可能需要一些额外的努力。'
- en: In *Figure 13**.11*, we used the `Get-CimInstance Win32_Printer` command, without
    specifying a namespace – this is because PowerShell has the `CIMV2` namespace
    set as the default, so that we don’t have to add the `-Namespace 'root/CIMV2'`
    parameter to every command.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图13.11*中，我们使用了`Get-CimInstance Win32_Printer`命令，而没有指定命名空间——这是因为PowerShell将`CIMV2`命名空间设置为默认命名空间，因此我们无需在每个命令中添加`-Namespace
    'root/CIMV2'`参数。
- en: Querying data
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询数据
- en: We use CIM and WMI for two main tasks – finding out information and changing
    things, frequently on large numbers of machines at once. Let’s start by looking
    at how we can find things out. We’ve already seen two CIM cmdlets that we can
    use; `Get-CimClass` and `Get-CimInstance`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用CIM和WMI来完成两个主要任务——获取信息和更改内容，通常是同时在大量机器上执行这些任务。让我们从了解如何查找信息开始。我们已经看过两个可以使用的CIM命令；`Get-CimClass`和`Get-CimInstance`。
- en: Get-CimClass
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Get-CimClass
- en: 'This cmdlet gets a list of the CIM classes in a specified namespace, or in
    the default namespace if no namespace is given. There are a few parameters for
    this cmdlet:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令用于获取指定命名空间中的CIM类列表，如果未指定命名空间，则获取默认命名空间中的类。这个命令有几个参数：
- en: '`-ClassName`: This allows us to either specify a class, or provide a partial
    class name when we’re looking for a specific class; e.g., `Get-CimClass -ClassName
    *disk*` will get all the classes in `CIMV2` with the word `disk` in the name.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-ClassName`：此参数允许我们指定一个类，或者在查找特定类时提供一个部分类名；例如，`Get-CimClass -ClassName *disk*`将获取`CIMV2`中所有名称中包含`disk`的类。'
- en: '`-Namespace`: This allows us to specify a namespace other than `root/CIMV2`.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Namespace`：此参数允许我们指定一个不同于`root/CIMV2`的命名空间。'
- en: '`-ComputerName`: This parameter allows us to specify a machine other than the
    local machine. We can use an FQDN, a NetBIOS name, or an IP address.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-ComputerName`：此参数允许我们指定除本地计算机外的其他计算机。我们可以使用FQDN、NetBIOS名称或IP地址。'
- en: '`-MethodName`: This parameter allows us to search for classes that have a particular
    method. For example, `Get-CimClass -MethodName ''term*''` will return the `Win32_Process`
    class, which has a `Terminate` method. No prizes for guessing what that method
    does.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-MethodName`：此参数允许我们搜索具有特定方法的类。例如，`Get-CimClass -MethodName ''term*''`将返回`Win32_Process`类，该类具有一个`Terminate`方法。猜猜这个方法的作用是什么，答案显而易见。'
- en: '`-PropertyName`: Similar to the `-MethodName` parameter, this allows us to
    search for classes with a particular property.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-PropertyName`：与`-MethodName`参数类似，允许我们搜索具有特定属性的类。'
- en: '`-QualifierName`: Qualifiers are like tags that are applied to classes. There
    is no standard list (a bit like tags), but they can sometimes be quite useful.
    For instance, we can use `Get-CimClass -QualifierName ''deprecated''` to retrieve
    a list of classes that are being phased out, and probably shouldn’t be used in
    a script.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-QualifierName`：限定符类似于应用于类的标签。没有标准的列表（有点像标签），但它们有时非常有用。例如，我们可以使用`Get-CimClass
    -QualifierName ''deprecated''`来检索正在淘汰的类列表，这些类可能不应在脚本中使用。'
- en: '`-Amended`: This parameter gets amended information – usually information that
    changes depending on the locale of the machine. Localizable information is often
    presented numerically and requires a lookup to be translated into the local language
    – this parameter will do that.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Amended`：此参数获取修订后的信息——通常是根据机器所在的区域设置变化的信息。可本地化的信息通常以数字形式呈现，并需要查找才能翻译为本地语言——此参数会执行该操作。'
- en: '`-OperationTimeoutSec`: If we are running the command against a remote computer,
    it’s possible that the machine is unresponsive or not even switched on. This allows
    us to specify a timeout other than the default network timeout set for the local
    machine, which is by default 3 minutes. If we were querying 1,000 machines, and
    10% of them are switched off or not connected to the network, this allows us to
    complete the command in less than 5 hours.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-OperationTimeoutSec`：如果我们对远程计算机执行命令，可能会出现机器无响应或未开机的情况。此参数允许我们指定一个超时时间，超出默认的本地机器网络超时（默认是3分钟）。如果我们查询1000台机器，其中10%未开机或未连接网络，使用此参数可以在不到5小时内完成命令。'
- en: '`-CimSession`: This allows us to run the command in a pre-existing CIM session.
    More on CIM sessions shortly.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-CimSession`：此参数允许我们在已存在的CIM会话中运行命令。稍后我们会详细介绍CIM会话。'
- en: Let’s take a look at `Get-CimInstance` next.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们来看一下`Get-CimInstance`。
- en: Get-CimInstance
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Get-CimInstance
- en: 'This cmdlet gets the instances of a given CIM class – again, the default namespace
    is root/CIMV2\. It has many of the same parameters as `Get-CimClass`, with a few
    differences. Let’s take a look:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令用于获取给定CIM类的实例——同样，默认命名空间是root/CIMV2\。它有许多与`Get-CimClass`相同的参数，但也有一些不同之处。让我们来看一下：
- en: '`-CimSession`: Same as for `Get-CimClass`.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-CimSession`：与`Get-CimClass`相同。'
- en: '`-ClassName`: Same as for `Get-CimClass`.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-ClassName`：与`Get-CimClass`相同。'
- en: '`-ComputerName`: Same as for `Get-CimClass`.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-ComputerName`：与`Get-CimClass`相同。'
- en: '`-Filter`: Allows us to specify a filter string to only get certain instances.
    For instance, `Get-CimInstance -Classname Win32_Printer -Filter "Name like ''HP%''"`
    will find the HP printer on my machine. Note that we must use **Windows Query
    Language** (**WQL**) or **Cassandra Query** **Language** (**CQL**).'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Filter`：允许我们指定过滤器字符串，以仅获取某些实例。例如，`Get-CimInstance -Classname Win32_Printer
    -Filter "Name like ''HP%''"`会查找我机器上的HP打印机。请注意，我们必须使用**Windows查询语言**（**WQL**）或**Cassandra查询语言**（**CQL**）。'
- en: '`-KeyOnly`: Returns only the key properties of an instance, rather than all
    the properties.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-KeyOnly`：仅返回实例的关键属性，而不是所有属性。'
- en: '`-Namespace`: Same as for `Get-CimClass`.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Namespace`：与`Get-CimClass`相同。'
- en: '-`OperationTimeoutSec`: Same as for `Get-CimClass`.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-OperationTimeoutSec`：与`Get-CimClass`相同。'
- en: '`-Property`: Unlike `Get-CimClass`, this doesn’t search for instances with
    a given property; remember, all instances of a class have the same properties
    and methods. Notice it is `-Property`, not `-PropertyName`. We can use this parameter
    to retrieve a list of specified properties, rather than all the properties of
    an instance.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Property`：与`Get-CimClass`不同，这个参数不会搜索具有指定属性的实例；记住，类的所有实例都有相同的属性和方法。注意，它是`-Property`，而不是`-PropertyName`。我们可以使用此参数来检索指定属性的列表，而不是实例的所有属性。'
- en: '`-Query`: Allows us to specify a query string written in WQL or CQL. For example,
    `Get-CimInstance -Query "SELECT * from Win32_Printer WHERE name LIKE ''HP%''"`
    will find my HP printer, again.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Query`：允许我们指定一个用WQL或CQL编写的查询字符串。例如，`Get-CimInstance -Query "SELECT * from
    Win32_Printer WHERE name LIKE ''HP%''"`将再次查找我的HP打印机。'
- en: '`-QueryDialect`: Specifies the dialect the query is written in. The default
    is WQL, so we would generally only use this parameter if we were supplying a query
    written in CQL.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-QueryDialect`：指定查询所使用的方言。默认是WQL，因此我们通常只在提供CQL编写的查询时使用此参数。'
- en: '`-Shallow`: By default, `Get-CimInstance` returns all instances of a class,
    and instances of any child classes. This parameter prevents any results from child
    classes being returned.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Shallow`：默认情况下，`Get-CimInstance`返回类的所有实例以及任何子类的实例。此参数可防止返回子类的任何结果。'
- en: We can see that both these cmdlets have a `-ComputerName` parameter for working
    with remote machines. Each time we use this parameter, we create and then remove
    an ad hoc CIM session. If we have a bunch of commands to run against a remote
    machine then we can create a persistent CIM session in the same way as we can
    create a persistent PowerShell remoting session. Let’s see how we can do this.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，这两个命令都具有`-ComputerName`参数，用于远程计算机的操作。每次使用此参数时，我们都会创建并删除一个临时的CIM会话。如果我们有一堆命令要在远程机器上运行，那么我们可以像创建持久的PowerShell远程会话一样创建一个持久的CIM会话。让我们看看如何做到这一点。
- en: CIM sessions
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CIM 会话
- en: There are four cmdlets for manipulating CIM sessions – `New-CimSession`, `Get-CimSession`,
    `Remove-CimSession`, and `New-CimSessionOption`. They behave in a very similar
    way to the PowerShell remoting cmdlets, and `Get-CimSession` and `Remove-CimSession`
    do exactly what you would expect. Note that CIM sessions work best in an Active
    Directory domain environment that uses Kerberos, which is the default authentication
    scheme. If this isn’t available, then the remote machines will need to be added
    to the TrustedHosts exception list in WinRM. Let’s take a quick look at how `New-CimSession`
    works.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 有四个 cmdlet 用于操作 CIM 会话——`New-CimSession`、`Get-CimSession`、`Remove-CimSession`
    和 `New-CimSessionOption`。它们的行为与 PowerShell 远程 cmdlet 非常相似，`Get-CimSession` 和 `Remove-CimSession`
    完全按预期执行。请注意，CIM 会话在使用 Kerberos（默认身份验证方案）的 Active Directory 域环境中效果最佳。如果没有这个环境，远程计算机将需要添加到
    WinRM 的 TrustedHosts 异常列表中。让我们快速看一下 `New-CimSession` 如何工作。
- en: 'The cmdlet has the following parameters:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 该 cmdlet 有以下参数：
- en: '`-Authentication`: Which authentication scheme we want to use. This will depend
    on the environment we are working in. Kerberos is the best option for a domain
    environment.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Authentication`：我们希望使用的身份验证方案。这将取决于我们所在的环境。在域环境中，Kerberos 是最佳选择。'
- en: '`-CertificateThumbprint`: If we are working in a certificate-based authentication
    scheme, then we will need to provide the details of our certificate.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-CertificateThumbprint`：如果我们在使用基于证书的身份验证方案，则需要提供证书的详细信息。'
- en: '`-ComputerName`: The name of the remote computer we want to work on. If not
    given, then a CIM session to the local machine over DCOM is created. WSMan is
    used for remote computers.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-ComputerName`：我们希望操作的远程计算机名称。如果未指定，则会创建一个通过 DCOM 连接到本地计算机的 CIM 会话。对于远程计算机，使用的是
    WSMan。'
- en: '`-Credential`: Again, depending on the authentication scheme we are working
    with, we might need to give a credential object.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Credential`：同样，根据我们使用的身份验证方案，可能需要提供一个凭据对象。'
- en: '`-Name`: We can assign a friendly name to the session to make it easier to
    work with.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Name`：我们可以为会话分配一个友好的名称，以便更容易操作。'
- en: '`-OperationTimeoutSec`: This is the same as for `Get-CimClass`.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-OperationTimeoutSec`：与 `Get-CimClass` 参数相同。'
- en: '`-Port`: We can specify a particular TCP port if our network is restricted,
    but this isn’t recommended.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Port`：如果我们的网络受到限制，可以指定一个特定的 TCP 端口，但不推荐这样做。'
- en: '`-SessionOption`: This allows us to set advanced options for the session by
    creating a `SessionOption` object with `New-CimSessionOption`.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-SessionOption`：这允许我们通过使用 `New-CimSessionOption` 创建一个 `SessionOption` 对象来设置会话的高级选项。'
- en: '`-SkipTestConnection`: This stops the cmdlet testing the session connectivity
    before creating it.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-SkipTestConnection`：此参数会停止 cmdlet 在创建会话前测试连接性。'
- en: There are a number of advanced options covering the use of proxy servers and
    controlling how we work with different authentication schemes. These can all be
    set with the `New-CimSessionOption` cmdlet, but we’re not going to go into them
    here.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些高级选项可以控制代理服务器的使用以及如何处理不同的身份验证方案。所有这些选项都可以通过 `New-CimSessionOption` cmdlet
    设置，但我们在此不作深入讨论。
- en: 'Let’s see how this all works in the following figure:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下图示中这些如何运作：
- en: '![Figure 13.13 – Working with CIM sessions](img/B17600_13_013.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.13 – 使用 CIM 会话](img/B17600_13_013.jpg)'
- en: Figure 13.13 – Working with CIM sessions
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.13 – 使用 CIM 会话
- en: In the first command, I create a new CIM session on the local machine and give
    it a friendly name, `localsession`. In the second command, I get the details of
    my session using the friendly name; notice this is using WSMan, not DCOM, even
    though it’s the local machine. That’s because I specified the local machine with
    the `-ComputerName` parameter, so the cmdlet automatically uses a WSMan session.
    Neat, huh? In the final command, I remove the session.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个命令中，我在本地计算机上创建了一个新的 CIM 会话，并为其指定了一个友好的名称 `localsession`。在第二个命令中，我使用友好的名称获取我的会话详情；请注意，尽管它是本地计算机，但这里使用的是
    WSMan 而不是 DCOM。这是因为我通过 `-ComputerName` 参数指定了本地计算机，因此 cmdlet 自动使用 WSMan 会话。很酷吧？在最后一个命令中，我删除了该会话。
- en: So, that’s the cmdlets we can use to get information about classes and instances.
    In the next section, we’ll look at how we can manipulate the properties of instances
    and use their methods.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这就是我们可以用来获取类和实例信息的 cmdlet。在下一节中，我们将看看如何操作实例的属性并使用它们的方法。
- en: Making changes
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改设置
- en: We can use the CIM cmdlets to manipulate the objects in the WMI repository as
    well; we can change their properties (sometimes) or use their methods. Let’s start
    with changing properties.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用CIM cmdlets操作WMI仓库中的对象；我们可以更改它们的属性（有时）或使用它们的方法。让我们从更改属性开始。
- en: Changing properties
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更改属性
- en: 'Let''s run the following command:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行以下命令：
- en: '[PRE6]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then we will see all the methods and properties of an HP printer installed
    on our local client. If we don’t have an HP printer installed, then we’ll get
    an error, but we can change the search string to match the sort of printer we
    might have; for instance `''can*''` will find Canon printers. Note that the properties
    are followed by a string that looks like `{get;set;}`. If it only reads `{get;}`
    then it is not writable. Let’s see how changing a writable property looks:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到安装在本地客户端上的HP打印机的所有方法和属性。如果我们没有安装HP打印机，那么会得到一个错误，但我们可以更改搜索字符串以匹配可能拥有的打印机类型；例如，`'can*'`将找到佳能打印机。注意，属性后面跟着一个看起来像`{get;set;}`的字符串。如果它只是`{get;}`，那么它是只读的。让我们看看修改可写属性的效果：
- en: '![Figure 13.14 – Changing the properties with Set-CimInstance](img/B17600_13_014.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.14 – 使用Set-CimInstance更改属性](img/B17600_13_014.jpg)'
- en: Figure 13.14 – Changing the properties with Set-CimInstance
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.14 – 使用Set-CimInstance更改属性
- en: In the first command, I’m creating a variable called `$printer` and putting
    my HP printer in it. In the second command, I’m calling the variable, just to
    check the right thing is in there. It is.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个命令中，我创建了一个名为`$printer`的变量，并将我的HP打印机放入其中。在第二个命令中，我调用了该变量，只是为了检查里面的内容是否正确。它是正确的。
- en: In the third command, I’m checking the current value of the `Comment` property
    of the `$printer` variable – we can see it’s empty. In the fourth command, I’m
    changing the property of the variable to `I` `Love PowerShell`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三个命令中，我正在检查`$printer`变量的`Comment`属性的当前值——我们可以看到它是空的。在第四个命令中，我将变量的属性更改为`I`
    `Love PowerShell`。
- en: The fifth command is the important bit – I’m taking the contents of the variable,
    and now I’m writing them back to the instance in the WMI repository with the `Set-CimInstance`
    cmdlet. The variable contains a WMI object so I’m using the `-InputObject` parameter
    of the cmdlet. Has it worked? Let’s take a look.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 第五个命令是关键部分——我正在获取变量的内容，现在使用`Set-CimInstance` cmdlet将它们写回到WMI仓库中的实例。该变量包含一个WMI对象，因此我使用了cmdlet的`-InputObject`参数。它是否成功了？我们来看一下。
- en: '![Figure 13.15 – My printer has an opinion](img/B17600_13_015.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.15 – 我的打印机有意见](img/B17600_13_015.jpg)'
- en: Figure 13.15 – My printer has an opinion
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.15 – 我的打印机有意见
- en: Of course it worked. Phew. If we look at the list of properties on a printer
    object, we can see that the majority of them are not writable. For instance, there
    is a `Default` property, but it’s not writable, and we can’t set it with `Set-CimInstance`.
    In the next section, we’ll look at a cmdlet that could do it, `Invoke-CimMethod`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当然它成功了。呼~ 如果我们查看打印机对象的属性列表，我们会发现大多数属性是不可写的。例如，有一个`Default`属性，但它是只读的，我们无法使用`Set-CimInstance`设置它。在接下来的章节中，我们将查看一个可能实现这一功能的cmdlet，`Invoke-CimMethod`。
- en: Discovering methods
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发现方法
- en: We know that objects have properties and methods, and that includes the objects
    in the WMI repository. We’ve looked at the properties, seen how to get them, and
    how to set them. Now we’re going to look at the methods those objects may have.
    Here, we’re going to see just why working with the WMI repository is sometimes
    such a pain.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道对象有属性和方法，这包括WMI仓库中的对象。我们已经查看了属性，了解了如何获取它们以及如何设置它们。现在，我们将看看这些对象可能拥有的方法。在这里，我们将看到为什么有时候与WMI仓库打交道会如此麻烦。
- en: 'Our first problem is knowing the name of the class we want, and we saw how
    to do that in the preceding section on querying data. Once we know the name of
    the class, we need to understand what methods are available. The `Get-CimClass`
    cmdlet doesn’t discover all the methods by default, unlike the `Get-WmiObject`
    cmdlet, so we have to use something like the following command:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们面临的第一个问题是知道我们需要的类的名称，我们在前面的查询数据部分已经看到了如何做到这一点。一旦知道了类的名称，我们需要了解可用的方法。与`Get-WmiObject`
    cmdlet不同，`Get-CimClass` cmdlet默认不会发现所有方法，因此我们必须使用类似下面的命令：
- en: '[PRE7]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will expose the full set of methods. Once we’ve got our method, of course,
    we need to know how to use it. Because WMI isn’t part of PowerShell, the PowerShell
    documentation won’t help us. Most of the time, we can find out what we need to
    know from the Microsoft website, here:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这将暴露完整的方法集。一旦我们找到了方法，当然，我们需要知道如何使用它。由于 WMI 不是 PowerShell 的一部分，PowerShell 文档不会帮助我们。大多数情况下，我们可以从微软官网找到所需的信息，链接如下：
- en: '[https://learn.microsoft.com/en-us/windows/win32/cimwin32prov/cimwin32-wmi-providers](https://learn.microsoft.com/en-us/windows/win32/cimwin32prov/cimwin32-wmi-providers)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/en-us/windows/win32/cimwin32prov/cimwin32-wmi-providers](https://learn.microsoft.com/en-us/windows/win32/cimwin32prov/cimwin32-wmi-providers)'
- en: However, it takes a bit of searching, and quite often the examples are given
    in Visual Basic, not PowerShell. Let’s see how we might do it.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这需要一点搜索，且经常会看到示例是用 Visual Basic 而不是 PowerShell 编写的。我们来看看如何实现它。
- en: 'In the next section, we’re going to see how to start and stop a process, so
    let’s use the `Win32_Process` documentation, here:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将看到如何启动和停止进程，所以让我们查看 `Win32_Process` 文档，链接如下：
- en: '[https://learn.microsoft.com/en-us/windows/win32/cimwin32prov/win32-process](https://learn.microsoft.com/en-us/windows/win32/cimwin32prov/win32-process)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/en-us/windows/win32/cimwin32prov/win32-process](https://learn.microsoft.com/en-us/windows/win32/cimwin32prov/win32-process)'
- en: We can see if we scroll down that there is a *Methods* section. The most likely
    method there is `Create`. If we click on the link, we can see that the `Create`
    method has a `CommandLine` parameter. Let’s see how that might work.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们往下滚动，可以看到一个 *Methods*（方法）部分。最可能的方法是 `Create`。如果点击链接，我们可以看到 `Create` 方法有一个
    `CommandLine` 参数。我们来看看它是如何工作的。
- en: Invoking methods
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调用方法
- en: 'Now we have our method, and a likely parameter for that method, let’s give
    it a try. First of all, we’ll need our `Invoke-CimMethod` cmdlet. This cmdlet
    has the following parameters, many of which work in ways we should now be familiar
    with:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了方法和可能的参数，试试看吧。首先，我们需要使用 `Invoke-CimMethod` cmdlet。这个 cmdlet 有以下参数，其中许多参数的用法我们应该已经熟悉：
- en: '`-ClassName`: Same as for `Get-CimClass`.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-ClassName`：与 `Get-CimClass` 相同。'
- en: '`-CimClass`: We can use this parameter to specify a WMI class instead of the
    `-ClassName` parameter. We need to pass it a WMI class object, however, via a
    variable, instead of a string.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-CimClass`：我们可以使用此参数来指定 WMI 类，而不是使用 `-ClassName` 参数。我们需要通过变量传递一个 WMI 类对象，而不是字符串。'
- en: '`-CimSession`: Same as for `Get-CimClass`.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-CimSession`：与 `Get-CimClass` 相同。'
- en: '`-Namespace`: Same as for `Get-CimClass`.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Namespace`：与 `Get-CimClass` 相同。'
- en: '`-ComputerName`: Same as for `Get-CimClass`.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-ComputerName`：与 `Get-CimClass` 相同。'
- en: '`-MethodName`: This is a mandatory parameter that accepts a string; the name
    of the method.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-MethodName`：这是一个必填参数，接受一个字符串；方法的名称。'
- en: '`-Arguments`: Here, we specify the parameters we are passing to the method,
    as an `iDictionary` hash table, like this: `-Arguments @{ ParameterName = ''``value''}`.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Arguments`：在这里，我们指定传递给方法的参数，作为一个 `iDictionary` 哈希表，像这样：`-Arguments @{ ParameterName
    = ''``value''}`。'
- en: '`-OperationTimeoutSeconds`: Same as for `Get-CimClass`.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-OperationTimeoutSeconds`：与 `Get-CimClass` 相同。'
- en: '`-Query` and `-QueryDialect`: Same as for `Get-CimInstance`.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Query` 和 `-QueryDialect`：与 `Get-CimInstance` 相同。'
- en: 'Let’s start the Notepad program; we may want to close any running instances
    of Notepad, especially if we’re working on Windows 11\. First, we’ll use the `Invoke-CimMethod`
    cmdlet. We’ll need the class name, `Win32_Process`, the method name, `Create()`,
    and the argument. We’ll use `CommandLine = ''notepad.exe''`, as `notepad.exe`
    is in the `PATH` environmental variable, so shouldn’t need a location:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们启动记事本程序；如果我们在 Windows 11 上工作，可能需要关闭任何正在运行的记事本实例。首先，我们将使用 `Invoke-CimMethod`
    cmdlet。我们需要类名 `Win32_Process`、方法名 `Create()` 和参数。我们将使用 `CommandLine = 'notepad.exe'`，因为
    `notepad.exe` 在 `PATH` 环境变量中，所以不需要指定位置：
- en: '[PRE8]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And it looks like this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来像这样：
- en: '![Figure 13.16 – Invoking a method](img/B17600_13_016.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 13.16 – Invoking a method](img/B17600_13_016.jpg)'
- en: Figure 13.16 – Invoking a method
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.16 – 调用方法
- en: We can see the return value (`0`) indicates success, and we get the `ProcessId`
    of the new Notepad process we’ve created. Note that this command may create the
    process in the background; we don’t see the Notepad window suddenly appear, but
    we’ll see it on the taskbar.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到返回值（`0`）表示成功，并且我们得到了新创建的记事本进程的 `ProcessId`。请注意，这个命令可能会在后台创建进程；我们不会突然看到记事本窗口出现，但我们会在任务栏看到它。
- en: Activities
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 活动
- en: How could we close the `notepad.exe` process we just started with PowerShell?
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何使用 PowerShell 关闭我们刚刚启动的 `notepad.exe` 进程？
- en: 'How can we set a printer as the default with PowerShell? Hint: we can’t use
    the Windows PowerShell `Set-Printer` cmdlet.'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何使用 PowerShell 设置打印机为默认打印机？提示：我们不能使用 Windows PowerShell 中的 `Set-Printer` cmdlet。
- en: That’s all we’re going to cover here. Just remember that properties and methods
    are not well documented, and that quite often there will be a PowerShell cmdlet
    specifically written for our purpose, either as part of PowerShell 7 or Windows
    PowerShell. Let’s summarize this chapter.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们在这里要讲解的全部内容。只需记住，属性和方法的文档不完整，而且经常会有一个专门为我们的目的编写的 PowerShell cmdlet，通常作为
    PowerShell 7 或 Windows PowerShell 的一部分。让我们总结一下本章内容。
- en: Summary
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We started the final section of the book in this chapter on using PowerShell
    in different environments. We’ve started with the Windows environment, arguably
    the environment in which PowerShell is most effective. However, we saw there are
    some important differences between PowerShell 7 and Windows PowerShell.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们开始了书的最后部分，讲解如何在不同环境中使用 PowerShell。我们从 Windows 环境开始，可以说这是 PowerShell 最有效的环境。然而，我们也看到
    PowerShell 7 和 Windows PowerShell 之间有一些重要的区别。
- en: We saw that PowerShell 7 can’t necessarily use modules written for Windows PowerShell,
    and we looked at three ways of coping with that; finding an equivalent module
    for PowerShell 7, loading the module anyway, or using Compatibility mode.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到 PowerShell 7 不一定能使用为 Windows PowerShell 编写的模块，且我们探讨了三种应对方法：为 PowerShell
    7 寻找等效模块、无论如何加载模块，或者使用兼容模式。
- en: While most of the time Compatibility mode is used transparently, we looked at
    how it works, and some cases where we might want to limit how it is used. However,
    it is incredibly useful, and we saw that it is getting better all the time.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大多数时候兼容模式是透明使用的，但我们了解了它的工作原理，以及一些我们可能希望限制其使用的情况。不过，它非常有用，我们看到它一直在不断改进。
- en: We moved on to look at some stuff that just doesn’t work with PowerShell 7,
    and why. Generally, this is related to older modules that are no longer worth
    rewriting to be compatible with PowerShell 7.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续探讨了与 PowerShell 7 不兼容的某些功能，以及为什么会这样。通常，这是因为一些旧模块不再值得重写以适配 PowerShell 7。
- en: 'We then looked at one of the most useful ways to use PowerShell 7 on a Windows
    machine: using CIM to manipulate the WMI repository. We took some time to understand
    the WMI repository, then moved on to how we can get the properties of objects
    there to understand the environment on both our local machine and remote machines.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们看了在 Windows 机器上使用 PowerShell 7 的最有用方法之一：使用 CIM 来操作 WMI 存储库。我们花了一些时间了解了
    WMI 存储库，然后继续讨论如何获取那里的对象属性，以便了解我们本地机器和远程机器上的环境。
- en: The final section looked at how to manipulate the properties of objects in the
    WMI repository, and then looked at how we can call the methods on those objects
    to affect the wider computing environment.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的部分讲解了如何操作 WMI 存储库中对象的属性，然后介绍了如何调用这些对象的方法来影响更广泛的计算环境。
- en: That’s it for this chapter. In the next chapter, we’re going to look at how
    we can use PowerShell 7 on Linux and macOS machines.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 本章就到这里。在下一章中，我们将讨论如何在 Linux 和 macOS 机器上使用 PowerShell 7。
- en: Exercises
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: What type of modules have compatibility information?
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些类型的模块包含兼容性信息？
- en: Why might a module have no compatibility information?
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么一个模块可能没有兼容性信息？
- en: We’ve run `Get-PSSession`, and we can see that there is a remote session called
    `WinPSCompatSession` running on the localhost machine. What version of PowerShell
    is it running?
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们运行了 `Get-PSSession`，可以看到本地主机上运行着一个名为 `WinPSCompatSession` 的远程会话。它正在运行哪个版本的
    PowerShell？
- en: What sort of objects do we get back from commands run in the `WinPSCompatSession`?
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从在 `WinPSCompatSession` 中运行的命令中获得的是什么类型的对象？
- en: Our local admin has disabled implicit Windows compatibility on our machine.
    How can we still import modules in Compatibility mode?
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的本地管理员禁用了我们机器上的隐式 Windows 兼容性。那么我们如何在兼容模式下仍然导入模块呢？
- en: What CIM class contains instances of namespaces?
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个 CIM 类包含命名空间的实例？
- en: What is the purpose of the `-OperationTimeoutSecs` parameter on the `Get-CimInstance`
    cmdlet?
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Get-CimInstance` cmdlet 中的 `-OperationTimeoutSecs` 参数的作用是什么？'
- en: What cmdlet would we use to change the properties of a WMI object?
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们会使用哪个 cmdlet 来更改 WMI 对象的属性？
- en: How do we pass method parameters to `Invoke-CimMethod` and what format do they
    need to be in?
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何将方法参数传递给 `Invoke-CimMethod`，它们需要什么格式？
- en: Further reading
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*.**NET Framework*:'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*.**NET Framework*：'
- en: '[https://en.wikipedia.org/wiki/.NET_Framework](https://en.wikipedia.org/wiki/.NET_Framework)'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/.NET_Framework](https://en.wikipedia.org/wiki/.NET_Framework)'
- en: '*Module compatibility*:'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*模块兼容性*：'
- en: '[https://learn.microsoft.com/en-us/powershell/gallery/concepts/module-psedition-support](https://learn.microsoft.com/en-us/powershell/gallery/concepts/module-psedition-support)'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/zh-cn/powershell/gallery/concepts/module-psedition-support](https://learn.microsoft.com/zh-cn/powershell/gallery/concepts/module-psedition-support)'
- en: '*PowerShell editions*:'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PowerShell 版本*：'
- en: '[https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_powershell_editions](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_powershell_editions)'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/zh-cn/powershell/module/microsoft.powershell.core/about/about_powershell_editions](https://learn.microsoft.com/zh-cn/powershell/module/microsoft.powershell.core/about/about_powershell_editions)'
- en: '*Differences in* *PowerShell 7*:'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PowerShell 7 中的差异*：'
- en: '[https://learn.microsoft.com/en-us/powershell/scripting/whats-new/differences-from-windows-powershell](https://learn.microsoft.com/en-us/powershell/scripting/whats-new/differences-from-windows-powershell)'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/zh-cn/powershell/scripting/whats-new/differences-from-windows-powershell](https://learn.microsoft.com/zh-cn/powershell/scripting/whats-new/differences-from-windows-powershell)'
- en: '*Web-Based* *Enterprise Management*:'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基于 Web 的企业管理*：'
- en: '[https://en.wikipedia.org/wiki/Web-Based_Enterprise_Management](https://en.wikipedia.org/wiki/Web-Based_Enterprise_Management)'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://zh.wikipedia.org/wiki/Web-Based_Enterprise_Management](https://zh.wikipedia.org/wiki/Web-Based_Enterprise_Management)'
- en: '*Common* *Information Model*:'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通用信息模型*：'
- en: '[https://en.wikipedia.org/wiki/Common_Information_Model_(computing)](https://en.wikipedia.org/wiki/Common_Information_Model_(computing))'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://zh.wikipedia.org/wiki/Common_Information_Model_(computing)](https://zh.wikipedia.org/wiki/Common_Information_Model_(computing))'
- en: '*WSMan*:'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*WSMan*：'
- en: '[https://en.wikipedia.org/wiki/WS-Management](https://en.wikipedia.org/wiki/WS-Management)'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://zh.wikipedia.org/wiki/WS-Management](https://zh.wikipedia.org/wiki/WS-Management)'
- en: '*Windows* *Management Instrumentation*:'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Windows 管理工具*：'
- en: '[https://en.wikipedia.org/wiki/Windows_Management_Instrumentation](https://en.wikipedia.org/wiki/Windows_Management_Instrumentation)'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://zh.wikipedia.org/wiki/Windows_Management_Instrumentation](https://zh.wikipedia.org/wiki/Windows_Management_Instrumentation)'
- en: '*Distributed Component* *Object Model*:'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分布式组件对象模型*：'
- en: '[https://en.wikipedia.org/wiki/Distributed_Component_Object_Model](https://en.wikipedia.org/wiki/Distributed_Component_Object_Model)'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://zh.wikipedia.org/wiki/Distributed_Component_Object_Model](https://zh.wikipedia.org/wiki/Distributed_Component_Object_Model)'
- en: '*Migrating from Windows PowerShell 5.1 to* *PowerShell 7.x*:'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从 Windows PowerShell 5.1 迁移到 PowerShell 7.x*：'
- en: '[https://learn.microsoft.com/en-us/powershell/scripting/whats-new/migrating-from-windows-powershell-51-to-powershell-7](https://learn.microsoft.com/en-us/powershell/scripting/whats-new/migrating-from-windows-powershell-51-to-powershell-7)'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/zh-cn/powershell/scripting/whats-new/migrating-from-windows-powershell-51-to-powershell-7](https://learn.microsoft.com/zh-cn/powershell/scripting/whats-new/migrating-from-windows-powershell-51-to-powershell-7)'
- en: '*About Windows* *PowerShell Compatibility*:'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*关于 Windows PowerShell 兼容性*：'
- en: '[https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_windows_powershell_compatibility](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_windows_powershell_compatibility)'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/zh-cn/powershell/module/microsoft.powershell.core/about/about_windows_powershell_compatibility](https://learn.microsoft.com/zh-cn/powershell/module/microsoft.powershell.core/about/about_windows_powershell_compatibility)'
- en: '*PowerShell 7* *module compatibility*:'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PowerShell 7 模块兼容性*：'
- en: '[https://learn.microsoft.com/en-us/powershell/scripting/whats-new/module-compatibility](https://learn.microsoft.com/en-us/powershell/scripting/whats-new/module-compatibility)'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/zh-cn/powershell/scripting/whats-new/module-compatibility](https://learn.microsoft.com/zh-cn/powershell/scripting/whats-new/module-compatibility)'
- en: '*Modules with compatible* *PowerShell editions*:'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*具有兼容的 PowerShell 版本的模块*：'
- en: '[https://learn.microsoft.com/en-us/powershell/gallery/concepts/module-psedition-support](https://learn.microsoft.com/en-us/powershell/gallery/concepts/module-psedition-support)'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/zh-cn/powershell/gallery/concepts/module-psedition-support](https://learn.microsoft.com/zh-cn/powershell/gallery/concepts/module-psedition-support)'
- en: '*About* *PowerShell editions*:'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*关于 PowerShell 版本*：'
- en: '[https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_powershell_editions](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_powershell_editions)'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/zh-cn/powershell/module/microsoft.powershell.core/about/about_powershell_editions](https://learn.microsoft.com/zh-cn/powershell/module/microsoft.powershell.core/about/about_powershell_editions)'
- en: '*Implicit remoting*:'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*隐式远程管理*：'
- en: '[https://devblogs.microsoft.com/scripting/remoting-the-implicit-way/](https://devblogs.microsoft.com/scripting/remoting-the-implicit-way/)'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://devblogs.microsoft.com/scripting/remoting-the-implicit-way/](https://devblogs.microsoft.com/scripting/remoting-the-implicit-way/)'
- en: '*Getting WMI objects* *with Get-CimInstance*:'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Get-CimInstance 获取 WMI 对象*：'
- en: '[https://learn.microsoft.com/en-us/powershell/scripting/samples/getting-wmi-objects--get-ciminstance-?view=powershell-7.4](https://learn.microsoft.com/en-us/powershell/scripting/samples/getting-wmi-objects--get-ciminstance-?view=powershell-7.4)'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/zh-cn/powershell/scripting/samples/getting-wmi-objects--get-ciminstance-?view=powershell-7.4](https://learn.microsoft.com/zh-cn/powershell/scripting/samples/getting-wmi-objects--get-ciminstance-?view=powershell-7.4)'
- en: '*Using PowerShell CIM cmdlets to explore* *WMI classes*:'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 PowerShell CIM cmdlet 探索* *WMI 类*：'
- en: '[https://devblogs.microsoft.com/scripting/using-powershell-cim-cmdlets-to-explore-wmi-classes/](https://devblogs.microsoft.com/scripting/using-powershell-cim-cmdlets-to-explore-wmi-classes/)'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://devblogs.microsoft.com/scripting/using-powershell-cim-cmdlets-to-explore-wmi-classes/](https://devblogs.microsoft.com/scripting/using-powershell-cim-cmdlets-to-explore-wmi-classes/)'
