- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Selecting a Build System
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择构建系统
- en: 'The preceding chapters covered the first four elements of embedded Linux. You
    built a bootloader, kernel, and root filesystem step by step before combining
    them into a basic embedded Linux system. That’s a lot of steps! Now it is time
    to simplify the process by automating as much of it as possible. Embedded Linux
    build systems can help, and we will look at two in particular: Buildroot and The
    Yocto Project. Both are complex tools that require an entire book to explain how
    they work.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 前几章介绍了嵌入式 Linux 的前四个元素。你逐步构建了引导加载程序、内核和根文件系统，然后将它们组合成一个基本的嵌入式 Linux 系统。这是一个繁琐的过程！现在是时候通过尽可能地自动化来简化这个过程了。嵌入式
    Linux 构建系统能够帮助实现这一点，我们将重点介绍两个：Buildroot 和 Yocto 项目。这两者都是复杂的工具，解释它们的工作原理需要整本书。
- en: In this chapter I will only present the general ideas behind build systems,
    laying the groundwork for *Chapters 7* and *8*. First, I will show you how to
    build a simple image to get an overall feel for the system. Then, I will show
    you how to make some useful modifications to the Nova board and Raspberry Pi 4
    examples from the previous chapters. In subsequent chapters, we will dive deeper
    into The Yocto Project, now the preeminent build system for embedded Linux.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将仅介绍构建系统背后的基本思想，为*第7章*和*第8章*打下基础。首先，我将展示如何构建一个简单的镜像，以便对系统有一个整体的了解。然后，我将展示如何对前几章中的
    Nova 开发板和 Raspberry Pi 4 示例做一些有用的修改。在接下来的章节中，我们将深入探讨 Yocto 项目，这是当前嵌入式 Linux 的主要构建系统。
- en: 'In this chapter we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将覆盖以下主题：
- en: Comparing build systems
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较构建系统
- en: Distributing binaries
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分发二进制文件
- en: Introducing Buildroot
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Buildroot
- en: Introducing The Yocto Project
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Yocto 项目
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with the examples, make sure you have the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随示例，确保你拥有以下内容：
- en: An Ubuntu 24.04 or later LTS host system with at least 90 GB of free disk space
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少具有 90 GB 可用磁盘空间的 Ubuntu 24.04 或更高版本 LTS 主机系统
- en: A microSD card reader and card
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: microSD 卡读卡器和卡片
- en: balenaEtcher for Linux
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用于 Linux 的 balenaEtcher
- en: An Ethernet cable and router with an available port for network connectivity
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一根以太网电缆和一个可用端口的路由器，用于网络连接
- en: A USB-to-TTL serial cable with a 3.3 V logic level
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一根 3.3V 逻辑电平的 USB-to-TTL 串口线
- en: Raspberry Pi 4
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Raspberry Pi 4
- en: BeaglePlay
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BeaglePlay
- en: A 5 V USB-C power supply capable of delivering 3A
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一款能够提供 3A 电流的 5V USB-C 电源
- en: 'The code used in this chapter can be found in the chapter folder in this book’s
    GitHub repository: [https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter06](https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter06).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码可以在本书 GitHub 仓库的本章文件夹中找到：[https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter06](https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter06)。
- en: Comparing build systems
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较构建系统
- en: In [*Chapter 5*](Chapter_05.xhtml#_idTextAnchor138), I described the process
    of creating an image manually as the **Roll Your Own** (**RYO**) process. This
    approach gives you complete control over the software so that you can tailor it
    to do anything you like. If you want to do something truly odd but innovative,
    or if you want to reduce the memory footprint to the smallest size possible, then
    RYO is the way to go. But in most situations, building manually is a waste of
    time and produces inferior, unmaintainable systems.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第5章*](Chapter_05.xhtml#_idTextAnchor138)中，我描述了手动创建镜像的过程，这就是**自定义构建**（**RYO**）过程。这种方法让你完全掌控软件，以便按需进行定制。如果你想做一些真正奇特却具有创新性的事情，或者你想将内存占用减少到最小，那么自定义构建就是最佳选择。但在大多数情况下，手动构建是浪费时间的，并且会产生不稳定、不可维护的系统。
- en: 'The idea behind a build system is to automate all the steps described up to
    this point. A build system should be able to build some or all of the following
    from upstream source code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 构建系统的理念是自动化完成到目前为止描述的所有步骤。构建系统应当能够从上游源代码构建以下某些或所有内容：
- en: toolchain
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工具链
- en: bootloader
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引导加载程序
- en: kernel
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核
- en: root filesystem
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根文件系统
- en: Building from upstream source code is important for several reasons. It gives
    you the peace of mind that you can rebuild at any time without external dependencies.
    It also means you can debug at the source level and meet your license requirements
    to distribute the code to users where necessary.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 从上游源代码构建非常重要，原因有几个。它能让你放心地在任何时候都可以重新构建，而无需依赖外部组件。这也意味着你可以在源代码层面进行调试，并在必要时满足分发代码给用户的许可证要求。
- en: 'To do its job, a build system must be able to:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成任务，构建系统必须能够：
- en: Download the source code from upstream, either directly from the version control
    system or as an archive, and cache it locally.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从上游下载源代码，既可以直接从版本控制系统获取，也可以作为归档文件下载，并将其缓存到本地。
- en: Apply patches to enable cross-compilation, fix architecture-dependent bugs,
    apply local configuration policies, and so on.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用补丁以启用交叉编译、修复架构相关的错误、应用本地配置策略等。
- en: Build the various components along with their compile-time and runtime dependencies.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建各种组件及其编译时和运行时的依赖关系。
- en: Create a staging area and assemble a root filesystem.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个暂存区并组装根文件系统。
- en: Create image files in various formats ready to be loaded onto the target.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建各种格式的镜像文件，准备好加载到目标设备上。
- en: 'Some other useful things are:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 其他一些有用的功能包括：
- en: Add your own packages containing applications or kernel changes.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加你自己的软件包，包含应用程序或内核更改。
- en: 'Select various root filesystem profiles: large or small, with or without graphics,
    and other features.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择各种根文件系统配置文件：大或小，有或没有图形界面，及其他功能。
- en: Create a standalone SDK that you can distribute to other developers so they
    don’t have to install the complete build system.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个独立的 SDK，你可以将其分发给其他开发者，这样他们就不需要安装完整的构建系统。
- en: Track which open source licenses are used by the various packages you selected.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪你选择的各种软件包使用了哪些开源许可证。
- en: Have a friendly user interface.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一个友好的用户界面。
- en: In all cases, build systems encapsulate the components of a system into packages,
    some for the host and some for the target. Each package defines a set of rules
    to get the source, build it, and install the results in the correct location.
    There are dependencies between packages and a mechanism to resolve the dependencies
    and build the set of packages required.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有情况下，构建系统将系统的组件封装为软件包，一些是针对主机的，一些是针对目标的。每个软件包都定义了一组规则，用于获取源代码、编译它，并将结果安装到正确的位置。软件包之间有依赖关系，并且有一个机制来解决这些依赖关系并构建所需的软件包集。
- en: 'Open source build systems have matured over the past few years. There are many
    around, including:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 开源构建系统在过去几年中已经成熟，市面上有很多这样的系统，包括：
- en: '**Buildroot**: Is an easy-to-use system using GNU Make and Kconfig ([https://buildroot.org/](https://buildroot.org/)).'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Buildroot**：是一个易于使用的系统，使用 GNU Make 和 Kconfig ([https://buildroot.org/](https://buildroot.org/))。'
- en: '**OpenEmbedded**: Is a powerful system and a core component of Yocto ([https://openembedded.org](https://openembedded.org)).'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenEmbedded**：是一个强大的系统，也是 Yocto 的核心组件 ([https://openembedded.org](https://openembedded.org))。'
- en: '**OpenWrt**: Is a build tool oriented toward building firmware for wireless
    routers ([https://openwrt.org/](https://openwrt.org/)) that supports runtime package
    management out of the box. It is a derivative of Buildroot.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenWrt**：是一个面向构建无线路由器固件的构建工具 ([https://openwrt.org/](https://openwrt.org/))，开箱即用支持运行时软件包管理。它是
    Buildroot 的衍生版本。'
- en: '**PTXdist**: Is an open source build system sponsored by Pengutronix ([https://www.ptxdist.org/](https://www.ptxdist.org/)).'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PTXdist**：是由 Pengutronix 提供支持的开源构建系统 ([https://www.ptxdist.org/](https://www.ptxdist.org/))。'
- en: '**Yocto**: Extends the OpenEmbedded core with metadata, tools, and documentation.
    It is the most popular embedded Linux build system today ([https://www.yoctoproject.org/](https://www.yoctoproject.org/)).'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Yocto**：通过元数据、工具和文档扩展了 OpenEmbedded 核心。它是目前最流行的嵌入式 Linux 构建系统 ([https://www.yoctoproject.org/](https://www.yoctoproject.org/))。'
- en: 'I will concentrate on two of them: Buildroot and Yocto. They approach the problem
    in different ways and with different objectives.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我将专注于其中的两个：Buildroot 和 Yocto。它们以不同的方式解决问题，并且有不同的目标。
- en: Buildroot has the primary aim of building root filesystem images, hence the
    name. But it can build bootloaders, kernels, and even toolchains as well. It is
    easy to install and configure. Most importantly, Buildroot generates target images
    quickly.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Buildroot 的主要目标是构建根文件系统镜像，因此得名。但它也可以构建引导加载程序、内核，甚至工具链。它易于安装和配置。最重要的是，Buildroot
    可以快速生成目标镜像。
- en: Yocto is more general in how it defines the target system, so it can build more
    complex embedded devices. Every component is generated as a binary package by
    default using the RPM format. Packages are then combined to make the filesystem
    image. You can install a package manager in the filesystem image that allows you
    to update packages at runtime. In other words, when you build with Yocto, you
    are creating your own custom Linux distribution. Bear in mind that enabling runtime
    package management also means provisioning and running your own corresponding
    package feed repository.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Yocto 在定义目标系统方面更为通用，因此它可以构建更复杂的嵌入式设备。默认情况下，每个组件都作为二进制包使用 RPM 格式生成。然后将这些包组合起来，制作成文件系统镜像。你可以在文件系统镜像中安装一个包管理器，这样就可以在运行时更新包。换句话说，当你使用
    Yocto 构建时，你是在创建你自己的定制 Linux 发行版。请记住，启用运行时包管理也意味着你需要提供并运行自己对应的包源库。
- en: Distributing binaries
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分发二进制文件
- en: Mainstream Linux distributions are in most cases constructed from collections
    of binary (precompiled) packages in either RPM or DEB format. **RPM** stands for
    **Red Hat Package Manager** and is used in Red Hat, SUSE, Fedora, and other RPM-based
    distributions. Debian and Debian-derived distributions, including Ubuntu and Mint,
    use the **Debian package manager** (**DEB**) format. There is also a lightweight
    format for embedded devices known as the **Itsy package** (**IPK**) format, which
    is based on DEB.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 主流 Linux 发行版通常是由 RPM 或 DEB 格式的二进制（预编译）包集合构建而成的。**RPM** 代表 **Red Hat 包管理器**，用于
    Red Hat、SUSE、Fedora 以及其他基于 RPM 的发行版。Debian 及其衍生发行版，包括 Ubuntu 和 Mint，使用 **Debian
    包管理器**（**DEB**）格式。此外，还有一种适用于嵌入式设备的轻量级格式，称为 **Itsy 包**（**IPK**）格式，它基于 DEB。
- en: The ability to include a package manager on the device is one of the big differentiators
    between build systems. Once you have a package manager on the target device, you
    have an easy path to deploy new packages and to update the existing ones. I will
    talk about the implications of this in [*Chapter 10*](Chapter_10.xhtml#_idTextAnchor341).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在设备上包含包管理器的能力是构建系统之间的一个重要区别。一旦在目标设备上安装了包管理器，就可以轻松部署新包并更新现有的包。我将在[*第 10 章*](Chapter_10.xhtml#_idTextAnchor341)中讨论这方面的影响。
- en: Now for the main event. We will start with Buildroot. As the simpler of the
    two build systems, Buildroot is easier to get started with than Yocto and the
    quickest way of generating a bootable image for all three of our targets.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在进入重点。我们将从 Buildroot 开始。作为两种构建系统中更简单的一个，Buildroot 比 Yocto 更容易上手，并且是为我们的三个目标生成可引导镜像的最快方法。
- en: Introducing Buildroot
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Buildroot
- en: The current versions of Buildroot can build a toolchain, a bootloader, a kernel,
    and a root filesystem. Buildroot uses GNU Make as its principal build tool. There
    is good online documentation at [https://buildroot.org/docs.html](https://buildroot.org/docs.html)
    along with *The Buildroot user manual* at [https://buildroot.org/downloads/manual/manual.html](https://buildroot.org/downloads/manual/manual.html).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 目前的 Buildroot 版本可以构建工具链、引导加载程序、内核和根文件系统。Buildroot 使用 GNU Make 作为其主要构建工具。在[https://buildroot.org/docs.html](https://buildroot.org/docs.html)上有很好的在线文档，以及在[https://buildroot.org/downloads/manual/manual.html](https://buildroot.org/downloads/manual/manual.html)上的*Buildroot
    用户手册*。
- en: Background
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 背景
- en: Buildroot was one of the first build systems. It began when the uClinux and
    uClibc projects needed a way to generate a small root filesystem for testing.
    Buildroot became a separate project in late 2001 and continued to evolve through
    2006, after which it went into a dormant phase.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Buildroot 是最早的构建系统之一。它最初是因为 uClinux 和 uClibc 项目需要一种生成小型根文件系统进行测试的方法。Buildroot
    于 2001 年底成为一个独立的项目，并在 2006 年继续发展，之后进入了一个休眠阶段。
- en: However, since Peter Korsgaard took over stewardship in 2009, it has been developing
    rapidly, adding support for glibc-based toolchains and a greatly increased number
    of packages and target boards. Peter is still the lead maintainer of Buildroot
    and has had a long and illustrious career as a software engineer at Barco in Belgium.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，自从 Peter Korsgaard 在 2009 年接管管理工作以来，Buildroot 发展迅速，增加了对基于 glibc 的工具链的支持，并大幅增加了包和目标板的数量。Peter
    目前仍然是 Buildroot 的首席维护者，并且在比利时 Barco 公司担任软件工程师时，拥有长久而辉煌的职业生涯。
- en: Buildroot is the ancestor of OpenWrt, another popular build system that forked
    from Buildroot around 2004\. The primary focus of OpenWrt is to produce software
    for wireless routers so the package mix is oriented toward networking infrastructure.
    It also has a runtime IPK package manager so that a device can be updated or upgraded
    without a complete reflash of the image. Buildroot and OpenWrt have diverged to
    such an extent that they are now almost completely different build systems. Packages
    built with one are not compatible with the other.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Buildroot 是 OpenWrt 的祖先，OpenWrt 是另一个流行的构建系统，约在 2004 年从 Buildroot 分支出来。OpenWrt
    的主要目标是为无线路由器生产软件，因此其软件包组合倾向于网络基础设施。它还具有一个运行时的 IPK 包管理器，允许设备在不完全重新刷写镜像的情况下进行更新或升级。Buildroot
    和 OpenWrt 已经发生了如此大的分歧，以至于它们现在几乎是完全不同的构建系统。用一个构建的包无法与另一个系统兼容。
- en: Stable releases and long-term support
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 稳定版本和长期支持
- en: The Buildroot developers produce stable releases four times a year in February,
    May, August, and November. They are marked by Git tags of the form `<year>.02`,
    `<year>.05`, `<year>.08`, and `<year>.11`. Each `<year>.02` release is marked
    for **Long-Term Support** (**LTS**), which means there will be point releases
    to fix security and other important bugs for 12 months after the initial release.
    The `2017.02` release is the first to receive the LTS label.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Buildroot 开发者每年发布四次稳定版本，分别在二月、五月、八月和十一月。这些版本通过 Git 标签进行标记，形式为 `<year>.02`、`<year>.05`、`<year>.08`
    和 `<year>.11`。每个 `<year>.02` 版本都会被标记为 **长期支持**（**LTS**），意味着在初始发布后的 12 个月内会有补丁发布来修复安全性和其他重要的
    bug。`2017.02` 版本是第一个获得 LTS 标签的版本。
- en: Installing
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装
- en: 'You install Buildroot either by cloning the repository or downloading an archive.
    Here is an example of obtaining version `2024.02.6`, which was the latest stable
    version at the time of writing:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过克隆仓库或下载档案来安装 Buildroot。以下是获取 `2024.02.6` 版本的示例，这是本文写作时的最新稳定版本：
- en: '[PRE0]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The equivalent TAR archive is available at [https://buildroot.org/downloads/](https://buildroot.org/downloads/).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的 TAR 档案可以在 [https://buildroot.org/downloads/](https://buildroot.org/downloads/)
    获取。
- en: Read the section titled *System requirements* in *The Buildroot user manual*,
    available at [https://buildroot.org/downloads/manual/manual.html,](https://buildroot.org/downloads/manual/manual.html,)
    and make sure to install all the packages listed there.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读《Buildroot 用户手册》中的 *系统要求* 部分，该手册可以在 [https://buildroot.org/downloads/manual/manual.html](https://buildroot.org/downloads/manual/manual.html)
    上找到，并确保安装手册中列出的所有软件包。
- en: Configuring
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置
- en: Buildroot uses the kernel Kconfig/Kbuild mechanism I described in the *Understanding
    kernel configuration* section from [*Chapter 4*](Chapter_04.xhtml#_idTextAnchor096).
    You can configure Buildroot from scratch directly using `make menuconfig` (`xconfig`
    or `gconfig`). Or you can choose one of the 100+ configurations for various development
    boards that you can find stored in the `configs` directory. Typing `make list-defconfigs`
    lists all the default configurations.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Buildroot 使用我在[*理解内核配置*](Chapter_04.xhtml#_idTextAnchor096)部分中描述的内核 Kconfig/Kbuild
    机制。你可以通过直接使用`make menuconfig`（`xconfig` 或 `gconfig`）从零开始配置 Buildroot。或者你也可以选择
    `configs` 目录中存储的 100 多个不同开发板的配置之一。输入 `make list-defconfigs` 会列出所有默认配置。
- en: 'Let’s begin by building a default configuration that you can run on the 64-bit
    Arm QEMU emulator:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从构建一个默认配置开始，这个配置可以在 64 位 Arm QEMU 模拟器上运行：
- en: '[PRE1]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**IMPORTANT NOTE**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: Do not tell GNU Make how many parallel jobs to run with the `-j` option. Buildroot
    will make optimum use of your CPU cores all by itself. If you want to limit the
    number of jobs, then run `make menuconfig` and look for **Number of jobs to run
    simultaneously** under **Build options**.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用 `-j` 选项告诉 GNU Make 要运行多少个并行任务。Buildroot 会自动充分利用你的 CPU 核心。如果你想限制任务数量，可以运行
    `make menuconfig` 并在 **构建选项**下查找 **同时运行的任务数**。
- en: 'The build can take up to an hour depending on how many CPU cores your host
    system has and the speed of your internet. It will download approximately 502
    MB of code and consume about 12 GB of disk space. When it completes, you will
    find two new directories have been created:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 构建过程可能需要一个小时，具体时间取决于你的主机系统有多少个 CPU 核心以及网络的速度。它将下载大约 502 MB 的代码，并消耗大约 12 GB 的磁盘空间。完成后，你会发现创建了两个新的目录：
- en: '`dl`: Contains archives of the upstream projects that Buildroot has built.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dl`：包含 Buildroot 所构建的上游项目的档案。'
- en: '`output`: Contains all the intermediate and final compiled artifacts.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`output`：包含所有中间和最终编译的产物。'
- en: 'Inside `output` you will find the following subdirectories:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `output` 目录中，你会找到以下子目录：
- en: '`build`: Contains the build directory for each component.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build`：包含每个组件的构建目录。'
- en: '`host`: Contains various tools required by Buildroot on the host, including
    the executables of the toolchain (in `output/host/usr/bin`).'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`host`：包含 Buildroot 在主机上所需的各种工具，包括工具链的可执行文件（位于 `output/host/usr/bin`）。'
- en: '`images`: Contains the finished results of the build. Depending on what you
    selected when configuring, you will find a bootloader, a kernel, and one or more
    root filesystem images.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`images`：包含构建的最终结果。根据你在配置时选择的内容，你将找到引导加载程序、内核以及一个或多个根文件系统映像。'
- en: '`staging`: Is a symbolic link to the `sysroot` of the toolchain. The name of
    the link is a little confusing because it does not point to a staging area as
    defined in [*Chapter 5*](Chapter_05.xhtml#_idTextAnchor138).'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`staging`：是工具链 `sysroot` 的符号链接。这个链接的名称可能有些令人困惑，因为它并没有指向如 [*第 5 章*](Chapter_05.xhtml#_idTextAnchor138)
    中定义的暂存区域。'
- en: '`target`: Is the staging area for the root directory. Note that you cannot
    use it as a root filesystem because the file ownership and permissions are not
    set correctly. Buildroot uses a device table as described in the previous chapter
    to set ownership and permissions when the filesystem image is created in the `image`
    directory.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target`：是根目录的暂存区域。请注意，您不能将其用作根文件系统，因为文件的所有权和权限没有正确设置。Buildroot 使用前一章中描述的设备表，在创建
    `image` 目录中的文件系统映像时设置所有权和权限。'
- en: Running
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行
- en: Some of the sample targets have a subfolder in the `board` directory containing
    custom configuration files and informationon how to install the results.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一些示例目标在 `board` 目录中有一个子文件夹，包含自定义配置文件和安装结果的相关信息。
- en: 'In the case of the system you just built, the relevant file is `board/qemu/aarch64-virt/readme.txt`.
    This `readme.txt` file tells you how to start QEMU with this target. Assuming
    you have already installed `qemu-system-aarch64` as described in [*Chapter 1*](Chapter_01.xhtml#_idTextAnchor016),
    you can run QEMU with this command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你刚刚构建的系统，相关的文件是 `board/qemu/aarch64-virt/readme.txt`。这个 `readme.txt` 文件告诉你如何使用该目标启动
    QEMU。假设你已经按照 [*第 1 章*](Chapter_01.xhtml#_idTextAnchor016) 中的描述安装了 `qemu-system-aarch64`，你可以使用以下命令运行
    QEMU：
- en: '[PRE2]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'There is a script named `start-qemu.sh` in `output/images` that includes the
    command. When QEMU boots up, you should see the kernel boot messages appear in
    the same terminal window where you started QEMU followed by a login prompt:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `output/images` 中有一个名为 `start-qemu.sh` 的脚本，其中包含命令。当 QEMU 启动时，你应该能看到内核启动信息出现在启动
    QEMU 的同一终端窗口中，随后是登录提示符：
- en: '[PRE3]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Log in as `root` with no password.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用无密码的 `root` 用户登录。
- en: To exit QEMU type *Ctrl + A* and then *x*.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要退出 QEMU，输入 *Ctrl + A*，然后按 *x*。
- en: Targeting real hardware
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定位真实硬件
- en: 'The steps for configuring and building a bootable image for Raspberry Pi 4
    are almost the same as for 64-bit Arm QEMU:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 配置和构建 Raspberry Pi 4 可启动映像的步骤几乎与构建 64 位 Arm QEMU 时相同：
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The finished image is written to a file named `output/images/sdcard.img`. The
    `post-image.sh` script and the `genimage.cfg.in` configuration file used to write
    the image file are both located in the `board/raspberrypi4-64 directory`. To write
    `sdcard.img` onto a microSD card and boot it on your Raspberry Pi 4:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的映像被写入名为 `output/images/sdcard.img` 的文件中。用于写入映像文件的 `post-image.sh` 脚本和 `genimage.cfg.in`
    配置文件都位于 `board/raspberrypi4-64` 目录中。要将 `sdcard.img` 写入 microSD 卡并在 Raspberry Pi
    4 上启动：
- en: Insert a microSD card into your Linux host machine.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 microSD 卡插入你的 Linux 主机。
- en: Launch balenaEtcher.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 balenaEtcher。
- en: Click **Flash from file** from Etcher.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Etcher 中点击 **Flash from file** 按钮。
- en: Locate the `sdcard.img` image that you built for Raspberry Pi 4 and open it.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位并打开你为 Raspberry Pi 4 构建的 `sdcard.img` 映像。
- en: Click **Select target** from Etcher.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Etcher 中点击 **Select target** 按钮。
- en: Select the microSD card that you inserted in *step 1*.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你在 *步骤 1* 中插入的 microSD 卡。
- en: Click **Flash** from Etcher to write the image.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Etcher 中点击 **Flash** 按钮以写入映像。
- en: Eject the microSD card when Etcher is done flashing.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 Etcher 完成闪存写入时，弹出 microSD 卡。
- en: Insert the microSD card into your Raspberry Pi 4.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 microSD 卡插入 Raspberry Pi 4。
- en: Apply power to Raspberry Pi 4 by way of the USB-C port.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过 USB-C 端口为 Raspberry Pi 4 提供电源。
- en: Confirm that your Raspberry Pi 4 booted successfully by plugging it into Ethernet
    and observing that the network activity lights blink. This default image is very
    minimal and includes little else besides BusyBox. To SSH into your Raspberry Pi
    4, you will need to add an SSH server like `dropbear` or `openssh` to your Buildroot
    image configuration.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将树莓派4插入以太网并观察网络活动指示灯闪烁，确认树莓派4已成功启动。这个默认镜像非常简约，除了BusyBox几乎不包含其他内容。要通过SSH连接到树莓派4，您需要在Buildroot镜像配置中添加一个SSH服务器，例如`dropbear`或`openssh`。
- en: Creating a custom BSP
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自定义BSP
- en: Now let’s use Buildroot to create a **Board Support Package** (**BSP**) for
    our Nova board using the same versions of U-Boot and Linux from earlier chapters.
    You can see the changes I made to Buildroot during this section of the book under
    `MELD/Chapter06/buildroot`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用Buildroot为我们的Nova开发板创建一个**板级支持包**（**BSP**），并使用前几章中相同版本的U-Boot和Linux。您可以在本书本节中的`MELD/Chapter06/buildroot`下查看我对Buildroot所做的更改。
- en: 'The recommended places to store your changes are:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐存储更改的位置是：
- en: '`board/<organization>/<device>`: Contains any patches, blobs, extra build steps,
    and configuration files for Linux, U-Boot, and other components'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`board/<organization>/<device>`：包含Linux、U-Boot以及其他组件的补丁、二进制文件、额外构建步骤和配置文件'
- en: '`configs/<device>_defconfig`: Contains the default configuration for the board'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`configs/<device>_defconfig`：包含该开发板的默认配置'
- en: '`package/<organization>/<package_name>`: Is the place to put any additional
    packages for this board'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package/<organization>/<package_name>`：用于存放此开发板的任何附加包'
- en: 'Create a directory to store changes to the Nova board:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个目录来存储对Nova开发板的更改：
- en: '[PRE5]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Copy `nova_defconfig` from `MELD/Chapter06/buildroot/configs` to `buildroot`/`configs`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 将`nova_defconfig`从`MELD/Chapter06/buildroot/configs`复制到`buildroot`/`configs`：
- en: '[PRE6]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Copy the contents of `MELD/Chapter06/buildroot/board/meld/nova` to `buildroot/board/meld/nova`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 将`MELD/Chapter06/buildroot/board/meld/nova`中的内容复制到`buildroot/board/meld/nova`：
- en: '[PRE7]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Clean the artifacts from any previous build (always do this when changing configurations):'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 清理之前构建的所有产物（更改配置时总是要这么做）：
- en: '[PRE8]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Select the Nova configuration:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 选择Nova配置：
- en: '[PRE9]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `make nova_defconfig` command configures Buildroot to build an image targeting
    the BeaglePlay. This configuration is a good starting point, but we still need
    to customize it for our Nova board. Let’s start by selecting the custom U-Boot
    patch we created for Nova.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`make nova_defconfig`命令将配置Buildroot，以便构建一个针对BeaglePlay的镜像。这个配置是一个良好的起点，但我们仍然需要为Nova开发板定制它。我们从选择为Nova创建的自定义U-Boot补丁开始。'
- en: U-Boot
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: U-Boot
- en: In [*Chapter 3*](Chapter_03.xhtml#_idTextAnchor061)*,* we created a custom bootloader
    for Nova based on the `f036fb` version of TI’s U-Boot fork and created a patch
    file for it saved as `MELD/Chapter03/0001-BSP-for-Nova.patch`. We can configure
    Buildroot to select the same version of U-Boot and apply our patch. Running `make
    nova_defconfig` already set the U-Boot version to `f036fb`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第3章*](Chapter_03.xhtml#_idTextAnchor061)中，我们为Nova创建了基于TI的U-Boot分支`f036fb`版本的自定义引导加载程序，并为其创建了一个补丁文件，保存为`MELD/Chapter03/0001-BSP-for-Nova.patch`。我们可以配置Buildroot来选择相同版本的U-Boot并应用我们的补丁。运行`make
    nova_defconfig`已经将U-Boot版本设置为`f036fb`。
- en: 'Copy the patch file into `board/meld/nova`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 将补丁文件复制到`board/meld/nova`：
- en: '[PRE10]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now run `make menuconfig` and drill down into the **Bootloaders** page. From
    that page, navigate down to **Custom U-Boot patches** and verify the path to our
    patch as shown:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行`make menuconfig`并进入**引导加载程序**页面。从该页面，进入**自定义U-Boot补丁**，并验证我们的补丁路径，如下所示：
- en: '![Figure 6.1 – Selecting custom U-Boot patches](img/B18466_06_01.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1 – 选择自定义U-Boot补丁](img/B18466_06_01.png)'
- en: Figure 6.1 – Selecting custom U-Boot patches
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – 选择自定义U-Boot补丁
- en: Now that we’ve patched U-Boot for our Nova board, the next step is patching
    the kernel.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为Nova开发板打了U-Boot补丁，接下来的步骤是为内核打补丁。
- en: Linux
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Linux
- en: 'In [*Chapter 4*](Chapter_04.xhtml#_idTextAnchor096)*,* we based the kernel
    on Linux 6.6.46 and supplied a new device tree from `MELD/Chapter04/nova.dts`.
    Running `make nova_defconfig` already set the kernel version to Linux 6.6.46 and
    changed the kernel series used for kernel headers to match the kernel being built.
    Back out of the **Bootloaders** page and drill down into the **Kernel** page.
    Confirm that the value of **Out-of-tree Device Tree Source file paths** is set
    to `board/meld/nova/nova.dts`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第4章*](Chapter_04.xhtml#_idTextAnchor096)中，我们基于Linux 6.6.46版本的内核，并提供了一个新的设备树文件，来自`MELD/Chapter04/nova.dts`。运行`make
    nova_defconfig`已经将内核版本设置为Linux 6.6.46，并将内核头文件使用的内核系列更改为与所构建内核匹配的版本。退出**引导加载程序**页面，并进入**内核**页面。确认**非树设备树源文件路径**的值已设置为`board/meld/nova/nova.dts`：
- en: '![Figure 6.2 – Selecting the device tree source](img/B18466_06_02.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2 – 选择设备树源](img/B18466_06_02.png)'
- en: Figure 6.2 – Selecting the device tree source
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – 选择设备树源
- en: Now that we’ve defined the device tree, let’s build the system image complete
    with the kernel and root filesystem.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了设备树，让我们构建包含内核和根文件系统的系统映像。
- en: Build
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建
- en: 'In the last stage of the build, Buildroot uses a tool named `genimage` to create
    an image for the microSD that we can copy directly to the card. We need a configuration
    file to lay out the image in the right way. Modify the existing `board/meld/nova/genimage.cfg`
    file by replacing `"k3-am625-beagleplay.dtb"` with `"nova.dtb"` as shown:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建的最后阶段，Buildroot使用一个名为`genimage`的工具来为microSD创建一个映像，我们可以直接将它复制到卡中。我们需要一个配置文件来以正确的方式布局映像。通过替换现有的`board/meld/nova/genimage.cfg`文件中的`"k3-am625-beagleplay.dtb"`为`"nova.dtb"`，如下所示：
- en: '[PRE11]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This will create a file named `sdcard.img`, which contains two partitions named
    `u-boot` and `rootfs`. The first contains the boot files listed in `boot.vfat`
    and the second contains the root filesystem image named `rootfs.ext4`, which will
    be generated by Buildroot.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为`sdcard.img`的文件，其中包含两个分区，分别为`u-boot`和`rootfs`。第一个分区包含`boot.vfat`中列出的启动文件，第二个分区包含名为`rootfs.ext4`的根文件系统映像，这将由Buildroot生成。
- en: 'Finally, we need a `post-image.sh` script that will call `genimage` and create
    the microSD card image. See `board/meld/nova/post-image.sh`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要一个`post-image.sh`脚本来调用`genimage`并创建microSD卡映像。请参见`board/meld/nova/post-image.sh`：
- en: '[PRE12]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This script copies the R5 firmware image into the `output/images` directory
    and runs `genimage` with our configuration file.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本将R5固件映像复制到`output/images`目录，并使用我们的配置文件运行`genimage`。
- en: 'Note that `post-image.sh` needs to be executable; otherwise the build will
    fail at the end:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`post-image.sh`需要具有可执行权限，否则构建将在最后失败：
- en: '[PRE13]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, run `make menuconfig` and drill down into the **System configuration**
    page. From that page, navigate down to **Custom scripts to run before creating
    filesystem images** and notice the path to our `post-image.sh` script:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行`make menuconfig`并进入**系统配置**页面。在该页面，向下导航到**创建文件系统映像前要运行的自定义脚本**，注意到我们`post-image.sh`脚本的路径：
- en: '![Figure 6.3 – Selecting custom scripts to run after creating filesystem images](img/B18466_06_03.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图6.3 – 选择在创建文件系统映像后要运行的自定义脚本](img/B18466_06_03.png)'
- en: Figure 6.3 – Selecting custom scripts to run after creating filesystem images
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 – 选择在创建文件系统映像后要运行的自定义脚本
- en: 'Finally, you can build Linux for the Nova board just by typing `make`. When
    the build is done, you will see these files in the `output/images` directory:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你只需输入`make`命令即可为Nova板构建Linux。当构建完成后，你将在`output/images`目录中看到这些文件：
- en: '[PRE14]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To test it, insert a microSD card into your card reader and use balenaEtcher
    to write `output/images/sdcard.img` out to a microSD card like we did for the
    Raspberry Pi 4\. There is no need to format the microSD beforehand like we did
    in the previous chapter because `genimage` has created the exact disk layout required.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试它，将microSD卡插入读卡器，并使用balenaEtcher将`output/images/sdcard.img`写入microSD卡，就像我们之前为Raspberry
    Pi 4所做的那样。无需像上一章那样先格式化microSD卡，因为`genimage`已创建了所需的磁盘布局。
- en: 'Having shown that our custom configuration for the Nova board works, it would
    be nice to save our changes back to the `nova_defconfig` file so that we and others
    can use it again. You can do that with this command:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经展示了我们为Nova板创建的自定义配置有效，现在最好将我们的更改保存回`nova_defconfig`文件，以便我们和其他人可以再次使用它。你可以通过以下命令来实现：
- en: '[PRE15]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now you have a custom Buildroot configuration for the Nova board. You can retrieve
    this configuration by typing the following command:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了一个针对Nova板的自定义Buildroot配置。你可以通过输入以下命令来获取这个配置：
- en: '[PRE16]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With that, we have successfully configured Buildroot. In the next section, we
    will learn how to add our own code to a Buildroot image.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，我们已成功配置了Buildroot。在接下来的部分，我们将学习如何将自己的代码添加到Buildroot映像中。
- en: Adding your own code
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加你自己的代码
- en: Suppose you develop a program and you want to include it in the build. You have
    two options. Firstly, build it separately using its own build system and then
    roll the binary into the final build as an overlay. Secondly, create a Buildroot
    package that can be selected from the menu and build it like any other.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你开发了一个程序，并且想将它包含在构建中。你有两种选择。首先，可以单独构建它，使用它自己的构建系统，然后将二进制文件作为覆盖层放入最终构建中。其次，创建一个Buildroot包，可以从菜单中选择并像其他任何包一样构建它。
- en: Overlays
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 覆盖
- en: 'An overlay is simply a directory structure that is copied over the top of the
    Buildroot root filesystem at a later stage in the build process. It can contain
    executables, libraries, and anything else you may want to include. Note that any
    compiled code must be compatible with the libraries deployed at runtime, which
    means that it must be compiled with the same toolchain that Buildroot uses. Using
    the Buildroot toolchain is quite easy; just add it to `PATH`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖层（overlay）只是一个目录结构，它会在构建过程中稍后的阶段覆盖到Buildroot根文件系统上。它可以包含可执行文件、库文件和你可能想要包含的任何其他内容。请注意，任何编译过的代码必须与运行时部署的库兼容，这意味着它必须使用与Buildroot相同的工具链进行编译。使用Buildroot工具链非常简单，只需将其添加到`PATH`中：
- en: '[PRE17]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The prefix for the toolchain is `<ARCH>-linux-`. So, to compile a simple program,
    you would do something like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 工具链的前缀是`<ARCH>-linux-`。因此，要编译一个简单的程序，你可以做类似下面的操作：
- en: '[PRE18]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Once you have compiled your program with the correct toolchain, install the
    executables and other supporting files into a staging area and mark it as an overlay
    for Buildroot. For the `helloworld` example, you can put it in the `board/meld/nova`
    directory:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你用正确的工具链编译了你的程序，将可执行文件和其他支持文件安装到临时区，并将其标记为Buildroot的覆盖层。对于`helloworld`示例，你可以将其放在`board/meld/nova`目录下：
- en: '[PRE19]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Finally, set `BR2_ROOTFS_OVERLAY` to the path pointing at the overlay. It can
    be configured in `menuconfig` with the **System configuration | Root filesystem
    overlay directories** option.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将`BR2_ROOTFS_OVERLAY`设置为指向覆盖层的路径。可以在`menuconfig`中通过**系统配置 | 根文件系统覆盖目录**选项进行配置。
- en: Adding a package
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加一个包
- en: '[PRE20]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**IMPORTANT NOTE**'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提醒**'
- en: Note that a Buildroot package does not contain the code, just the instructions
    to get the code by downloading a tarball, doing `git clone`, or whatever is necessary
    to obtain the upstream source.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Buildroot包不包含代码，只是包含获取代码的指令，可能是下载一个tar包，执行`git clone`，或任何获取上游源代码所需的操作。
- en: The makefile is written in a format expected by Buildroot and contains directives
    that allow Buildroot to download, configure, compile, and install the program.
    Writing a new package makefile is a complex operation which is covered in detail
    in *The Buildroot user manual*.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Makefile是按照Buildroot预期的格式编写的，包含指令，允许Buildroot下载、配置、编译并安装程序。编写一个新的包的Makefile是一个复杂的操作，详细内容可以参考*Buildroot用户手册*。
- en: 'Here is an example that shows you how to create a package for a simple program
    such as our `helloworld` program. Begin by creating a `package/helloworld` subdirectory
    with a `Config.in` file that looks like this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例，展示如何为像`helloworld`这样的简单程序创建一个包。首先，创建一个`package/helloworld`子目录，并在其中创建一个类似如下的`Config.in`文件：
- en: '[PRE21]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The first line must be of the format `BR2_PACKAGE_<uppercase package name>`.
    This is followed by `bool` and the package name as it will appear in the configuration
    menu. The second line is what enables a user to select this package. The `help`
    section is optional but usually a good idea because it acts as self-documentation.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行必须是`BR2_PACKAGE_<大写包名>`的格式。接下来是`bool`和包名，这将在配置菜单中显示。第二行是启用用户选择此包的部分。`help`部分是可选的，但通常是一个好主意，因为它起到了自我文档的作用。
- en: 'Link the new package into the **Target Packages** menu by editing `package/Config.in`
    and sourcing the configuration file as shown below:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编辑`package/Config.in`并引用配置文件，如下所示，将新包链接到**目标包**菜单中：
- en: '[PRE22]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You could append this new `helloworld` package to an existing submenu, but it’s
    cleaner to create a new submenu with only our package and insert it before the
    **Audio and video applications** menu.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这个新的`helloworld`包附加到现有的子菜单中，但创建一个只包含我们包的新子菜单，并将其插入到**音频和视频应用**菜单之前会更加简洁。
- en: 'After inserting the **My programs** menu into `package/Config.in`, create a
    `package/helloworld/helloworld.mk` file to supply the data needed by Buildroot:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在将**我的程序**菜单插入到`package/Config.in`后，创建一个`package/helloworld/helloworld.mk`文件，以提供Buildroot所需的数据：
- en: '[PRE23]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You can find my `helloworld` package in the book’s code archive at `MELD/Chapter06/buildroot/package/helloworld`
    and the source code for the program in `MELD/Chapter06/helloworld`. The location
    of the code is hardcoded to a local path name.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在书籍的代码档案中找到我的`helloworld`包，路径是`MELD/Chapter06/buildroot/package/helloworld`，程序的源代码位于`MELD/Chapter06/helloworld`。代码的位置是硬编码的本地路径名称。
- en: In a more realistic case, you would get the code from a source code system or
    from a central server of some kind. There are details on how to do this in *The
    Buildroot user manual* and plenty of examples in other packages.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在更现实的情况下，你会从源代码系统或某种中央服务器获取代码。有关如何操作的详细信息可以在*Buildroot用户手册*中找到，其他包中也有大量示例。
- en: License compliance
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 许可证合规性
- en: 'Buildroot is based on open source software. So are the packages it compiles.
    At some point during the project, you should check the licenses by running:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Buildroot基于开源软件，所编译的包也是如此。在项目的某个阶段，你应该通过运行以下命令检查许可证：
- en: '[PRE24]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The license information is gathered in the `output/legal-info` directory. There
    are summaries of the licenses used to compile the host tools in `host-manifest.csv`
    and on the target in `manifest.csv`. There is more information in the `README`
    file and in *The Buildroot user manual*.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 许可信息会被收集到`output/legal-info`目录中。用于编译主机工具的许可证摘要保存在`host-manifest.csv`中，目标系统上的摘要保存在`manifest.csv`中。更多信息请参考`README`文件和*Buildroot用户手册*。
- en: Now let’s switch build systems and start learning about The Yocto Project.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们切换构建系统，开始学习Yocto项目。
- en: Introducing The Yocto Project
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Yocto项目
- en: The Yocto Project is a more complex beast than Buildroot. Not only can it build
    toolchains, bootloaders, kernels, and root filesystems, but it can generate an
    entire Linux distribution for you with binary packages that can be installed at
    runtime. The build process is structured around groups of recipes written using
    a combination of Python and shell script. The Yocto Project includes a task scheduler
    called **BitBake** that produces whatever you have configured from the recipes.
    There is plenty of online documentation at [https://www.yoctoproject.org/](https://www.yoctoproject.org/).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Yocto项目比Buildroot更加复杂。它不仅可以构建工具链、引导加载程序、内核和根文件系统，还能为你生成一个完整的Linux发行版，其中的二进制包可以在运行时安装。构建过程围绕着一组使用Python和Shell脚本编写的配方进行。Yocto项目包括一个名为**BitBake**的任务调度器，它根据配方生成你所配置的内容。有关更多在线文档，请访问[https://www.yoctoproject.org/](https://www.yoctoproject.org/)。
- en: Background
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 背景
- en: The structure of The Yocto Project makes more sense if you look at the background
    first. Its roots are in **OpenEmbedded** ([https://openembedded.org](https://openembedded.org)),
    which grew out of a number of projects to port Linux to various hand-held computers,
    including the Sharp Zaurus and the Compaq iPAQ. OpenEmbedded came to life in 2003
    as the build system for those hand-held computers. Soon after, other developers
    began to use it as a general build system for devices running embedded Linux.
    It was developed and continues to be developed by an enthusiastic community of
    programmers.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果先了解背景，Yocto项目的结构就更加清晰。它的根源在于**OpenEmbedded**（[https://openembedded.org](https://openembedded.org)），OpenEmbedded源自多个项目，旨在将Linux移植到各种手持计算机上，包括Sharp
    Zaurus和Compaq iPAQ。OpenEmbedded于2003年诞生，作为这些手持计算机的构建系统。此后，其他开发者开始将它作为运行嵌入式Linux设备的通用构建系统。OpenEmbedded由一个充满热情的程序员社区开发并持续发展。
- en: The OpenEmbedded project set out to create a set of binary packages using the
    compact IPK format. These packages could then be installed on the target at runtime
    to create a variety of systems. It did this by creating recipes for each package
    and using BitBake as the task scheduler. OpenEmbedded is very flexible. By supplying
    the right metadata, you can create an entire Linux distribution according to your
    specifications.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: OpenEmbedded项目的目标是使用紧凑的IPK格式创建一组二进制包。这些包可以在运行时安装到目标系统上，以创建各种系统。它通过为每个包创建配方，并使用BitBake作为任务调度器来实现这一点。OpenEmbedded非常灵活。通过提供正确的元数据，你可以根据自己的需求创建一个完整的Linux发行版。
- en: Back in 2005, Richard Purdie, then a developer at OpenedHand, created a fork
    of OpenEmbedded that had a more conservative choice of packages and created releases
    that were stable over a period of time. He named it **Poky** (rhymes with hockey)
    after the Japanese snack. Although Poky was a fork, OpenEmbedded and Poky continued
    to track each other, sharing updates and keeping architectures in step. Intel
    bought OpenedHand in 2008 and transferred Poky to the Linux Foundation in 2010
    when they formed The Yocto Project.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 2005年，时任OpenedHand开发者的Richard Purdie创建了一个OpenEmbedded的分支，选择了更加保守的包，并创建了在一段时间内稳定的版本。他将其命名为**Poky**（发音类似hockey），以一种日本小吃命名。虽然Poky是一个分支，但OpenEmbedded和Poky依然保持同步，分享更新并保持架构一致。英特尔在2008年收购了OpenedHand，并于2010年将Poky移交给Linux基金会，成立了Yocto项目。
- en: Since 2010, the common components of OpenEmbedded and Poky have been combined
    into a separate project known as **OpenEmbedded Core**, or just **OE-Core**.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 自 2010 年以来，OpenEmbedded 和 Poky 的通用组件已合并为一个名为 **OpenEmbedded Core** 或简称 **OE-Core**
    的独立项目。
- en: 'The Yocto Project collects together several components, the most important
    of which are:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Yocto 项目汇集了多个组件，其中最重要的包括：
- en: '**OE-Core**: Is the core metadata that is shared with OpenEmbedded.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OE-Core**：是与 OpenEmbedded 共享的核心元数据。'
- en: '**BitBake**: Is the task scheduler that is shared with OpenEmbedded and other
    projects.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BitBake**：是与 OpenEmbedded 和其他项目共享的任务调度器。'
- en: '**Poky**: Is the reference distribution. The Git repo for Poky also includes
    a `meta-yocto-bsp` layer with reference hardware machines.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Poky**：是参考发行版。Poky 的 Git 仓库还包括一个带有参考硬件机器的 `meta-yocto-bsp` 层。'
- en: '**Documentation**: Is the user manuals and developer guides for each component.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档**：每个组件的用户手册和开发者指南。'
- en: '**Toaster**: is a web-based interface to BitBake and its metadata.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Toaster**：是一个基于 Web 的 BitBake 和其元数据的接口。'
- en: Yocto provides a stable base that can be used as-is or extended using **meta
    layers** which I will discuss later in this chapter. Many SoC vendors provide
    BSPs for their devices in this way. Meta layers can also be used to create extended
    or different build systems. Some are open source like Poky and others are commercial
    like Wind River Linux. Yocto has a branding and compatibility testing scheme to
    ensure that there is interoperability between components. You will see statements
    like “Yocto Project compatible” on various web pages.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Yocto 提供了一个稳定的基础，可以按原样使用，也可以使用 **meta 层** 扩展，我将在本章稍后讨论。许多 SoC 厂商通过这种方式为其设备提供
    BSP。Meta 层还可以用来创建扩展的或不同的构建系统。有些是开源的，比如 Poky，其他的是商业的，比如 Wind River Linux。Yocto
    有一个品牌和兼容性测试方案，确保组件之间的互操作性。你会在各种网页上看到像“Yocto Project compatible”这样的声明。
- en: Consequently, you should think of Yocto as the foundation for a whole sector
    of embedded Linux in addition to being a complete build system in its own right.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你应该将 Yocto 视为嵌入式 Linux 领域的基础，除了它本身作为一个完整的构建系统。
- en: '**IMPORTANT NOTE**'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要说明**'
- en: You may be wondering about the name. It turns out *yocto* is the SI prefix for
    10^(-24) in the same way that *micro* is 10^(-6). Why name the project Yocto?
    The name was chosen partly to indicate that it could build very small Linux systems
    (although to be fair so can other build systems). It is also a dig at the now
    defunct Ångström Distribution, which was based on OpenEmbedded. An Ångström is
    10^(10). That’s huge compared to a *yocto*!
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会好奇这个名字的由来。事实上，*yocto* 是 SI 前缀，表示 10^(-24)，就像 *micro* 表示 10^(-6) 一样。为什么选择
    Yocto 这个名字？这个名字部分是为了表示它能够构建非常小的 Linux 系统（尽管公平地说，其他构建系统也可以做到）。它也是对已经停用的 Ångström
    分发版的一个讽刺，该分发版基于 OpenEmbedded。一个 Ångström 是 10^(10)，与 *yocto* 相比，差距巨大！
- en: Stable releases and supports
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 稳定发布和支持
- en: 'Routinely, there is a release of Yocto every six months: in April and October.
    They are principally known by their code names, but it is also useful to know
    their Yocto and BitBake version numbers. Here is a table of the six most recent
    releases at the time of writing:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Yocto 每六个月发布一次：分别在四月和十月。它们通常以代号为人所知，但了解它们的 Yocto 和 BitBake 版本号也很有用。以下是本文撰写时六个最新版本的表格：
- en: '| **Code Name** | **Release Date** | **Yocto Version** | **BitBake Version**
    |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| **代号** | **发布日期** | **Yocto 版本** | **BitBake 版本** |'
- en: '| Scarthgap | April 2024 | 5.0 | 2.8 |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| Scarthgap | 2024年4月 | 5.0 | 2.8 |'
- en: '| Nanbield | November 2023 | 4.3 | 2.6 |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| Nanbield | 2023年11月 | 4.3 | 2.6 |'
- en: '| Mickledore | May 2023 | 4.2 | 2.4 |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| Mickledore | 2023年5月 | 4.2 | 2.4 |'
- en: '| Langdale | October 2022 | 4.1 | 2.2 |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| Langdale | 2022年10月 | 4.1 | 2.2 |'
- en: '| Kirkstone | May 2022 | 4.0 | 2.0 |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| Kirkstone | 2022年5月 | 4.0 | 2.0 |'
- en: '| Honister | October 2021 | 3.4 | 1.52 |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| Honister | 2021年10月 | 3.4 | 1.52 |'
- en: Table 6.1 – Six most recent releases of Yocto
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.1 – Yocto 的六个最新版本
- en: The stable releases are supported with security and critical bug fixes for the
    current release cycle and the next cycle. In other words, each stable version
    is supported for approximately 12 months after release. In addition to stable
    releases, Yocto also provides LTS releases. The 3.1 (dunfell) release of Yocto
    back in April 2020 was the first LTS release. The LTS designation means that the
    version of Yocto will receive defect fixes and updates for an extended period
    of two years. Consequently, the plan going forward is to choose an LTS release
    of Yocto every two years.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 稳定版本会在当前发布周期及下一个周期内提供安全性和关键性漏洞修复。换句话说，每个稳定版本会在发布后大约12个月内获得支持。除了稳定版本，Yocto还提供LTS（长期支持）版本。2020年4月发布的Yocto
    3.1（dunfell）是第一个LTS版本。LTS标识意味着该版本会获得缺陷修复和更新，支持周期为两年。因此，未来的计划是每两年选择一个Yocto的LTS版本。
- en: As with Buildroot, if you want continued support, you can update to the next
    stable release or you can backport changes to your version. With Yocto, you also
    have the option of commercial support for several years from operating system
    vendors such as Siemens and Wind River.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 与Buildroot类似，如果你希望继续获得支持，可以更新到下一个稳定版本，或者将更改回移植到当前版本。对于Yocto，你还可以选择来自操作系统供应商（如西门子和Wind
    River）的商业支持，通常支持几年。
- en: Installing The Yocto Project
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Yocto项目
- en: 'To get a copy of The Yocto Project, clone the repo choosing the code name (`scarthgap`
    in this case) as the branch:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取Yocto项目的副本，克隆仓库时选择代号（此处为`scarthgap`）作为分支：
- en: '[PRE25]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Since we are building images for BeaglePlay, we also need to clone the `meta-ti`
    repo:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们要为BeaglePlay构建镜像，我们还需要克隆`meta-ti`仓库：
- en: '[PRE26]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'And since the `meta-ti-bsp` layer depends on the `meta-arm` layer, we must
    clone that repo well:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`meta-ti-bsp`层依赖于`meta-arm`层，因此我们必须正确克隆该仓库：
- en: '[PRE27]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that both the `meta-ti` and `meta-arm` branch names must match the Yocto
    code name to ensure these additional layers are compatible with the scarthgap
    version of Yocto. It is also good practice to run `git pull` periodically to grab
    the latest bug fixes and security patches from all the remote branches.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`meta-ti`和`meta-arm`分支名称必须与Yocto的代号匹配，以确保这些附加层与scarthgap版本的Yocto兼容。定期运行`git
    pull`来获取所有远程分支的最新漏洞修复和安全补丁也是一个好习惯。
- en: Read the *Compatible Linux Distribution* and *Build Host Packages* sections
    in the *Yocto Project Quick Build* guide ([https://docs.yoctoproject.org/brief-yoctoprojectqs/](https://docs.yoctoproject.org/brief-yoctoprojectqs/)).
    Make sure that the essential packages for your Ubuntu host distribution are installed
    on your host computer. The next step is configuring.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读*兼容的Linux发行版*和*构建主机包*部分，详见*Yocto项目快速构建*指南（[https://docs.yoctoproject.org/brief-yoctoprojectqs/](https://docs.yoctoproject.org/brief-yoctoprojectqs/)）。确保在主机计算机上安装了你的Ubuntu主机发行版所需的基本包。下一步是进行配置。
- en: '**IMPORTANT NOTE**'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: 'Ubuntu 24.04 LTS (Noble Numbat) was not officially supported by The Yocto Project
    at the time of writing. Upon Noble Numbat’s release, users experienced numerous
    BitBake errors related to permissions. These errors were a result of increased
    security restrictions placed on the operating system by AppArmor. To temporarily
    disable these AppArmor protections:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Ubuntu 24.04 LTS（Noble Numbat）尚未得到Yocto项目的官方支持。在Noble Numbat发布后，用户遇到了与权限相关的许多BitBake错误。这些错误是由于AppArmor对操作系统施加了更严格的安全限制所致。要暂时禁用这些AppArmor保护：
- en: '`$ echo 0 | sudo tee /proc/sys/kernel/apparmor_restrict_unprivileged_userns`'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ echo 0 | sudo tee /proc/sys/kernel/apparmor_restrict_unprivileged_userns`'
- en: Remember to rerun this command every time you reboot your Ubuntu host before
    using Yocto.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，每次重启Ubuntu主机后，在使用Yocto之前都需要重新运行此命令。
- en: Configuring
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置
- en: 'Let’s begin by building the 64-bit Arm QEMU emulator. Start by sourcing a script
    to set up the environment:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从构建64位Arm QEMU模拟器开始。首先通过运行脚本来设置环境：
- en: '[PRE28]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This creates a working directory for you named `build` and makes it the current
    directory. All the configuration, intermediate, and target image files will be
    put in this directory. You must source this script each time you want to work
    on this project.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为你创建一个名为`build`的工作目录，并将其设为当前目录。所有的配置文件、中间文件和目标镜像文件都将存放在此目录中。每次想要继续该项目时，必须重新运行该脚本。
- en: 'To choose a different working directory, add it as a parameter to `oe-init-build-env`
    like so:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 要选择不同的工作目录，可以将其作为参数添加到`oe-init-build-env`，如下所示：
- en: '[PRE29]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This will put you into the `build-qemu-arm64` directory. This way, you can have
    several build directories, each for a different project. You choose which one
    you want to work with through the parameter passed to `oe-init-build-env`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把您带到 `build-qemu-arm64` 目录。通过这种方式，您可以拥有多个构建目录，每个目录用于不同的项目。您可以通过传递给 `oe-init-build-env`
    的参数选择要使用的目录。
- en: 'Initially, the `build` directory contains only one subdirectory named `conf`
    with the configuration files for this project:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，`build` 目录只包含一个名为 `conf` 的子目录，其中包含此项目的配置文件：
- en: '`local.conf`: Contains a specification of the device you are going to build
    and the build environment.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`local.conf`：包含您将要构建的设备的规格和构建环境。'
- en: '`bblayers.conf`: Contains paths of the meta layers you are going to use. I
    will describe layers later.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bblayers.conf`：包含您将要使用的元层的路径。我稍后会描述这些层。'
- en: 'For now, we just need to set the `MACHINE` variable in `conf/local.conf` to
    `qemuarm64` by removing the comment character (*#*) at the start of this line:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只需要通过去掉这一行开头的注释字符 (*#*)，在 `conf/local.conf` 中设置 `MACHINE` 变量为 `qemuarm64`：
- en: '[PRE30]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now we are ready to build our first image with Yocto.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好使用 Yocto 构建我们的第一个镜像。
- en: Building
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建中
- en: 'To perform the build, you need to run BitBake and tell it which root filesystem
    image you want to create. Some common images are:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行构建，您需要运行 BitBake 并告诉它您想要创建的根文件系统镜像。一些常见的镜像包括：
- en: '`core-image-minimal`: Is a small console-based system that is useful for tests
    and as the basis for custom images.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`core-image-minimal`：是一个小型的基于控制台的系统，适用于测试以及作为自定义镜像的基础。'
- en: '`core-image-minimal-initramfs`: Is similar to `core-image-minimal` but built
    as a RAM disk.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`core-image-minimal-initramfs`：类似于 `core-image-minimal`，但构建为 RAM 磁盘。'
- en: '`core-image-x11`: Is a basic image with support for graphics through an X11
    server and the XTerminal terminal app.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`core-image-x11`：是一个基本镜像，通过 X11 服务器和 XTerminal 终端应用提供图形支持。'
- en: '`core-image-full-cmdline`: Is a console-based system that offers a standard
    CLI experience and full support for the target hardware.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`core-image-full-cmdline`：是一个基于控制台的系统，提供标准的 CLI 体验，并完全支持目标硬件。'
- en: 'By giving BitBake the final target, it will work backward and build all the
    dependencies starting with the toolchain. For now, we just want to create a minimal
    image to see how it works:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 通过给 BitBake 最终目标，它将从后向前工作，并构建所有依赖项，从工具链开始。目前，我们只想创建一个最小的镜像，以查看它是如何工作的：
- en: '[PRE31]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The first build will take some time (likely more than an hour) even with several
    CPU cores and lots of RAM. It will download about 4.9 GB of source code and consume
    about 49 GB of disk space. When the build completes, you will find several new
    directories in the `build` directory.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次构建可能需要一些时间（即使有多个 CPU 核心和大量内存，可能也超过一个小时）。它将下载大约 4.9 GB 的源代码，并消耗大约 49 GB 的磁盘空间。当构建完成时，您将在
    `build` 目录下找到几个新目录。
- en: 'These include `downloads`, which contains all the source downloaded for the
    build, and `tmp`, which contains most of the build artifacts. Inside `tmp` you
    will find the following:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这些包括 `downloads`，它包含构建所需的所有源文件，以及 `tmp`，它包含大部分构建产物。在 `tmp` 目录下，您会找到以下内容：
- en: '`work`: Contains the build directory and the staging area for the root filesystem.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`work`：包含构建目录和根文件系统的暂存区域。'
- en: '`deploy`: Contains the final binaries to be deployed on the target:'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deploy`：包含要部署到目标的最终二进制文件：'
- en: '`deploy/images/<machine name>`: Contains the bootloader, kernel, and root filesystem
    images for the target.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deploy/images/<machine name>`：包含目标的引导加载程序、内核和根文件系统镜像。'
- en: '`deploy/rpm`: Contains the RPM packages that make up the images.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deploy/rpm`：包含构成镜像的 RPM 软件包。'
- en: '`deploy/licenses`: Contains the license files extracted from each package.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deploy/licenses`：包含从每个软件包中提取的许可证文件。'
- en: When the build is done, we can boot the finished image on QEMU.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建完成后，我们可以在 QEMU 上启动完成的镜像。
- en: Running the QEMU target
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行 QEMU 目标
- en: When you build a QEMU target, an internal version of QEMU is generated. This
    eliminates the need to install the QEMU package for your distribution. There is
    a wrapper script named `runqemu` to run this internal version of QEMU.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 当您构建 QEMU 目标时，会生成一个 QEMU 的内部版本。这免去了您为您的发行版安装 QEMU 包的需求。还有一个名为 `runqemu` 的包装脚本，用来运行这个内部版本的
    QEMU。
- en: 'To run the QEMU emulation, make sure to first run `source oe-init-build-env
    build-qemu-arm64` and then type:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行 QEMU 仿真，确保首先运行 `source oe-init-build-env build-qemu-arm64`，然后输入：
- en: '[PRE32]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this case, QEMU has been configured with a graphic console so that the login
    prompt appears in a black framebuffer. Log in as root without a password. Close
    the framebuffer window to exit QEMU.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，QEMU已配置为使用图形控制台，因此登录提示将出现在黑色帧缓冲区中。以root身份登录，无需密码。关闭帧缓冲窗口以退出QEMU。
- en: 'To launch QEMU without the graphic window, add `nographic` to the command line:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 要在没有图形窗口的情况下启动QEMU，请在命令行中添加`nographic`：
- en: '[PRE33]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the `nographic` case, close QEMU using the key sequence *Ctrl + A* and then
    *x*.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在`nographic`模式下，使用键序列*Ctrl + A*然后按*x*来关闭QEMU。
- en: The `runqemu` script has many other options. Type `runqemu help` for more information.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`runqemu`脚本有许多其他选项。键入`runqemu help`以获取更多信息。'
- en: Layers
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 层
- en: 'Yocto metadata is structured as layers. A layer is a directory containing a
    collection of BitBake metadata in the form of recipe files. Each recipe file is
    used to build an individual software package. The layers are stacked on top of
    each other to build or “bake” all the software recipes into a finished Linux image
    much like baking a cake. By convention, each layer has a name beginning with `meta`.
    The core layers are:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: Yocto元数据是按层结构组织的。每个层都是一个包含BitBake元数据的目录，元数据以食谱文件的形式存在。每个食谱文件用于构建一个单独的软件包。这些层叠加在一起，构建或“烘焙”所有软件食谱，最终生成一个完整的Linux镜像，就像烘焙一个蛋糕一样。根据约定，每个层的名称都以`meta`开头。核心层包括：
- en: '`meta`: Is the equivalent of an unmodified OpenEmbedded core.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`meta`: 相当于一个未修改的OpenEmbedded核心。'
- en: '`meta-poky`: Is the metadata specific to the Poky distribution.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`meta-poky`: 是特定于Poky发行版的元数据。'
- en: '`meta-yocto-bsp`: Contains the BSPs for the reference machines that Yocto regularly
    tests.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`meta-yocto-bsp`: 包含Yocto定期测试的参考机器的BSP。'
- en: The list of layers in which BitBake searches for recipes is stored in `<your
    build directory>/conf/bblayers.conf` and by default includes all three layers
    from the preceding list.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: BitBake搜索食谱的层列表存储在`<your build directory>/conf/bblayers.conf`中，默认情况下包括前面列出的所有三个层。
- en: 'Structuring the recipes and other configuration data in this way makes it very
    easy to extend Yocto by adding new layers. Additional layers are available from
    SoC manufacturers, The Yocto Project itself, and a wide range of people wishing
    to add value to Yocto and OpenEmbedded. There is a useful list of layers at [https://layers.openembedded.org/layerindex/](https://layers.openembedded.org/layerindex/).
    Here are some examples:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式构建食谱和其他配置数据使得通过添加新层来扩展Yocto变得非常容易。额外的层可以从SoC制造商、Yocto项目本身以及一大批希望为Yocto和OpenEmbedded增值的人们那里获得。这里有一个有用的层列表：[https://layers.openembedded.org/layerindex/](https://layers.openembedded.org/layerindex/)。以下是一些示例：
- en: '`meta-qt5`: Qt 5 libraries and utilities'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`meta-qt5`: Qt 5库和工具。'
- en: '`meta-intel`: BSPs for Intel CPUs and SoCs'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`meta-intel`: 为Intel CPU和SoC提供的BSP。'
- en: '`meta-raspberrypi`: BSPs for the Raspberry Pi boards'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`meta-raspberrypi`: 为Raspberry Pi开发板提供的BSP。'
- en: '`meta-ti`: BSPs for TI Arm-based SoCs'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`meta-ti`: 为TI基于Arm的SoC提供的BSP。'
- en: Adding a layer is as simple as copying the meta directory to a suitable location
    and adding it to `bblayers.conf`. Make sure that you read the `REAMDE` file that
    should accompany each layer to see what dependencies it has on other layers and
    which versions of Yocto it is compatible with.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个层就像是将meta目录复制到合适的位置，并将其添加到`bblayers.conf`中一样简单。确保阅读每个层应附带的`README`文件，以了解该层对其他层的依赖关系以及与哪个版本的Yocto兼容。
- en: To illustrate how layers work, let’s create a layer for our Nova board that
    we can use for the remainder of the chapter as we add features. You can see the
    complete implementation of the layer under `MELD/Chapter06/meta-nova` in the code
    archive.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明层是如何工作的，假设我们为Nova开发板创建一个层，在本章后续部分中，我们将使用这个层来添加新特性。你可以在代码档案中的`MELD/Chapter06/meta-nova`下看到该层的完整实现。
- en: Each meta layer must have at least one configuration file named `conf/layer.conf`
    and should also have a `README` file and a license.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 每个meta层必须至少有一个名为`conf/layer.conf`的配置文件，并且还应该有一个`README`文件和一个许可证。
- en: 'To create our `meta-nova` layer, perform the following steps:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建我们的`meta-nova`层，请执行以下步骤：
- en: '[PRE34]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This will put you in a working directory named `build-nova` and create a layer
    named `meta-nova` with a `conf/layer.conf`, an outline `README`, and a `COPYING.MIT`
    license under `../meta-nova`. The `layer.conf` file looks like this:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把你放入一个名为`build-nova`的工作目录，并在`../meta-nova`下创建一个名为`meta-nova`的层，其中包含一个`conf/layer.conf`文件、一个大致的`README`文件和一个`COPYING.MIT`许可证。`layer.conf`文件如下所示：
- en: '[PRE35]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The layer adds itself to `BBPATH` and the recipes it contains to `BBFILES`.
    From looking at the code, you can see that the recipes are found in the directories
    with names beginning with `recipes-` and have filenames ending in `.bb` (for normal
    BitBake recipes) or `.bbappend` (for recipes that extend existing recipes by overriding
    or adding to the instructions). This layer has the name `nova` and is added to
    the list of layers in `BBFILE_COLLECTIONS` with a priority of `6`. The layer priority
    is used if the same recipe appears in several layers. The one in the layer with
    the highest priority wins.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 层将自身添加到 `BBPATH` 中，并将其中包含的配方添加到 `BBFILES` 中。从代码中可以看到，配方位于以 `recipes-` 开头、文件名以
    `.bb`（普通 BitBake 配方）或 `.bbappend`（扩展现有配方，通过覆盖或添加指令的配方）结尾的目录中。这个层的名称是 `nova`，并以优先级
    `6` 被添加到 `BBFILE_COLLECTIONS` 的层列表中。层的优先级用于当同一配方出现在多个层时，优先级最高的层中的配方会生效。
- en: 'Before adding the Nova layer, we must first add the `meta-arm-toolchain`, `meta-arm`,
    and `meta-ti-bsp` layers in that precise order:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加 Nova 层之前，我们必须先按照严格顺序添加 `meta-arm-toolchain`、`meta-arm` 和 `meta-ti-bsp` 层：
- en: '[PRE36]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now add the Nova layer to your build configuration:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将 Nova 层添加到你的构建配置中：
- en: '[PRE37]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Make sure to run all these `bitbake-layers add-layer` commands from your `build-nova`
    working directory after sourcing that environment.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在从环境中加载后，确保从你的 `build-nova` 工作目录运行所有这些 `bitbake-layers add-layer` 命令。
- en: 'Confirm that your layer structure is set up correctly like this:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 确认你的层结构已正确设置，如下所示：
- en: '[PRE38]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: There you can see the new layer. Because it has a priority of `6`, it can override
    recipes in the other layers that all have a lower priority.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到新添加的层。由于它的优先级是 `6`，它可以覆盖所有优先级较低的其他层中的配方。
- en: Run a build using this empty layer. The final target will be the Nova board,
    but for now, build for the BeaglePlay by adding `MACHINE ?= "beagleplay-ti"` to
    `conf/local.conf`. Then build a small image using `bitbake core-image-minimal`
    like before.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个空层进行构建。最终目标将是 Nova 板，但现在先通过在 `conf/local.conf` 中添加 `MACHINE ?= "beagleplay-ti"`
    来为 BeaglePlay 构建。然后像之前一样使用 `bitbake core-image-minimal` 构建一个小镜像。
- en: In addition to recipes, layers may contain BitBake classes, configuration files,
    distributions, and more. I will look at recipes next and show you how to create
    a customized image and a package.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 除了配方，层还可以包含 BitBake 类、配置文件、发行版等内容。接下来我将讲解配方，并展示如何创建自定义镜像和包。
- en: BitBake and recipes
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: BitBake 和配方
- en: 'BitBake processes metadata of several different types:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: BitBake 处理几种不同类型的元数据：
- en: '**recipes** (files ending in `.bb`): Contain information about building a unit
    of software, including how to get a copy of the source code, the dependencies
    on other components, and how to build and install it.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配方**（以 `.bb` 结尾的文件）：包含有关构建软件单元的信息，包括如何获取源代码副本、对其他组件的依赖关系以及如何构建和安装它。'
- en: '**append** (files ending in `.bbappend`): Override or extend some details of
    a recipe. A `.bbappend` file appends its instructions to the end of a recipe (`.bb`)
    file with the same root name.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**附加**（以 `.bbappend` 结尾的文件）：覆盖或扩展配方的某些细节。`.bbappend` 文件将其指令附加到与之具有相同根名称的配方（`.bb`）文件的末尾。'
- en: '**include** (files ending in `.inc`): Contain information that is common to
    several recipes allowing information to be shared among them. The files may be
    included using the **include** or **require** keyword. The difference is that
    `require` produces an error if the file does not exist whereas `include` does
    not.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包含**（以 `.inc` 结尾的文件）：包含多个配方共享的信息，使它们能够共享信息。可以使用 **include** 或 **require**
    关键字包含这些文件。区别在于，如果文件不存在，`require` 会产生错误，而 `include` 不会。'
- en: '**classes** (files ending in `.bbclass`): Contain common build information
    like how to build a kernel or how to build an Autotools project. Classes are inherited
    by recipes and by other classes using the `inherit` keyword. The class `classes/base.bbclass`
    is implicitly inherited by every recipe.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类**（以 `.bbclass` 结尾的文件）：包含一些常见的构建信息，例如如何构建内核或如何构建 Autotools 项目。类通过 `inherit`
    关键字被配方和其他类继承。类 `classes/base.bbclass` 会被每个配方隐式继承。'
- en: '**configuration** (files ending in `.conf`): Define various configuration variables
    that govern a project’s build process.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置**（以 `.conf` 结尾的文件）：定义控制项目构建过程的各种配置变量。'
- en: 'A **recipe** is a collection of tasks written in a combination of Python and
    shell script. The tasks have names such as `do_fetch`, `do_unpack`, `do_patch`,
    `do_configure`, `do_compile`, and `do_install`. You use BitBake to execute these
    tasks. The default task is `do_build`, which performs all the subtasks required
    to build the recipe. You can list the tasks available in a recipe using `bitbake
    -c listtasks <recipe>`. For example, to list the tasks in `core-image-minimal`:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '**配方**是一个任务集合，任务内容使用Python和Shell脚本的组合编写。这些任务有诸如`do_fetch`、`do_unpack`、`do_patch`、`do_configure`、`do_compile`和`do_install`等名称。你使用BitBake来执行这些任务。默认任务是`do_build`，它执行构建配方所需的所有子任务。你可以使用`bitbake
    -c listtasks <recipe>`列出配方中可用的任务。例如，要列出`core-image-minimal`中的任务：'
- en: '[PRE39]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '**IMPORTANT NOTE**'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: The `-c` option tells BitBake to run a specific task from a recipe without having
    to include the `do_` part at the beginning of the task name.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`-c`选项告诉BitBake运行配方中的特定任务，而无需在任务名称的开头包含`do_`部分。'
- en: '`do_listtasks` is a special task that lists all the tasks defined within a
    recipe. Here is the `fetch` task, which downloads the source code for a recipe:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`do_listtasks`是一个特殊的任务，用于列出配方中定义的所有任务。这里是`fetch`任务，它用于下载配方的源代码：'
- en: '[PRE40]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To get the code for a target and all its dependencies (which is useful when
    you want to make sure you have downloaded all the code for the image you are about
    to build), use the following:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取目标及其所有依赖项的代码（当你想确保已下载了即将构建的镜像的所有代码时，这很有用），请使用以下命令：
- en: '[PRE41]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The recipe files are usually named `<package-name>_<version>.bb`. They may have
    dependencies on other recipes, which would allow BitBake to work out all the subtasks
    that need to be executed to complete the top-level job.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 配方文件通常命名为`<package-name>_<version>.bb`。它们可能依赖于其他配方，这样BitBake可以计算出完成顶级任务所需执行的所有子任务。
- en: 'To create a recipe for our `helloworld` program in `meta-nova`, you would create
    a directory structure like this:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 要为我们在`meta-nova`中的`helloworld`程序创建一个配方，你需要创建如下的目录结构：
- en: '[PRE42]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The recipe is `helloworld_1.0.bb` and the source is kept local to the recipe
    in the `files` subdirectory. The recipe contains these instructions:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 配方是`helloworld_1.0.bb`，源代码保存在配方所在目录的`files`子目录中。该配方包含以下指令：
- en: '[PRE43]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The location of the source code is set by `SRC_URI`. In this case, the `file://`
    URI means that the code is local to the recipe directory. BitBake will search
    the `files`, `helloworld`, and `helloworld-1.0` directories relative to the directory
    that contains the recipe. The tasks that need to be defined are `do_compile` and
    `do_install`, which compile the source file and install it into the target root
    filesystem: `${D}` expands to the staging area of the recipe and `${bindir}` to
    the default `/usr/bin` binary directory.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码的位置由`SRC_URI`设置。在这种情况下，`file://` URI意味着代码是本地的，位于配方目录中。BitBake将相对于包含配方的目录搜索`files`、`helloworld`和`helloworld-1.0`目录。需要定义的任务是`do_compile`和`do_install`，它们分别将源文件编译并安装到目标根文件系统中：`${D}`表示配方的暂存区，而`${bindir}`表示默认的`/usr/bin`二进制目录。
- en: Every recipe has a license defined by `LICENSE`, which is set to `GPL-2.0-only`
    here. The file containing the text of the license and a checksum is defined by
    `LIC_FILES_CHKSUM`. BitBake will terminate the build if the checksum does not
    match, indicating that the license has changed in some way. Note that the MD5
    checksum value and `COMMON_LICENSE_DIR` are on the same line separated by a semicolon.
    The license file may be part of the package, or it may point to one of the standard
    license texts in `meta/files/common-licenses` as is the case here.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 每个配方都有一个由`LICENSE`定义的许可证，这里设置为`GPL-2.0-only`。包含许可证文本及其校验和的文件由`LIC_FILES_CHKSUM`定义。如果校验和不匹配，BitBake将终止构建，表示许可证已发生变化。请注意，MD5校验和值和`COMMON_LICENSE_DIR`在同一行，且由分号分隔。许可证文件可能是包的一部分，或者可能指向`meta/files/common-licenses`中的标准许可证文本，正如这里所示。
- en: 'Commercial licenses are disallowed by default, but it is easy to enable them.
    You need to specify the license in the recipe as shown here:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 商业许可证默认不允许，但可以很容易地启用它们。你需要在配方中指定许可证，如下所示：
- en: '[PRE44]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Then, in your `conf/local.conf`, explicitly allow this license like so:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在你的`conf/local.conf`中，明确允许此许可证，如下所示：
- en: '[PRE45]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To make sure that our `helloworld` recipe compiles correctly, ask BitBake to
    build it:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们的`helloworld`配方正确编译，可以让BitBake构建它：
- en: '[PRE46]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If all goes well, you should see that it has created a working directory for
    it in `tmp/work/aarch64-poky-linux/helloworld`. You should also see that there
    is an RPM package for it in `tmp/deploy/rpm/aarch64/helloworld-1.0-r0.aarch64.rpm`.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你应该会看到它在`tmp/work/aarch64-poky-linux/helloworld`目录下创建了一个工作目录。你还应该能看到在`tmp/deploy/rpm/aarch64/helloworld-1.0-r0.aarch64.rpm`中为它创建了一个RPM包。
- en: 'The package is not part of the target image yet. The list of packages to be
    installed is held in a variable named `IMAGE_INSTALL`. You can append to the end
    of that list by adding this line to `conf/local.conf`:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 包尚未成为目标镜像的一部分。待安装包的列表保存在一个名为`IMAGE_INSTALL`的变量中。你可以通过将以下行添加到`conf/local.conf`来将它追加到该列表的末尾：
- en: '[PRE47]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Note that there needs to be a space between the opening double quote and the
    first package name. Now the package will be added to any image that you `bitbake`:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，开头的双引号和第一个包名之间需要有一个空格。现在该包将被添加到你`bitbake`的任何镜像中：
- en: '[PRE48]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: If you look in `deploy-ti/images/beagleplay-ti/core-image-minimal-beagleplay-ti.rootfs.tar.xz`,
    you will see that `/usr/bin/helloworld` has indeed been installed.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看`deploy-ti/images/beagleplay-ti/core-image-minimal-beagleplay-ti.rootfs.tar.xz`，你会看到`/usr/bin/helloworld`确实已经被安装。
- en: Customizing images via local.conf
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过`local.conf`自定义镜像
- en: 'You often may want to add a package to an image during development or tweak
    it in other ways. As we’ve just seen, you can simply append to the list of packages
    to be installed by adding a statement like:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，你可能经常需要向镜像中添加包或以其他方式调整它。正如我们刚刚看到的，你可以通过添加类似以下的语句，将包简单地追加到安装包列表中：
- en: '[PRE49]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'You can make more sweeping changes via `EXTRA_IMAGE_FEATURES`. Here is a short
    list, which should give you an idea of the features you can enable:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过`EXTRA_IMAGE_FEATURES`做更多广泛的更改。以下是一个简短的列表，应该能给你提供启用功能的想法：
- en: '`dbg-pkgs`: Installs debug symbol packages for all the packages installed in
    the image.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dbg-pkgs`：为镜像中安装的所有包安装调试符号包。'
- en: '`debug-tweaks`: Allows `root` logins without passwords and other changes that
    make development easier. Never enable `debug-tweaks` in production images.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`debug-tweaks`：允许`root`用户无密码登录，并进行其他开发便利的更改。在生产镜像中绝对不要启用`debug-tweaks`。'
- en: '`package-management`: Installs package management tools and preserves the package
    manager database.'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package-management`：安装包管理工具并保留包管理器数据库。'
- en: '`read-only-rootfs`: Makes the root filesystem read-only. We will cover this
    in more detail in [*Chapter 9*](Chapter_09.xhtml#_idTextAnchor293).'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`read-only-rootfs`：使根文件系统为只读。我们将在[*第9章*](Chapter_09.xhtml#_idTextAnchor293)中详细讲解这一点。'
- en: '`x11`: Installs the X server.'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x11`：安装X服务器。'
- en: '`x11-base`: Installs the X server with a minimal environment.'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x11-base`：安装带有最小环境的X服务器。'
- en: There are many more features you can add in this way. I recommend you look at
    the *Image Features* section of the *Yocto Project Reference Manual* at [https://docs.yoctoproject.org/ref-manual/](https://docs.yoctoproject.org/ref-manual/)
    and read through the code in `meta/classes-recipe/core-image.bbclass`.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过这种方式添加更多功能。我建议你查看*Yocto项目参考手册*中的*镜像特性*部分：[https://docs.yoctoproject.org/ref-manual/](https://docs.yoctoproject.org/ref-manual/)，并阅读`meta/classes-recipe/core-image.bbclass`中的代码。
- en: Writing an image recipe
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写镜像配方
- en: The problem with making changes to `local.conf` is that they are, well, local.
    If you want to create an image that is to be shared with other developers or to
    be loaded onto a production system, then you should put the changes in an **image
    recipe**.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`local.conf`的问题在于它是局部的。如果你想创建一个可以与其他开发者共享或加载到生产系统上的镜像，那么你应该将更改放在**镜像配方**中。
- en: 'An image recipe contains instructions about how to create the image files for
    a target, including the bootloader, kernel, and root filesystem images. By convention,
    image recipes are put into a directory named `images`. You can get a list of all
    the images that are available by scanning the `poky` directory and any additional
    layers that you cloned:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 一个镜像配方包含了如何为目标创建镜像文件的指令，包括引导加载程序、内核和根文件系统镜像。按照约定，镜像配方通常放在名为`images`的目录中。你可以通过扫描`poky`目录和任何你克隆的附加层来获取所有可用镜像的列表：
- en: '[PRE50]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: You will find that the recipe for `core-image-minimal` is in `poky`/`meta/recipes-core/images/core-image-minimal.bb`.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现`core-image-minimal`的配方位于`poky`/`meta/recipes-core/images/core-image-minimal.bb`。
- en: A simple approach is to take an existing image recipe and modify it using statements
    like the ones you used in `local.conf`.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 一种简单的方法是采用现有的镜像配方，并使用像你在`local.conf`中使用的语句进行修改。
- en: 'Imagine that you want an image that is the same as `core-image-minimal` but
    includes your `helloworld` program and the `strace` utility. You can do that with
    a two-line recipe file that includes (using the `require` keyword) the base image
    and adds the packages you want. It is conventional to put the image in a directory
    named `images`, so add the recipe `nova-image.bb` with this content in `meta-nova/recipes-local/images`:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要一个与 `core-image-minimal` 相同的镜像，但包括你的 `helloworld` 程序和 `strace` 工具。你可以通过一个两行的配方文件来实现这一点，文件中包含（使用
    `require` 关键字）基本镜像并添加你需要的包。通常将镜像放在名为 `images` 的目录中，所以在 `meta-nova/recipes-local/images`
    中添加配方 `nova-image.bb`，内容如下：
- en: '[PRE51]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now remove the `IMAGE_INSTALL:append` line from your `local.conf` and build
    the image:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 现在从你的 `local.conf` 文件中移除 `IMAGE_INSTALL:append` 行，并构建镜像：
- en: '[PRE52]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This time, the build should proceed much quicker because BitBake reuses the
    intermediate build objects built during prior runs.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，构建应该会更快，因为 BitBake 重用了之前构建过程中生成的中间构建对象。
- en: Not only does BitBake build images for running on a target device, but it can
    also build an SDK for doing cross-development on a host machine.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: BitBake 不仅可以为目标设备构建镜像，还可以为主机机器构建 SDK，以进行交叉开发。
- en: Creating an SDK
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 SDK
- en: 'It is very useful to be able to create a standalone toolchain that other developers
    can install. This avoids the need for everyone on the team to have a full installation
    of Yocto. Ideally, you want the toolchain to include development libraries and
    header files for all the libraries installed on the target. You can do that for
    any image using the `populate_sdk` task, as shown:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个可以供其他开发人员安装的独立工具链非常有用。这样可以避免团队中的每个人都必须安装完整的 Yocto。理想情况下，你希望工具链包含目标设备上安装的所有库的开发库和头文件。你可以使用`populate_sdk`任务为任何镜像实现这一点，如下所示：
- en: '[PRE53]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The result is a self-installing shell script in `deploy-ti/sdk`:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个自安装的 shell 脚本，位于 `deploy-ti/sdk` 目录下：
- en: '[PRE54]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'For the SDK built with the `nova-image` recipe:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用`nova-image`配方构建的 SDK：
- en: '[PRE55]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'If you only want a basic toolchain with just C and C++ cross-compilers, the
    C library, and header files, then run this instead:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只需要一个基本工具链，包含 C 和 C++ 交叉编译器、C 库和头文件，那么可以改用这个命令：
- en: '[PRE56]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'To install the SDK, just run the shell script. The default install directory
    is `/opt/poky` but the install script allows you to change this:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 SDK，只需运行该 shell 脚本。默认的安装目录是`/opt/poky`，但安装脚本允许你更改此目录：
- en: '[PRE57]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'To make use of the toolchain, first source the environment and set up the script:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用工具链，首先源化环境并设置脚本：
- en: '[PRE58]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '**TIP**'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: The `environment-setup-*` script that sets things up for the SDK is not compatible
    with the `oe-init-build-env` script that you source when working in the Yocto
    build directory. It is a good rule to always start a new terminal session before
    you source either script.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 SDK 环境的`environment-setup-*`脚本与在 Yocto 构建目录中使用的`oe-init-build-env`脚本不兼容。在执行任何一个脚本之前，最好先开启一个新的终端会话。
- en: 'The toolchain generated by The Yocto Project does not have a valid `sysroot`
    directory. We know this to be true because passing the `-print-sysroot` option
    to the toolchain’s compiler returns `/not/exist`:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: Yocto 项目生成的工具链没有有效的 `sysroot` 目录。我们知道这一点，因为将`-print-sysroot`选项传递给工具链的编译器时返回的是`/not/exist`：
- en: '[PRE59]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Consequently, if you try to cross-compile, it will fail like this:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你尝试交叉编译，它会像这样失败：
- en: '[PRE60]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This is because the compiler has been configured to work for a wide range of
    Arm processors and the fine-tuning is done when you launch it using the right
    set of flags. Instead, you should use the shell variables that are created when
    you source the `environment-setup` script for cross-compiling. These include:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为编译器已经配置为支持多种 Arm 处理器，并且微调是在使用正确的标志启动编译器时完成的。相反，你应该使用在执行 `environment-setup`
    脚本时创建的 shell 变量来进行交叉编译。这些变量包括：
- en: '`CC`: C compiler'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CC`: C 编译器'
- en: '`CXX`: C++ compiler'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CXX`: C++ 编译器'
- en: '`CPP`: C preprocessor'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CPP`: C 预处理器'
- en: '`AS`: Assembler'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AS`: 汇编器'
- en: '`LD`: Linker'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LD`: 链接器'
- en: 'This is what we find `CC` has been set to:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们发现 `CC` 被设置为的值：
- en: '[PRE61]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'As long as you use `$CC` to compile, everything should work fine:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 只要使用`$CC`进行编译，应该一切正常：
- en: '[PRE62]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The license audit
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 许可证审计
- en: 'The Yocto Project insists that each package has a license. A copy of the license
    is placed in `tmp/deploy/licenses/<package name>` for each package as it is built.
    In addition, a summary of the packages and licenses used in an image is put into
    the directory: `<image name>-<machine name>.rootfs-<date stamp>`. For the `nova-image`
    we just built, the directory would be named something like this:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: Yocto 项目要求每个软件包都有一个许可证。每个软件包在构建时都会将许可证副本放置在 `tmp/deploy/licenses/<package name>`
    中。此外，镜像中使用的所有软件包和许可证的摘要会被放入目录：`<image name>-<machine name>.rootfs-<date stamp>`。对于我们刚刚构建的
    `nova-image`，该目录将命名为类似以下的名称：
- en: '[PRE63]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This completes our survey of the two leading build systems for embedded Linux.
    Buildroot is simple and quick, making it a good choice for simple single-purpose
    devices. Yocto is more complex and flexible. Even though there is good support
    throughout the community and industry for Yocto, the tool still has a very steep
    learning curve. You can expect it will take several months for you to become proficient
    with Yocto, and even then, it will sometimes do things that surprise you.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们对两种主流嵌入式 Linux 构建系统的概述。Buildroot 简单且快速，非常适合用于简单的单一用途设备。Yocto 更加复杂和灵活。尽管
    Yocto 在社区和行业中得到了良好的支持，但这个工具仍然有一个非常陡峭的学习曲线。你可以预期，成为 Yocto 的熟练用户可能需要几个月的时间，甚至即便如此，它有时也会做出一些让你吃惊的事情。
- en: Summary
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to use both Buildroot and The Yocto Project
    to configure, customize, and build embedded Linux images. We used Buildroot to
    create a BSP with a custom U-Boot patch and device tree specification for a hypothetical
    board based on the BeaglePlay. We then learned how to add our own code to an image
    in the form of a Buildroot package. You were introduced to The Yocto Project,
    which we will cover in depth over the next two chapters. In particular, you learned
    some basic BitBake terminology, how to write an image recipe, and how to create
    an SDK.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用 Buildroot 和 Yocto 项目来配置、定制和构建嵌入式 Linux 镜像。我们使用 Buildroot 创建了一个
    BSP，其中包括自定义的 U-Boot 补丁和针对假设基于 BeaglePlay 的板子的设备树规格。接着，我们学习了如何以 Buildroot 包的形式将自己的代码添加到镜像中。你还接触了
    Yocto 项目，我们将在接下来的两章中深入探讨。特别是，你学习了一些基本的 BitBake 术语，如何编写镜像配方，以及如何创建 SDK。
- en: Don’t forget that any devices you create using these tools will need to be maintained
    in the field for a period of time, often over many years. Both Yocto and Buildroot
    provide point releases for about one year after the initial release, and Yocto
    now offers long-term support for at least four years. In either case, you will
    find yourself having to maintain your own releases or paying for commercial support.
    The third possibility, ignoring the problem, is not an option!
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记，使用这些工具创建的任何设备都需要在现场维护一段时间，通常是多年。Yocto 和 Buildroot 都会在初始发布后的大约一年内提供点发布版本，且
    Yocto 现在至少提供四年的长期支持。在这两种情况下，你都会发现需要自己维护版本或支付商业支持费用。第三种可能性，忽视问题，绝不是一个选项！
- en: Further study
  id: totrans-387
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步学习
- en: '*The Buildroot user manual, Buildroot Association* –[https://buildroot.org/downloads/manual/manual.html](https://buildroot.org/downloads/manual/manual.html%0D%0A)'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Buildroot 用户手册，Buildroot 协会* – [https://buildroot.org/downloads/manual/manual.html](https://buildroot.org/downloads/manual/manual.html%0D%0A)'
- en: '*Yocto Project Documentation, Yocto Project* –[https://docs.yoctoproject.org/](https://docs.yoctoproject.org/)'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Yocto 项目文档，Yocto 项目* – [https://docs.yoctoproject.org/](https://docs.yoctoproject.org/)'
