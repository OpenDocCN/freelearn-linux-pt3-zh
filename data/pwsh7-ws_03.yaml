- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: The PowerShell Pipeline – How to String Cmdlets Together
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PowerShell 管道——如何将 cmdlet 串联起来
- en: Almost all **operating systems** (**OSs**) have the concept of a **pipeline**,
    allowing the output of one process to be fed into the input of the next. This
    concept is credited to Douglas McIlroy in 1973 when he was working on version
    3 of Unix at Bell Labs. This initial implementation envisaged the output of every
    command as a file-like structure, on which the next command could operate.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有的 **操作系统** (**OSs**) 都有 **管道** 的概念，它允许一个进程的输出被传递到下一个进程的输入中。这个概念归功于 Douglas
    McIlroy，在 1973 年他在贝尔实验室工作时开发了 Unix 第 3 版。最初的实现设想将每个命令的输出视为一种类似文件的结构，下一条命令可以在此结构上操作。
- en: This chapter will explain how PowerShell adheres to this vision and differs
    from it. We’ll start by exploring the pipeline concept, then look at some basic
    ways of manipulating the contents of the pipeline before taking a medium-depth
    dive into how the pipeline works in PowerShell, and how we can troubleshoot it
    when it doesn’t.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将解释 PowerShell 如何遵循这一愿景并与之有所不同。我们将从探讨管道的概念开始，然后介绍一些操作管道内容的基本方法，再深入分析 PowerShell
    中管道的工作原理，以及当管道出现问题时如何进行故障排除。
- en: By the end of this chapter, we’ll understand how information passes from one
    cmdlet to the next, how to manipulate that information so that we only work with
    the stuff we need, and how to work out what’s going wrong when we get an error
    message.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将理解信息如何从一个 cmdlet 传递到下一个 cmdlet，如何操作这些信息以便只处理我们需要的部分，以及当出现错误信息时，如何找出问题所在。
- en: 'In this chapter, we’re going to cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: How to bring cmdlets together – the pipeline
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将 cmdlet 组合在一起——管道
- en: Selecting and sorting objects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择和排序对象
- en: Filtering objects
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤对象
- en: Enumerating objects
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举对象
- en: Formatting objects
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格式化对象
- en: How the pipeline works – parameter binding
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道是如何工作的——参数绑定
- en: Troubleshooting the pipeline – pipeline tracing
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故障排除管道——管道跟踪
- en: How to bring cmdlets together – the pipeline
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何将 cmdlet 组合在一起——管道
- en: Since Unix and the C programming language in the 1970s, operating systems have
    abstracted computer input and output into `Read-Host` cmdlet. The stdout stream
    is the successful output of the cmdlet. The stderr stream contains any error messages
    produced by the program and is sent to a separate stream so as not to interfere
    with any successful output.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 自1970年代的 Unix 和 C 编程语言以来，操作系统已将计算机的输入和输出抽象为 `Read-Host` cmdlet。stdout 流是 cmdlet
    成功输出的结果。stderr 流包含程序产生的任何错误信息，并被发送到一个单独的流，以避免干扰任何成功的输出。
- en: 'PowerShell expands on these streams a bit and has six output streams instead
    of two. Each of these streams can be captured either with an explicit PowerShell
    cmdlet or by specifying one of the common parameters when running a cmdlet, as
    shown in the following table:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 对这些流进行了扩展，拥有六个输出流，而不是两个。每个流都可以通过显式的 PowerShell cmdlet 捕获，或者在运行 cmdlet
    时指定一个常用参数，如下表所示：
- en: '| **Stream #** | **Description** | **Cmdlet** | **Common Parameters** |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| **流 #** | **描述** | **Cmdlet** | **常用参数** |'
- en: '| 1 | Success | `Write-Output` | None – this is the default output |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 成功 | `Write-Output` | 无——这是默认的输出 |'
- en: '| 2 | Error | `Write-Error` | `-ErrorAction` and `-ErrorVariable` |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 错误 | `Write-Error` | `-ErrorAction` 和 `-ErrorVariable` |'
- en: '| 3 | Warning | `Write-Warning` | `-WarningAction` and `-WarningVariable` |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 警告 | `Write-Warning` | `-WarningAction` 和 `-WarningVariable` |'
- en: '| 4 | Verbose | `Write-Verbose` | `-``Verbose` |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 详细信息 | `Write-Verbose` | `-Verbose` |'
- en: '| 5 | Debug | `Write-Debug` | `-``Debug` |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 调试 | `Write-Debug` | `-Debug` |'
- en: '| 6 | Information | `Write-Information` | `-``InformationAction` and`-``InformationVariable`
    |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 信息 | `Write-Information` | `-InformationAction` 和 `-InformationVariable`
    |'
- en: Table 3.1 – PowerShell streams
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.1 – PowerShell 流
- en: Stream 1 is the equivalent of stdout, while stream 2 is the equivalent of stderr.
    The PowerShell pipeline passes the contents of stream 1, success, from one cmdlet
    to the next in the pipeline. When we see red error messages on the screen, they
    are not output in stream 1 – they are output in stream 2\. This is because we
    don’t want error messages (or verbose messages or anything other than an output
    object) being passed into the next cmdlet and causing another error. After all,
    the second cmdlet has no way of interpreting that information.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 流 1 相当于标准输出（stdout），而流 2 相当于标准错误输出（stderr）。PowerShell 管道将流 1 的内容（即成功）从一个 cmdlet
    传递到管道中的下一个 cmdlet。当我们看到屏幕上的红色错误信息时，它们并不是输出在流 1 中——它们输出在流 2 中。原因是我们不希望错误信息（或者详细信息或任何除输出对象之外的信息）被传递到下一个
    cmdlet 中，导致另一个错误。毕竟，第二个 cmdlet 没有办法解释这些信息。
- en: 'The pipeline may consist of one or more PowerShell cmdlets, separated by a
    pipe character (`|`). Every PowerShell cmdlet is part of a pipeline, even if it’s
    just one cmdlet. There is an implicit pair of cmdlets, `Out-Default | Out-Host`,
    at the end of every pipeline so that the output in stream 1 of the cmdlet gets
    formatted and written to the screen. Some cmdlets have no stream 1 output, so
    we see nothing on the screen after running them. For example, in [*Chapter 2*](B17600_02.xhtml#_idTextAnchor034),
    *Exploring PowerShell Cmdlets and Syntax*, we ran the following cmdlet:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 管道可能由一个或多个 PowerShell cmdlet 组成，使用管道符号 (`|`) 分隔。每个 PowerShell cmdlet 都是管道的一部分，即使它只是一个单独的
    cmdlet。在每个管道的末尾都有一对隐式的 cmdlet，`Out-Default | Out-Host`，确保 cmdlet 在流 1 中的输出被格式化并写入屏幕。有些
    cmdlet 没有流 1 输出，因此在运行它们后我们不会看到任何屏幕上的输出。例如，在 [*第 2 章*](B17600_02.xhtml#_idTextAnchor034)，*探索
    PowerShell Cmdlet 和语法* 中，我们运行了以下 cmdlet：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once the cmdlet finished running, we were returned to the prompt. If we look
    at the help file for `Set-Alias`, we will see that it has no output by default,
    so we see nothing on the screen when it runs successfully. `Set-Alias` is still
    a pipeline, though; `Out-Default` still runs, it just receives no output.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 cmdlet 执行完毕，我们会返回到提示符。如果我们查看 `Set-Alias` 的帮助文件，会看到它默认没有输出，因此在成功运行时我们不会看到屏幕上的任何内容。尽管如此，`Set-Alias`
    仍然是一个管道；`Out-Default` 仍然运行，只是没有接收到任何输出。
- en: 'Cmdlets execute from left to right, with the output object of the cmdlet on
    the left being passed to the next cmdlet in the pipeline on the right. For ease
    of reading (and typing), the pipe symbol can be used as a line break when working
    interactively. Try pressing *return* or *Enter* after the pipe symbol:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Cmdlet 从左到右执行，左侧 cmdlet 的输出对象会传递到管道右侧的下一个 cmdlet。为了便于阅读（和输入），管道符号可以用作交互式工作时的换行符。尝试在管道符号后按
    *return* 或 *Enter*：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You should see a continuation prompt (`>>`) after pressing *return*/*Enter*
    after the pipe symbol, as shown here:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在按下 *return*/*Enter* 键后，你应该看到一个继续提示符（`>>`），如下所示：
- en: '![Figure 3.1 – Using the pipe symbol as a line break](img/B17600_03_001.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1 – 使用管道符号作为换行符](img/B17600_03_001.jpg)'
- en: Figure 3.1 – Using the pipe symbol as a line break
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – 使用管道符号作为换行符
- en: We keep referring to objects – it would be useful to describe exactly what we
    mean. This is what we’ll do in the next section.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在提到对象——描述我们具体指的是什么将会很有帮助。我们将在下一节中做这件事。
- en: What is an object?
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是对象？
- en: When we run commands in Linux and the Windows console, the commands output a
    byte stream to stdout; this is interpreted as a text file, held in memory. When
    we want to manipulate the contents of this output, we must use the same tools
    that we would use to search and manipulate text; this may be Perl, sed, AWK, or
    a host of others.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 Linux 和 Windows 控制台中运行命令时，命令将字节流输出到标准输出（stdout）；这被解释为一个文本文件，保存在内存中。当我们想要操作这个输出的内容时，我们必须使用与查找和操作文本相同的工具；这些工具可能是
    Perl、sed、AWK 或其他一些工具。
- en: 'This means that we become adept at text manipulation; I’ve got about seven
    volumes of Perl books on my desk, dating back to the mid-nineties. PowerShell
    cmdlets don’t produce a text-like byte stream; instead, they produce objects and
    collections of objects, which are table structures held in memory, that are produced
    when we run `Get-Process`, as shown here:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们变得擅长文本操作；我的桌子上大约有七本 Perl 书籍，最早的是上世纪九十年代出版的。PowerShell cmdlet 不产生类似文本的字节流；相反，它们生成对象和对象集合，这些对象是以表格结构保存在内存中的，在我们运行
    `Get-Process` 时产生，如下所示：
- en: '![Figure 3.2 – The Get-Process collection of objects](img/B17600_03_002.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2 – 获取进程对象集合](img/B17600_03_002.jpg)'
- en: Figure 3.2 – The Get-Process collection of objects
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – 获取进程对象集合
- en: 'Each line in the table is an object. Each column is a property of the objects
    in the table. The whole table is a collection of objects. From *Figure 3**.1*,
    we know that each object is of the `System.Diagnostics.Process` type and has the
    list of properties and methods associated with that object type. With the pipeline,
    we can send this collection to another cmdlet to extract further information,
    or just call the specific property we are interested in. If we want to know the
    value of a property that isn’t displayed by default, such as how much privileged
    processor time had been consumed in the lifetime of a particular process, we could
    type the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 表格中的每一行都是一个对象。每一列是表中对象的一个属性。整个表格是对象的集合。从*图 3.1*中，我们知道每个对象都是`System.Diagnostics.Process`类型，并且具有与该对象类型相关联的属性和方法列表。通过管道，我们可以将这个集合发送到另一个cmdlet来提取更多信息，或者仅仅调用我们感兴趣的特定属性。如果我们想知道一个默认未显示的属性值，例如一个特定进程在其生命周期中消耗的特权处理器时间，我们可以输入以下命令：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Where did that `4514` come from? It’s the `Id` property of one of the `pwsh`
    processes in *Figure 3**.2*. From this, I can see that my `pwsh` process has 11.75
    seconds in privileged mode. I know – we probably don’t want to know that for a
    process as trivial as `pwsh`, but we might be interested in the value for other
    processes if we were investigating a storage performance issue on a database server.
    Run the following code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 那个`4514`是从哪里来的？它是*图 3.2*中某个`pwsh`进程的`Id`属性。从这里，我可以看到我的`pwsh`进程在特权模式下消耗了11.75秒。我知道——我们可能不想知道像`pwsh`这样简单的进程的这些信息，但如果我们在调查数据库服务器的存储性能问题时，可能会对其他进程的这些值感兴趣。运行以下代码：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, we will get the privileged process time for all the processes currently
    running on our client, using the alias we have set for `Get-Process`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将获取当前在客户端上运行的所有进程的特权处理时间，使用我们为`Get-Process`设置的别名。
- en: 'Not all cmdlets produce a single type of object. Some cmdlets may produce more
    than one, and we need to be careful how we process these and pass their output
    in the pipeline. For instance, consider the `Get-ChildItem` cmdlet. It gets the
    contents of a directory or folder. A directory may contain two basic types of
    items – that is, files and sub-directories. These two types will have different
    properties – for instance, we can’t nest a sub-directory inside a file. A pipeline
    that has been set up to manipulate file objects may fail if it is also passed
    directory objects. Let’s have a look; type the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 并不是所有cmdlet都会生成单一类型的对象。一些cmdlet可能会生成多个对象，我们需要小心如何处理这些对象并将它们的输出传递到管道中。例如，考虑`Get-ChildItem`
    cmdlet。它获取目录或文件夹的内容。一个目录可能包含两种基本类型的项目——即文件和子目录。这两种类型会有不同的属性——例如，我们不能将子目录嵌套在文件中。如果一个管道已经设置为操作文件对象，那么如果也传递了目录对象，它可能会失败。让我们来看看，输入以下命令：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here, we can see that the `C:\scratch` directory on my Windows machine contains
    both directories and files, as shown in the following screenshot:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我Windows机器上的`C:\scratch`目录包含了目录和文件，如下图所示：
- en: '![Figure 3.3 – Checking the types of objects in a directory](img/B17600_03_003.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3 – 检查目录中对象的类型](img/B17600_03_003.jpg)'
- en: Figure 3.3 – Checking the types of objects in a directory
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – 检查目录中对象的类型
- en: What are we doing there? This looks a bit complicated. Well, we’re taking the
    output of the `Get-ChildItem C:\scratch` cmdlet and passing it to `Get-Member`.
    We’re only interested in the `TypeName` property, so we put the pipeline in parentheses
    so that we can easily access just the property we need. Once we’ve got the collection
    of all `TypeName` instances, we pass it in a second pipeline to `Select-Object`,
    which we tell to only return unique values by using the `-unique` parameter. Clever,
    eh?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做了什么？看起来有点复杂。好吧，我们将`Get-ChildItem C:\scratch` cmdlet的输出传递给`Get-Member`。我们只对`TypeName`属性感兴趣，所以我们把管道放在括号中，这样我们就可以轻松访问我们需要的那个属性。一旦得到所有`TypeName`实例的集合，我们就把它传递到第二个管道，传给`Select-Object`，并使用`-unique`参数告诉它只返回唯一的值。聪明吧？
- en: We’re going to look at basic ways of manipulating these objects in the next
    few sections. Let’s start with selecting and sorting objects.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几个章节中，我们将探讨操作这些对象的基本方法。让我们从选择和排序对象开始。
- en: Selecting and sorting objects
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择和排序对象
- en: 'Many of the cmdlets we might run will produce a large amount of output, and,
    likely, much of it will not be interesting. Therefore, it’s useful to be able
    to select just the bits we need and sort them into a meaningful order. There are
    two cmdlets for doing this: `Select-Object` and `Sort-Object`. We will often see
    these referred to by their aliases – `select` and `sort`.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行的许多 cmdlet 会产生大量输出，而且其中很多内容可能并不有趣。因此，能够仅选择我们需要的部分并将其排序成有意义的顺序是非常有用的。为此，有两个
    cmdlet：`Select-Object` 和 `Sort-Object`。我们通常会看到它们的别名——`select` 和 `sort`。
- en: Using Select-Object
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `Select-Object`
- en: 'We used `Select-Object` in the *What is an object?* section to select the unique
    properties of objects in a collection. However, we can use it to do so much more.
    Look at the help file for `Select-Object` by running the following command:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 *什么是对象？* 部分中使用了 `Select-Object` 来选择集合中对象的唯一属性。然而，我们可以用它做更多的事情。通过运行以下命令，查看
    `Select-Object` 的帮助文件：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, we can see that there are four parameter sets, all of which work in one
    of two ways – we can either use the cmdlet to work with one or more properties
    of a collection, or we can use it to select a subset of objects in a collection.
    Let’s try the first one by typing the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到有四组参数集，它们的工作方式有两种——我们可以使用 cmdlet 操作集合的一个或多个属性，或者我们可以用它来选择集合中的一部分对象。让我们尝试第一种方法，输入以下内容：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here, we’ll see a collection of objects with two properties – `Name` and `Id`.
    Now, let’s run that in `Get-Member`, as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将看到一个包含两个属性的对象集合——`Name` 和 `Id`。现在，让我们在 `Get-Member` 中运行它，如下所示：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, we can see that we’ve taken that collection of `System.Diagnostics.Process`
    objects and changed them into `Selected.System.Diagnostics.Process` objects –
    these objects only have two properties – the `Name` and `Id` properties we used
    in the `Select-Object` cmdlet:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们已将那组 `System.Diagnostics.Process` 对象转变为 `Selected.System.Diagnostics.Process`
    对象——这些对象只有两个属性——我们在 `Select-Object` cmdlet 中使用的 `Name` 和 `Id` 属性：
- en: '![Figure 3.4 – The properties of our new objects](img/B17600_03_004.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4 – 新对象的属性](img/B17600_03_004.jpg)'
- en: Figure 3.4 – The properties of our new objects
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – 新对象的属性
- en: We’ve still got the same number of objects, but now, they only have the properties
    we’re interested in. This has two benefits; first, PowerShell will run much quicker
    while working on these smaller objects, but also PowerShell will require less
    memory. The downside is that we no longer have access to the properties we *didn’t*
    select from the original objects in the pipeline.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在仍然有相同数量的对象，但它们只包含我们感兴趣的属性。这有两个好处；首先，PowerShell 在处理这些较小的对象时会更快，其次，PowerShell
    将需要更少的内存。缺点是，我们不再能访问管道中原始对象的那些*未*选择的属性。
- en: 'The second way we can use `Select-Object` is to select a subset of objects
    from a collection. The parameters for doing that are in the first parameter set;
    `-first`, `-last`, and `-skip`. Each of these parameters requires an integer as
    an argument. `-first 5` will select the first five objects in the pipeline, whereas
    `-last 2` will select the last two objects in the pipeline, like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `Select-Object` 的第二种方式是从集合中选择一部分对象。实现这一点的参数在第一个参数集中；`-first`、`-last`
    和 `-skip`。每个参数都需要一个整数作为参数。`-first 5` 会选择管道中的前五个对象，而 `-last 2` 会选择管道中的最后两个对象，如下所示：
- en: '![Figure 3.5 – Selecting a subset of objects](img/B17600_03_005.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5 – 选择对象的子集](img/B17600_03_005.jpg)'
- en: Figure 3.5 – Selecting a subset of objects
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – 选择对象的子集
- en: 'We can use the `-skip` parameter to miss out values at the start or end, like
    this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `-skip` 参数来跳过开始或结尾的值，如下所示：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will return the integers `2` and `3` which are the first two if we skip
    the first one.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回整数 `2` 和 `3`，它们是跳过第一个后得到的前两个元素。
- en: Activity 1
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 活动 1
- en: How might we return `2`, `3`, `4`, `7`, and `8` from that array?
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何从这个数组中返回 `2`、`3`、`4`、`7` 和 `8`？
- en: The problem with running `Select-Object` in this way is that unless we can control
    the order of the objects in the collection, we’re just grabbing random objects.
    This brings us to our next cmdlet, `Sort-Object`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式运行`Select-Object`的问题在于，除非我们能够控制集合中对象的顺序，否则我们只是在随机抓取对象。这引出了下一个 cmdlet，`Sort-Object`。
- en: Ordering objects with Sort-Object
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `Sort-Object` 排序对象
- en: When we run `Get-Process`, the processes are returned in alphabetical order,
    by process name. This is determined in the PowerShell source code. We can, however,
    change the order in which the objects are presented (and by implication, re-order
    them in the pipeline) using the `Sort-Object` cmdlet.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行`Get-Process`时，进程会按进程名称的字母顺序返回。这是由PowerShell源代码决定的。然而，我们可以通过使用`Sort-Object`
    cmdlet来更改对象的显示顺序（从而间接地重新排序管道中的对象）。
- en: '`Sort-Object` can sort a collection of objects on one or more properties. We
    don’t need to run it with any parameters; if we don’t specify a property to sort
    on, it will sort the collection based on the default sort property of the first
    object in the pipeline, which is defined deep within the PowerShell source code
    and is not easy to find.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sort-Object`可以根据一个或多个属性对对象集合进行排序。我们不需要指定任何参数来运行它；如果我们没有指定排序的属性，它将根据管道中第一个对象的默认排序属性来对集合进行排序，该属性深藏在PowerShell的源代码中，并且很难找到。'
- en: 'What does this mean? Remember that `Get-ChildItem` produces two types of output.
    By default, when you run `Get-ChildItem`, you get a list of all the first type
    of object (`System.IO.DirectoryInfo`, or directories), and then a list of all
    the second type of object (`System.IO.FileInfo`, or files), as shown in the first
    example in the following screenshot:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着什么？记住，`Get-ChildItem`会生成两种类型的输出。默认情况下，当你运行`Get-ChildItem`时，你会首先得到所有第一类型对象（`System.IO.DirectoryInfo`，即目录）的列表，然后是所有第二类型对象（`System.IO.FileInfo`，即文件）的列表，如以下截图中的第一个示例所示：
- en: '![Figure 3.6 – The effect of running Select-Object with no parameters](img/B17600_03_006.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.6 – 运行Select-Object没有参数的效果](img/B17600_03_006.jpg)'
- en: Figure 3.6 – The effect of running Select-Object with no parameters
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – 运行Select-Object没有参数的效果
- en: In the second example, `Get-ChildItem -Path C:\Scratch\ | Sort-Object`, we have
    a list of all the objects arranged alphabetically and mixed; it ignores the object
    type.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个示例中，`Get-ChildItem -Path C:\Scratch\ | Sort-Object`，我们得到了一个按字母顺序排列并混合的所有对象列表；它忽略了对象类型。
- en: 'We can add a property name to sort our collection on that property. For instance,
    we could run `Get-Process` and sort on the working set size, like so:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加一个属性名来根据该属性对我们的集合进行排序。例如，我们可以运行`Get-Process`并按工作集大小进行排序，像这样：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is nice. However, it’s sorted them in the default order, ascending, so
    the processes we are most likely to be interested in – those with the highest
    memory consumption – are at the bottom of the table. We can fix that with another
    parameter, `-Descending`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好。不过，它们已经按照默认的升序进行了排序，因此我们最感兴趣的进程——那些消耗内存最多的——排在了表格的底部。我们可以通过添加另一个参数`-Descending`来解决这个问题：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This produces a much more useful output, as shown here:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生一个更有用的输出，如下所示：
- en: '![Figure 3.7 – Using Sort-Object to sort in descending order](img/B17600_03_007.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.7 – 使用Sort-Object按降序排序](img/B17600_03_007.jpg)'
- en: Figure 3.7 – Using Sort-Object to sort in descending order
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 – 使用Sort-Object按降序排序
- en: 'We can even sort on multiple properties at once. For instance, we could try
    doing the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以一次按多个属性进行排序。例如，我们可以尝试以下操作：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This orders our list by **Session ID** (**SI**), and then by **Working** **Set**
    (**WS**).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这将按**会话 ID**（**SI**）排序，然后按**工作集**（**WS**）排序。
- en: Let’s take a look at the help file. Here, we can see that `Sort-Object` has
    three parameter sets that all work in much the same fashion; the only difference
    is the `-top`, `-bottom`, and `-stable` parameters. The `-top` and `-bottom` parameters
    are fairly self-explanatory, but `-stable` is less so. When we run `Sort-Object`,
    it will output objects of equal value in an order according to its internal logic,
    not necessarily in the order that they are received. The `-stable` parameter (as
    well as `-top` and `-bottom`) will preserve the order that `Sort-Object` received
    the objects in if the sorted properties are equal.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下帮助文件。在这里，我们可以看到`Sort-Object`有三个参数集，它们的工作方式大致相同；唯一的区别是`-top`、`-bottom`和`-stable`参数。`-top`和`-bottom`参数比较容易理解，但`-stable`就不那么直观了。当我们运行`Sort-Object`时，如果存在相等值的对象，它会根据其内部逻辑输出对象的顺序，而不一定是它们被接收的顺序。`-stable`参数（以及`-top`和`-bottom`）会在排序的属性相等时，保持`Sort-Object`接收对象的顺序。
- en: 'We can now see how we can combine these two cmdlets, `Sort-Object` and `Select-Object`,
    to produce meaningful collections of interesting information. For instance, we
    could type the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以看到如何将这两个cmdlet，`Sort-Object`和`Select-Object`，结合起来生成有意义的信息集合。例如，我们可以键入以下内容：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This will get us the five most CPU-intensive running processes, as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这将获取我们当前 CPU 占用最多的五个进程，如下所示：
- en: '![Figure 3.8 – Combining Sort-Object and Select-Object](img/B17600_03_008.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.8 – 结合 Sort-Object 和 Select-Object](img/B17600_03_008.jpg)'
- en: Figure 3.8 – Combining Sort-Object and Select-Object
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 – 结合 Sort-Object 和 Select-Object
- en: What if we don’t want the top five, though? What if we want all the processes
    that are using *a lot* of CPU? That’s where filtering comes in.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果我们不想要前五名呢？如果我们想要所有使用 *大量* CPU 的进程呢？这就是过滤的作用。
- en: Filtering objects
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤对象
- en: 'We can filter objects in a more sophisticated way using the `Where-Object`
    cmdlet. `Where-Object` also looks at the properties of the objects in the pipeline,
    but it can also make decisions about which objects to output and which to discard.
    Try this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `Where-Object` cmdlet 以更复杂的方式过滤对象。`Where-Object` 也查看管道中对象的属性，但它还可以做出决定，输出哪些对象，丢弃哪些对象。尝试以下操作：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This will return a list of processes where the CPU property has a value greater
    than 1\. In practice, we very rarely see people include the `-Property` and `-Value`
    names for the parameters, as they are positional. It is far more likely that you
    will see this written as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个进程列表，其中 CPU 属性的值大于 1。在实际操作中，我们很少看到人们为参数包含 `-Property` 和 `-Value` 名称，因为它们是位置参数。更常见的写法如下：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Wait, though. What’s that `-gt`? The `-gt` parameter is a **comparison operator**,
    an important concept in coding.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下，`-gt` 是什么？`-gt` 参数是一个 **比较运算符**，这是编程中的一个重要概念。
- en: Understanding comparison operators
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解比较运算符
- en: 'Comparison operators are expressed as switch parameters when using the `Where-Object`
    cmdlet, resulting in the help file being a long and complex document, with many
    parameter sets, as only one comparison operator can be used at a time. The basic
    comparison operators are shown in the following table:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 比较运算符在使用 `Where-Object` cmdlet 时作为开关参数表示，导致帮助文档成为一个冗长且复杂的文档，包含许多参数集，因为每次只能使用一个比较运算符。基本的比较运算符如下表所示：
- en: '| **Comparison** | **Operator** | **Case-Sensitive Operator** |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| **比较** | **运算符** | **区分大小写的运算符** |'
- en: '| --- | --- | --- |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Equality | `-``eq` | `-``ceq` |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| 相等 | `-``eq` | `-``ceq` |'
- en: '| Inequality | `-``ne` | `-``cne` |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 不等式 | `-``ne` | `-``cne` |'
- en: '| Greater than | `-``gt` | `-``cgt` |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| 大于 | `-``gt` | `-``cgt` |'
- en: '| Less than | `-``lt` | `-``clt` |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| 小于 | `-``lt` | `-``clt` |'
- en: '| Greater than or equal to | `-``ge` | `-``cge` |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 大于或等于 | `-``ge` | `-``cge` |'
- en: '| Less than or equal to | `-``le` | `-``cle` |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 小于或等于 | `-``le` | `-``cle` |'
- en: '| Wildcard equality | `-``like` | `-``clike` |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 通配符相等 | `-``like` | `-``clike` |'
- en: Table 3.2 – Basic comparison operators
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.2 – 基本比较运算符
- en: 'By default, the operators are not case-sensitive, so `-eq top` is functionally
    the same as `-eq TOP`. There are also several NOT operators to obtain the opposite,
    such as `-NotLike`. Additionally, we have more advanced comparison operators,
    such as the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，运算符是不区分大小写的，因此 `-eq top` 与 `-eq TOP` 在功能上是相同的。也有一些 NOT 运算符可以获得相反的结果，例如
    `-NotLike`。此外，我们还有一些更高级的比较运算符，如下所示：
- en: '`-match` to get values based on regular expressions.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `-match` 根据正则表达式获取值。
- en: '`-in` to get objects where the property has a value in a specified array. We’ll
    discuss arrays in [*Chapter 4*](B17600_04.xhtml#_idTextAnchor071), *PowerShell
    Variables and* *Data Structures*.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `-in` 获取属性值在指定数组中的对象。我们将在 [*第 4 章*](B17600_04.xhtml#_idTextAnchor071) 中讨论数组，*PowerShell
    变量和* *数据结构*。
- en: '`-contains` to get objects where the specified value might be in a property
    that contains an array, rather than a single value.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `-contains` 获取对象，其中指定的值可能在包含数组的属性中，而不是单一值。
- en: 'Let’s explore how some of these might work. Try running the following commands
    to get a list of your running PowerShell processes:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索这些操作的一些工作方式。尝试运行以下命令，以获取正在运行的 PowerShell 进程列表：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The last one works because we have given `Where-Object` a two-item array of
    values, `"pwsh"` and `"bash"`, and asked it to return any objects with a `ProcessName`
    property value in that array. In practice, the array probably wouldn’t be a list
    of strings like that but something much more complicated, derived by running another
    cmdlet.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一条能正常工作，是因为我们给 `Where-Object` 提供了一个包含两个项的数组，`"pwsh"` 和 `"bash"`，并要求它返回任何 `ProcessName`
    属性值在该数组中的对象。实际上，数组可能不会像这样是一个字符串列表，而是通过运行另一个 cmdlet 得到的更复杂的东西。
- en: Activity 2
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 活动 2
- en: Why doesn’t `Get-Process | Where-Object ProcessName -contains *wsh` produce
    any output?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么 `Get-Process | Where-Object ProcessName -contains *wsh` 没有输出任何结果？
- en: That’s all very interesting, but what happens if we want to find something more
    complicated, such as a filter on two properties, or find values within a range?
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这都很有意思，但如果我们想要查找更复杂的内容，比如对两个属性进行过滤，或者查找某个范围内的值，会发生什么呢？
- en: Understanding Where-Object advanced syntax
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解Where-Object高级语法
- en: So far, we’ve been using `Where-Object` with what is known as the `-FilterScript`
    parameter. This parameter allows us to pass a short script object to the cmdlet,
    which then runs on each item in the pipeline.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用`Where-Object`与所谓的`-FilterScript`参数。这个参数允许我们将一个简短的脚本对象传递给cmdlet，然后该cmdlet在管道中的每个项目上运行。
- en: 'Filter scripts are `-and`, `-or`, and `-not`. Let’s see how one of our previous
    examples might work using advanced syntax. Earlier in this section, we typed the
    following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器脚本有`-and`、`-or`和`-not`。让我们看看之前的一个例子，如何在高级语法中使用。我们在本节早些时候输入了以下内容：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This gave us a list of all our running `pwsh` processes when using the basic
    syntax.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们得到了所有正在运行的`pwsh`进程的列表，使用的是基本语法。
- en: 'Writing the same command using the advanced syntax would look like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用高级语法编写相同命令的形式如下：
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The filter script is the bit enclosed in curly brackets – that is, `$PSItem.ProcessName
    -eq ''pwsh''`. Let’s break this down. `-eq ''pwsh''` is familiar to us, as we
    used it earlier, but what about `$PSItem.ProcessName`? This is a construction
    that allows us to access the `ProcessName` property of the object currently being
    processed. `$PSItem` is a `$PSItem` outside of textbooks; the variable is almost
    always written as `$_` (*dollar underscore*); for example, `$_.ProcessName -eq
    ''pwsh''`. In the basic syntax, we didn’t need quotes around `pwsh`, but in the
    advanced syntax, we do so that the script knows that we are passing it a string
    value, like so:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器脚本是被花括号包围的部分——也就是`$PSItem.ProcessName -eq 'pwsh'`。让我们来解析一下。`-eq 'pwsh'`对我们来说很熟悉，因为我们之前使用过，但`$PSItem.ProcessName`又是什么呢？这是一个结构，允许我们访问当前正在处理的对象的`ProcessName`属性。`$PSItem`是课本之外的一个`$PSItem`；这个变量通常写作`$_`（*美元符号下划线*）；例如，`$_.ProcessName
    -eq 'pwsh'`。在基本语法中，我们不需要对`pwsh`加引号，但在高级语法中，我们需要加引号，以便脚本知道我们传递的是一个字符串值，像这样：
- en: '![Figure 3.9 – Three ways of filtering with Where-Object, one of which is wrong](img/B17600_03_009.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.9 – 使用Where-Object过滤的三种方式，其中一种是错误的](img/B17600_03_009.jpg)'
- en: Figure 3.9 – Three ways of filtering with Where-Object, one of which is wrong
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9 – 使用Where-Object过滤的三种方式，其中一种是错误的
- en: Without the quotes, the cmdlet will interpret `pwsh` as the next cmdlet. If
    you look closely at the error, you will see that it doesn’t get as far as that,
    though, because `-eq` is missing a value. It doesn’t matter much if you use single
    or double quotes here, but the best practice is to use single quotes unless you
    need some of the special powers of double quotes, which we will talk about in
    [*Chapter 4*](B17600_04.xhtml#_idTextAnchor071), *PowerShell Variables and* *Data
    Structures*.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 没有引号时，cmdlet会将`pwsh`解释为下一个cmdlet。如果你仔细查看错误，你会发现它并没有走到那一步，因为`-eq`缺少了一个值。如果在这里使用单引号或双引号并没有太大关系，但最佳实践是使用单引号，除非你需要双引号的一些特殊功能，我们将在[*第4章*](B17600_04.xhtml#_idTextAnchor071)中讨论，*PowerShell
    变量和* *数据结构*。
- en: Multiple filters in the advanced syntax
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级语法中的多个过滤器
- en: 'Now that we understand the syntax, we can start using it to combine filters
    to produce more complex results. Try this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们理解了语法，可以开始使用它来组合过滤器，以生成更复杂的结果。试试这个：
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This should give you a list of your `pwsh` processes where the `CPU` value
    is greater than 1\. Now, if you change the `CPU` value to something higher, you
    should see the output change:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该给你一个`pwsh`进程的列表，其中`CPU`值大于1。现在，如果你将`CPU`值改为更高的数字，你应该会看到输出发生变化：
- en: '![Figure 3.10 – Combining filters with Where-Object advanced syntax](img/B17600_03_010.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.10 – 使用Where-Object高级语法组合过滤器](img/B17600_03_010.jpg)'
- en: Figure 3.10 – Combining filters with Where-Object advanced syntax
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10 – 使用Where-Object高级语法组合过滤器
- en: 'Be aware that the script block syntax is unforgiving. Unless we type it carefully
    and exactly right, we will not get the result we are hoping for. For instance,
    let’s say we type the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要注意，脚本块语法是严格的。除非我们小心且准确地输入，否则我们将得不到期望的结果。例如，假设我们输入以下内容：
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here, we will get an error saying `You must provide a value expression following
    the ''-and'' operator`. Because we can see the error, we can fix it by replacing
    `CPU` with `$PSItem.CPU`. However, let’s say we only want processes named `pwsh`
    or `bash`, and we type this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们会得到一个错误，提示`You must provide a value expression following the '-and' operator`。因为我们能看到这个错误，我们可以通过将`CPU`替换为`$PSItem.CPU`来修正它。然而，假设我们只想要名为`pwsh`或`bash`的进程，并输入如下：
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here, we *don’t* get an error, we just get the wrong result, as shown in the
    following screenshot. The correct syntax is shown in the second example in the
    following screenshot:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们*不会*得到错误，只会得到错误的结果，如下图所示。正确的语法在下图的第二个示例中展示：
- en: '![Figure 3.11 – Careful with that syntax, Eugene](img/B17600_03_011.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.11 – 小心语法，尤金](img/B17600_03_011.jpg)'
- en: Figure 3.11 – Careful with that syntax, Eugene
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.11 – 小心语法，尤金
- en: 'We can also use the advanced syntax to access properties of properties. Let’s
    run the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用高级语法来访问属性的属性。让我们运行以下命令：
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here, we can see that the `ProcessName` property is a string, so it has the
    properties of a string object. This means we can run something like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到`ProcessName`属性是一个字符串，因此它具有字符串对象的属性。这意味着我们可以像这样运行：
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we are looking for all the processes running on the machine with a `ProcessName`
    that’s fewer than `5` characters. We’re also using the more common `$_` in place
    of `$PSItem`. You must get used to this.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们要查找所有机器上`ProcessName`少于`5`个字符的进程。我们还使用了更常见的`$_`来代替`$PSItem`。你必须习惯这个。
- en: Filter optimization
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤优化
- en: 'Consider the following two cmdlets:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下两个cmdlet：
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'They produce the same results (at least, they do on my machine). However, on
    my client, the first one takes 29 milliseconds, while the second one only takes
    20 milliseconds. Try it yourself with the `Measure-Command` cmdlet, like this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 它们产生相同的结果（至少在我的机器上是这样）。然而，在我的客户端，第一种方法需要29毫秒，而第二种方法只需要20毫秒。你可以自己试试，使用`Measure-Command`
    cmdlet，像这样：
- en: '[PRE24]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now and then, because they’re both very short pipelines, you may get a surprising
    result, but if you run them 10 times in a row, the second cmdlet will be quicker
    than the first in some way almost every time. This variation is caused by the
    other things running on your client, competing with PowerShell for resources.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，由于它们都是非常短的管道，你可能会得到一个意外的结果，但如果你连续运行它们10次，第二个cmdlet几乎每次都会在某些方面比第一个更快。这种变化是由于在你的客户端上有其他程序在运行，它们与PowerShell争夺资源。
- en: 'Earlier in this chapter, we talked about reducing the amount of processing
    and memory PowerShell requires to produce a result. Filter optimization is a great
    way to do this. We should filter objects as early as possible in the pipeline
    to reduce the number of objects PowerShell has to work on. There’s a basic rule:
    **filter left**.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 本章前面我们讨论了如何减少PowerShell生成结果所需的处理和内存量。过滤优化是实现这一点的好方法。我们应该尽早在管道中进行过滤，以减少PowerShell需要处理的对象数量。这里有一个基本规则：**左侧过滤**。
- en: We don’t just have the `Where-Object` cmdlet for filtering. Many cmdlets also
    have filtering parameters that are either explicit, where the parameter name is
    `-Filter`, or parameters that will perform common filtering tasks. For instance,
    the `Get-ChildItem` cmdlet has `-File` and `-Directory` parameters to limit its
    output to just those object types. Where possible, use the built-in parameters
    of the cmdlet to filter objects before passing them into the pipeline for further
    processing.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅仅有`Where-Object` cmdlet用于过滤。许多cmdlet也具有过滤参数，这些参数要么是显式的，参数名为`-Filter`，要么是执行常见过滤任务的参数。例如，`Get-ChildItem`
    cmdlet有`-File`和`-Directory`参数，可以将输出限制为这两种对象类型中的一种。尽可能使用cmdlet的内建参数来过滤对象，再将它们传递到管道中进行进一步处理。
- en: Activity 3
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 活动 3
- en: How can we find a list of cmdlets that have a `-``Filter` parameter?
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如何找到具有`-Filter`参数的cmdlet列表？
- en: We’ve now got a pretty good grasp of how to limit the objects in the pipeline
    to just the ones we’re interested in. Next, we’ll look at how we can perform operations
    on those objects.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经相当了解如何将管道中的对象限制为我们感兴趣的对象。接下来，我们将看看如何对这些对象执行操作。
- en: Enumerating objects
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举对象
- en: 'Often, we will want to perform an operation on the objects that we’re working
    with. Most of the time, there will be a cmdlet to do this, but sometimes, there
    won’t. For instance, say we want to output the filename and path of some items
    in a folder. There is no convenient property that will produce just the filename
    and path; there are properties such as `pspath`, which will get us what we want
    and a bit extra, but nothing that gets exactly what we want. There is, however,
    a method on the objects that are produced by `Get-ChildItem` that will: `tostring()`.
    We can execute this method on each item by enumerating them, like so:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常需要对正在处理的对象执行某些操作。大多数时候，会有相应的 cmdlet 来执行这个操作，但有时也没有。例如，假设我们想输出文件夹中某些项的文件名和路径。没有一个便捷的属性可以仅输出文件名和路径；有像
    `pspath` 这样的属性，可以获取我们想要的内容，但会包含一些额外信息，并没有完全符合我们需求的属性。然而，对于 `Get-ChildItem` 返回的对象，有一个方法可以实现这一点：`tostring()`。我们可以通过枚举每个项来执行这个方法，如下所示：
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This will produce exactly the output I want, as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生我想要的完全输出，如下所示：
- en: '![Figure 3.12 – Basic enumeration](img/B17600_03_012.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.12 – 基本枚举](img/B17600_03_012.jpg)'
- en: Figure 3.12 – Basic enumeration
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.12 – 基本枚举
- en: 'This is a pretty simple example. Like `Where-Object`, `Foreach-Object` has
    basic and advanced syntax, and the advanced syntax looks very similar to what
    we saw in the previous section. You must provide a script block to the `-Process`
    parameter of `ForEach-Object`. To run the last cmdlet with the advanced syntax,
    we would type the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的示例。就像 `Where-Object` 一样，`Foreach-Object` 有基本语法和高级语法，高级语法与我们在前面部分看到的非常相似。你必须将一个脚本块提供给
    `ForEach-Object` 的 `-Process` 参数。要使用高级语法运行最后一个 cmdlet，我们需要输入以下内容：
- en: '[PRE26]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As shown in the following screenshot, the output is the same. Note that when
    using a script block, the method name, `tostring`, must be followed by an open
    and close bracket pair:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如下图所示，输出是相同的。请注意，当使用脚本块时，方法名 `tostring` 后面必须跟着一对括号：
- en: '![Figure 3.13 – Advanced enumeration](img/B17600_03_013.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.13 – 高级枚举](img/B17600_03_013.jpg)'
- en: Figure 3.13 – Advanced enumeration
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.13 – 高级枚举
- en: 'If the method takes arguments, then we would put them in parentheses as a comma-separated
    list, like so:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果方法需要参数，那么我们需要将它们放在括号内，并以逗号分隔，如下所示：
- en: '[PRE27]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This will correct the spelling by inserting the `''S''` string at position
    5 in the original string. We don’t see interactive enumeration as much as we used
    to, since usually, cmdlets are written to perform most of the things we might
    have wanted to enumerate interactively. However, this is an important concept
    in scripting, as we will see in [*Chapter 5*](B17600_05.xhtml#_idTextAnchor096),
    *PowerShell Control Flow – Conditionals and Loops*. There is one useful technique
    we can use it for, though – repeating a process a set number of times. Try this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这将通过在原始字符串的第 5 个位置插入 `'S'` 字符串来修正拼写。我们不再像以前那样经常看到交互式枚举，因为通常，cmdlet 会被编写来执行我们可能想要交互式枚举的大多数操作。然而，这在脚本编写中是一个重要的概念，我们将在
    [*第 5 章*](B17600_05.xhtml#_idTextAnchor096)，“*PowerShell 控制流 – 条件语句与循环*”中看到。不过，这里有一个我们可以使用它的有用技巧
    —— 重复执行某个过程指定次数。试试看：
- en: '[PRE28]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: So, in the first part of the pipeline, we are using a range operator (`..`)
    to create an array of 10 integers from 1 to 10\. We’re not using the `$PSItem`
    pipeline variable in the second cmdlet, though – we’re just instructing it to
    run once for each item in the pipeline. As you can see, we’re not limited to just
    putting object methods into the script block; we can put cmdlets and scripts in
    there too.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，在管道的第一部分，我们使用范围操作符（`..`）创建一个包含从 1 到 10 的 10 个整数的数组。在第二个 cmdlet 中，我们没有使用 `$PSItem`
    管道变量 —— 我们只是指示它对管道中的每个项运行一次。正如你所看到的，我们不仅可以在脚本块中放入对象方法；我们也可以将 cmdlet 和脚本放入其中。
- en: Parallel enumeration
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并行枚举
- en: 'One of the problems with enumeration is that it can take a very long time if
    there are a lot of objects, or if the process is complicated. With PowerShell
    7, we gained the ability to run `ForEach-Object` processes in parallel. Try running
    the following code, which will print out the numbers 1 to 10:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举的一个问题是，当对象数量很多，或者过程很复杂时，它可能需要很长时间。在 PowerShell 7 中，我们获得了并行运行 `ForEach-Object`
    进程的能力。尝试运行以下代码，它会输出从 1 到 10 的数字：
- en: '[PRE29]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As you press *Enter* after each line, you should see a continuation prompt
    until you close the curly brackets. Slow, eh? 10 seconds to print out 10 numbers.
    Now, let’s try it with parallel processing:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在每行后按 *Enter* 时，应该会看到一个继续提示，直到你关闭大括号。慢吧？打印 10 个数字要 10 秒钟。现在，让我们尝试使用并行处理：
- en: '[PRE30]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now, you should see the numbers being printed out in groups of five. We can
    alter the number of parallel processes with the `-``ThrottleLimit` parameter.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该看到数字按每五个一组打印出来。我们可以通过`-ThrottleLimit`参数来改变并行处理的数量。
- en: Now that we’ve explored some useful cmdlets for manipulating the pipeline and
    had our first taste of scripting (yes, that’s what you did just now), we will
    have a look at how the pipeline works.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经探索了一些用于操作管道的有用cmdlet，并且体验了第一次脚本编写（是的，这就是你刚才做的），接下来我们将看看管道是如何工作的。
- en: How the pipeline works – parameter binding
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管道如何工作 – 参数绑定
- en: The main difference between the output of PowerShell cmdlets and more generic
    shells is that instead of being file-like, the output is an **object**, with a
    type, properties, and methods. So, how does an object produced by one cmdlet get
    passed to another cmdlet?
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell cmdlet输出与其他通用shell的主要区别在于，它的输出不是类似文件的内容，而是一个**对象**，具有类型、属性和方法。那么，一个cmdlet生成的对象是如何传递给另一个cmdlet的呢？
- en: 'Cmdlets can only accept input via their parameters. There is no other way,
    so it follows that the output objects of one cmdlet must be fed to a parameter
    of the next cmdlet in the pipeline. Consider the following cmdlet pipeline:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Cmdlet只能通过它们的参数接受输入。没有其他方式，因此输出对象必须通过管道传递给下一个cmdlet的参数。考虑以下cmdlet管道：
- en: '[PRE31]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We can only see one parameter here, `-property`, and it’s being given an argument
    of `CPU`. So, what’s going on? `Sort-Object` is being given two parameters, but
    we can’t see one of them. This is called **pipeline** **parameter binding**.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们只看到了一个参数，`-property`，它被赋予了`CPU`的值。那么，发生了什么呢？`Sort-Object`被赋予了两个参数，但我们看不见其中一个。这就是所谓的**管道**
    **参数绑定**。
- en: PowerShell takes the output of the first cmdlet, `Get-Process`, and must do
    something with it, so it looks for a parameter on the second cmdlet that can accept
    the object that PowerShell is holding. There are two ways this can happen; `ByValue`
    and `ByPropertyName`. Let’s look at them in detail.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell将第一个cmdlet `Get-Process`的输出传递到第二个cmdlet，并且必须对其进行处理，因此它会查找第二个cmdlet中可以接受PowerShell当前持有的对象的参数。这可以通过两种方式发生：`ByValue`和`ByPropertyName`。让我们详细看看这两种方式。
- en: '`ByValue` is the default method, and PowerShell will always try that first,
    so let’s start with that.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`ByValue`是默认方法，PowerShell总是首先尝试这个方法，所以我们从这个开始。'
- en: Understanding ByValue parameter binding
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解`ByValue`参数绑定
- en: 'Let’s have a look at the help file for `Sort-Object` by typing the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过输入以下命令查看`Sort-Object`的帮助文件：
- en: '[PRE32]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Have a look through the parameters. You will see that only one parameter can
    accept objects from the pipeline: `-InputObject`. The help file has this to say
    about it:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下参数。你会看到，只有一个参数可以接受来自管道的对象：`-InputObject`。帮助文件对它有如下描述：
- en: '[PRE33]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here, we can see that it only accepts input `ByValue`, and it only accepts
    `PSObject` type input. `PSObject` is pretty broad; it means anything that is an
    object in PowerShell. So, we can use it to sort an array of numbers because they
    are objects of the `System.Int32` type, as shown in the following screenshot.
    Notice that, as described in the help file, we can’t successfully pass an array
    directly to the `-InputObject` parameter; it must go through the pipeline. If
    we try to explicitly feed it an array via the parameter, it sees a single array
    object and returns the array unsorted. We need it to pass through the pipeline
    one item at a time:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们可以看到它只接受`ByValue`输入，并且只接受`PSObject`类型的输入。`PSObject`是非常宽泛的，它意味着PowerShell中的任何对象。所以，我们可以用它来排序一个数字数组，因为它们是`System.Int32`类型的对象，如下图所示。注意，正如帮助文件中所描述的那样，我们不能直接将数组传递给`-InputObject`参数；它必须通过管道。如果我们尝试通过参数显式传递数组，它会将整个数组作为单个对象返回，并且不会排序。我们需要让它通过管道，一次传递一个项：
- en: '![Figure 3.14 – Correct and incorrect use of the -InputObject parameter](img/B17600_03_014.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.14 – 正确与错误使用`-InputObject`参数](img/B17600_03_014.jpg)'
- en: Figure 3.14 – Correct and incorrect use of the -InputObject parameter
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.14 – 正确与错误使用`-InputObject`参数
- en: 'Let’s have a look at another. We can see from the help file for `Get-ChildItem`
    that it has a parameter, `-path`, that accepts pipeline input `ByValue`, and accepts
    string objects. This means we can do something like this, where we put the `myfiles`
    string into the pipeline:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看一个。我们可以从`Get-ChildItem`的帮助文件中看到，它有一个参数`-path`，可以接受`ByValue`管道输入，并且接受字符串对象。这意味着我们可以做类似这样的事情，把`myfiles`字符串放入管道中：
- en: '[PRE34]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, we will get a meaningful output – a list of all the items in the `myfiles`
    directory. If we had a cmdlet pipeline that outputs paths as strings, we could
    feed this into `Get-ChildItem` to get the contents. The important thing to remember
    when using `ByValue` is that the type of object you are passing into the pipeline
    must match the type of object that is specified by the parameter of the next cmdlet
    that accepts pipeline input.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将得到一个有意义的输出——`myfiles` 目录中所有项目的列表。如果我们有一个输出路径作为字符串的 cmdlet 管道，我们可以将其传递给
    `Get-ChildItem` 来获取内容。使用 `ByValue` 时需要记住的重要一点是，你传递到管道中的对象类型必须与下一个接受管道输入的 cmdlet
    的参数所要求的对象类型匹配。
- en: '`Get-ChildItem` is interesting because the parameter that accepts pipeline
    input is not the `-InputObject` parameter – it’s `-path`. What happens if you
    try to pipe a string to `Get-ChildItem`, but you also explicitly specify the `-path`
    parameter? You will get an error, as shown here:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`Get-ChildItem` 很有意思，因为接受管道输入的参数不是 `-InputObject` 参数，而是 `-path`。如果你尝试将一个字符串传递给
    `Get-ChildItem`，同时又显式指定了 `-path` 参数，会发生什么？你将会得到一个错误，如下所示：'
- en: '![Figure 3.15 – Pipeline sabotage](img/B17600_03_015.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.15 – 管道破坏](img/B17600_03_015.jpg)'
- en: Figure 3.15 – Pipeline sabotage
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.15 – 管道破坏
- en: The preceding error says that there is no parameter to accept pipeline input,
    even though we know there is. This is because we bound a value to `Get-ChildItem`
    before we started processing the objects in the pipeline, effectively removing
    that parameter from those available. If we see this error, it’s always worth checking
    that we haven’t already used the parameter before we throw our laptops at the
    wall in frustration.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的错误表示没有参数可以接受管道输入，尽管我们知道有这个参数。这是因为我们在开始处理管道中的对象之前，将一个值绑定到 `Get-ChildItem`，从而有效地将该参数从可用的参数列表中移除。如果我们看到这个错误，通常需要检查是否已经使用过该参数，而不是在沮丧中将笔记本电脑扔向墙壁。
- en: 'Let’s have a look at the other method of binding pipeline content to a parameter:
    `ByPropertyName`.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下另一种将管道内容绑定到参数的方法：`ByPropertyName`。
- en: ByPropertyName parameter binding
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ByPropertyName 参数绑定
- en: PowerShell will always try to bind to a parameter `ByValue` first. It will only
    try to shoehorn the pipeline objects using `ByPropertyName` if `ByValue` is not
    available. What happens if your first cmdlet produces objects of the wrong sort
    for the `pipeline-accepting` parameter of the next cmdlet? Well, PowerShell will
    look and see if there is a parameter in the second cmdlet that accepts pipeline
    input where there is a matching property name – usually, `-Id` or `-Name`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 会首先尝试按 `ByValue` 绑定参数。如果 `ByValue` 不可用，它才会尝试使用 `ByPropertyName` 来强行绑定管道对象。如果你的第一个
    cmdlet 生成的对象类型不适合下一个 cmdlet 的 `pipeline-accepting` 参数会发生什么？PowerShell 会查看第二个 cmdlet
    是否有接受管道输入的参数，并且该参数的属性名与对象匹配——通常是 `-Id` 或 `-Name`。
- en: 'Unsurprisingly, `Stop-Process` is a cmdlet that stops processes. If we look
    at the help file, we will see that three parameters accept pipeline input:`-InputObject`,
    which accepts objects `ByValue`, and `-Id` and `-Name`, which accept `ByPropertyName`.
    Now, let’s type the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 不出所料，`Stop-Process` 是一个停止进程的 cmdlet。如果我们查看帮助文件，我们会看到三个参数接受管道输入：`-InputObject`，它接受
    `ByValue` 对象，以及 `-Id` 和 `-Name`，它们接受 `ByPropertyName`。现在，让我们输入以下内容：
- en: '[PRE35]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here, we will get an error – the same one shown in *Figure 3**.15*. We know
    that `Stop-Process` has three parameters that take pipeline input, so it’s not
    the first reason. We haven’t explicitly bound anything to any parameters either,
    so it must be because the type of object we have in the pipeline is the wrong
    sort of object. If we use `Get-Member` to determine the type of objects `Get-Random`
    produces, and then refer to the help file for `Stop-Process`, we will see that
    `Get-Random` produces `System.Int32` objects, but `Stop-Process` requires `System.Diagnostics.Process`
    objects. So, if we’ve not got the right sort of objects in our pipeline, why didn’t
    PowerShell try to do anything `ByPropertyName`? Well, it did, but none of the
    properties of the object that were output by `Get-Random` have a property name
    that matches the `-Id` or `-Name` parameters in `Stop-Process`. Let’s have some
    fun. Type the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们会遇到一个错误——与*图 3.15*中显示的错误相同。我们知道 `Stop-Process` 有三个接受管道输入的参数，因此这不是第一个原因。我们也没有显式地将任何内容绑定到参数上，因此错误一定是因为管道中的对象类型不正确。如果我们使用
    `Get-Member` 来确定 `Get-Random` 生成的对象类型，然后查阅 `Stop-Process` 的帮助文件，我们会发现 `Get-Random`
    生成的是 `System.Int32` 类型的对象，而 `Stop-Process` 需要的是 `System.Diagnostics.Process` 类型的对象。所以，如果管道中没有正确的对象类型，为什么
    PowerShell 没有尝试使用 `ByPropertyName` 呢？其实它是尝试过的，但 `Get-Random` 输出的对象的属性名称并没有与 `Stop-Process`
    中的 `-Id` 或 `-Name` 参数匹配。让我们来玩点有趣的。输入以下内容：
- en: '[PRE36]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'What are we doing there? We’re using the `New-Object` cmdlet to create a generic
    PowerShell object (`-TypeName PSObject`) with a single property, `Id`, which we
    populate by running the `Get-Random` cmdlet to produce a random number. We will
    be able to see it in the output if we pipe the cmdlet into `Get-Member`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做什么？我们使用 `New-Object` cmdlet 创建一个通用的 PowerShell 对象（`-TypeName PSObject`），并添加一个属性
    `Id`，该属性的值由运行 `Get-Random` cmdlet 生成的随机数填充。如果我们将该 cmdlet 的输出传递给 `Get-Member`，就可以看到这个属性：
- en: '![Figure 3.16 – Creating custom objects](img/B17600_03_016.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.16 – 创建自定义对象](img/B17600_03_016.jpg)'
- en: Figure 3.16 – Creating custom objects
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.16 – 创建自定义对象
- en: Once we’ve created this new custom object, we can pipe it into `Stop-Process`.
    The object type is not right, so it can’t bind to `-InputObject`, but the object
    has a property name that matches the `-Id` parameter, so it binds there. Finally,
    because we don’t want to have too much fun, we’re using the `-WhatIf` parameter,
    just in case `Get-Random` provides us with a legitimate process ID. `-WhatIf`
    is one of the common parameters available in most PowerShell cmdlets, and it tells
    us what would happen if we ran the cmdlet without actually changing anything.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了这个新的自定义对象，我们就可以将它传递给 `Stop-Process`。由于对象类型不正确，它不能绑定到 `-InputObject` 参数，但该对象有一个与
    `-Id` 参数匹配的属性名称，因此它会绑定到这个参数。最后，因为我们不想玩得太过火，所以我们使用了 `-WhatIf` 参数，以防 `Get-Random`
    给我们提供一个有效的进程 ID。`-WhatIf` 是大多数 PowerShell cmdlet 中常见的参数之一，它告诉我们如果运行该 cmdlet 而不实际更改任何内容，会发生什么。
- en: Parenthetical commands
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 括号命令
- en: A few times now, we have run cmdlets in parentheses, as we did previously. Parentheses
    are a way of overriding the order in which PowerShell runs. The same as in mathematics,
    parentheses are an instruction to do something *first*. When we use them in PowerShell,
    the content inside the parentheses must be completed before anything else in that
    segment of the pipeline is processed. This gives us another way to pass input
    directly to a parameter.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 几次之前，我们已经运行了括号中的 cmdlet，就像我们之前所做的那样。括号是一种覆盖 PowerShell 执行顺序的方式。就像数学中一样，括号是一个指令，表示*优先执行*。当我们在
    PowerShell 中使用它们时，括号中的内容必须在该管道段的其他任何内容之前完成处理。这为我们提供了另一种直接将输入传递给参数的方式。
- en: 'In the preceding example, we tried to run the following:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们尝试运行以下内容：
- en: '[PRE37]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This didn’t work. While the object type (`System.Int32`) was correct for the
    `-Id` parameter, the `PropertyName` value was incorrect. With parentheses, we
    can explicitly pass that content to the `-Id` parameter, like so:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这并没有成功。尽管对象类型（`System.Int32`）对于 `-Id` 参数来说是正确的，但 `PropertyName` 值是错误的。使用括号时，我们可以显式地将内容传递给
    `-Id` 参数，像这样：
- en: '[PRE38]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: First, PowerShell will produce a random number, and then pass it to the `-Id`
    parameter for us. We will see many more useful examples of parentheses as we go
    through this book.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，PowerShell 会生成一个随机数，然后将其传递给 `-Id` 参数。我们将在本书中看到更多括号的有用示例。
- en: Troubleshooting the pipeline – pipeline tracing
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 故障排除管道 – 管道追踪
- en: We’ve done a lot of work in this chapter, so now it’s time to kick back and
    have some fun with `Trace-Command`. At least, I think it’s fun; other opinions
    are available. This cmdlet does, however, really let us get into the nuts and
    bolts of how PowerShell works so that we get to see it in action.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们已经做了很多工作，现在是时候放松一下，和`Trace-Command`玩得开心了。至少，我觉得这很有趣；其他意见另当别论。然而，这个 cmdlet
    确实让我们深入了解 PowerShell 的工作原理，从而能够看到它的实际操作。
- en: 'Run the following code:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下代码：
- en: '[PRE39]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, we’re running `Trace-Command` and asking it to record `ParameterBinding`
    events. We’re giving it the cmdlet we ran previously as an expression in a script
    block, and then with `-PSHost`, we’re telling it to output to the screen, rather
    than its default, which is the debug stream that we saw right at the start of
    this chapter when we were talking about streams.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们运行 `Trace-Command` 并请求它记录 `ParameterBinding` 事件。我们将之前运行的 cmdlet 作为脚本块中的表达式传给它，然后通过
    `-PSHost`，我们告诉它将输出显示到屏幕，而不是其默认的调试流，正如我们在本章一开始谈论流时所看到的。
- en: 'We’ve now got a screen full of yellow writing, which is messy; we’re going
    to need to have a dig around in there. These are the questions we’re interested
    in:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们屏幕上满是黄色文字，显得很乱；我们需要仔细看看其中的内容。我们感兴趣的问题是：
- en: Where did the custom object bind?
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义对象绑定到哪里了？
- en: How did the custom object bind?
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义对象是如何绑定的？
- en: 'Here’s my output, tidied up, with comments below each line:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我的输出，整理后的版本，每一行下方有注释：
- en: '`DEBUG: BIND PIPELINE object to` `parameters: [Stop-Process]`'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DEBUG: 绑定管道对象到` `参数：[Stop-Process]`'
- en: In this line, we’re starting by binding to the parameters of `Stop-Process`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一行中，我们开始绑定到 `Stop-Process` 的参数。
- en: '`DEBUG: PIPELINE object TYPE = [``System.Management.Automation.PSCustomObject]`'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DEBUG: 管道对象类型 = [``System.Management.Automation.PSCustomObject]`'
- en: This tells us what sort of object we have in the pipeline.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们管道中的对象类型是什么。
- en: '`DEBUG: Parameter [InputObject] PIPELINE INPUT ValueFromPipeline` `NO COERCION`'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DEBUG: 参数 [InputObject] 管道输入 ValueFromPipeline` `NO COERCION`'
- en: This tells us that `-InputObject` only takes the `ByValue objects`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们，`-InputObject` 只接受 `ByValue 对象`。
- en: '`DEBUG: BIND arg [@{Id=1241688337}] to` `parameter [InputObject]`'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DEBUG: 绑定参数 [@{Id=1241688337}] 到` `参数 [InputObject]`'
- en: '`arg [1241688337]` is the random number that was generated.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`arg [1241688337]` 是生成的随机数。'
- en: '`DEBUG: Binding collection parameter InputObject: argument type [PSObject],
    parameter type [System.Diagnostics.Process[]], collection type Array, element
    type [System.Diagnostics.Process],` `no coerceElementType`'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DEBUG: 绑定集合参数 InputObject：参数类型 [PSObject]，参数类型 [System.Diagnostics.Process[]]，集合类型
    Array，元素类型 [System.Diagnostics.Process]，` `无强制元素类型`'
- en: This shows us that the object types don’t match.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示我们对象类型不匹配。
- en: '`DEBUG: BIND arg [@{Id=1241688337}] to param [``InputObject] SKIPPED`'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DEBUG: 绑定参数 [@{Id=1241688337}] 到参数 [``InputObject] 被跳过`'
- en: Here, we’re skipping binding to `-InputObject`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们跳过了对 `-InputObject` 的绑定。
- en: '`DEBUG: Parameter [Id] PIPELINE INPUT ValueFromPipelineByPropertyName` `NO
    COERCION`'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DEBUG: 参数 [Id] 管道输入 ValueFromPipelineByPropertyName` `NO COERCION`'
- en: This line shows that the `-Id` parameter accepts `ByPropertyName` `as` `input`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行显示 `-Id` 参数接受 `ByPropertyName` 作为输入。
- en: '`DEBUG: BIND arg [1241688337] to` `parameter [Id]`'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DEBUG: 绑定参数 [1241688337] 到` `参数 [Id]`'
- en: '`DEBUG: Binding collection parameter Id: argument type [Int32], parameter type
    [System.Int32[]], collection type Array, element type [System.Int32],` `no coerceElementType`'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`DEBUG: 绑定集合参数 Id：参数类型 [Int32]，参数类型 [System.Int32[]]，集合类型 Array，元素类型 [System.Int32]，`
    `无强制元素类型`'
- en: This shows us that the object types match.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示我们对象类型匹配。
- en: '`DEBUG: BIND arg [System.Int32[]] to param [``Id] SUCCESSFUL`'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DEBUG: 绑定参数 [System.Int32[]] 到参数 [``Id] 成功`'
- en: Here, we are told we have successfully bound to the `–``Id` parameter.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们得知我们已经成功绑定到 `–``Id` 参数。
- en: So, we have the answers to our questions – the object in the pipeline bound
    to the `-Id` parameter, `ByPropertyName`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们得到了问题的答案——管道中的对象绑定到了 `-Id` 参数，`ByPropertyName`。
- en: That was a whirlwind introduction to `Trace-Command`. If your pipeline is failing,
    and you are sure that your object types match, or that you have matching property
    names, and you haven’t bound something explicitly to the only parameter that accepts
    pipeline input, then this cmdlet is your best hope of understanding what’s happening.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是对 `Trace-Command` 的一个快速介绍。如果你的管道失败了，且你确信对象类型匹配，或者你确保了属性名称匹配，并且没有明确绑定到唯一接受管道输入的参数，那么这个
    cmdlet 是你了解发生了什么的最佳希望。
- en: Summary
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We covered some really interesting and quite technical topics in this chapter.
    We started by describing what the pipeline does, and then looked at techniques
    for selecting and sorting objects. We then looked at filtering objects and talked
    about the importance of using filtering to allow PowerShell to work as efficiently
    as possible.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了一些非常有趣且相当技术性的主题。我们首先描述了管道的作用，然后探讨了选择和排序对象的技巧。接着，我们讨论了过滤对象，并谈到了使用过滤功能的重要性，以便让
    PowerShell 能够高效地工作。
- en: 'From there, we introduced a topic that will be important later, enumeration,
    and looked at one of the newer features of PowerShell 7, parallel enumeration.
    In the last part of this chapter, we took a deeper dive into how the pipeline
    accomplishes its magic and examined the two methods of parameter binding: `ByValue`
    and `ByPropertyName`. Finally, we played with a cmdlet that allows us to get under
    the hood of how the pipeline is working: `Trace-Command`.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，我们引入了一个之后会很重要的主题：枚举，并探讨了 PowerShell 7 的一项新特性——并行枚举。在本章的最后部分，我们深入了解了管道如何实现其魔力，并研究了两种参数绑定方法：`ByValue`
    和 `ByPropertyName`。最后，我们玩了一下一个可以让我们深入了解管道工作原理的 cmdlet：`Trace-Command`。
- en: Most of the time, the pipeline *just works*. However, for cases when it doesn’t,
    this chapter has given us the essential knowledge we need to understand what it
    is doing and, hopefully, how to fix it. Sometimes, cmdlet authors do not provide
    a way for their cmdlets to accept pipeline input. This chapter has shown us how
    to spot that and given us one technique for working around it.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，管道*只需正常工作*。然而，对于那些不工作的情况，本章为我们提供了必要的知识，帮助我们理解管道的工作原理，并且希望能帮助我们修复问题。有时候，cmdlet
    作者没有为其 cmdlet 提供接受管道输入的方式。本章向我们展示了如何发现这一点，并给我们提供了一种解决方法。
- en: This chapter concludes the introductory part of this book on PowerShell mechanics.
    In the next chapter, we’re going to start doing some coding by looking at variables
    and data structures. Hold tight.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束了本书关于 PowerShell 工作机制的介绍部分。在下一章，我们将开始编写一些代码，重点讲解变量和数据结构。请继续关注。
- en: Exercises
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'The following are some exercises to help you solidify your knowledge of this
    chapter:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些练习，帮助你巩固本章的知识：
- en: How can we use PowerShell to display just the day of the week it is today?
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何使用 PowerShell 仅显示今天是星期几？
- en: We need to get a list of CPU usage and the locations of all our running processes,
    and we don’t want a lot of unnecessary information. How do we do that?
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要获取 CPU 使用情况和所有正在运行的进程的路径位置，并且我们不想要过多的无关信息。我们该如何操作？
- en: Now that we’ve got our list, how can we get the path names in reverse alphabetical
    order?
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了列表，如何按字母顺序反向排列路径名？
- en: There’s a lot of stuff here. How do we ensure it only lists the processes that
    have a CPU usage of greater than 5?
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里有很多内容。我们如何确保它只列出 CPU 使用率大于 5 的进程？
- en: What is the most efficient way to get a list of read-only files from our home
    drive?
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取我们主驱动器中只读文件的最有效方法是什么？
- en: We need to get the size of all the files in our home directory. We just want
    the name and the size in bytes.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要获取我们主目录下所有文件的大小。我们只需要文件名和字节大小。
- en: We have a file that contains a list of process names, called `processes.txt`.
    we need to use it to discover information about the processes on our local machine,
    so we will need to find a cmdlet that can get content from the file.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有一个包含进程名称列表的文件，名为 `processes.txt`。我们需要使用它来发现本地计算机上进程的信息，因此我们需要找到一个可以从文件中获取内容的
    cmdlet。
- en: Without *actually running the cmdlet*, what will happen if we run this without
    `-WhatIf` on a Windows host?
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果不*实际运行 cmdlet*，在 Windows 主机上如果我们在没有 `-WhatIf` 的情况下运行它会发生什么？
- en: '[PRE40]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If it’s not right, what would the right cmdlet be?
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它不正确，那么正确的 cmdlet 应该是什么？
- en: 'What would happen if we ran it on a Linux host? Tip: think about this. Don’t
    try it. Especially don’t try it without `-WhatIf`.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在 Linux 主机上运行它，会发生什么？提示：思考一下这个问题。不要尝试它，特别是在没有 `-WhatIf` 的情况下。
- en: Further reading
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'As I get older, I find the history of computing more and more fascinating;
    concepts and devices that were bleeding edge when I was in my twenties are now
    dusty old relics. However, these old relics go some way to explaining why we are
    where we are. The Unix Oral History Project has a great section on the concept
    of pipes: [https://dspinellis.github.io/oral-history-of-unix/frs122/unixhist/finalhis.htm](https://dspinellis.github.io/oral-history-of-unix/frs122/unixhist/finalhis.htm).'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我年龄的增长，我发现计算机历史变得越来越迷人；在我二十多岁时被认为是前沿的概念和设备，如今已经成为布满灰尘的旧遗物。然而，这些旧遗物在某种程度上帮助解释了我们现在所处的位置。Unix口述历史项目中有一部分内容讲解了管道的概念：[https://dspinellis.github.io/oral-history-of-unix/frs122/unixhist/finalhis.htm](https://dspinellis.github.io/oral-history-of-unix/frs122/unixhist/finalhis.htm)。
