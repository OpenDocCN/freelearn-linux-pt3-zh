- en: Streamlining Infrastructure Management with AWX
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AWX简化基础设施管理
- en: As we have discussed so far in this book, effective enterprise automation on
    Linux involves several key elements, including standardization of both tools and
    technologies, and implementing processes and tools that make the management of
    the environment more efficient. Ansible is a great first step in this journey
    and can be supplemented with a complementary technology called AWX to further
    streamline its application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本书迄今为止所讨论的，Linux上的有效企业自动化涉及几个关键要素，包括工具和技术的标准化，以及实现使环境管理更加高效的流程和工具。Ansible是这条旅程的第一步，可以通过一种名为AWX的互补技术来进一步简化其应用。
- en: 'AWX is, in short, a GUI-driven tool for the management of Ansible jobs. It
    does not replace Ansible functionality, but rather adds to it by providing a multi-user
    GUI-driven frontend that allows for the simple management and orchestration of
    playbooks. When managing large Linux environments such as those in an enterprise,
    AWX is the perfect complement to Ansible automation and is an important step in
    effective and efficient management. In this chapter, we will cover the following
    topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: AWX简而言之是一个用于管理Ansible任务的图形界面驱动工具。它并不替代Ansible的功能，而是通过提供一个多用户图形界面的前端来补充Ansible，从而简化了剧本的管理和编排。当管理像企业环境中那样的大型Linux环境时，AWX是Ansible自动化的完美补充，是实现高效管理的重要一步。在本章中，我们将涵盖以下主题：
- en: Introduction to AWX
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWX简介
- en: Installing AWX
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装AWX
- en: Running your playbooks from AWX
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从AWX运行你的剧本
- en: Automating routine tasks with AWX
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用AWX自动化常规任务
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter includes examples based on the following technologies:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括基于以下技术的示例：
- en: Ubuntu Server 18.04 LTS
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ubuntu Server 18.04 LTS
- en: CentOS 7.6
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CentOS 7.6
- en: Ansible 2.8
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible 2.8
- en: To run through these examples, you will need access to a server or virtual machine
    running one of the aforementioned operating systems and Ansible. Note that the
    examples given in this chapter may be destructive in nature (for example, they
    involve installing Docker and running services on the server) and, if run as is,
    are only intended to be run in an isolated test environment.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行这些示例，你需要访问运行上述操作系统之一和Ansible的服务器或虚拟机。请注意，本章给出的示例可能具有破坏性（例如，它们涉及在服务器上安装Docker并运行服务），如果按照原样运行，仅适合在隔离的测试环境中运行。
- en: Once you are satisfied that you have a safe environment to operate in, let's
    get started by looking at the installation of new software packages with Ansible.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确认你有一个安全的操作环境，我们就可以开始看看如何使用Ansible安装新的软件包。
- en: All example code discussed in this book is available from GitHub at: [https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux](https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中讨论的所有示例代码可从GitHub获取：[https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux](https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux)。
- en: Introduction to AWX
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AWX简介
- en: AWX sets out to solve the problems associated with Ansible automation in an
    enterprise environment. To maintain our hands-on focus, let's consider the organic
    growth scenario we discussed in [Chapter 1](c7596fb8-4971-44d7-943a-7660c5eecb17.xhtml),
    *Building a Standard Operating Environment on Linux*. In a small environment where
    Ansible has been implemented, you might have just one or two key people responsible
    for writing and running playbooks against the environment. In this small scenario,
    it is reasonably easy to know who has run which playbooks and what the latest
    versions are, and the training requirements for Ansible are low as only a small
    number of key people are responsible for its use.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: AWX旨在解决在企业环境中使用Ansible自动化所面临的问题。为了保持我们的实践焦点，让我们考虑一下我们在[第1章](c7596fb8-4971-44d7-943a-7660c5eecb17.xhtml)中讨论的有机增长场景，*在Linux上构建标准操作环境*。在一个已经实现了Ansible的小型环境中，可能只有一到两个人负责编写和运行剧本。在这个小型场景中，了解谁运行了哪些剧本以及最新版本是什么相对容易，而且Ansible的培训需求较低，因为只有少数关键人员负责使用它。
- en: As the environment scales to enterprise sizing, so do the number of Ansible
    operators. If all of those responsible for running Ansible have it installed on
    their own machines, and all have local copies of the playbooks, suddenly the management
    of that environment becomes a nightmare! How can you ensure that everyone is using
    the latest versions of the playbooks? How do you know who ran what and what the
    outcome was? What if a change needs to be run out of hours? Can you pass the Ansible
    job off to a **Network Operations Center **(**NOC**) team, or is that not possible
    because they would need training on how to use Ansible?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 随着环境规模的扩大，Ansible 操作员的数量也会增加。如果所有负责运行 Ansible 的人都在自己的机器上安装了它，并且每个人都有本地的 playbook
    副本，突然之间，管理这个环境就变成了一场噩梦！你如何确保每个人都在使用最新版本的 playbook？你怎么知道是谁运行了什么，结果是什么？如果需要在非工作时间执行某个变更怎么办？你能将
    Ansible 作业交给 **网络运营中心**（**NOC**）团队吗？还是说不行，因为他们需要接受 Ansible 使用培训？
- en: AWX sets out to address all of these challenges, as we shall see subsequently,
    starting in the next section, where we look at how AWX can reduce your staff training
    costs.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: AWX 旨在解决所有这些挑战，正如我们接下来将看到的那样，从下一节开始，我们将讨论 AWX 如何帮助降低员工培训成本。
- en: AWX reduces training requirements
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AWX 降低了培训需求
- en: 'Ansible is very easy to get up and running. It still needs a little training,
    though. For example, IT admins and operators who haven''t received training may
    not be comfortable with running a playbook on the command line. This is demonstrated
    in the following example. Although fairly simple in Ansible terms, anyone unfamiliar
    with the tool will find that it isn''t very user-friendly:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 非常容易上手。不过，它仍然需要一些培训。例如，未接受过培训的 IT 管理员和操作员可能不习惯在命令行上运行 playbook。以下示例演示了这一点。虽然从
    Ansible 的角度来看这个过程相当简单，但任何不熟悉这个工具的人都会发现，它并不十分友好：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Although it isn't a complex command, those unfamiliar with it might be reluctant
    to run it for fear of causing damage to production systems, let alone interpret
    the pages of output that a sizeable playbook can produce.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这不是一个复杂的命令，但那些不熟悉它的人可能会因为害怕对生产系统造成损害而不愿意执行，更不用说解读一个大型 playbook 可能产生的输出内容了。
- en: To alleviate this, AWX provides a web GUI-based interface that is quite literally
    point and click. Although many advanced features can be used by those familiar
    with it, a playbook can be run with literally a few clicks of the mouse, and the
    results are shown using a simple *traffic light* system (red indicating that the
    playbook run failed, while green shows that it passed). In this way, AWX provides
    an interface from which even those with no prior Ansible experience can launch
    a playbook and pass the results on to another team for analysis.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了缓解这一问题，AWX 提供了一个基于 Web GUI 的界面，字面意思就是点击即可使用。虽然熟悉该工具的用户可以使用许多高级功能，但通过鼠标点击几下就可以运行
    playbook，结果将通过一个简单的 *交通信号灯* 系统展示（红色表示 playbook 运行失败，而绿色表示成功）。通过这种方式，AWX 提供了一个接口，使得即使是没有
    Ansible 使用经验的人也能够启动 playbook，并将结果传递给其他团队进行分析。
- en: AWX offers benefits for security teams and managers too, by logging detailed
    results of all actions and jobs performed, and we shall provide an overview of
    this in the next section.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: AWX 也为安全团队和管理者提供了好处，通过记录所有执行的操作和作业的详细结果，下一节中我们将提供对此的概述。
- en: AWX enables auditability
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AWX 使审计变得可能
- en: Although the Ansible command-line tools provide logging options, these are not
    enabled by default and as a result, the run output of playbooks can be lost as
    soon as a terminal session is closed. This is not great in an enterprise scenario,
    particularly when an issue or outage occurs and a root cause analysis is required.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Ansible 命令行工具提供了日志选项，但这些选项默认是禁用的，因此，一旦终端会话关闭，playbook 的运行输出可能会丢失。在企业环境中，这并不理想，特别是在出现问题或故障时，进行根本原因分析是必需的。
- en: AWX addresses this in two ways. First of all, every user must log in to the
    GUI before any actions can be performed. AWX can integrate with centralized accounting
    systems such as LDAP or Active Directory, or users can be defined locally on the
    AWX host. All actions in the UI are then tracked, and as such, it is possible
    to trace back playbook runs to specific users and indeed configuration changes.
    In an enterprise environment, this level of accountability and this kind of audit
    trail is a *must-have*.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: AWX通过两种方式解决了这个问题。首先，所有用户在执行任何操作之前必须登录GUI。AWX可以与集中式会计系统（如LDAP或Active Directory）集成，或者用户可以在AWX主机上本地定义。然后，所有UI中的操作都会被跟踪，因此，可以将剧本运行追溯到特定用户，甚至配置更改。在企业环境中，这种级别的问责制和审计追踪是*必不可少*的。
- en: Beyond this, AWX captures all of the output of every playbook run, along with
    key pieces of information such as which inventory the playbook was run against,
    what variables were passed to it (if any), and the date and time of the run. This
    means that if an issue occurs, AWX can provide a complete audit trail to help
    you find out what happened and when.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，AWX会捕获每次剧本运行的所有输出，以及一些关键信息，例如剧本运行的清单、传递给它的变量（如果有的话）以及运行的日期和时间。这意味着如果发生问题，AWX可以提供完整的审计追踪，帮助你找出发生了什么以及发生的时间。
- en: Not only can AWX assist with auditing your automation, but it can also help
    with ensuring version control of your playbooks, as we shall discuss in the next
    section.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: AWX不仅可以帮助审计你的自动化，还可以帮助确保剧本的版本控制，我们将在下一节中详细讨论这一点。
- en: AWX supports version control
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AWX支持版本控制
- en: In an enterprise scenario, individuals storing playbooks locally could be a
    problem waiting to happen. For example, if user A updates a playbook with a critical
    fix, how do you ensure that user B has access to that code? Ideally, the code
    should be stored in a version control system (for example, GitHub) and the local
    copy updated for every single run.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业场景中，个人将剧本存储在本地可能会导致潜在的问题。例如，如果用户A更新了包含关键修复的剧本，如何确保用户B能够访问到该代码？理想情况下，代码应存储在版本控制系统中（例如，GitHub），并且每次运行时本地副本都会更新。
- en: Good processes are an important component of enterprise automation of Linux
    and while user B should update their local playbooks before running them, you
    cannot enforce this. Again, AWX addresses this issue by allowing playbooks to
    be sourced from a version control repository, with the local copy of the playbooks
    on the AWX server being updated automatically.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的流程是Linux企业自动化的重要组成部分，尽管用户B在运行剧本之前应更新本地剧本，但你无法强制执行这一点。同样，AWX通过允许剧本从版本控制仓库中获取来解决这个问题，AWX服务器上的本地剧本副本会自动更新。
- en: Although AWX can help you, especially when it comes to ensuring the latest version
    of code has been pulled from the repository, it cannot help with other errant
    behaviors such as someone not committing their code in the first place. The intention,
    however, of enforcing the use of AWX for Ansible playbook runs is that anyone
    who makes changes must commit them for AWX to run them. Local access to the AWX
    server should be tightly restricted to prevent people from making code changes
    on the local filesystem, and in this way, you can have confidence that everyone
    is actively and effectively using your version control system.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管AWX可以帮助你，特别是在确保从仓库拉取最新版本的代码时，但它无法帮助解决其他错误行为，例如有人根本没有提交代码。然而，强制使用AWX来执行Ansible剧本的目的是：任何做出更改的人都必须提交这些更改，AWX才能运行它们。应严格限制本地访问AWX服务器，以防止人们在本地文件系统上修改代码，通过这种方式，你可以确信每个人都在积极有效地使用版本控制系统。
- en: These updates can be event-driven so that, for example, local playbooks can
    be updated every single time a playbook from that store is run. They can also
    be updated on a scheduled basis or manually, as per the decisions of the AWX administrators.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更新可以是事件驱动的，例如，当从该存储库运行剧本时，本地剧本每次都会更新。它们也可以按照AWX管理员的决策，定期更新或手动更新。
- en: AWX can help with the security of your automation too. We shall explore this
    in the next section by looking at credential management in AWX.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: AWX还可以帮助你确保自动化的安全性。我们将在下一节中通过查看AWX中的凭证管理来探讨这一点。
- en: AWX helps with credential management
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AWX有助于凭证管理
- en: For Ansible to effectively manage an Enterprise Linux environment, it must have
    some form of credentials to access all of the servers it is managing. SSH authentication
    is normally secured with either SSH keys or passwords, and in a large team of
    Ansible operators, this can mean everyone has access to those passwords and SSH
    private keys since they are required for Ansible to be run. Needless to say, this
    presents a security risk!
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 Ansible 有效地管理企业 Linux 环境，它必须具有某种形式的凭证来访问它所管理的所有服务器。SSH 认证通常使用 SSH 密钥或密码进行保护，在一个大型的
    Ansible 操作员团队中，这意味着每个人都可能访问这些密码和 SSH 私钥，因为它们是运行 Ansible 所必需的。不言而喻，这带来了安全风险！
- en: As stated previously, from a security standpoint, this is less than desirable
    as it would be too easy for someone to copy and paste credentials and use them
    in a manner for which they were not intended. AWX also handles this by storing
    required credentials in its database, encrypted with a passphrase chosen at installation
    time. The GUI stores all the credentials using reversible encryption so that they
    can be passed to Ansible when playbooks are run later on. However, the GUI does
    not let you see any previously entered sensitive data (such as passwords or SSH
    private keys)—that is to say that they can be entered and changed, but you cannot
    show a password or SSH key in the GUI, and hence operators can't easily make use
    of the AWX frontend to obtain credential information for use elsewhere. In this
    way, AWX helps enterprises keep their credentials under lock and key and ensures
    that they are only used for Ansible deployments and are not leaked or used for
    any other unintended purposes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，从安全角度来看，这种做法并不理想，因为别人可以轻易地复制并粘贴凭证，将其用于未经授权的方式。AWX 通过将所需的凭证存储在数据库中，并使用安装时选择的密码短语加密，来处理这个问题。GUI
    使用可逆加密存储所有凭证，以便在稍后运行 playbook 时将它们传递给 Ansible。然而，GUI 不允许你查看任何以前输入的敏感数据（例如密码或 SSH
    私钥）——也就是说，凭证可以输入和更改，但你无法在 GUI 中显示密码或 SSH 密钥，因此操作员无法轻松通过 AWX 前端获取凭证信息以供其他用途。通过这种方式，AWX
    帮助企业将凭证锁定保管，并确保它们仅用于 Ansible 部署，避免泄露或被用于其他非预期目的。
- en: Ansible Vault is an excellent tool for encrypting any sensitive data that a
    playbook needs to operate on, be that for playbook data in the form of variables
    or storing server credentials themselves, such as an SSH private key. Although
    Vault is highly secure, it is easy to see the vault contents if you have the vault
    password (here, you would need to run a playbook that uses the Vault). As a result,
    AWX provides unique functionality to supplement Ansible and ensure security in
    an enterprise environment.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible Vault 是一个出色的工具，用于加密 playbook 操作时需要的任何敏感数据，无论是作为变量形式的 playbook 数据，还是存储服务器凭证本身，例如
    SSH 私钥。尽管 Vault 非常安全，但如果你拥有 Vault 密码（在这里，你需要运行使用 Vault 的 playbook），仍然可以查看 Vault
    内容。因此，AWX 提供了独特的功能，以补充 Ansible 并确保企业环境中的安全性。
- en: In these ways, AWX helps to address many of the challenges that enterprises
    face when deploying Ansible in a large-scale environment. Before we complete this
    section of this chapter, we will touch very briefly on how AWX can help you to
    integrate with other services.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些方式，AWX 帮助解决企业在大规模环境中部署 Ansible 时面临的许多挑战。在我们完成本章的这一部分之前，我们将简要讨论 AWX 如何帮助你与其他服务进行集成。
- en: Integrating AWX with other services
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 AWX 与其他服务集成
- en: There is a myriad of tools that AWX can integrate with—for example, both Red
    Hat's Satellite 6 and CloudForms products (and their open source Katello and ManageIQ
    counterparts) provide native integration with both AWX and Ansible Tower. These
    are just two examples, and this is all possible because everything that we will
    explore as we progress through this chapter is also accessible through an API
    and a command-line interface.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: AWX 可以与各种工具集成——例如，Red Hat 的 Satellite 6 和 CloudForms 产品（及其开源版本 Katello 和 ManageIQ）都提供与
    AWX 和 Ansible Tower 的原生集成。这只是两个示例，而所有这些都可能实现，因为我们将在本章中探索的所有内容也可以通过 API 和命令行界面访问。
- en: This enables AWX to be integrated with a wide variety of services, or you could
    even write your own that would run a playbook from AWX as a result of some other
    action, just by calling the API. The command-line interface (called `tower-cli`,
    after the commercial Ansible Tower product) is also incredibly useful, especially
    when it comes to programmatically populating data in AWX. For example, if you
    wanted to add a host to a static inventory, you could do this through the web
    user interface (as we shall demonstrate later), the API, or using the CLI. The
    latter two methods lend themselves incredibly well to integration with other services—for
    example, a **Configuration Management Database** (**CMDB**) could push new hosts
    into an inventory using the API, without the need for any manual action by the
    user.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得 AWX 可以与各种服务进行集成，或者您甚至可以编写自己的服务，通过调用 API 来运行 AWX 的 playbook，从而响应某些其他操作。命令行界面（称为
    `tower-cli`，来源于商业产品 Ansible Tower）也非常有用，尤其是在程序化地向 AWX 填充数据时。例如，如果您想将一个主机添加到静态清单中，您可以通过
    Web 用户界面（稍后我们会演示）、API 或使用 CLI 来完成。后两种方法非常适合与其他服务集成——例如，**配置管理数据库**（**CMDB**）可以通过
    API 将新主机推送到清单中，无需用户手动操作。
- en: 'To explore these two integration points further, you can refer to the following
    official documentation sources:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 若要进一步探索这两个集成点，您可以参考以下官方文档来源：
- en: The AWX API is documented here: [https://docs.ansible.com/ansible-tower/latest/html/towerapi/index.html](https://docs.ansible.com/ansible-tower/latest/html/towerapi/index.html).
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWX API 的文档可以在此查看：[https://docs.ansible.com/ansible-tower/latest/html/towerapi/index.html](https://docs.ansible.com/ansible-tower/latest/html/towerapi/index.html)。
- en: The `tower-cli` command is documented here: [https://tower-cli.readthedocs.io/en/latest/](https://tower-cli.readthedocs.io/en/latest/).
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tower-cli` 命令的文档可以在此查看：[https://tower-cli.readthedocs.io/en/latest/](https://tower-cli.readthedocs.io/en/latest/)。'
- en: Given the wide and varied nature of such integrations, they are beyond the scope
    of this book—however, it is important to mention them here because it is hoped
    that, as you read this chapter, you will see opportunities for integration with
    other services and hence be able to explore this topic further. In the next section
    of this chapter, we shall get hands-on with AWX and look at a simple deployment.
    Later in this chapter, this will be followed up with some example use cases.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于这类集成的广泛性和多样性，超出了本书的讨论范围——然而，提到这些集成点很重要，因为希望在阅读本章时，您会看到与其他服务集成的机会，从而能够进一步探索这一主题。本章的下一部分，我们将实际操作
    AWX，并查看一个简单的部署。稍后本章将通过一些示例用例进行补充。
- en: Installing AWX
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 AWX
- en: Installing AWX is a straightforward affair once you put the right prerequisites
    in place. In fact, one of the prerequisites for AWX is Ansible, proving the complementary
    nature of this technology. Most of the AWX code runs in a set of Docker containers,
    which makes it straightforward to deploy in most Linux environments.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了正确的前提条件，安装 AWX 就非常简单。事实上，AWX 的一个前提条件是 Ansible，证明了这项技术的互补性。大多数 AWX 代码运行在一组
    Docker 容器中，这使得它在大多数 Linux 环境中都能轻松部署。
- en: 'The use of Docker containers means that it is possible to run AWX in OpenShift
    or other Kubernetes environments—however, for the sake of simplicity here, we
    will get started by installing it on a single Docker host. Before you proceed
    any further, you should ensure that your chosen host has the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Docker 容器意味着可以在 OpenShift 或其他 Kubernetes 环境中运行 AWX——然而，为了简便起见，我们将在单一 Docker
    主机上开始安装。在继续之前，您应该确保所选主机具备以下条件：
- en: Docker, fully installed and working
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker，完全安装并正常工作
- en: The `docker-py` module for your version of Python
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您版本的 Python 的 `docker-py` 模块
- en: Access to Docker Hub (internet access)
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问 Docker Hub（需要互联网访问）
- en: Ansible 2.4 or newer
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible 2.4 或更高版本
- en: Git 1.8.4 or newer
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git 1.8.4 或更高版本
- en: Docker Compose
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Compose
- en: 'These prerequisites are normally readily available for most Linux systems.
    Now, we will perform the following steps to begin our installation:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这些前提条件通常在大多数 Linux 系统中都可以轻松获得。现在，我们将执行以下步骤开始我们的安装：
- en: 'Continuing our example of the Ubuntu system we used in the previous chapter,
    we will run the following command to install the AWX requirements:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续我们在上一章中使用的 Ubuntu 系统示例，我们将运行以下命令来安装 AWX 所需的依赖：
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once these have been installed, the next task is to clone the AWX code from
    its repository on GitHub:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装这些之后，接下来的任务是从 GitHub 上的仓库克隆 AWX 代码：
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The Git tool will faithfully clone the latest and greatest version of the AWX
    source code—note that this project is under active development and there is a
    possibility that the latest release might have bugs in it.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Git 工具将忠实地克隆 AWX 源代码的最新版本—请注意，该项目正在积极开发中，最新发布版本可能存在错误。
- en: If you want to clone one of the stable AWX releases, browse the Releases section
    of the repository and check out the desired version: [https:/​/​github.​com/ansible/​awx/​releases](https://github.com/ansible/awx/releases).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想克隆稳定的 AWX 发行版之一，请浏览存储库的 Releases 部分并检出所需版本：[https:/​/​github.​com/ansible/​awx/​releases](https://github.com/ansible/awx/releases).
- en: 'We have cloned the repository, and it is now time for us to define the configuration
    for our installation of AWX, especially security details such as a password. To
    get started on this, change into the `installer` directory under the cloned repository:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经克隆了存储库，现在是时候为我们的 AWX 安装定义配置了，特别是安全细节如密码。要开始此过程，请切换到克隆存储库下的 `installer` 目录：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Hopefully, the contents of this directory will look familiar to you after reading
    the previous chapter. There is an `inventory` file, a playbook for us to run called `install.yml`, and
    a `roles/` directory. However, don't go and run the `install.yml` playbook just
    yet as there are some variables in the inventory file that we must set before
    we proceed.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 希望在阅读前一章节后，您对此目录的内容已经感到熟悉。这里有一个 `inventory` 文件，一个我们要运行的 playbook 叫做 `install.yml`，还有一个
    `roles/` 目录。但在运行 `install.yml` playbook 之前，请注意清单文件中还有一些变量需要设置。
- en: 'If you take a look through the inventory file, you will see there is a great
    deal of configuration that can occur inside it. Some variables are commented out,
    while others are set to default values. There is a minimum of six variables that
    I recommend that you set before installing AWX, and these are as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看清单文件，您会看到其中有大量的配置可供设置。一些变量被注释掉，而其他变量则设置为默认值。在安装 AWX 之前，我建议您至少设置六个变量，具体如下：
- en: '| **Variables name** | **Recommended value** |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| **变量名** | **推荐值** |'
- en: '| `admin_password` |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `admin_password` |'
- en: This is the default password for the admin user—you will need this the first
    time you log in, so be sure to set it to something memorable and secure!
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是管理员用户的默认密码—第一次登录时需要它，所以请务必将其设置为易于记忆且安全的内容！
- en: '|'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `pg_password` |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `pg_password` |'
- en: This is the password for the backend PostgreSQL database—be sure to set it to
    something unique and secure.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这是后端 PostgreSQL 数据库的密码—请确保将其设置为独特且安全的内容。
- en: '|'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `postgres_data_dir` |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `postgres_data_dir` |'
- en: This is the directory on the local filesystem where the PostgreSQL container
    will store its data—it defaults to a directory under `/tmp`, which, on most systems,
    will be automatically cleaned up regularly. This often destroys the PostgreSQL
    database, so set it to something AWX-specific (for example, `/var/lib/awx/pgdocker`).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本地文件系统上 PostgreSQL 容器存储其数据的目录—它默认位于 `/tmp` 下的一个目录，在大多数系统上会定期自动清理。这通常会销毁 PostgreSQL
    数据库，因此请将其设置为 AWX 特定的目录（例如，`/var/lib/awx/pgdocker`）。
- en: '|'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `project_data_dir` |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `project_data_dir` |'
- en: For uploading playbooks manually to AWX without the need for a version control
    system, the playbooks must sit somewhere on the filesystem. To prevent having
    to copy them into a container, this variable maps the local folder specified to
    the required one inside a container. For the examples in this book, we will use
    the default (the `/var/lib/awx/projects` folder).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 若要手动上传 Playbooks 到 AWX 而无需使用版本控制系统，则 Playbooks 必须位于文件系统的某个位置。为了避免复制到容器中，此变量将本地指定的文件夹映射到容器内所需的文件夹。在本书的示例中，我们将使用默认的
    (`/var/lib/awx/projects` 文件夹)。
- en: '|'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `rabbitmq_password` |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `rabbitmq_password` |'
- en: This is the password for the backend RabbitMQ service—be sure to set it to something
    unique and secure.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是后端 RabbitMQ 服务的密码—请确保将其设置为独特且安全的内容。
- en: '|'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `secret_key` |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `secret_key` |'
- en: This is the secret key used to encrypt credentials in the PostgreSQL database.
    It must be the same between upgrades of AWX, so be sure to store it somewhere
    secure as it will need to be set in future AWX inventories. Make this something
    long and secure.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用于加密 PostgreSQL 数据库凭据的秘钥。在 AWX 升级之间必须保持一致，所以请确保将其存储在安全的地方，因为将来需要在 AWX 的清单中设置它。请设置一个又长又安全的内容。
- en: '|'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: You will observe that in this inventory file there is a great deal of secret
    information that is in plaintext. While we can tolerate this for the duration
    of the installation process, this file should not be left lying around on the
    filesystem when the installation is complete as it could give a potential attacker
    all of the details they need to easily compromise your systems. Once the installation
    phase is complete, be sure to either copy this file into a password manager of
    some kind or simply store the individual passwords—either way, do not leave the
    file unencrypted!
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会发现，在这个清单文件中有大量的秘密信息以明文形式显示。虽然在安装过程中我们可以容忍这一点，但安装完成后，不应该把这个文件留在文件系统上，因为它可能为潜在攻击者提供获取系统详细信息的途径，进而轻易地破坏你的系统。安装阶段完成后，务必将此文件复制到某种密码管理器中，或者将单独的密码存储起来——无论哪种方式，都不要将文件以未加密形式存放！
- en: 'Once the inventory is customized, it is time to run the installation itself—this
    is launched by running the following command:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦清单被自定义，就可以开始执行安装过程——通过运行以下命令启动安装：
- en: '[PRE4]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'From our work on Ansible in the previous chapter, you will recognize this command—it
    is using the `ansible-playbook` command to run the `install.yml` playbook, while
    also using the inventory file called `inventory` that we edited in *step 1*. Pages
    of output will pass by in the Terminal, and if the installation is successful,
    you should see something like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们在上一章关于Ansible的工作中，你会认识到这个命令——它使用`ansible-playbook`命令来运行`install.yml`剧本，同时也使用我们在*步骤1*中编辑的名为`inventory`的清单文件。终端中将会输出很多内容，如果安装成功，你应该能看到类似这样的信息：
- en: '![](img/dee5a8b0-d9cf-4bee-9b6f-9548214848c6.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dee5a8b0-d9cf-4bee-9b6f-9548214848c6.png)'
- en: 'Once the installation completes, it takes a few minutes for the Docker containers
    to actually start up and for the backend database to be created. However, once
    this is done, you should be able to navigate to the IP address of your chosen
    AWX host in your browser and see the login page, an example of which is shown
    in the following screenshot:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，Docker容器需要几分钟才能启动，后台数据库也需要一些时间来创建。然而，一旦完成，你应该能够在浏览器中导航到所选AWX主机的IP地址，并看到登录页面，下面的截图展示了一个示例：
- en: '![](img/7caaf347-b763-4d94-bc54-66c73f41c063.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7caaf347-b763-4d94-bc54-66c73f41c063.png)'
- en: 'Log in as the admin user using the password you set in the `admin_password`
    variable in the inventory file earlier. You should then be taken to the dashboard
    page of AWX:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你之前在清单文件中的`admin_password`变量设置的密码，以管理员身份登录。登录后，你将被带到AWX的仪表板页面：
- en: '![](img/e060d907-ecc2-4090-9e63-c63983ad2840.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e060d907-ecc2-4090-9e63-c63983ad2840.png)'
- en: That's it—you have successfully installed and logged in to AWX! Of course, there
    are many more advanced installation parameters you can define, and equally, in
    an enterprise, you would not rely on just a single AWX host with no backup (or
    high availability).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样——你已经成功安装并登录到AWX了！当然，你可以定义更多的高级安装参数，而且在企业环境中，你也不应该只依赖单个AWX主机而没有备份（或高可用性）。
- en: Note that when you log in to AWX, the connection is not SSL-secured, which could
    result in sensitive data such as machine credentials being transmitted over your
    network in the clear.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当你登录AWX时，连接没有使用SSL加密，这可能导致敏感数据（如机器凭证）以明文形式通过网络传输。
- en: There is no one solution to out-of-the-box high availability and SSL issues
    that will suit every enterprise, and so we leave the actual solution for this
    as an exercise for you. For example, if you have an OpenShift environment with
    multiple hosts, then installing AWX in this environment will enable it to keep
    running, even if the host it runs on fails. There are of course ways to achieve
    high availability without OpenShift too.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 没有一种适合所有企业的现成高可用性和SSL解决方案，因此我们将实际解决方案留给你作为练习。例如，如果你有一个包含多个主机的OpenShift环境，那么在该环境中安装AWX可以确保即使运行AWX的主机发生故障，它也能继续运行。当然，也有方法可以在没有OpenShift的情况下实现高可用性。
- en: Applying secure HTTP to AWX is also going to be solved in a different manner
    in different environments. Most Docker environments will have some kind of load
    balancer in front of them to help to handle their multi-host nature, and as a
    result, the SSL encryption could be offloaded onto this. It is also possible to
    secure a single Docker host, such as the one we have built here, but installing
    something capable of reverse proxying (for example, nginx) and configuring that
    to handle the SSL encryption.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 将安全HTTP应用于AWX的解决方法会因不同的环境而异。大多数Docker环境前面会有某种负载均衡器来帮助处理其多主机特性，因此，SSL加密可能会卸载到负载均衡器上。也可以通过安装能够进行反向代理的软件（例如nginx）并配置它来处理SSL加密，从而保护单个Docker主机，例如我们在这里构建的那个。
- en: In short, there is no one-size-fits-all solution to this, but it is recommended
    that you address these in the manner best suited to your enterprise. For this
    reason, we will not discuss them further here, other than to recommend that you
    take them into account when deploying AWX for production use.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，这并没有统一的解决方案，但建议你根据自己企业的需求采取最合适的方法。因此，我们在此不再进一步讨论它们，只建议你在为生产环境部署AWX时考虑这些问题。
- en: Now that you have an AWX instance running, we must configure it so that we can
    successfully replicate how we ran playbooks from the command line in the previous
    chapter. For example, we must define an inventory just as we did previously and
    ensure we have set up SSH authentication so that Ansible can perform the automated
    tasks on the remote computer. In the next part of this chapter, we will walk through
    all of the setup that's required to run your first playbook through AWX.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了一个运行中的AWX实例，我们必须对其进行配置，以便我们能够成功地复现上一章中从命令行运行剧本的方式。例如，我们必须像之前那样定义一个库存，并确保我们已设置SSH身份验证，以便Ansible可以在远程计算机上执行自动化任务。在本章的下一部分，我们将演示运行第一个剧本所需的所有设置。
- en: Running your playbooks from AWX
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从AWX运行剧本
- en: When we ran an example playbook from the command line, we created our inventory
    file and then our playbook and then ran it using the `ansible-playbook` command.
    All of this, of course, assumed that we had already set up connectivity to the
    remote system by way of either specifying a password interactively or through
    the setup of SSH keys.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从命令行运行示例剧本时，我们创建了库存文件，然后是剧本，并使用`ansible-playbook`命令运行它。所有这些，当然，假设我们已经通过交互式输入密码或设置SSH密钥的方式与远程系统建立了连接。
- en: Although the end result in AWX is very similar—playbooks are run against an
    inventory—the terminology and naming are rather different. In this part of this
    chapter, we will walk through the process of getting your first playbook up and
    running from AWX. Although we don't have space in this book to give a complete
    rundown on every feature AWX has to offer, this section intends to give you sufficient
    knowledge and confidence to start managing your playbooks from AWX, and to explore
    further on your own.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管AWX中的最终结果非常相似——剧本是针对库存运行的——但术语和命名方式却有很大不同。在本章的这一部分，我们将演示如何通过AWX启动并运行第一个剧本。虽然本书没有足够的篇幅详细介绍AWX的每个功能，但本节旨在让你具备足够的知识和信心，从AWX管理剧本，并进一步探索。
- en: Before you can run your first playbook from AWX, there are several prerequisite
    setup stages that must be completed. In the next section, we will complete the
    first of these—creating the credentials that will be used to authenticate over
    SSH with our target machine.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在你能够从AWX运行第一个剧本之前，必须完成几个前置设置步骤。在接下来的部分中，我们将完成其中的第一个——创建将用于通过SSH与目标机器进行身份验证的凭据。
- en: Setting up credentials in AWX
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在AWX中设置凭据
- en: 'When you log in to AWX, you will notice a menu bar down the left-hand side
    of the screen. To define a new set of credentials that we will use to allow Ansible
    to log into our target machine, perform the following steps:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当你登录到AWX时，你会注意到屏幕左侧有一个菜单栏。为了定义一组新的凭据，我们将用它来让Ansible登录到我们的目标机器，执行以下步骤：
- en: Click on Credentials in the left-hand menu bar.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击左侧菜单栏中的 Credentials。
- en: Click on the green + icon to create a new credential.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击绿色的 + 图标以创建新的凭据。
- en: Give the credential a name and select Machine from the CREDENTIAL TYPE field.
    There are many types of credentials that enable AWX to interact with a wide variety
    of services, but for now, we are only interested in this particular type.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给凭据起个名字，并从 CREDENTIAL TYPE 字段中选择 Machine。AWX 支持许多类型的凭据，可以与各种服务交互，但目前我们只关注这一类型。
- en: There are many other fields available for specifying parameters for more advanced
    use cases—however, for our demonstration purposes, this is sufficient.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还有许多其他字段可以用于指定更高级的参数，但对于我们的演示来说，这些已经足够。
- en: 'Your end result should look something like the following screenshot. Note that
    I have specified the login password for my demo machine, but you could equally
    have specified the SSH private key in the larger text box on the screen. You will
    also observe the presence of the Prompt on launch checkbox—there are many options
    in AWX that it can prompt the user for at the time a playbook is run, which can
    lend itself to a really rich interactive user experience. However, in this demo,
    we won''t do this as we want to demonstrate playbooks running without user intervention:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你的最终结果应类似于下面的截图。请注意，我已经为我的示范机器指定了登录密码，但你也可以在屏幕上的较大文本框中指定 SSH 私钥。你还会看到 Prompt
    on launch 复选框的存在—AWX 有许多选项，可以在运行 playbook 时提示用户，这能提供丰富的交互式用户体验。不过，在本示例中，我们不会使用这个选项，因为我们希望演示无需用户干预即可运行
    playbook：
- en: '![](img/4ff1346b-bb6c-46e1-9298-1f9ac3d128ce.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4ff1346b-bb6c-46e1-9298-1f9ac3d128ce.png)'
- en: When you have a credential defined, the next step is to define the inventory
    to run our playbook against. We'll explore this in the next section.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 定义凭据后，下一步是定义库存来运行我们的 playbook。我们将在下一节中详细探讨。
- en: Creating inventories in AWX
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 AWX 中创建库存
- en: Just like on the command line, AWX requires an inventory to be created for playbooks
    to be executed against. Here, we are going to make use of one of the official,
    publicly available Ansible example playbooks, which requires an inventory with
    two groups in it. In a larger setup, we would specify a different server for each
    group, but for this small demo, we can reuse the same server for both roles.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在命令行一样，AWX 需要创建一个库存，才能执行 playbook。在这里，我们将使用一个官方的、公开可用的 Ansible 示例 playbook，它需要一个包含两个组的库存。在更大的设置中，我们会为每个组指定不同的服务器，但在这个小型示例中，我们可以重复使用同一台服务器作为两个角色。
- en: The code in question is used to install a simple LAMP stack on an RHEL or CentOS
    7 machine and is available to view here: [https://github.com/ansible/ansible-examples/tree/master/lamp_simple_rhel7](https://github.com/ansible/ansible-examples/tree/master/lamp_simple_rhel7).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 相关代码用于在 RHEL 或 CentOS 7 机器上安装一个简单的 LAMP 堆栈，可以在这里查看：[https://github.com/ansible/ansible-examples/tree/master/lamp_simple_rhel7](https://github.com/ansible/ansible-examples/tree/master/lamp_simple_rhel7)。
- en: 'To run this demo, you will need a CentOS 7 machine. My demo host is called `centos-testhost`,
    and if I were defining an inventory file on the command line, it would look like
    this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行这个示例，你需要一台 CentOS 7 机器。我的示例主机叫做 `centos-testhost`，如果我在命令行定义一个库存文件，它看起来会是这样的：
- en: '[PRE5]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To replicate this in the AWX GUI, run through the following sequence:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 AWX 图形界面中复制此操作，请按照以下步骤执行：
- en: Click on Inventories on the left-hand menu bar.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧菜单栏点击 Inventories。
- en: Click on the green + icon to create a new inventory.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击绿色的 + 图标来创建一个新的库存。
- en: Select Inventory from the drop-down menu.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下拉菜单中选择 Inventory。
- en: Give the inventory a suitable name and click SAVE.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给库存起个合适的名字，然后点击 SAVE。
- en: 'Your screen should look something like the one shown here once you have completed
    this process:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此过程后，屏幕应显示如下所示：
- en: '![](img/bed15396-0309-4519-a742-e4bb04628a76.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bed15396-0309-4519-a742-e4bb04628a76.png)'
- en: 'When complete, we can create our first group and put our test host into it.
    To do this, follow these steps:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们可以创建第一个组，并将我们的测试主机加入其中。按照以下步骤操作：
- en: Click on the GROUPS button at the top of the pane.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击窗格顶部的 GROUPS 按钮。
- en: Click the green + icon to create a new group.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击绿色的 + 图标来创建一个新的组。
- en: Enter the name `webservers` into the NAME field.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 NAME 字段中输入名称 `webservers`。
- en: Click the green SAVE button.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击绿色的 SAVE 按钮。
- en: Click the HOSTS button at the top.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击顶部的 HOSTS 按钮。
- en: Click the green + icon button to add a new host.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击绿色的 + 图标按钮来添加一个新主机。
- en: Select New Host from the drop-down list.
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下拉列表中选择 New Host。
- en: Enter the name `centos-testhost` into the HOST NAME field.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 HOST NAME 字段中输入名称 `centos-testhost`。
- en: Click the green SAVE button.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击绿色的 SAVE 按钮。
- en: 'Once you have completed these steps, your screen should look something like
    the following screenshot:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成了这些步骤，屏幕应该像下面的截图一样：
- en: '![](img/9e74477c-6284-4e84-ad09-055599012176.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9e74477c-6284-4e84-ad09-055599012176.png)'
- en: Repeat this process to define the `dbservers` group. Take care not to create
    this group as a subgroup of the `webservers` group, which is easy to do. You will
    note the breadcrumb trail at the top of the preceding screenshot—use that to navigate
    back to the top level of our new inventory by clicking on `Hands on Inventory` (or
    your name, if you chose a different one).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 重复这个过程来定义 `dbservers` 组。小心不要把这个组创建为 `webservers` 组的子组，这是很容易犯的错误。你会注意到前面截图顶部的面包屑路径——通过点击 `Hands
    on Inventory` （或你的名字，如果你选择了不同的名称），你可以用它来返回到新库存的顶级页面。
- en: 'From here, the process is almost identical, except that when you come to adding
    the host to the newly created group (*step 6* onward from the preceding steps),
    choose Existing Hostas we are reusing our single host for both groups in this
    example. Your resulting screen should look something like the following screenshot:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，过程几乎相同，唯一的不同是，当你开始将主机添加到新创建的组时（从前面的步骤第*6步*开始），选择 Existing Host，因为我们在这个示例中为两个组复用了同一台主机。你最终的屏幕应该像下面的截图一样：
- en: '![](img/ca729358-47ce-4211-b682-4546efb81a52.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ca729358-47ce-4211-b682-4546efb81a52.jpg)'
- en: With those steps complete, our inventory complete with groupings is complete
    in AWX, and we can move on to the next stage in defining our configuration—the
    creation of an AWX project. We will do exactly this in the next section of this
    chapter.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些步骤后，我们的库存和分组就已经在 AWX 中完成了，我们可以继续下一步，定义我们的配置——创建 AWX 项目。我们将在本章的下一节中详细介绍这部分内容。
- en: Creating a project in AWX
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 AWX 中创建项目
- en: If you were working with Ansible on the command line, it is unlikely you would
    store all of your playbooks and roles in one directory for very long as it would
    get unmanageable and very difficult to work out which file was which. This is
    the purpose of a project in AWX—it is quite simply a logical grouping of playbooks
    and is used to make organization easier and simpler.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在命令行中使用 Ansible，可能不太会将所有的 playbook 和角色存储在一个目录下太长时间，因为这样会变得难以管理，并且很难判断哪个文件是哪个。这就是
    AWX 中项目的目的——它简单来说就是 playbook 的逻辑分组，用来让组织变得更加简单和清晰。
- en: Although we will not go into **Role-Based Access Control** (**RBAC**) in this
    book, projects also serve a role in this. In the screenshots provided so far,
    you may have noticed a PERMISSIONS button at the top of a number of the panes.
    These are present throughout the UI and are used to define which users have access
    to which configuration items. For example, if you have a team of **Database Administrators**
    (**DBAs**) who should only have access to run playbooks relevant to database servers
    against those servers, you could create an inventory of database servers and only
    give the DBAs access to this. Similarly, you could put all of the DBA-related
    playbooks into one project, and again only give that team permission to access
    that project. In this way, AWX forms a part of the good processes inside an enterprise,
    both making Ansible more accessible, and ensuring that the right items are only
    available to the correct people.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在本书中不会深入讨论 **基于角色的访问控制** (**RBAC**)，项目在这方面也起着重要作用。在迄今为止提供的截图中，你可能注意到在多个面板的顶部有一个
    PERMISSIONS 按钮。这些按钮遍布整个 UI，用于定义哪些用户可以访问哪些配置项。例如，如果你有一个 **数据库管理员** (**DBA**) 团队，他们只需要有权运行与数据库服务器相关的
    playbooks，你可以创建一个数据库服务器的库存，并仅允许 DBAs 访问它。同样，你可以将所有与 DBA 相关的 playbook 放入一个项目中，并且再次仅给该团队访问该项目的权限。通过这种方式，AWX
    作为企业内部良好流程的一部分，既让 Ansible 更加易于访问，又确保了只有正确的人可以访问到正确的项目。
- en: 'To continue our simple example, let''s create a new project to reference our
    example Ansible code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了继续我们的简单示例，让我们创建一个新项目来引用我们的示例 Ansible 代码：
- en: Click on Projects on the left-hand menu bar.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击左侧菜单栏中的 Projects。
- en: Click on the green + icon to create a new project.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击绿色的 + 图标 以创建一个新项目。
- en: Give the project a suitable name.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给项目起一个合适的名称。
- en: Select Git from the SCM TYPE drop-down list.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 SCM TYPE 下拉列表中选择 Git。
- en: Enter the following URL into the SCM URL field: [https://github.com/ansible/ansible-examples.git](https://github.com/ansible/ansible-examples.git).
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 SCM URL 字段中输入以下 URL： [https://github.com/ansible/ansible-examples.git](https://github.com/ansible/ansible-examples.git)。
- en: Optionally, you could also populate the SCM BRANCH/TAG/COMMIT field if you wanted
    to only work with a specific commit or branch in the repository. In this simple
    example, we will use the latest commit, known in Git as **HEAD**.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，如果你只想在仓库中的特定提交或分支上工作，也可以填写 SCM BRANCH/TAG/COMMIT 字段。在这个简单的示例中，我们将使用最新的提交，即在
    Git 中被称为**HEAD**。
- en: No other credentials are necessary as this is a publicly available GitHub example—however,
    if you were using a password-protected repository, you would create an SCM credential
    to the machine credential we created in the *Setting up credentials in AWX* section
    of this chapter.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这是一个公开可用的 GitHub 示例，因此不需要其他凭据——然而，如果你使用的是受密码保护的仓库，你需要为我们在本章 *设置 AWX 中的凭据*
    部分创建一个 SCM 凭据。
- en: Check the UPDATE REVISION ON LAUNCH checkbox—this causes AWX to pull the latest
    version of the code from our SCM URL every time a playbook from this project is
    run. If this is unchecked, you must manually update the local copy of the code
    before AWX will see the latest version.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 勾选 UPDATE REVISION ON LAUNCH 复选框——这会导致 AWX 在每次运行该项目的 playbook 时，从我们的 SCM URL
    拉取最新的代码版本。如果未勾选此选项，则必须在 AWX 看到最新版本之前手动更新本地代码副本。
- en: Click on the green SAVE button.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击绿色的 SAVE 按钮。
- en: 'When complete, the resulting screen should look something like the following
    screenshot:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，结果页面应该类似于以下截图：
- en: '![](img/8d443141-ad17-4f37-a99e-c3400ce628df.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8d443141-ad17-4f37-a99e-c3400ce628df.png)'
- en: 'Before we can proceed to the final step of configuring our playbook for its
    first run, we need to manually pull the contents from the GitHub repository. To
    do this, click on the two semicircular arrows to the right of your newly created
    project—this forces a manual sync of the project from the upstream repository.
    An example of this is shown in the following screenshot for your reference:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入配置 playbook 以进行首次运行的最后一步之前，我们需要手动从 GitHub 仓库拉取内容。为此，点击新创建项目右侧的两个半圆形箭头——这将强制从上游仓库手动同步项目。以下截图展示了这个操作，供你参考：
- en: '![](img/dc1aba58-056f-4006-bdda-739c1be74faf.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dc1aba58-056f-4006-bdda-739c1be74faf.png)'
- en: The green dot to the left of the project title (as seen in the preceding screenshot)
    will pulsate during the sync. Once this completes successfully, it will turn a
    static green, whereas if something goes wrong, it will turn red. Assuming all
    is well, we can proceed to the final stage of preparing to run our playbook.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 项目标题左侧的绿色圆点（如前面的截图所示）将在同步过程中闪烁。当同步成功完成时，它会变为静态绿色；如果出现问题，则会变为红色。假设一切正常，我们可以继续进行准备运行
    playbook 的最后一步。
- en: With our project defined in AWX, the next task required as we head toward running
    our first playbook from it is to create a template, and we will do exactly that
    in the next section.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在 AWX 中定义好项目后，接下来的任务是创建模板，为从该项目运行我们的第一个 playbook 做准备，接下来我们将正好完成这一任务。
- en: Creating a template in AWX
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 AWX 中创建模板
- en: Templates in AWX pull together all of the other configuration items you have
    created so far—in essence, a template is the AWX definition of all of the parameters
    you would specify on the command line following the `ansible-playbook` command.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: AWX 中的模板汇集了你目前已创建的所有其他配置项——本质上，模板是 AWX 对你在命令行中执行 `ansible-playbook` 命令时所指定的所有参数的定义。
- en: 'Let''s walk through the process of creating a template so that we can run our
    playbook:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步步走过创建模板的过程，以便能够运行我们的 playbook：
- en: Click on Templates on the left-hand menu bar.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧菜单栏中点击 Templates。
- en: Click on the green + icon to create a new template.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击绿色的 + 图标创建一个新模板。
- en: Select Job Template from the drop-down list.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下拉列表中选择 Job Template。
- en: Give the template a suitable name.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给模板起一个合适的名称。
- en: In the INVENTORY field, select the inventory we created earlier in this chapter.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 INVENTORY 字段中，选择我们在本章中创建的清单。
- en: In the PROJECT field, select the project we created earlier.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 PROJECT 字段中，选择我们之前创建的项目。
- en: In the PLAYBOOK field, note that the drop-down list has automatically been populated
    with a list of all of the viable playbooks that are available in the GitHub repository
    we specified in our PROJECT definition. Choose `lamp_simple_rhel7/site.yml` from
    the list.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 PLAYBOOK 字段中，注意下拉列表已自动填充了我们在 PROJECT 定义中指定的 GitHub 仓库中所有可用的 playbook 列表。从中选择
    `lamp_simple_rhel7/site.yml`。
- en: Finally, select the credential we defined earlier in the CREDENTIAL field.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在 CREDENTIAL 字段中选择我们之前定义的凭据。
- en: Click the green SAVE button.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击绿色的 SAVE 按钮。
- en: 'The end result should look something like the following screenshot, which shows
    all of the fields filled in:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果应该像下图所示，展示了所有字段都已填写的情况：
- en: '![](img/d70ecb42-2c66-4ec7-a4e1-062c91d779ff.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d70ecb42-2c66-4ec7-a4e1-062c91d779ff.png)'
- en: With those steps complete, we have now completed everything required to run
    our first ever job from AWX. Hence, we shall proceed to do exactly that in the
    next section and observe the results.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些步骤后，我们已经完成了运行第一个 AWX 作业所需的一切。因此，我们将在下一节继续执行这一操作并观察结果。
- en: Running a playbook from AWX
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 AWX 运行 playbook
- en: When we run a playbook from AWX, what we're actually doing is running a template.
    Hence, to do this interactively, we will navigate our way back to the Templates
    screen, which should present a list of available templates. Note that when you
    are employing role-based access control, you can only see the templates (and inventories
    and other configuration items) that you have permission to see—if you don't have
    permission, it is invisible. This helps make AWX more manageable when using it
    across different teams.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从 AWX 运行 playbook 时，实际上是在运行一个模板。因此，为了交互式操作，我们需要返回到模板屏幕，在这里可以看到可用模板的列表。请注意，当你使用基于角色的访问控制时，你只能看到你有权限查看的模板（以及清单和其他配置项）——如果你没有权限，它们将不可见。这有助于在不同团队间使用
    AWX 时使其更加易于管理。
- en: 'We are using an administrator account, so we can see everything. To launch
    our newly created template, follow these instructions:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的是管理员账户，所以可以看到所有内容。要启动我们新创建的模板，请按照以下说明操作：
- en: 'Click on the rocket ship icon on the right of the template name, as shown in
    the following screenshot, which shows our newly created Templates with the option
    to execute it highlighted:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击模板名称右侧的火箭图标，如下图所示，展示了我们新创建的模板，并高亮显示了执行该模板的选项：
- en: '![](img/b1b13551-3177-4e92-a149-87416697561a.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b1b13551-3177-4e92-a149-87416697561a.png)'
- en: When you do this, the screen automatically reloads and you will see details
    of the run on your screen. Don't worry if you navigate away from this—you can
    always find it again later by clicking on Jobs on the left-hand menu bar. Since
    we have defined this job, it fails in the first instance. Luckily, the Jobs pane
    shows you all of the same details and output that you would get when you run Ansible
    from the command line, only in AWX, it is archived in the database so that you
    can always go back to it at a later date or so that another user can analyze it
    simply by logging into AWX (assuming they have the required permissions).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行此操作时，屏幕会自动重新加载，并且你将看到运行的详细信息。不要担心如果你离开此页面——你始终可以稍后通过点击左侧菜单栏上的“Jobs”来再次找到它。由于我们已经定义了这个作业，第一次运行时它会失败。幸运的是，作业面板会显示你在命令行运行
    Ansible 时看到的所有相同的详细信息和输出，只是在 AWX 中，这些信息被存档在数据库中，你可以随时回溯它，或者其他用户可以通过登录 AWX（假设他们有相应的权限）来分析它。
- en: 'Looking at the job output, we can see the problem is some kind of permissions
    issue, and a screenshot showing what this might look like is shown for your reference:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从作业输出中，我们可以看到问题是某种权限问题，下面显示了一张截图，供您参考：
- en: '![](img/1c1d28ac-d66c-41ec-9999-8872caf5f667.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1c1d28ac-d66c-41ec-9999-8872caf5f667.png)'
- en: 'Taking a look at the playbook source code on GitHub, we can see that the original
    author hardcoded the use of the root user account for this playbook (note the `remote_user:
    root` statements in `site.yml`). Normally, you wouldn''t do this—it is generally
    better practice to get Ansible to log in using an unprivileged account, and then
    to use `sudo` as required by putting the `become: true` statement in the play
    headers (we''ll see this in action later in this book).'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '查看 GitHub 上的 playbook 源代码，我们可以看到原作者在此 playbook 中硬编码了使用 root 用户账户（请注意 `site.yml`
    中的 `remote_user: root` 语句）。通常情况下，你不会这样做——更好的做法是让 Ansible 使用非特权账户登录，然后在需要时通过在 play
    头部添加 `become: true` 语句来使用 `sudo`（稍后我们会在本书中看到这个操作）。'
- en: 'To work around this, for now, we''ll simply allow root logins over SSH on our
    CentOS 7 server, and then modify the credential in AWX to be for the root account.
    Note that you could also define a new credential and change the credential linked
    to the template—either are acceptable solutions. Once you have changed the credential,
    run the template again—this time, the output should look somewhat different, as
    we can see in the following screenshot, which is showing now a successful run
    of the playbook:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了绕过这个问题，目前我们将允许在 CentOS 7 服务器上通过 SSH 进行 root 登录，然后在 AWX 中修改凭证以使用 root 账户。请注意，你也可以定义一个新凭证并更改与模板相关联的凭证——这两种方案都可以接受。更改凭证后，再次运行模板——这次，输出应该看起来有所不同，正如我们在以下截图中看到的，这显示了
    playbook 的成功运行：
- en: '![](img/d03368a4-488b-44fe-a351-31194a819cc8.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d03368a4-488b-44fe-a351-31194a819cc8.png)'
- en: As we can see from the preceding screenshot, we have a successful playbook run,
    along with all of the relevant details about which user launched it, which revision
    on GitHub was used, which credentials were used, which inventory, and so on. Scrolling
    down this pane gives the output from `ansible-playbook` that we saw in the error
    screenshot previously; if we wish to, we can further analyze the playbook run
    to see whether there were any warnings, what was changed, and so on. Hence, with
    AWX we really achieve a nice simple user interface to Ansible, which integrates
    all of the good practices that should be present when automating Linux in an enterprise
    environment such as security, auditability, and centralized control of Ansible
    (and indeed playbook code through source control integration).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从前面的截图中看到的，我们已经成功运行了 playbook，并且获得了所有相关的细节信息，包括哪个用户启动了它、使用了 GitHub 上的哪个修订版本、使用了哪些凭证、使用了哪个库存等等。向下滚动此面板可以看到我们在之前错误截图中看到的
    `ansible-playbook` 输出；如果我们愿意，还可以进一步分析 playbook 的运行情况，查看是否有任何警告、哪些内容被更改等。因此，通过
    AWX，我们真正实现了一个简洁的 Ansible 用户界面，集成了自动化 Linux 的企业环境中应该具备的所有最佳实践，如安全性、可审计性和 Ansible
    的集中控制（通过源代码控制集成，甚至是 playbook 代码的集中控制）。
- en: We have seen how AWX can assist us with running tasks manually—but what if we
    want a truly *hands-off* approach to task automation? We will explore scheduling
    tasks in the next section of this chapter.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到 AWX 如何帮助我们手动运行任务——但是如果我们想要真正的*无人干预*的任务自动化呢？我们将在本章的下一节探讨任务调度。
- en: Automating routine tasks with AWX
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 AWX 自动化例行任务
- en: Although there are many facets to AWX that would require much more space than
    we have in this book, one particular one stands out—the automation of routine
    tasks. Routine tasks that Ansible could handle might include patching of servers,
    running some kind of compliance check or audit, or enforcing a security policy.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 AWX 具有许多方面需要更大的篇幅来讨论，但其中有一项特别突出——例行任务的自动化。Ansible 可以处理的例行任务可能包括服务器的打补丁、运行某种合规性检查或审计，或者执行安全策略。
- en: For example, you could write an Ansible playbook to ensure that the SSH daemon
    does not allow remote root logins as this is considered a good security practice.
    It is, of course, easy for any system administrator with root privileges to log
    in and turn this back on; however, running an Ansible playbook regularly to turn
    this off enforces it and ensures no-one (well-meaning or otherwise) turns it back
    on. The idempotent nature of Ansible changes means that where the configuration
    is already in place, Ansible will not make any changes, and hence running the
    playbook is safe, light on system resources, and non-disruptive.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以编写一个 Ansible playbook，确保 SSH 守护进程不允许远程 root 登录，因为这是一个良好的安全实践。当然，任何具有 root
    权限的系统管理员都可以登录并重新启用这一功能；然而，定期运行 Ansible playbook 来关闭这个功能，可以强制执行这一策略，并确保没有人（无论动机如何）会重新启用它。Ansible
    的幂等性意味着，如果配置已经到位，Ansible 不会做任何更改，因此运行 playbook 是安全的，且对系统资源消耗小，不会中断系统。
- en: If you wanted to do this with Ansible on the command line, you would need to
    create a cron job to run the `ansible-playbook` command regularly, along with
    all of the required parameters. This would mean having the SSH private keys installed
    on the server handling the automation, and means you have to keep track of which
    servers are running Ansible on a routine basis. This is not ideal for an enterprise
    where good practice is the byword of automation and ensures that everything keeps
    running smoothly.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在命令行中使用 Ansible 做到这一点，你需要创建一个 cron 任务，定期运行 `ansible-playbook` 命令，并且包含所有必需的参数。这意味着需要在处理自动化的服务器上安装
    SSH 私钥，并且需要跟踪哪些服务器定期运行 Ansible。这对于一个以良好实践为自动化标杆并确保一切顺利运行的企业来说并不理想。
- en: Luckily, AWX can help us out here, too. To keep this example concise, we will
    reuse the LAMP stack example from the previous section of this chapter. In this
    scenario, we might want to schedule a one-off installation of the LAMP stack for
    a time when things are quiet, whereas for a routine task, it would be on an ongoing
    basis.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，AWX 也能在这里帮上忙。为了简洁起见，我们将重用本章前面部分中的 LAMP 堆栈示例。在这种情况下，我们可能希望在安静时段安排一次性安装 LAMP
    堆栈，而对于常规任务，则会选择持续性计划。
- en: 'To set a schedule for this template, follow these steps:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要为此模板设置计划，请按照以下步骤操作：
- en: Click on Templates on the left-hand menu bar.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击左侧菜单栏中的 Templates。
- en: Click on the template we created earlier.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击我们之前创建的模板。
- en: Click on the SCHEDULES button at the top of the pane.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击窗格顶部的 SCHEDULES 按钮。
- en: Click on the green + icon to add a new schedule to it.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击绿色的 + 图标 以添加一个新的计划。
- en: Set the appropriate start date and time—I will set mine a few minutes from now
    to demonstrate it in action.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置适当的开始日期和时间——为了演示，我将把时间设置为几分钟后。
- en: Also, set the appropriate timezone.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同时，设置适当的时区。
- en: Finally, select the REPEAT FREQUENCY—in this example, I will choose None (run
    once), but note that other ongoing options are available from the drop-down list.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，选择 REPEAT FREQUENCY——在这个例子中，我将选择 None（运行一次），但请注意，从下拉列表中还可以选择其他持续性的选项。
- en: Click on the green SAVE button to activate the schedule.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击绿色的 SAVE 按钮以激活该计划。
- en: 'When you have completed the preceding steps, the resulting configuration screen
    should look something like the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成上述步骤时，生成的配置屏幕应该类似于以下内容：
- en: '![](img/0e8be2b3-313f-472a-8063-4aa45aa11664.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0e8be2b3-313f-472a-8063-4aa45aa11664.png)'
- en: 'Now, if you watch the Jobs pane, you should see your template start to run
    at the scheduled time. When you analyze the completed (or indeed running) job,
    you should see that it was launched by the name of the schedule you created earlier,
    rather than by the name of a user account such as admin (as we saw when we launched
    it manually). A screenshot is provided here that shows an example of a completed
    job that was launched by our Scheduled install schedule that we created earlier
    in this section:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你观察作业窗格，你应该能看到模板在预定时间开始运行。当你分析已完成（或正在运行的）作业时，你应该会看到它是由你之前创建的计划名称启动的，而不是由像
    admin 这样的用户帐户启动的（就像我们手动启动时看到的那样）。以下截图展示了一个已完成的作业示例，它是由我们在本节中创建的计划安装计划启动的：
- en: '![](img/1941ebd7-ea00-422f-acbe-ec9d7827b5d0.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1941ebd7-ea00-422f-acbe-ec9d7827b5d0.png)'
- en: 'If you want to see all scheduled jobs that are forthcoming on your AWX instance,
    you can simply click on the Schedules menu item on the left-hand menu bar, and
    a screen will load that lists all configured schedules in your AWX instance. For
    those of you familiar with Linux administration, this is akin to listing cron
    jobs. An example of such a screen is shown in the following screenshot:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看所有即将到来的计划任务，可以点击左侧菜单栏中的 Schedules 菜单项，屏幕将加载并列出所有在 AWX 实例中配置的计划任务。如果你熟悉
    Linux 管理，这类似于列出 cron 任务。以下截图展示了这样一个屏幕的示例：
- en: '![](img/684bd26f-4715-4940-8223-a963b250e95f.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/684bd26f-4715-4940-8223-a963b250e95f.png)'
- en: This gives you a concise overview of all of the schedules you have created,
    without having to go into the individual configuration items themselves to edit
    them.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这为你提供了一个简洁的概述，展示了你创建的所有计划，而无需进入各个配置项进行编辑。
- en: In this way, AWX supports not just interactive automation of your Linux environment,
    but also hands-off scheduled automation tasks too, hence increasing the power
    and flexibility of your automation solution.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，AWX 不仅支持交互式自动化 Linux 环境，还支持无人值守的定时自动化任务，从而增强了自动化解决方案的能力和灵活性。
- en: It is hoped that this overview gives you an idea of the benefits that a tool
    such as AWX or Ansible Tower can bring to your enterprise, and why it is beneficial
    to supplement your Ansible automation with this.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这个概述能让你了解 AWX 或 Ansible Tower 这样的工具能为你的企业带来哪些好处，以及为什么将 Ansible 自动化与这些工具结合使用是有益的。
- en: Summary
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小结
- en: Ansible offers a great deal of power with just a small amount of learning, yet
    when deployed at a large scale in an enterprise, it can become more difficult
    to keep track of everything, especially which users have the latest versions of
    playbook code and who ran what playbook when. AWX supplements Ansible in the enterprise
    by bringing with it key benefits such as role-based access control, auditability,
    integrated source control management of playbook code, secure credential management,
    and job scheduling. It achieves this while providing an easy to use point and
    click interface, which further lowers the barrier to entry for all staff responsible
    for the Linux environment.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 只需少量学习就能提供强大的功能，但当在企业中大规模部署时，管理所有内容变得更加困难，尤其是要追踪哪些用户拥有最新版本的 playbook
    代码，谁在何时运行了什么 playbook。AWX 通过带来一些关键功能，如基于角色的访问控制、可审计性、playbook 代码的集成源代码管理、安全的凭据管理和作业调度，来补充
    Ansible 在企业中的应用。它在提供易于使用的点选界面的同时，还进一步降低了所有负责 Linux 环境的员工的入门门槛。
- en: In this chapter, you learned why AWX is important to an Enterprise Linux environment
    and how to leverage a number of its key features. You then carried out a hands-on
    installation of a single AWX node before completing a practical end-to-end example
    of running a playbook directly from GitHub to install a LAMP stack on a CentOS
    7 server. Finally, you learned about job scheduling to automate routine maintenance
    tasks using Ansible.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学习了 AWX 对企业 Linux 环境的重要性以及如何利用其一些关键功能。接着，你进行了单个 AWX 节点的实际安装，并完成了从 GitHub
    直接运行 playbook 在 CentOS 7 服务器上安装 LAMP 堆栈的实践端到端示例。最后，你学习了作业调度，以便使用 Ansible 自动化日常维护任务。
- en: In the next chapter, we will look at the different deployment methodologies
    that are relevant to an Enterprise Linux environment and how to leverage these.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将探讨与企业 Linux 环境相关的不同部署方法，以及如何利用这些方法。
- en: Questions
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is a key advantage of using AWX to store your credentials over the methods
    available to you on the command line?
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 AWX 存储凭据相较于命令行方法的一个关键优势是什么？
- en: Why is it important to make good use of a version control system such as Git
    to store your playbooks?
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么充分利用版本控制系统（如 Git）存储 playbooks 变得如此重要？
- en: How is AWX advantageous over Ansible on the command line when it comes to dynamic
    inventories?
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在动态清单方面，AWX 相对于命令行的 Ansible 有哪些优势？
- en: What is a project in AWX?
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: AWX 中的项目是什么？
- en: What is a template in AWX analogous to on the command line?
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: AWX 中的模板在命令行上类似于什么？
- en: How does AWX tell you which commit to a Git repository a playbook run was performed
    against?
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: AWX 如何告诉你，playbook 运行时是对 Git 仓库的哪个提交进行的？
- en: Why is it advisable to restrict access to the server that hosts AWX, especially
    the shell and local filesystem?
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么建议限制对托管 AWX 的服务器的访问，特别是对 shell 和本地文件系统的访问？
- en: If you need to programmatically launch playbook runs, how can AWX help you?
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你需要通过编程方式启动 playbook 运行，AWX 如何帮助你？
- en: Further reading
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入阅读
- en: For an in-depth understanding of Ansible including AWX, please refer to *Mastering
    Ansible, Third Edition* by* James Freeman* and *Jesse Keating* ([https://www.packtpub.com/gb/virtualization-and-cloud/mastering-ansible-third-edition](https://www.packtpub.com/gb/virtualization-and-cloud/mastering-ansible-third-edition)).
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要深入了解 Ansible，包括 AWX，请参阅*《精通 Ansible，第 3 版》*，作者是*James Freeman* 和*Jesse Keating*（[https://www.packtpub.com/gb/virtualization-and-cloud/mastering-ansible-third-edition](https://www.packtpub.com/gb/virtualization-and-cloud/mastering-ansible-third-edition)）。
- en: To achieve a greater understanding of version control with Git and best practices
    associated with its use, please refer to *Git Best Practices Guide* by* Eric Pidoux*
    ([https://www.packtpub.com/application-development/git-best-practices-guide](https://www.packtpub.com/application-development/git-best-practices-guide)).
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要深入了解 Git 版本控制及其使用的最佳实践，请参阅*《Git 最佳实践指南》*，作者是*Eric Pidoux*（[https://www.packtpub.com/application-development/git-best-practices-guide](https://www.packtpub.com/application-development/git-best-practices-guide)）。
- en: To understand how to access and work with the AWX API, please refer to [https://docs.ansible.com/ansible-tower/latest/html/towerapi/index.html](https://docs.ansible.com/ansible-tower/latest/html/towerapi/index.html).
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解如何访问并使用AWX API，请参考[https://docs.ansible.com/ansible-tower/latest/html/towerapi/index.html](https://docs.ansible.com/ansible-tower/latest/html/towerapi/index.html)。
- en: If you wish to explore the control of AWX with the `tower-cli` tool, please
    refer to the official documentation here: [https://tower-cli.readthedocs.io/en/latest/](https://tower-cli.readthedocs.io/en/latest/).
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你希望探索如何使用`tower-cli`工具控制AWX，请参考官方文档：[https://tower-cli.readthedocs.io/en/latest/](https://tower-cli.readthedocs.io/en/latest/)。
