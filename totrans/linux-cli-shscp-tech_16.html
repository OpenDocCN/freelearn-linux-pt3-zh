<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer272">
			<h1 id="_idParaDest-360"><em class="italic"><a id="_idTextAnchor367"/>Chapter 16</em>: Shell Script Examples for Server Management, Network Configuration, and Backups</h1>
			<p>Now that we've covered everything that we wanted to cover in terms of various concepts and structures in Bash shell scripting, let's dig into some examples. This will allow us to put these last few chapters to good use as shell scripts are the most commonly used tools in system engineers' daily jobs. Due to this, we are going to go through some shell scripts to emphasize the point of scripting – to make our lives a lot easier.</p>
			<p>In this chapter, we're going to cover the following recipes:</p>
			<ul>
				<li>Creating a file and folder inventory</li>
				<li>Checking if you're running as root</li>
				<li>Displaying server stats</li>
				<li>Finding files by name, ownership, or content type and copying them to a specified directory</li>
				<li>Parsing date and time data</li>
				<li>Configuring the most common firewall settings interactively (<strong class="source-inline">firewalld</strong> and <strong class="source-inline">ufw</strong>)</li>
				<li>Configuring network settings interactively (<strong class="source-inline">nmcli</strong>)</li>
				<li>Backing up the current directory with shell script arguments and variables</li>
				<li>Creating a current backup based on the user input for the backup source and destination</li>
			</ul>
			<h1 id="_idParaDest-361"><a id="_idTextAnchor368"/>Technical requirements </h1>
			<p>Let's continue using our Ubuntu machine, specifically the <strong class="source-inline">cli1</strong> machine. If you've not started it up yet, please start it now so that we can go through our examples. We will use the <strong class="source-inline">cli2</strong> CentOS machine for a few recipes as well, so make sure that you start that one when the time comes.</p>
			<h1 id="_idParaDest-362"><a id="_idTextAnchor369"/>Creating a file and folder inventory</h1>
			<p>Let's start with something basic – a script that reports in terms of folder and file inventory. As<a id="_idIndexMarker1078"/> simple as this is, this type of script can use a variety of different tools, including commands, built-in CLI applications, loops – there are a lot of choices to be made. We're going to do this in the simplest way possible – by taking advantage of our knowledge of commands and CLI applications. We're going to create a couple of different versions of this script as it can be used in a variety of different ways – for example, as input into future shell scripts or as plain text reporting tools.</p>
			<h2 id="_idParaDest-363"><a id="_idTextAnchor370"/>How to do it…</h2>
			<p>Let's start by creating a script that's just going to tell us the following:</p>
			<ul>
				<li>The number of folders in the current folder and their sizes, sorted by size in descending order</li>
				<li>The number of files in the current folder and their size, sorted by size in descending order</li>
			</ul>
			<p>Here's the first version of our script – we saved it as a file called <strong class="source-inline">sscript1.sh</strong>:</p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code"># V1.0 / Jasmin Redzepagic / 01/11/2021 Initial script version </p>
			<p class="source-code"># Distribution allowed under GNU Licence V2.0</p>
			<p class="source-code">echo "Number of directories in current directory is:"</p>
			<p class="source-code">find . -type d | wc -l</p>
			<p class="source-code">echo "Directory usage, sorted in descending order, is as follows:"</p>
			<p class="source-code">find . -type d | du | sort -nr</p>
			<p class="source-code">echo "Number of files in current directory is:"</p>
			<p class="source-code">find . -type f | wc -l</p>
			<p class="source-code">echo "File usage, sorted in descending order, is as follows:"</p>
			<p class="source-code">find . -type f -exec ls -al {} \; | sort -k 5 -nr | sed 's/ \+/\t/g' | cut -f5,9</p>
			<p>As we can see, we <a id="_idIndexMarker1079"/>only used basic commands here, without going into a lot of looping, actual programming, and so on. Let's treat this as a reporting script and go from there.</p>
			<p>On our <strong class="source-inline">cli1</strong> machine, this was the result:</p>
			<div>
				<div id="_idContainer265" class="IMG---Figure">
					<img src="Images/Figure_16.1_B16269.jpg" alt="Figure 16.1 – First version of our folder and file inventory script&#13;&#10;" width="1163" height="1150"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.1<a id="_idTextAnchor371"/> – First version of our folder and file inventory script</p>
			<p>This is working and <a id="_idIndexMarker1080"/>can be used for reports – yep, that's all good. But what happens if we want some more functionality? What if we were to use the first version of this script to generate a .<strong class="source-inline">txt</strong> file that contains lists of files in the current directory, modify it a little bit, and then use this file for something else, such as to copy those files to a pre-configured location?</p>
			<p>We would need to make<a id="_idIndexMarker1081"/> some adjustments, as follows:</p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code"># V1.0 / Jasmin Redzepagic / 01/11/2021 Initial script version </p>
			<p class="source-code"># Distribution allowed under GNU Licence V2.0 </p>
			<p class="source-code"># First, let's find out if the destination directory exists by</p>
			<p class="source-code"># using test function. If it does, go on with the script. If it</p>
			<p class="source-code"># doesn't, create that destination directory. In our example,</p>
			<p class="source-code"># destination directory is called copylocation.</p>
			<p class="source-code">if [ -d "./copylocation" ]</p>
			<p class="source-code">then</p>
			<p class="source-code">             echo "Directory ./copylocation exists."</p>
			<p class="source-code">else</p>
			<p class="source-code">              echo "Error: Directory ./copylocation does not exist."</p>
			<p class="source-code">              mkdir ./copylocation</p>
			<p class="source-code">fi</p>
			<p class="source-code"># next step, let's create a friendly file list with all of the files</p>
			<p class="source-code"># in current folder</p>
			<p class="source-code">find . -type f -exec ls -al {} \; | sed 's/  */ /g' | cut -f9 -d" " &gt; filelist.txt</p>
			<p class="source-code"># Last step, let's load this file into variable so that we can loop</p>
			<p class="source-code"># over it and copy every file from it to our destination folder</p>
			<p class="source-code">file_list='cat filelist.txt'</p>
			<p class="source-code">for current_file in $file_list</p>
			<p class="source-code">do</p>
			<p class="source-code">             echo "Copying $current_file to destination"</p>
			<p class="source-code">             cp "$current_file" ./copylocation</p>
			<p class="source-code">done</p>
			<p>The next script we'll look at is simple but very, very useful – it's about checking if we're running the script as root. The reasoning is simple – there will be scripts that we don't want to run<a id="_idIndexMarker1082"/> as root for fear of messing something up, in which case we'd use some accessible resources. Let's see how that would work. </p>
			<h2 id="_idParaDest-364"><a id="_idTextAnchor372"/>See also</h2>
			<p>If you need more information about <strong class="source-inline">sort</strong>, <strong class="source-inline">find</strong>, <strong class="source-inline">wc</strong>, <strong class="source-inline">cut</strong> or <strong class="source-inline">sed</strong>, we suggest that you visit these links:</p>
			<ul>
				<li><strong class="source-inline">sort</strong> command <a id="_idIndexMarker1083"/>man page: <a href="https://man7.org/linux/man-pages/man1/sort.1.html">https://man7.org/linux/man-pages/man1/sort.1.html</a> </li>
				<li><strong class="source-inline">find</strong> command<a id="_idIndexMarker1084"/> man page: <a href="https://man7.org/linux/man-pages/man1/find.1.html">https://man7.org/linux/man-pages/man1/find.1.html</a></li>
				<li><strong class="source-inline">wc</strong> command man<a id="_idIndexMarker1085"/> page: <a href="https://man7.org/linux/man-pages/man1/wc.1.html">https://man7.org/linux/man-pages/man1/wc.1.html</a></li>
				<li><strong class="source-inline">cut</strong> command <a id="_idIndexMarker1086"/>man page: <a href="https://man7.org/linux/man-pages/man1/cut.1.html">https://man7.org/linux/man-pages/man1/cut.1.html</a></li>
				<li><strong class="source-inline">sed</strong> command <a id="_idIndexMarker1087"/>man page: <a href="https://man7.org/linux/man-pages/man1/sed.1.html">https://man7.org/linux/man-pages/man1/sed.1.html</a></li>
			</ul>
			<h1 id="_idParaDest-365"><a id="_idTextAnchor373"/>Checking if you're running as root</h1>
			<p>There are different <a id="_idIndexMarker1088"/>ways of checking if we're running a script <a id="_idIndexMarker1089"/>as root. We can use environment variables, just as we can use the <strong class="source-inline">whoami</strong> or <strong class="source-inline">id</strong> commands to <a id="_idIndexMarker1090"/>check if it equals root/number <strong class="source-inline">0</strong> or not. </p>
			<h2 id="_idParaDest-366"><a id="_idTextAnchor374"/>Getting ready</h2>
			<p>We'll continue using the <strong class="source-inline">cli1</strong> machine for this recipe, so make sure that it's powered on.</p>
			<h2 id="_idParaDest-367"><a id="_idTextAnchor375"/>How to do it…</h2>
			<p>Let's create a short snippet of Bash shell script code that's going to help us find out whether we're running a script as root or not. It's a rather simple thing to do in Linux, considering that we have easy access to an environment variable called <strong class="source-inline">EUID</strong>, and reading its value is enough to determine <a id="_idIndexMarker1091"/>whether we're running as root (EUID=0) or not (EUID value &gt; 1):</p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code"># V1.0 / Jasmin Redzepagic / 01/11/2021 Initial script version </p>
			<p class="source-code"># Distribution allowed under GNU Licence V2.0 </p>
			<p class="source-code"># First, we need to check if our environment variable UID is set to</p>
			<p class="source-code"># 0 or not and branch that out to either yes or no with appropriate</p>
			<p class="source-code"># status messages</p>
			<p class="source-code">if [ "$EUID" -eq 0 ]</p>
			<p class="source-code">             then</p>
			<p class="source-code">                         echo "You are running as root user. Please be careful!"</p>
			<p class="source-code">             else</p>
			<p class="source-code">                         echo "You are not root. It's all sunshine and roses, you can't do much damage!"</p>
			<p class="source-code">fi</p>
			<p class="source-code">exit 0</p>
			<p>The next example that we're going to cover is about displaying server stats. We're going to use the <strong class="source-inline">sar</strong> command to do so. Let's go!</p>
			<h2 id="_idParaDest-368"><a id="_idTextAnchor376"/>See also</h2>
			<p>If you need more information about<a id="_idIndexMarker1092"/> internal variables, we suggest that you go to <a href="https://tldp.org/LDP/abs/html/internalvariables.html">https://tldp.org/LDP/abs/html/internalvariables.html</a>.</p>
			<h1 id="_idParaDest-369"><a id="_idTextAnchor377"/>Displaying server stats</h1>
			<p>Let's say that we have to write a<a id="_idIndexMarker1093"/> shell script that's going to display the following pieces of information:</p>
			<ul>
				<li>Current hostname</li>
				<li>Current date</li>
				<li>Current kernel version</li>
				<li>Current CPU usage</li>
				<li>Current memory usage</li>
				<li>Current swap space usage</li>
				<li>Current disk I/O</li>
				<li>Current network bandwidth</li>
			</ul>
			<p>This is more of an exercise in filtering data and using commands, but there are some interesting concepts in terms of how to format data to look <em class="italic">nice</em> and <em class="italic">readable</em>. This is something we consider to be very important. </p>
			<h2 id="_idParaDest-370"><a id="_idTextAnchor378"/>Getting ready</h2>
			<p>We need to leave the <strong class="source-inline">cli1</strong> machine running. Also, for this script to work, we need to deploy the <strong class="source-inline">sysstat</strong> package, and then enable the necessary service. We can do this by using the following command for Ubuntu:</p>
			<p class="source-code">sudo apt-get -y install sysstat</p>
			<p>We can use the following command for CentOS:</p>
			<p class="source-code">sudo yum -y install sysstat</p>
			<p>After that, we need to start the <strong class="source-inline">sysstat</strong> service:</p>
			<p class="source-code">sudo systemctl enable --now sysstat</p>
			<p>Now, we can start working on our script. </p>
			<h2 id="_idParaDest-371"><a id="_idTextAnchor379"/>How to do it…</h2>
			<p>We are going to use<a id="_idIndexMarker1094"/> the <strong class="source-inline">sar</strong> command to get a lot of information about our Linux machine. We are also going to<a id="_idIndexMarker1095"/> filter out some of the unnecessary details. Our script should look like this:</p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code"># V1.0 / Jasmin Redzepagic / 01/11/2021 Initial script version </p>
			<p class="source-code"># Distribution allowed under GNU Licence V2.0 </p>
			<p class="source-code">echo "Hostname: $(hostname)"</p>
			<p class="source-code">echo "Current date: $(date)"</p>
			<p class="source-code">echo "Current kernel version and CPU architecture: $(uname -rp)"</p>
			<p class="source-code"># sar command has a default first line output telling us that it's</p>
			<p class="source-code"># running on Linux, and which kernel we are using. It's pointless</p>
			<p class="source-code"># to get this information four or five times, so let's filter that</p>
			<p class="source-code"># out from the get-go (grep -v "Linux" part of every command)</p>
			<p class="source-code">echo "Current CPU usage:"</p>
			<p class="source-code">sar -u 1 1| grep -v "Linux"</p>
			<p class="source-code">echo ""</p>
			<p class="source-code">echo "Current memory usage:"</p>
			<p class="source-code">sar -r 1 1| grep -v "Linux"</p>
			<p class="source-code">echo ""</p>
			<p class="source-code">echo "Current swap space usage:"</p>
			<p class="source-code">sar -S 1 1| grep -v "Linux"</p>
			<p class="source-code">echo ""</p>
			<p class="source-code"># When sar displays disk I/O info, it displays that info per</p>
			<p class="source-code"># device, which isn't all that important. What's important for</p>
			<p class="source-code"># us are sd* and vd* devices, as well as the status line telling</p>
			<p class="source-code"># us which specific metrics are shown in the column (DEV).</p>
			<p class="source-code">echo "Current disk I/O:"</p>
			<p class="source-code">sar -d 1 1| grep -E "(DEV|sd|vd)" | grep -v "Linux"</p>
			<p class="source-code">echo ""</p>
			<p class="source-code"># When sar displays network information, it shows it per device.</p>
			<p class="source-code"># Having in mind that we have a loopback network device (lo) and </p>
			<p class="source-code"># that its statistics isn't important, let's just filter that out</p>
			<p class="source-code"># so that we can see network bandwidth info per real network device</p>
			<p class="source-code">echo "Current network bandwidth usage:"</p>
			<p class="source-code">sar -n DEV 1 1| grep -v lo | grep -v "Linux"</p>
			<p>We used <strong class="source-inline">echo ""</strong> multiple<a id="_idIndexMarker1096"/> times here so that our output looks clean and readable. The output should look like this:</p>
			<div>
				<div id="_idContainer266" class="IMG---Figure">
					<img src="Images/Figure_16.2_B16269.jpg" alt="Figure 16.2 – Displaying the server stats from our script&#13;&#10;" width="1428" height="1491"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.2 – Displaying the server stats from our script</p>
			<p>The next recipe is about finding content – by name, ownership, or extension – so that we can copy the content<a id="_idIndexMarker1097"/> we find to a specific location. Let's get started!</p>
			<h2 id="_idParaDest-372"><a id="_idTextAnchor380"/>There's more…</h2>
			<p>If you need to learn <a id="_idIndexMarker1098"/>more about the <strong class="source-inline">sar</strong> command, take a look at the <strong class="source-inline">sar</strong> command's man page at <a href="https://man7.org/linux/man-pages/man1/sar.1.html">https://man7.org/linux/man-pages/man1/sar.1.html</a>.</p>
			<h1 id="_idParaDest-373"><a id="_idTextAnchor381"/>Finding files by name, ownership, or content type and copying them to a specified directory</h1>
			<p>Managing files can be a bit of a burden. Usually, we have thousands of them, and if it's an enterprise-level company that we're discussing, there might be millions. What happens if we need to find files that follow specific criteria? </p>
			<p>We'll start with <a id="_idIndexMarker1099"/>something simpler – finding by name. Then, we'll move <a id="_idIndexMarker1100"/>on to ownership-based searches, and then, the most <a id="_idIndexMarker1101"/>involved – content type-based searches.</p>
			<h2 id="_idParaDest-374"><a id="_idTextAnchor382"/>Getting ready</h2>
			<p>Before you start this recipe, you need to make sure that our <strong class="source-inline">cli1</strong> virtual machine is up and running.</p>
			<h2 id="_idParaDest-375"><a id="_idTextAnchor383"/>How to do it…</h2>
			<p>This is a perfect<a id="_idIndexMarker1102"/> script to do a bit more interaction, so case loops are in store for us. We're<a id="_idIndexMarker1103"/> making a conscious effort to use case a lot, with<a id="_idIndexMarker1104"/> a lot of status/debugging code that can guide us through script usage. </p>
			<p>We want to slice this script into <a id="_idIndexMarker1105"/>three parts as it's going to do three different things. Here's what the script will look like:</p>
			<p class="source-code">#!/usr/bin/bash</p>
			<p class="source-code"># V1.0 / Jasmin Redzepagic / 01/11/2021 Initial script version </p>
			<p class="source-code"># Distribution allowed under GNU Licence V2.0 </p>
			<p class="source-code">read -p "Enter directory to move file to: " DESTDIR</p>
			<p class="source-code">echo -e "\n"</p>
			<p class="source-code"># Let's first establish a destination directory with a loop that can test if that directory exists or not</p>
			<p class="source-code">if [ "$DESTDIR" == "" ];</p>
			<p class="source-code">then</p>
			<p class="source-code">        echo "You must specify a directory."</p>
			<p class="source-code">else</p>
			<p class="source-code">        if [ ! -d "$DESTDIR" ]</p>
			<p class="source-code">        then</p>
			<p class="source-code">                echo "Directory $DESTDIR must exist. Exiting!"</p>
			<p class="source-code">                         </p>
			<p class="source-code">                exit</p>
			<p class="source-code">        fi</p>
			<p class="source-code">fi</p>
			<p class="source-code"># Directory is ready, let's go to the main part of the script. First</p>
			<p class="source-code"># step is selecting which type of search we want to use.</p>
			<p class="source-code">echo "Enter number denoting criteria for search: "</p>
			<p class="source-code">echo "1 = by name "</p>
			<p class="source-code">echo "2 = by ownership "</p>
			<p class="source-code">echo "3 = by content extension "</p>
			<p class="source-code">echo -e "\n"</p>
			<p class="source-code">read CRIT</p>
			<p class="source-code"># Let's start our case loop against CRIT variable.</p>
			<p class="source-code">case $CRIT in</p>
			<p class="source-code">        1)</p>
			<p class="source-code">                read -p "Enter name to search for: " NAME</p>
			<p class="source-code">                echo -e "\n"</p>
			<p class="source-code">                if [ ! -z  $NAME="" ]</p>
			<p class="source-code">                        then</p>
			<p class="source-code">                                find / -name "$NAME" -exec cp {} $DESTDIR \; 2&gt; /dev/null</p>
			<p class="source-code">                        else</p>
			<p class="source-code">                                echo You have to enter the name!</p>
			<p class="source-code">                fi</p>
			<p class="source-code">                ;;</p>
			<p class="source-code">        2)</p>
			<p class="source-code">                read -p "Enter owner to search for: " OWNER</p>
			<p class="source-code">                echo -e "\n"</p>
			<p class="source-code">                if [ ! -z $OWNER="" ]</p>
			<p class="source-code">                      then</p>
			<p class="source-code">                                find / -user $OWNER -exec cp {} $DESTDIR \;  2&gt; /dev/null</p>
			<p class="source-code">                        else</p>
			<p class="source-code">                                echo You have to input an owner!</p>
			<p class="source-code">                fi</p>
			<p class="source-code">                ;;</p>
			<p class="source-code">        3)</p>
			<p class="source-code">                read -p "Enter content extension: " CEXT</p>
			<p class="source-code">                echo -e "\n"</p>
			<p class="source-code">                if [ ! -z $CEXT="" ]</p>
			<p class="source-code">                        then</p>
			<p class="source-code">                                read -p "Where are we looking for files, in which directory?" LOOKUP</p>
			<p class="source-code">                                find "$LOOKUP" -type f -name "$CEXT" -exec cp {} $DESTDIR \; 2&gt; /dev/null</p>
			<p class="source-code">                        else</p>
			<p class="source-code">                                echo You have to enter the content type!</p>
			<p class="source-code">                fi</p>
			<p class="source-code">                  ;;</p>
			<p class="source-code">        *)      echo please make a choice, either 1, 2 or 3!</p>
			<p class="source-code">esac</p>
			<p>Note that when we're asked about the extension, we have to type something like <strong class="source-inline">*.txt</strong> for this script to work. Here's what the script execution looks like with that extension in mind:</p>
			<div>
				<div id="_idContainer267" class="IMG---Figure">
					<img src="Images/Figure_16.3_B16269.jpg" alt="Figure 16.3 – Script execution with a file extension as the criteria&#13;&#10;" width="1174" height="747"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.3 – Script execution with a file extension as the criteria</p>
			<p>In the next recipe, we'll learn how to work with date and time-based data, a concept that's often used in shell scripting for indexing purposes. While easy to use and understand, we need to learn how to use this concept programmatically, via variables. So, let's do that next!</p>
			<h2 id="_idParaDest-376"><a id="_idTextAnchor384"/>There's more…</h2>
			<p>If you need more information about the <strong class="source-inline">sar</strong> command, we recommend that you check out the following <a id="_idIndexMarker1106"/>link to learn more: <strong class="source-inline">https://www.howtogeek.com/662422/how-to-use-linuxs-screen-command/</strong>.</p>
			<h1 id="_idParaDest-377"><a id="_idTextAnchor385"/>Parsing date and time data</h1>
			<p>Working with <a id="_idIndexMarker1107"/>time-based data is often less than fun, especially when you're working with a lot of time-based content. But for our use cases, we often use date/time information for indexing; that is, to name our backup files and similar purposes. So, learning how to get information from the <strong class="source-inline">date</strong> command and putting that information into variables so that our code can be as modular as possible is very important. Let's create a shell script that we are going to be able to use in future scripts as a snippet of code for a lot of our shell scripts – at least bits and pieces of it.</p>
			<h2 id="_idParaDest-378"><a id="_idTextAnchor386"/>Getting ready</h2>
			<p>We don't need any special utilities to be installed, just our Linux machine to be alive and ready for action.</p>
			<h2 id="_idParaDest-379"><a id="_idTextAnchor387"/>How to do it…</h2>
			<p>We are going to go back to the basics and use the <strong class="source-inline">date</strong> command to extract all of the date and time pieces that we'll ever need:</p>
			<ul>
				<li>Information about the current time in terms of hours, minutes, and seconds</li>
				<li>Information about today's date</li>
				<li>Information about what day it is today</li>
			</ul>
			<p>Let's type the following in our text editor and execute our script:</p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code"># V1.0 / Jasmin Redzepagic / 01/11/2021 Initial script version </p>
			<p class="source-code"># Distribution allowed under GNU Licence V2.0 </p>
			<p class="source-code"># This part of our script is just plain using date command to assign</p>
			<p class="source-code"># values to "obviously named variables". This further shows two</p>
			<p class="source-code"># things - how to assign a variable value from external command,</p>
			<p class="source-code"># and how to use that principle on date and time data.</p>
			<p class="source-code">hour=$(date +%H)</p>
			<p class="source-code">minute=$(date +%M)</p>
			<p class="source-code">second=$(date +%S)</p>
			<p class="source-code">day=$(date +%d)</p>
			<p class="source-code">month=$(date +%m)</p>
			<p class="source-code">year=$(date +%Y)</p>
			<p class="source-code"># Let's print that out</p>
			<p class="source-code">echo "Current time is: $hour:$minute:$second"</p>
			<p class="source-code">echo "Current date is: $day-$month-$year"</p>
			<p>Here's an example <a id="_idIndexMarker1108"/>of the sample output. We called this script <strong class="source-inline">sscript2.sh</strong>:</p>
			<div>
				<div id="_idContainer268" class="IMG---Figure">
					<img src="Images/Figure_16.4_B16269.jpg" alt="Figure 16.4 – Sample output from our date and time script&#13;&#10;" width="1224" height="162"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.4 – Sample output from our date and time script</p>
			<p>This can be very useful for backup scripts – for example, when we're indexing backup files (<strong class="source-inline">.tar.gz</strong> or something else) by dates. This is a concept that we're going to use later in this chapter. For now, let's learn how to configure firewall settings via shell scripts.</p>
			<h1 id="_idParaDest-380"><a id="_idTextAnchor388"/>Configuring the most common firewall settings interactively</h1>
			<p>Firewall configuration <a id="_idIndexMarker1109"/>is just one of those things – we often need to do it, but we don't necessarily know all of the commands off the top of our heads. Let's do this via shell scripts, for both CentOS (<strong class="source-inline">firewalld</strong>) and Ubuntu (<strong class="source-inline">ufw</strong>).</p>
			<h2 id="_idParaDest-381"><a id="_idTextAnchor389"/>Getting ready</h2>
			<p>Before you start this recipe, you need to make sure that you have <strong class="source-inline">firewalld</strong> on your CentOS machine and <strong class="source-inline">ufw</strong> on your Ubuntu machine up. So, first, you need to use the following command:</p>
			<p class="source-code">systemctl status firewalld</p>
			<p>Use the following command for CentOS and Ubuntu:</p>
			<p class="source-code">systemctl status ufw</p>
			<p>If they're disabled, we need to turn them on, like so:</p>
			<p class="source-code">systemctl enable --now firewalld</p>
			<p>On CentOS and Ubuntu, you can use the following command:</p>
			<p class="source-code">systemctl enable --now ufw</p>
			<p>Now, we're ready to get started. Of course, you need to be logged in as an administrator to be able to change your firewall configuration, so make sure that you're either logged in as root (or a user with similar capabilities) or use the sudo configuration to change your firewall configuration.</p>
			<p>Furthermore, with <strong class="source-inline">firewalld</strong>, a lot of<a id="_idIndexMarker1110"/> people have trouble remembering the service names that it uses. That's not a problem – we just need to use the following command:</p>
			<p class="source-code">firewall-cmd --get-services</p>
			<p>For <strong class="source-inline">ufw</strong>, we just need to go and look at <strong class="source-inline">/etc/service</strong>, since all of the service names are listed there, and <strong class="source-inline">ufw</strong> uses them for configuration purposes.</p>
			<h2 id="_idParaDest-382"><a id="_idTextAnchor390"/>How to do it…</h2>
			<p>First, let's make a <a id="_idIndexMarker1111"/>CentOS-based script for <strong class="source-inline">firewalld</strong>. We'll include eight standard operations – manipulating service configuration, TCP and UDP ports and rich rules, both adding and removing them, as well as the capability to list current configuration. Here's what the script should look like:</p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code"># V1.0 / Jasmin Redzepagic / 01/11/2021 Initial script version </p>
			<p class="source-code"># Distribution allowed under GNU Licence V2.0 </p>
			<p class="source-code">echo "1 = firewalld (CentOS) - manipulate service configuration - add"</p>
			<p class="source-code">echo "2 = firewalld (CentOS) - manipulate service configuration - remove"</p>
			<p class="source-code">echo "3 = firewalld (CentOS) - manipulate TCP ports - add"</p>
			<p class="source-code">echo "4 = firewalld (CentOS) - manipulate TCP ports - remove"</p>
			<p class="source-code">echo "5 = firewalld (CentOS) - manipulate UDP ports - add"</p>
			<p class="source-code">echo "6 = firewalld (CentOS) - manipulate UDP ports - remove"</p>
			<p class="source-code">echo "7 = firewalld (CentOS) - manipulate rich rules - add"</p>
			<p class="source-code">echo "8 = firewalld (CentOS) - manipulate rich rules - remove"</p>
			<p class="source-code">echo "9 = firewalld (CentOS) - list current configuration"</p>
			<p class="source-code">echo -e "Your choice:"</p>
			<p class="source-code">read CRIT</p>
			<p class="source-code"># Let's start our case loop against CRIT variable.</p>
			<p class="source-code">case $CRIT in</p>
			<p class="source-code">        1)</p>
			<p class="source-code">                echo "Enter service names, using space as separator."</p>
			<p class="source-code">                echo "Hint: ssh http https etc. Get list from firewall-cmd --get-services"</p>
			<p class="source-code">                echo "Your input:"</p>
			<p class="source-code">                read -a FW1</p>
			<p class="source-code">                for svcs1 in ${FW1[@]}</p>
			<p class="source-code">                do</p>
			<p class="source-code">                        firewall-cmd --permanent --add-service=$svcs1</p>
			<p class="source-code">                done</p>
			<p class="source-code">                firewall-cmd --reload</p>
			<p class="source-code">                ;;</p>
			<p class="source-code">        2)</p>
			<p class="source-code">                echo "Enter service names, using space as separator."</p>
			<p class="source-code">                echo "Hint: ssh http https etc. Get list from firewall-cmd --get-services"</p>
			<p class="source-code">                echo "Your input:"</p>
			<p class="source-code">                read -a FW2</p>
			<p class="source-code">                for svcs2 in ${FW2[@]}</p>
			<p class="source-code">                do</p>
			<p class="source-code">                        firewall-cmd --permanent --remove-service=$svcs2</p>
			<p class="source-code">                done</p>
			<p class="source-code">                firewall-cmd --reload</p>
			<p class="source-code">                ;;</p>
			<p class="source-code">        3)</p>
			<p class="source-code">                echo "Enter TCP port numbers, using space as separator."</p>
			<p class="source-code">                echo "Hint: 22 80 443 etc."</p>
			<p class="source-code">                echo "Your input:"</p>
			<p class="source-code">                read -a FW3</p>
			<p class="source-code">                for svcs3 in ${FW3[@]}</p>
			<p class="source-code">                do</p>
			<p class="source-code">                        firewall-cmd --permanent --add-port=$svcs3/tcp</p>
			<p class="source-code">                done</p>
			<p class="source-code">                firewall-cmd --reload</p>
			<p class="source-code">                ;;</p>
			<p class="source-code">        4)</p>
			<p class="source-code">                echo "Enter TCP port numbers, using space as separator."</p>
			<p class="source-code">                echo "Hint: 22 80 443 etc."</p>
			<p class="source-code">                echo "Your input:"</p>
			<p class="source-code">                read -a FW4</p>
			<p class="source-code">                for svcs4 in ${FW4[@]}</p>
			<p class="source-code">                do</p>
			<p class="source-code">                        firewall-cmd --permanent --remove-port=$svcs4/tcp</p>
			<p class="source-code">                done</p>
			<p class="source-code">                firewall-cmd --reload</p>
			<p class="source-code">                ;;</p>
			<p class="source-code">        5)</p>
			<p class="source-code">                echo "Enter UDP port numbers, using space as separator."</p>
			<p class="source-code">                echo "Hint: 22 80 443 etc."</p>
			<p class="source-code">                echo "Your input:"</p>
			<p class="source-code">                read -a FW5</p>
			<p class="source-code">                for svcs5 in ${FW5[@]}</p>
			<p class="source-code">                do</p>
			<p class="source-code">                        firewall-cmd --permanent --add-port=$svcs5/udp</p>
			<p class="source-code">                done</p>
			<p class="source-code">                firewall-cmd --reload</p>
			<p class="source-code">                ;;</p>
			<p class="source-code">        6)</p>
			<p class="source-code">                echo "Enter UDP port numbers, using space as separator."</p>
			<p class="source-code">                echo "Hint: 22 80 443 etc."</p>
			<p class="source-code">                echo "Your input:"</p>
			<p class="source-code">                read -a FW6</p>
			<p class="source-code">                for svcs6 in ${FW6[@]}</p>
			<p class="source-code">                do</p>
			<p class="source-code">                        firewall-cmd --permanent --remove-port=$svcs6/udp</p>
			<p class="source-code">                done</p>
			<p class="source-code">                firewall-cmd --reload</p>
			<p class="source-code">                ;;</p>
			<p class="source-code">        7)</p>
			<p class="source-code">                echo "Let's manipulate rich rules - to add specific IPs access to specific port."</p>
			<p class="source-code">                echo "Hint: first, we need an endpoint IP address, like 45.67.98.43                   "</p>
			<p class="source-code">                echo "Your input (IP address):"</p>
			<p class="source-code">                read -a FW71</p>
			<p class="source-code">                echo "To which TCP port you want to allow access?"</p>
			<p class="source-code">                echo "Your input (TCP port number):"</p>
			<p class="source-code">                echo "Your input:"</p>
			<p class="source-code">                read -a FW72</p>
			<p class="source-code">                for svcs71 in ${FW71[@]}</p>
			<p class="source-code">                do</p>
			<p class="source-code">                        for svcs72 in ${FW72[@]}</p>
			<p class="source-code">                        do</p>
			<p class="source-code">                                firewall-cmd --permanent --add-rich-rule='rule family="ipv4" source address="'$svcs71'/32" port protocol="tcp" port="'$svcs72'" accept'</p>
			<p class="source-code">                        done</p>
			<p class="source-code">                done</p>
			<p class="source-code">                firewall-cmd --reload</p>
			<p class="source-code">                ;;</p>
			<p class="source-code">        8)</p>
			<p class="source-code">                echo "Let's manipulate rich rules - to add specific IPs access to specific port."</p>
			<p class="source-code">                echo "Hint: first, we need an endpoint IP address, like 45.67.98.43"</p>
			<p class="source-code">                echo "Your input (IP address):"</p>
			<p class="source-code">                read -a FW81</p>
			<p class="source-code">                echo "To which TCP port you want to allow access?"</p>
			<p class="source-code">                echo "Your input (TCP port number):"</p>
			<p class="source-code">                echo "Your input:"</p>
			<p class="source-code">                read -a FW82</p>
			<p class="source-code">                for svcs81 in ${FW81[@]}</p>
			<p class="source-code">                do</p>
			<p class="source-code">                        for svcs82 in ${FW82[@]}</p>
			<p class="source-code">                        do</p>
			<p class="source-code">                                firewall-cmd --permanent --remove-rich-rule='rule family="ipv4" source address="'$svcs81'/32" port protocol="tcp" port="'$svcs82'" accept'</p>
			<p class="source-code">                        done</p>
			<p class="source-code">                done</p>
			<p class="source-code">                firewall-cmd --reload</p>
			<p class="source-code">                ;;</p>
			<p class="source-code">        9)</p>
			<p class="source-code">                echo "Let's just list the firewalld settings first:"</p>
			<p class="source-code">                firewall-cmd --list-all</p>
			<p class="source-code">                echo "Let's list all the rich rules, if any:"</p>
			<p class="source-code">                firewall-cmd --list-rich-rules</p>
			<p class="source-code">                ;;</p>
			<p class="source-code">        *)      echo "Please make a correct choice, available choices are 1-9!"</p>
			<p class="source-code">esac</p>
			<p>This is a lot of code, but<a id="_idIndexMarker1112"/> it makes it so much more readable (since we're using a case loop). We could've done this in a couple of different ways, but this is the easiest code to debug, and, most importantly, it works well.</p>
			<p>Now, let's look at <a id="_idIndexMarker1113"/>Ubuntu's <strong class="source-inline">ufw</strong> script, which is going to be very similar – we just need to get the <strong class="source-inline">ufw</strong> commands correct. We're also going to look at two different ways of deleting rules (by an index number and by rule), just so that we know how to get on with both:</p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code">echo "1 = ufw (Ubuntu) - manipulate service configuration - add"</p>
			<p class="source-code">echo "2 = ufw (Ubuntu) - manipulate service configuration - remove"</p>
			<p class="source-code">echo "3 = ufw (Ubuntu) - manipulate TCP ports - add"</p>
			<p class="source-code">echo "4 = ufw (Ubuntu) - manipulate TCP ports - remove"</p>
			<p class="source-code">echo "5 = ufw (Ubuntu) - manipulate UDP ports - add"</p>
			<p class="source-code">echo "6 = ufw (Ubuntu) - manipulate UDP ports - remove"</p>
			<p class="source-code">echo "7 = ufw (Ubuntu) - manipulate whitelist IP/port configuration - add"</p>
			<p class="source-code">echo "8 = ufw (Ubuntu) - manipulate whitelist IP/port configuration - remove"</p>
			<p class="source-code">echo "9 = ufw (Ubuntu) - list current configuration"</p>
			<p class="source-code">echo -e "Your choice:"</p>
			<p class="source-code">read CRIT</p>
			<p class="source-code"># Let's start our case loop against CRIT variable.</p>
			<p class="source-code">case $CRIT in</p>
			<p class="source-code">        1)</p>
			<p class="source-code">                echo "Enter service names, using space as separator."</p>
			<p class="source-code">                echo "Hint: ssh http https etc. Get list from /etc/services"</p>
			<p class="source-code">                echo "Your input:"</p>
			<p class="source-code">                read -a FW1</p>
			<p class="source-code">                for svcs1 in ${FW1[@]}</p>
			<p class="source-code">                do</p>
			<p class="source-code">                        ufw allow $svcs1</p>
			<p class="source-code">                done</p>
			<p class="source-code">                ;;</p>
			<p class="source-code">        2)</p>
			<p class="source-code">                echo "Enter rule numbers from the list:"</p>
			<p class="source-code">                ufw status numbered</p>
			<p class="source-code">                echo "Your input, single number or multiple numbers separated by space:"</p>
			<p class="source-code">                echo "Hint: Best way to do it would be backwards - from top rule number to bottom rule number!"</p>
			<p class="source-code">                read -a FW2</p>
			<p class="source-code">                for svcs2 in ${FW2[@]}</p>
			<p class="source-code">                do</p>
			<p class="source-code">                       echo "y" | ufw delete $svcs2</p>
			<p class="source-code">                done</p>
			<p class="source-code">                ;;</p>
			<p class="source-code">        3)</p>
			<p class="source-code">                echo "Enter TCP port numbers, using space as separator."</p>
			<p class="source-code">                echo "Hint: 22 80 443 etc."</p>
			<p class="source-code">                echo "Your input:"</p>
			<p class="source-code">                read -a FW3</p>
			<p class="source-code">                for svcs3 in ${FW3[@]}</p>
			<p class="source-code">                do</p>
			<p class="source-code">                        ufw allow $svcs3/tcp</p>
			<p class="source-code">                done</p>
			<p class="source-code">                ;;</p>
			<p class="source-code">        4)</p>
			<p class="source-code">                echo "Enter TCP port numbers, using space as separator."</p>
			<p class="source-code">                echo "Hint: 22 80 443 etc."</p>
			<p class="source-code">                echo "Your input:"</p>
			<p class="source-code">                read -a FW4</p>
			<p class="source-code">                for svcs4 in ${FW4[@]}</p>
			<p class="source-code">                do</p>
			<p class="source-code">                        ufw delete allow $svcs4/tcp</p>
			<p class="source-code">                done</p>
			<p class="source-code">                ;;</p>
			<p class="source-code">        5)</p>
			<p class="source-code">                echo "Enter UDP port numbers, using space as separator."</p>
			<p class="source-code">                echo "Hint: 22 80 443 etc."</p>
			<p class="source-code">                echo "Your input:"</p>
			<p class="source-code">                read -a FW5</p>
			<p class="source-code">                for svcs5 in ${FW5[@]}</p>
			<p class="source-code">                do</p>
			<p class="source-code">                        ufw allow $svcs5/udp</p>
			<p class="source-code">                done</p>
			<p class="source-code">                ;;</p>
			<p class="source-code">        6)</p>
			<p class="source-code">                echo "Enter UDP port numbers, using space as separator."</p>
			<p class="source-code">                echo "Hint: 22 80 443 etc."</p>
			<p class="source-code">                echo "Your input:"</p>
			<p class="source-code">                read -a FW6</p>
			<p class="source-code">                for svcs6 in ${FW6[@]}</p>
			<p class="source-code">                do</p>
			<p class="source-code">                        ufw delete allow $svcs6/udp</p>
			<p class="source-code">                done</p>
			<p class="source-code">                ;;</p>
			<p class="source-code">        7)</p>
			<p class="source-code">                echo "Let's manipulate whitelist rules - to add specific IPs access to specific port."</p>
			<p class="source-code">                echo "Hint: first, we need an endpoint IP address, like 45.67.98.43"</p>
			<p class="source-code">                echo "Your input (IP address):"</p>
			<p class="source-code">                read -a FW71</p>
			<p class="source-code">                echo "To which port you want to allow access?"</p>
			<p class="source-code">                echo "Your input (port number):"</p>
			<p class="source-code">                echo "Your input:"</p>
			<p class="source-code">                read -a FW72</p>
			<p class="source-code">                for svcs71 in ${FW71[@]}</p>
			<p class="source-code">                do</p>
			<p class="source-code">                        for svcs72 in ${FW72[@]}</p>
			<p class="source-code">                        do</p>
			<p class="source-code">                                ufw allow from $svcs71 to any port $svcs72</p>
			<p class="source-code">                        done</p>
			<p class="source-code">                done</p>
			<p class="source-code">                ;;</p>
			<p class="source-code">        8)</p>
			<p class="source-code">                echo "Let's manipulate whitelist rules - to remove specific IPs access to specific port."</p>
			<p class="source-code">                echo "Hint: first, we need an endpoint IP address, like 45.67.98.43"</p>
			<p class="source-code">                echo "Your input (IP address):"</p>
			<p class="source-code">                read -a FW81</p>
			<p class="source-code">                echo "To which port you want to allow access?"</p>
			<p class="source-code">                echo "Your input (port number):"</p>
			<p class="source-code">                echo "Your input:"</p>
			<p class="source-code">                read -a FW82</p>
			<p class="source-code">                for svcs81 in ${FW81[@]}</p>
			<p class="source-code">                do</p>
			<p class="source-code">                        for svcs82 in ${FW82[@]}</p>
			<p class="source-code">                        do</p>
			<p class="source-code">                                ufw delete allow from $svcs81 to any port $svcs82</p>
			<p class="source-code">                        done</p>
			<p class="source-code">                done</p>
			<p class="source-code">                ;;</p>
			<p class="source-code">        9)</p>
			<p class="source-code">                echo "Let's list the ufw settings:"</p>
			<p class="source-code">                ufw status</p>
			<p class="source-code">                ;;</p>
			<p class="source-code">        *)      echo "Please make a correct choice, available choices are 1-9!"</p>
			<p class="source-code">esac</p>
			<p>There we go – that's <a id="_idIndexMarker1114"/>another long script done. This should help us when we're using Ubuntu a lot. Next, we will be going in a different direction – using <strong class="source-inline">nmcli</strong> in interactive, scripted mode to configure network settings on CentOS.</p>
			<h2 id="_idParaDest-383"><a id="_idTextAnchor391"/>There's more…</h2>
			<p>For additional information about the <strong class="source-inline">firewall-cmd</strong> and <strong class="source-inline">ufw</strong> command-line options, we suggest that you visit the following links:</p>
			<ul>
				<li><strong class="source-inline">firewall-cmd</strong> man<a id="_idIndexMarker1115"/> page: <strong class="source-inline">https://firewalld.org/documentation/man-pages/firewall-cmd.html</strong></li>
				<li>Configuring complex firewall rules with the <em class="italic">rich language</em> syntax: <strong class="source-inline">https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/security_guide/configuring_complex_firewall_rules_with_the_rich-language_syntax</strong></li>
				<li>ufw cheatsheet: <strong class="source-inline">https://blog.rtsp.us/ufw-uncomplicated-firewall-cheat-sheet-a9fe61933330</strong></li>
			</ul>
			<h1 id="_idParaDest-384"><a id="_idTextAnchor392"/>Configuring network settings interactively</h1>
			<p>Often, we don't have<a id="_idIndexMarker1116"/> access to GUIs and GUI-based configuration tools. If we need to configure network settings, this can lead to a bunch of problems. Either we need to learn the syntax of <strong class="source-inline">/etc/sysconfig/network-script</strong> files (not user-friendly), or we need to use the tools that are at our disposal to configure network settings from the CLI. Let's learn how to use <strong class="source-inline">nmcli</strong> for that purpose.</p>
			<h2 id="_idParaDest-385"><a id="_idTextAnchor393"/>Getting ready</h2>
			<p>Before you start this recipe, you need to make sure that you are using our <strong class="source-inline">cli2</strong> CentOS machine as Ubuntu doesn't use <strong class="source-inline">nmcli</strong> by default. Once you've done that, you're all set!</p>
			<h2 id="_idParaDest-386"><a id="_idTextAnchor394"/>How to do it…</h2>
			<p>Configuring network settings via <strong class="source-inline">nmcli</strong> isn't difficult, but at the same time, it's far from super user-friendly. There's quite a bit of syntax involved and sometimes, that can get a bit overwhelming. So, let's create a script that's going to do three things for us:</p>
			<ul>
				<li>Configure network settings via <strong class="source-inline">nmcli</strong> so that we use static IP network configuration.</li>
				<li>Configure network settings via <strong class="source-inline">nmcli</strong> so that we use DHCP network configuration.</li>
				<li>Check/output the current network settings</li>
			</ul>
			<p>Our script should <a id="_idIndexMarker1117"/>look like this:</p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code"># V1.0 / Jasmin Redzepagic / 01/11/2021 Initial script version </p>
			<p class="source-code"># Distribution allowed under GNU Licence V2.0 </p>
			<p class="source-code">echo "1 = nmcli - static IP address configuration for existing interface"</p>
			<p class="source-code">echo "2 = nmcli - reconfigure a static IP-based configuration to DHCP"</p>
			<p class="source-code">echo "3 = nmcli - list current device and connection status"</p>
			<p class="source-code">echo -e "Your choice:"</p>
			<p class="source-code">read CRIT</p>
			<p class="source-code"># Let's start our case loop against CRIT variable.</p>
			<p class="source-code">case $CRIT in</p>
			<p class="source-code">        1)</p>
			<p class="source-code">                echo "Let's first check current connection configuration:"</p>
			<p class="source-code">                nmcli con show</p>
			<p class="source-code">                echo "Which interface do you want to configure from this list?"</p>
			<p class="source-code">                echo "HINT: We need to use an entry from NAME field"</p>
			<p class="source-code">                echo "Type in the interface name: "</p>
			<p class="source-code">                read -a interface1</p>
			<p class="source-code">                echo "Type in the IP address/prefix: "</p>
			<p class="source-code">                read -a address1</p>
			<p class="source-code">                echo "Type in the default gateway IP address: "</p>
			<p class="source-code">                read -a gateway1</p>
			<p class="source-code">                echo "Type in DNS servers, use space to separate entries: "</p>
			<p class="source-code">                read -a dns1</p>
			<p class="source-code">                echo</p>
			<p class="source-code">                nmcli con mod $interface1 ipv4.address "$address1" ipv4.gateway "$gateway1"</p>
			<p class="source-code">                nmcli con mod $interface1 ipv4.method manual</p>
			<p class="source-code">                for dnsservers in ${dns1[@]}</p>
			<p class="source-code">                do</p>
			<p class="source-code">                        nmcli con mod $interface1 ipv4.dns $dnsservers</p>
			<p class="source-code">                done</p>
			<p class="source-code">                systemctl restart NetworkManager</p>
			<p class="source-code">                ;;</p>
			<p class="source-code">        2)</p>
			<p class="source-code">                echo "Let's first check current connection configuration:"</p>
			<p class="source-code">                nmcli con show</p>
			<p class="source-code">                echo "Which interface do you want to configure from this list?"</p>
			<p class="source-code">                echo "HINT: We need to use an entry from NAME field"</p>
			<p class="source-code">                echo "Type in the interface name: "</p>
			<p class="source-code">                read -a interface1</p>
			<p class="source-code">                nmcli con mod $interface1 ipv4.method auto</p>
			<p class="source-code">                systemctl restart NetworkManager</p>
			<p class="source-code">                ;;</p>
			<p class="source-code">        3)</p>
			<p class="source-code">                echo "Current status of network devices: "</p>
			<p class="source-code">                nmcli dev show</p>
			<p class="source-code">                echo "Current status of network connections: "</p>
			<p class="source-code">                nmcli con show</p>
			<p class="source-code">                ;;</p>
			<p class="source-code">        *)      echo "Please make a correct choice, available choices are 1-3!"</p>
			<p class="source-code">esac</p>
			<p>Here's what the <a id="_idIndexMarker1118"/>output will look if we use this script:</p>
			<div>
				<div id="_idContainer269" class="IMG---Figure">
					<img src="Images/Figure_16.5_B16269.jpg" alt="Figure 16.5 – Configuring a network interface from a shell script to make it a static IP configuration&#13;&#10;" width="1306" height="1346"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.5 – Configuring a network interface from a shell script to make it a static IP configuration</p>
			<p>As we can see, all of the network settings get applied. Also, for the second use case – which is to revert to using <a id="_idIndexMarker1119"/>DHCP from an existing configuration – the output will look like this:</p>
			<div>
				<div id="_idContainer270" class="IMG---Figure">
					<img src="Images/Figure_16.6_B16269.jpg" alt="Figure 16.6 – Reverting to our DHCP configuration with the BOOTPROTO parameter set up correctly&#13;&#10;" width="1306" height="1104"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.6 – Reverting to our DHCP configuration with the BOOTPROTO parameter set up correctly</p>
			<p>This file also looks <a id="_idIndexMarker1120"/>good, so we're good to go with this script as well.</p>
			<p>The next set of <a id="_idIndexMarker1121"/>scripts we'll be looking at is about backups – one will use shell script arguments and variables, while the other will use one very handy <strong class="source-inline">tar</strong> characteristic. Let's work on some backup scripts! </p>
			<h2 id="_idParaDest-387"><a id="_idTextAnchor395"/>There's more…</h2>
			<p><strong class="source-inline">Screen</strong> requires a bit of trial and error and getting used to. We recommend that you check out the following links to learn more:</p>
			<ul>
				<li><strong class="source-inline">nmcli</strong> man<a id="_idIndexMarker1122"/> page: <strong class="source-inline">https://linux.die.net/man/1/nmcli</strong></li>
				<li><strong class="source-inline">nmcli</strong> examples: <strong class="source-inline">https://people.freedesktop.org/~lkundrak/nm-docs/nmcli-examples.html</strong></li>
			</ul>
			<h1 id="_idParaDest-388"><a id="_idTextAnchor396"/>Backing up the current directory with shell script arguments and variables</h1>
			<p>One of the most <a id="_idIndexMarker1123"/>common reasons<a id="_idIndexMarker1124"/> why system engineers use Bash shell scripting is for backup purposes. There are various tools available, but for shell scripting purposes, we are going to make a couple of <strong class="source-inline">tar</strong>-based shell scripts, work with arguments and variables, and learn how to make our jobs easier by using shell scripting for backup purposes. Let's take a look!</p>
			<h2 id="_idParaDest-389"><a id="_idTextAnchor397"/>Getting ready</h2>
			<p>Before you start this recipe, you need to make sure that you have <strong class="source-inline">tar</strong> installed on your Linux machine. For this, you need to use the following command:</p>
			<p class="source-code">sudo apt-get -y install tar</p>
			<p>If you're using a CentOS-based machine, use the following command:</p>
			<p class="source-code">sudo yum -y install tar</p>
			<p>Now, you're ready to get started.</p>
			<h2 id="_idParaDest-390"><a id="_idTextAnchor398"/>How to do it…</h2>
			<p>Our premise for this first backup script, which is based on <strong class="source-inline">tar</strong>, is simple:</p>
			<ul>
				<li>We want to be able to create a backup while using an argument to set the backup's filename.</li>
				<li>We want to be able to easily change our shell script so that it can back up whatever number of directories we want (this is easy to do by listing the source directories in the <strong class="source-inline">backup_source</strong> variable).</li>
			</ul>
			<p>Let's see how <a id="_idIndexMarker1125"/>this would<a id="_idIndexMarker1126"/> work:</p>
			<p class="source-code">#!/bin/sh</p>
			<p class="source-code"># V1.0 / Jasmin Redzepagic / 01/11/2021 Initial script version </p>
			<p class="source-code"># Distribution allowed under GNU Licence V2.0 </p>
			<p class="source-code"># This script contains some pre-defined parameters:</p>
			<p class="source-code"># - which directories we want to backup, used as a variable</p>
			<p class="source-code"># backup_source</p>
			<p class="source-code"># - destination folder, via variable called backup_dest</p>
			<p class="source-code"># - indexing according to date, used as a variable date</p>
			<p class="source-code">#</p>
			<p class="source-code"># Also, it uses a shell script argument $1 (first argument that we</p>
			<p class="source-code"># use to call on the script) to set value for variable filename</p>
			<p class="source-code">filename=$1</p>
			<p class="source-code"># let's set the directory that we want to backup</p>
			<p class="source-code"># if we want to backup more of them, we create a space-separated</p>
			<p class="source-code"># list</p>
			<p class="source-code">backup_source="./"</p>
			<p class="source-code"># let's set the destination folder</p>
			<p class="source-code">backup_dest="/tmp"</p>
			<p class="source-code"># let's set value of the date variable in accordance to current date</p>
			<p class="source-code">date='date '+%d-%B-%Y''</p>
			<p class="source-code"># let's set the value of the hostname variable in accordance to host</p>
			<p class="source-code"># name</p>
			<p class="source-code">hostname=$(hostname -s)</p>
			<p class="source-code"># let's start the backup process</p>
			<p class="source-code">echo "Starting backup"</p>
			<p class="source-code">sleep 2</p>
			<p class="source-code">tar cvpzf   $backup_dest/$filename-$hostname-$date.tar.gz  $backup_source</p>
			<p class="source-code"># let's announce the end of the backup process</p>
			<p class="source-code">echo "Backup done"</p>
			<p>The <a id="_idIndexMarker1127"/>process should<a id="_idIndexMarker1128"/> look like this:</p>
			<div>
				<div id="_idContainer271" class="IMG---Figure">
					<img src="Images/Figure_16.7_B16269.jpg" alt="Figure 16.7 – Simple backup script with argument&#13;&#10;" width="618" height="1111"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.7 – Simple backup script with argument</p>
			<p>The <strong class="source-inline">backup</strong> word that <a id="_idIndexMarker1129"/>we typed as <a id="_idIndexMarker1130"/>part of the script is our <strong class="source-inline">$1</strong> argument in the script – the first argument that we start the script with. As we can see, the script did its job properly. </p>
			<h2 id="_idParaDest-391"><a id="_idTextAnchor399"/>There's more…</h2>
			<p>If you need any more information about the <strong class="source-inline">tar</strong> command, we suggest that you look at the following links:</p>
			<ul>
				<li><strong class="source-inline">tar</strong> command <a id="_idIndexMarker1131"/>man page: <a href="https://man7.org/linux/man-pages/man1/tar.1.html">https://man7.org/linux/man-pages/man1/tar.1.html</a></li>
				<li>18 useful <strong class="source-inline">tar</strong> examples: <a href="https://www.tecmint.com/18-tar-command-examples-in-linux/">https://www.tecmint.com/18-tar-command-examples-in-linux/</a></li>
			</ul>
			<h1 id="_idParaDest-392"><a id="_idTextAnchor400"/>Creating a current backup based on the user input for the backup source and destination</h1>
			<p>After making <a id="_idIndexMarker1132"/>backup scripts via <strong class="source-inline">tar</strong>, we need to make a completely interactive script that asks for all of the details from us to be inputted with the keyboard. Let's learn how to make this happen!</p>
			<h2 id="_idParaDest-393"><a id="_idTextAnchor401"/>Getting ready</h2>
			<p>If you followed the previous recipe, then you won't need anything new – the same requirements apply.</p>
			<h2 id="_idParaDest-394"><a id="_idTextAnchor402"/>How to do it…</h2>
			<p>Our premise has changed somewhat this time around. We want a fully functional backup script, but one that doesn't use any static variables (like the previous one). Also, we want to be able to call this script at will, which is why we're using multiple questions to set up the necessary variables. Here's what the script should look like: </p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code"># V1.0 / Jasmin Redzepagic / 01/11/2021 Initial script version </p>
			<p class="source-code"># Distribution allowed under GNU Licence V2.0 </p>
			<p class="source-code"># This script does a custom backup, based on our arguments</p>
			<p class="source-code"># We need to give it a couple of arguments @start:</p>
			<p class="source-code"># - backup file name</p>
			<p class="source-code"># - list of directories (or a single directory) that we</p>
			<p class="source-code"># want to backup</p>
			<p class="source-code"># We also added a bit of code to skip standard error</p>
			<p class="source-code">echo -e "Type in the backup file name, use something like file-date.tar.gz:"</p>
			<p class="source-code">read filename</p>
			<p class="source-code">echo -e "Type in the list or a single directory that you want to backup:"</p>
			<p class="source-code">read directories</p>
			<p class="source-code">echo "Let's do this thing!"</p>
			<p class="source-code">tar cfvz $filename $directories 2&gt; /dev/null</p>
			<p>This is simple, yet<a id="_idIndexMarker1133"/> effective. Note that we used one very, very cool capability of the <strong class="source-inline">tar</strong> command, which is to use a list of directories for backup purposes, but specifically, as the list that's at <em class="italic">the end</em> of the <strong class="source-inline">tar</strong> command's syntax, which makes things a bit easier. </p>
			<p>In the next chapter, things are going to get progressively more complicated. Make sure that you check out the second part of our shell scripting examples there.</p>
			<h2 id="_idParaDest-395"><a id="_idTextAnchor403"/>There's more…</h2>
			<p>If you need any more information about the <strong class="source-inline">tar</strong> command, we suggest that you visit the following links:</p>
			<ul>
				<li><strong class="source-inline">tar</strong> command man page: <a href="https://man7.org/linux/man-pages/man1/tar.1.html">https://man7.org/linux/man-pages/man1/tar.1.html</a></li>
				<li>18 useful <strong class="source-inline">tar</strong> examples: <a href="https://www.tecmint.com/18-tar-command-examples-in-linux/">https://www.tecmint.com/18-tar-command-examples-in-linux/</a></li>
			</ul>
		</div>
	</div></body></html>