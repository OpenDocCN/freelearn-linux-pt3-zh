<html><head></head><body>
<div id="_idContainer192">
<h1 class="chapter-number" id="_idParaDest-170"><a id="_idTextAnchor199"/><span class="koboSpan" id="kobo.1.1">16</span></h1>
<h1 id="_idParaDest-171"><a id="_idTextAnchor200"/><span class="koboSpan" id="kobo.2.1">Speeding Up Product Development through Emulation – QEMU</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In this chapter, we explore the possibilities of shortening product development through emulation and reducing the dependency on real hardware for most development. </span><span class="koboSpan" id="kobo.3.2">You will come to understand the benefits of using QEMU over hardware and when choosing real hardware is preferable. </span><span class="koboSpan" id="kobo.3.3">We also describe the </span><strong class="source-inline"><span class="koboSpan" id="kobo.4.1">runqemu</span></strong><span class="koboSpan" id="kobo.5.1"> capabilities and demonstrate some </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">use cases.</span></span></p>
<h1 id="_idParaDest-172"><a id="_idTextAnchor201"/><span class="koboSpan" id="kobo.7.1">What is QEMU?</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.8.1">Quick EMUlator</span></strong><span class="koboSpan" id="kobo.9.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.10.1">QEMU</span></strong><span class="koboSpan" id="kobo.11.1">) is a free, open</span><a id="_idIndexMarker479"/><span class="koboSpan" id="kobo.12.1"> source software tool that allows users to run multiple architectures on the same physical machine. </span><span class="koboSpan" id="kobo.12.2">It is a system emulator that can virtualize complete device hardware, including the CPU, memory, storage, </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">and peripherals.</span></span></p>
<p><span class="koboSpan" id="kobo.14.1">Using QEMU for testing and debugging can save time and effort during development. </span><span class="koboSpan" id="kobo.14.2">It allows developers to test their code in various </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">simulated environments.</span></span></p>
<p><span class="koboSpan" id="kobo.16.1">Among other things, the Yocto Project uses</span><a id="_idIndexMarker480"/><span class="koboSpan" id="kobo.17.1"> QEMU to run automated </span><strong class="bold"><span class="koboSpan" id="kobo.18.1">Quality Assurance</span></strong><span class="koboSpan" id="kobo.19.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.20.1">QA</span></strong><span class="koboSpan" id="kobo.21.1">) tests on final images shipped with each release. </span><span class="koboSpan" id="kobo.21.2">Within the context of the Yocto Project, QEMU allows you to run a complete image you have built using the Yocto Project as another task on your build system. </span><span class="koboSpan" id="kobo.21.3">In addition, QEMU helps to run and test images and applications on supported Yocto Project architectures without having </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">actual hardware.</span></span></p>
<h1 id="_idParaDest-173"><a id="_idTextAnchor202"/><span class="koboSpan" id="kobo.23.1">What are the benefits of using QEMU over hardware?</span></h1>
<p><span class="koboSpan" id="kobo.24.1">There are several</span><a id="_idIndexMarker481"/><span class="koboSpan" id="kobo.25.1"> situations where it may be more practical to use QEMU instead of real hardware for testing </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">and debugging:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.27.1">It allows you to quickly and easily test your code in various simulated environments without constantly deploying it to the </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">target device</span></span></li>
<li><span class="koboSpan" id="kobo.29.1">If you don’t have the hardware that the software will be running on or if its availability </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">is limited</span></span></li>
<li><span class="koboSpan" id="kobo.31.1">When you need to test software on multiple hardware platforms without having to set up multiple </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">physical machines</span></span></li>
<li><span class="koboSpan" id="kobo.33.1">When you want to debug software in a controlled environment, such as reduced memory availability, to </span><a id="_idIndexMarker482"/><span class="koboSpan" id="kobo.34.1">observe </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">its behavior</span></span></li>
<li><span class="koboSpan" id="kobo.36.1">When you want to validate software that isn’t hardware specific and wish to reduce the time needed for testing, such as flashing, board wiring, and </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">so on</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.38.1">However, it is essential to note that QEMU is a software emulator, which may not be a perfect substitute for real hardware at all times. </span><span class="koboSpan" id="kobo.38.2">Therefore, testing software on real hardware may be necessary to ensure it </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">works correctly.</span></span></p>
<h1 id="_idParaDest-174"><a id="_idTextAnchor203"/><span class="koboSpan" id="kobo.40.1">When is choosing real hardware preferable?</span></h1>
<p><span class="koboSpan" id="kobo.41.1">There are several situations</span><a id="_idIndexMarker483"/><span class="koboSpan" id="kobo.42.1"> where it may be more practical, and even required, to use real hardware instead of QEMU for testing and debugging, such as </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.44.1">When the software relies </span><a id="_idIndexMarker484"/><span class="koboSpan" id="kobo.45.1">on specific hardware features, for</span><a id="_idIndexMarker485"/><span class="koboSpan" id="kobo.46.1"> example, a particular </span><strong class="bold"><span class="koboSpan" id="kobo.47.1">Video Processing Unit</span></strong><span class="koboSpan" id="kobo.48.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.49.1">VPU</span></strong><span class="koboSpan" id="kobo.50.1">) or </span><strong class="bold"><span class="koboSpan" id="kobo.51.1">Graphics Processing Unit</span></strong><span class="koboSpan" id="kobo.52.1"> (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.53.1">GPU</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">) feature</span></span></li>
<li><span class="koboSpan" id="kobo.55.1">When evaluating the software performance, QEMU may not be able to replicate the performance of </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">real hardware</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.57.1">While QEMU can be a valuable tool for testing and debugging software, it is not always a perfect substitute for </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">real hardware.</span></span></p>
<h1 id="_idParaDest-175"><a id="_idTextAnchor204"/><span class="koboSpan" id="kobo.59.1">Using runqemu capabilities</span></h1>
<p><span class="koboSpan" id="kobo.60.1">QEMU is </span><a id="_idIndexMarker486"/><span class="koboSpan" id="kobo.61.1">deeply integrated into the Yocto Project, and it is crucial to learn how to take advantage of this integration so we can plan the testing of our projects. </span><span class="koboSpan" id="kobo.61.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.62.1">runqemu</span></strong><span class="koboSpan" id="kobo.63.1"> usage lists the variety of options available, which you can see in the </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">following figure:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer186">
<span class="koboSpan" id="kobo.65.1"><img alt="Figure 16.1 ﻿– The runqemu usage" src="image/Figure_16.1_B19361.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.66.1">Figure 16.1 – The runqemu usage</span></p>
<p><span class="koboSpan" id="kobo.67.1">There are a few</span><a id="_idIndexMarker487"/><span class="koboSpan" id="kobo.68.1"> use cases of QEMU that are important </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">to highlight:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.70.1">Allows choosing different kernel images </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">for testing</span></span></li>
<li><span class="koboSpan" id="kobo.72.1">Allows choosing different </span><strong class="source-inline"><span class="koboSpan" id="kobo.73.1">rootfs</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.74.1">for booting</span></span></li>
<li><span class="koboSpan" id="kobo.75.1">The capability to pass boot arguments for </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">the kernel</span></span></li>
<li><span class="koboSpan" id="kobo.77.1">Supports the use of a graphical environment with OpenGL or OpenGL </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">ES options</span></span></li>
<li><span class="koboSpan" id="kobo.79.1">It can pass extra QEMU </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">command-line parameters</span></span></li>
<li><span class="koboSpan" id="kobo.81.1">Allows the use of serial console-only for rapid </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">image testing</span></span></li>
<li><span class="koboSpan" id="kobo.83.1">Testing the audio </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">stack support</span></span></li>
<li><span class="koboSpan" id="kobo.85.1">Testing different init systems (</span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">e.g., systemd)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.87.1">In the following few </span><a id="_idIndexMarker488"/><span class="koboSpan" id="kobo.88.1">sections, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">qemux86-64</span></strong><span class="koboSpan" id="kobo.90.1"> machine as a reference to cover some common use cases, illustrating the main </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.91.1">runqemu</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.92.1"> capabilities.</span></span></p>
<h2 id="_idParaDest-176"><a id="_idTextAnchor205"/><span class="koboSpan" id="kobo.93.1">Using runqemu to test graphical applications</span></h2>
<p><span class="koboSpan" id="kobo.94.1">When we aim to </span><a id="_idIndexMarker489"/><span class="koboSpan" id="kobo.95.1">validate the application, ignoring the</span><a id="_idIndexMarker490"/><span class="koboSpan" id="kobo.96.1"> embedded device GPU performance, we can rely on QEMU for such validation, for example, a Qt or GTK+ application. </span><span class="koboSpan" id="kobo.96.2">At first, we need to build the </span><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">core-image-weston</span></strong><span class="koboSpan" id="kobo.98.1"> image. </span><span class="koboSpan" id="kobo.98.2">Next, we can run the validation </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer187">
<span class="koboSpan" id="kobo.100.1"><img alt="Figure 16.2 – The log after running QEMU with graphic support" src="image/Figure_16.2_B19361.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.101.1">Figure 16.2 – The log after running QEMU with graphic support</span></p>
<p><span class="koboSpan" id="kobo.102.1">Next, you see the execution of </span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">core-image-weston</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.104.1">inside QEMU:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer188">
<span class="koboSpan" id="kobo.105.1"><img alt="Figure 16.3 – Screenshot of QEMU running core-image-weston" src="image/Figure_16.3_B19361.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.106.1">Figure 16.3 – Screenshot of QEMU running core-image-weston</span></p>
<p><span class="koboSpan" id="kobo.107.1">The preceding </span><a id="_idIndexMarker491"/><span class="koboSpan" id="kobo.108.1">screenshot shows the </span><a id="_idIndexMarker492"/><span class="koboSpan" id="kobo.109.1">Wayland Terminal open, showing the information of the running </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">Linux kernel.</span></span></p>
<h2 id="_idParaDest-177"><a id="_idTextAnchor206"/><span class="koboSpan" id="kobo.111.1">Using runqemu to validate memory constraints</span></h2>
<p><span class="koboSpan" id="kobo.112.1">When we aim to </span><a id="_idIndexMarker493"/><span class="koboSpan" id="kobo.113.1">validate the application</span><a id="_idIndexMarker494"/><span class="koboSpan" id="kobo.114.1"> memory usage, we can rely on QEMU for such validation. </span><span class="koboSpan" id="kobo.114.2">At first, we need to build the </span><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">core-image-full-cmdline</span></strong><span class="koboSpan" id="kobo.116.1"> image and run QEMU with the following </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">command line:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer189">
<span class="koboSpan" id="kobo.118.1"><img alt="Figure 16.4 – The log after running QEMU with 128 MB of RAM" src="image/Figure_16.4_B19361.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.119.1">Figure 16.4 – The log after running QEMU with 128 MB of RAM</span></p>
<p><span class="koboSpan" id="kobo.120.1">In the following screenshot, we can</span><a id="_idIndexMarker495"/><span class="koboSpan" id="kobo.121.1"> see the amount</span><a id="_idIndexMarker496"/><span class="koboSpan" id="kobo.122.1"> of memory in use </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">inside QEMU:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer190">
<span class="koboSpan" id="kobo.124.1"><img alt="Figure 16.5 – Screenshot of QEMU running core-image-full-cmdline with 128 MB of RAM" src="image/Figure_16.5_B19361.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.125.1">Figure 16.5 – Screenshot of QEMU running core-image-full-cmdline with 128 MB of RAM</span></p>
<p><span class="koboSpan" id="kobo.126.1">Changing the command line used to run QEMU can help us test a set of different memory sizes </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">via </span></span><span class="No-Break"><a id="_idIndexMarker497"/></span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">emulation.</span></span></p>
<h2 id="_idParaDest-178"><a id="_idTextAnchor207"/><span class="koboSpan" id="kobo.129.1">Using runqemu to help with image regression tests</span></h2>
<p><span class="koboSpan" id="kobo.130.1">The Yocto Project</span><a id="_idIndexMarker498"/><span class="koboSpan" id="kobo.131.1"> provides an automated testing framework, a crucial part of the Yocto Project Quality Assurance process. </span><span class="koboSpan" id="kobo.131.2">The</span><a id="_idIndexMarker499"/><span class="koboSpan" id="kobo.132.1"> integration or validation testing support uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">testimage</span></strong><span class="koboSpan" id="kobo.134.1"> class to execute the images inside </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">the target.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.136.1">Tip</span></p>
<p class="callout"><span class="koboSpan" id="kobo.137.1">The testing framework can test existing recipes and images and be enhanced with custom tests to validate new applications and integrations. </span><span class="koboSpan" id="kobo.137.2">The testing framework capabilities are described in the section </span><em class="italic"><span class="koboSpan" id="kobo.138.1">Types of Testing Overview from Yocto Project </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.139.1">Tests</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.140.1"> (</span></span><a href="https://docs.yoctoproject.org/4.0.4/test-manual/intro.html#yocto-project-tests-types-of-testing-overview"><span class="No-Break"><span class="koboSpan" id="kobo.141.1">https://docs.yoctoproject.org/4.0.4/test-manual/intro.html#yocto-project-tests-types-of-testing-overview</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.142.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.143.1">First, we enabled the </span><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">testimage</span></strong><span class="koboSpan" id="kobo.145.1"> support by adding </span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">IMAGE_CLASSES += "testimage"</span></strong><span class="koboSpan" id="kobo.147.1"> in </span><strong class="source-inline"><span class="koboSpan" id="kobo.148.1">build/conf/local.conf</span></strong><span class="koboSpan" id="kobo.149.1"> and made sure to build the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.150.1">core-image-weston</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.151.1"> image.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.152.1">Warning</span></p>
<p class="callout"><span class="koboSpan" id="kobo.153.1">During the image testing, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">sudo</span></strong><span class="koboSpan" id="kobo.155.1"> command is used for networking setup and may trigger an error depending on your host configuration. </span><span class="koboSpan" id="kobo.155.2">Check </span><em class="italic"><span class="koboSpan" id="kobo.156.1">Yocto Project Development Tasks Manual</span></em><span class="koboSpan" id="kobo.157.1">, in the </span><em class="italic"><span class="koboSpan" id="kobo.158.1">Enabling Runtime Tests on QEMU</span></em><span class="koboSpan" id="kobo.159.1"> section (</span><a href="https://docs.yoctoproject.org/4.0.4/dev-manual/common-tasks.html#enabling-runtime-tests-on-qemu"><span class="koboSpan" id="kobo.160.1">https://docs.yoctoproject.org/4.0.4/dev-manual/common-tasks.html#enabling-runtime-tests-on-qemu</span></a><span class="koboSpan" id="kobo.161.1">) for how to avoid </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">those errors.</span></span></p>
<p><span class="koboSpan" id="kobo.163.1">Then, we must build the </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">core-image-weston</span></strong><span class="koboSpan" id="kobo.165.1"> image. </span><span class="koboSpan" id="kobo.165.2">We are ready now to start the execution of </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">testimage</span></strong><span class="koboSpan" id="kobo.167.1"> with the </span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">following command:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer191">
<span class="koboSpan" id="kobo.169.1"><img alt="Figure 16.6 – The result of running the testimage task for core-image-weston" src="image/Figure_16.6_B19361.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.170.1">Figure 16.6 – The result of running the testimage task for core-image-weston</span></p>
<p><span class="koboSpan" id="kobo.171.1">In the preceding log, we</span><a id="_idIndexMarker500"/><span class="koboSpan" id="kobo.172.1"> see the regression </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">test </span></span><span class="No-Break"><a id="_idIndexMarker501"/></span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">results.</span></span></p>
<h1 id="_idParaDest-179"><a id="_idTextAnchor208"/><span class="koboSpan" id="kobo.175.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.176.1">In this chapter, we have learned how to use QEMU and how its capabilities can shorten the development cycle by emulating when possible and describing when it is not possible. </span><span class="koboSpan" id="kobo.176.2">It also presented some </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">runqemu</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.178.1">use cases.</span></span></p>
<p><span class="koboSpan" id="kobo.179.1">In the final chapter, we offer a list of good practices that authors have been using over the years in the development of Yocto </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">Project-based products.</span></span></p>
</div>
</body></html>