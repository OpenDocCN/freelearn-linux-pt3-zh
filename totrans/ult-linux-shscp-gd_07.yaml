- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Text Stream Filters – Part 2
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本流过滤器 – 第二部分
- en: In this chapter, we’ll continue our look at various text-stream filters. As
    you go through this chapter, I challenge you to use your imagination. Instead
    of thinking of these filter utilities as something you have to learn because I
    said so, or because you need to learn them for a Linux certification exam, try
    to imagine the ways in which each of these utilities can help you format your
    own text files and reports. Trust me, you’ll never know when one or more of these
    utilities could come in handy.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续探讨各种文本流过滤器。在学习本章时，我挑战你发挥想象力。不要把这些过滤器工具当作是因为我说了或者你需要通过Linux认证考试就必须学的东西，试着去想象每个工具是如何帮助你格式化自己的文本文件和报告的。相信我，你永远不会知道这些工具什么时候会派上用场。
- en: 'Here are the topics that we’ll cover in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Using `expand`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`expand`
- en: Using `unexpand`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`unexpand`
- en: Using `nl`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`nl`
- en: Using `head`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`head`
- en: Using `tail`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`tail`
- en: Using `head` and `tail` together
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同时使用`head`和`tail`
- en: Using `od`
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`od`
- en: Using `uniq`
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`uniq`
- en: Using `wc`
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`wc`
- en: Using `fmt`
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`fmt`
- en: Using `split`
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`split`
- en: Using `tr`
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`tr`
- en: Using `xargs`
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`xargs`
- en: Using `pr`
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`pr`
- en: Printing from the Command-line
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从命令行打印
- en: They’re not hard to master, but there is a lot to cover. So if you’re ready,
    let’s get started.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 它们并不难掌握，但涉及的内容很多。所以如果你准备好了，我们开始吧。
- en: Technical Requirements
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Use either of your virtual machines, because things will work the same on either
    of them. Or, if your host machine is running either Linux or macOS, feel free
    to use it instead of a virtual machine. I won’t be providing an actual hands-on
    lab, so feel free to follow along on your own machine as you read through the
    chapter. And, as before, you can download the text files that you’ll need from
    the GitHub repository.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用任意一个虚拟机，因为在两者上效果是一样的。或者，如果你的主机正在运行Linux或macOS，也可以直接使用主机，而不必使用虚拟机。我不会提供实际的实验室操作，因此你可以在阅读本章节时，随时在自己的机器上操作。同时，和之前一样，你可以从GitHub仓库下载所需的文本文件。
- en: Using expand
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用expand
- en: There may be times when a text document that you create with columnar data just
    won’t display correctly under certain circumstances. It may be because you separated
    the columns with tabs instead of with spaces. Sometimes, tabs won’t display correctly,
    and you’ll need to replace them with spaces.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你创建的包含列数据的文本文件在某些情况下可能无法正确显示。这可能是因为你用制表符而不是空格分隔列。有时，制表符显示不正确，你需要将它们替换为空格。
- en: 'To look at this, create the `expand.txt` text file. There will be three columns
    of data with two tabs between each column. The file will look like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看这一点，创建一个`expand.txt`文本文件。文件中将包含三列数据，每列之间有两个制表符。文件内容如下：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, expand the file and note the output. It should look like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，展开文件并查看输出。它应该如下所示：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Since I still have this creepy habit of reading your mind, I know that you’re
    wondering what’s really going on, since the expanded output looks the same as
    the original file. This is where looks can be deceiving. When you expanded the
    file, each tab that you placed between the columns was replaced by a number of
    blank spaces. The number of spaces varies from line-to-line, depending upon how
    many characters are in each text string. That way, the columns will still all
    line up evenly.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我还保留着阅读你心思的怪癖，我知道你一定在想，既然扩展后的输出与原文件看起来一样，究竟发生了什么。这时，外观可能会让人产生误导。当你扩展文件时，你在列之间放置的每个制表符都被若干空格所替换。空格的数量因行而异，取决于每个文本字符串中的字符数量。这样，列仍然可以保持对齐。
- en: Actually, expand replaces each whole tab character with eight spaces. But when
    you have text strings of varying lengths, it doesn’t appear to do that. That’s
    because expand adjusts the number of blank spaces it inserts to keep all of the
    columns lined up. If you have a text file with more than one tab between the columns
    and with varying length text strings, all but one of the tabs will be replaced
    by exactly eight spaces.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`expand`会将每个制表符字符替换为八个空格。但当文本字符串长度不一致时，它似乎不会这么做。这是因为`expand`会调整插入的空格数，以确保所有列都对齐。如果你的文本文件中列与列之间有多个制表符，且文本长度不一致，除了一个制表符，其他的都会被替换成恰好八个空格。
- en: 'If you want to prove this, save the expanded output to a new file, and then
    open the new file with your favorite text editor. In my case, I’ll use `vim`,
    like so:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想验证这一点，可以将扩展后的输出保存到一个新文件中，然后用你喜欢的文本编辑器打开新文件。在我的例子中，我将使用`vim`，像这样：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, move your cursor to the blank area between two of the columns. Move to
    the left or right between the columns, and you’ll see that you’ll only move one
    space at a time. Close this file, and open the original file. When you move the
    cursor between the columns of this file, you’ll see that it moves by the length
    of a tab, instead of by just one space.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，移动光标到两个列之间的空白区域。左右移动光标时，你会发现它每次只能移动一个空格。关闭此文件，打开原始文件。当你在此文件的列之间移动光标时，你会看到光标移动了一个制表符的长度，而不是一个空格。
- en: There are two options that you can use with expand. The first is the `-t` option.
    This lets you set the number of spaces you want to use in place of the tabs, instead
    of using the default of eight. Here, we want to replace each tab with only two
    blank spaces.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`expand` 有两个可以使用的选项。第一个是 `-t` 选项。这个选项让你设置想要替换制表符的空格数，而不是使用默认的八个空格。这里，我们想将每个制表符替换为两个空格。'
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With only two spaces replacing each tab, `expand` failed to keep the columns
    properly aligned. Feel free to experiment with other `-t` values to see how things
    turn out.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个制表符仅替换为两个空格，`expand` 未能保持列的正确对齐。你可以随意尝试其他 `-t` 值，看看会发生什么。
- en: 'With the `-i` switch, you can instruct `expand` to only replace tabs that are
    at the beginning of each line. Subsequent tabs in each line will remain unaltered.
    To see how it works, copy the `expand_1.txt` file to the `expand_1a.txt` file,
    like so:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `-i` 开关，你可以指示 `expand` 只替换每行开头的制表符。每行后续的制表符将保持不变。为了看看它是如何工作的，将 `expand_1.txt`
    文件复制到 `expand_1a.txt` 文件中，如下所示：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Open expand_1a.txt in your text editor, and insert one tab at the beginning
    of line 1, two tabs at the beginning of line 2, and three tabs at the beginning
    of line 3\. The edited file should now look like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在文本编辑器中打开 expand_1a.txt 文件，并在第 1 行的开头插入一个制表符，在第 2 行的开头插入两个制表符，在第 3 行的开头插入三个制表符。编辑后的文件应该如下所示：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Using the -i option, expand this file into the expand_1b.txt file, like so:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 -i 选项，将此文件展开到 expand_1b.txt 文件中，如下所示：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Open `expand_1b.txt` in your text editor, and verify that only the tabs that
    preceded each line were replaced with blank spaces.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在文本编辑器中打开 `expand_1b.txt` 文件，并确认只有每行前面的制表符被替换为空格。
- en: Guess what? That’s all I have to say about `expand`. Now, let’s go in the opposite
    direction.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 猜猜看？这就是我关于 `expand` 要说的全部内容。现在，让我们反向操作。
- en: Using unexpand
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 unexpand
- en: Now that I’ve told you what `expand` does, do I really need to tell you what
    `unexpand` does? That’s right, you guessed it. `unexpand` removes the blank spaces
    from between columns, and replaces them with tabs. There are a couple of slight
    catches, though. By default, `unexpand` only operates on spaces that are at the
    beginning of a line. That’s just the opposite of how expand works with tabs. So,
    if you want to replace all spaces in a line with tabs, you’ll need to use the
    `-a` switch. The second catch is that by default, `unexpand` only works if it
    sees eight consecutive blank spaces. Any grouping of fewer than eight consecutive
    blank spaces won’t get converted to tabs. (You can change that behavior with the
    `-t` switch, as you’ll see in a few moments.)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我已经告诉你 `expand` 做了什么，我还需要告诉你 `unexpand` 做了什么吗？没错，你猜对了。`unexpand` 会删除列之间的空格，并将其替换为制表符。不过，有几个小问题。默认情况下，`unexpand`
    仅作用于行首的空格。这正好与 `expand` 用制表符的方式相反。因此，如果你想将一行中的所有空格都替换为制表符，就需要使用 `-a` 开关。第二个问题是，默认情况下，`unexpand`
    只有在看到连续的八个空格时才会生效。少于八个连续空格的分组不会被替换为制表符。（你可以通过 `-t` 开关来更改这种行为，稍后你会看到。）
- en: 'I’ll demonstrate by unexpanding the `expand_2.txt` file that I’ve just created
    in the `expand` section, using the `-a` option, like so:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我将通过使用 `-a` 选项，来展示如何取消展开我在 `expand` 部分刚刚创建的 `expand_2.txt` 文件，如下所示：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Again, you can’t really tell the difference. To see the difference, save the
    results to a new file, like so:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，你可能看不出区别。为了看到区别，将结果保存到一个新文件中，如下所示：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Open the new file in your favorite text editor. Now, when you move your cursor
    between the columns, you’ll see that it jumps by the length of a tab, instead
    of by just one space. In other words, it’s now just like the original file that
    I expanded in the previous section.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在你最喜欢的文本编辑器中打开新文件。现在，当你在列之间移动光标时，你会发现它跳过了一个制表符的长度，而不仅仅是一个空格。换句话说，它现在和我在上一节中展开的原始文件一样。
- en: This works because when I used `expand` to create the `expand_2.txt` file, the
    tabs between the columns were all replaced by eight or more blank spaces.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 之所以这样工作，是因为当我使用 `expand` 创建 `expand_2.txt` 文件时，列之间的制表符都被替换为八个或更多的空格。
- en: 'Now, I told you before that by default, `unexpand` only operates on the blank
    spaces that are at the beginning of a line. To see that, open the `expand_3.txt`
    file, which will look like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我之前告诉过你，默认情况下，`unexpand` 只对位于行首的空白字符进行操作。要验证这一点，打开 `expand_3.txt` 文件，内容将如下所示：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It’s rather ugly because nothing is in alignment, but in this case that’s what
    we want. The first line is preceded by eight blank spaces, the second line is
    preceded by four blank spaces, and the third line is preceded by two blank spaces.
    Between the columns are varying numbers of blank spaces.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来有点乱，因为没有任何对齐，但在这种情况下正是我们想要的。第一行前面有八个空白字符，第二行前面有四个空白字符，第三行前面有两个空白字符。各列之间有不同数量的空白字符。
- en: 'Next, create the `unexpand_2.txt` file by unexpanding the `expand_3.txt` file,
    like so:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过取消展开 `expand_3.txt` 文件来创建 `unexpand_2.txt` 文件，方法如下：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Open the `unexpand_2.txt` file in your text editor and verify that only the
    eight blank spaces at the beginning of the first line were replaced by a tab.
    Close the file and repeat the command with the `-t4` option, like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `unexpand_2.txt` 文件，在文本编辑器中验证只有第一行开头的八个空白字符被替换为一个制表符。关闭文件，然后用 `-t4` 选项重新运行命令，如下所示：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This time, you should see that the blank spaces at the beginning of both lines
    1 and 2 have been replaced by tabs. Try this again with the `-t2` option, and
    you’ll see that the blank spaces that precede all three lines are replaced by
    tabs. Finally, run these commands again with the `-a` option to perform a global
    replacement of the blank spaces.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，你应该看到第 1 行和第 2 行开头的空白字符已被制表符替代。再试一次，使用 `-t2` 选项，你会看到所有三行前面的空白字符都被制表符替代。最后，再次运行这些命令，使用
    `-a` 选项来执行空白字符的全局替换。
- en: I have to confess that for a long time, I never thought that I would use either
    `expand` or `unexpand` for anything. But, I was wrong. Several years ago, a former
    client tasked me with teaching a Kali Linux course. The book that I was using
    had a shell script that was supposed to automatically extract the IP address from
    the output of the `ifconfig` command. The script didn’t work though, because after
    the author wrote the book someone changed the `ifconfig` code so that the output
    would be formatted differently.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我必须承认，长期以来，我从未认为自己会使用 `expand` 或 `unexpand` 做任何事。但我错了。几年前，一位前客户委托我教授一门 Kali
    Linux 课程。我使用的书中有一个 shell 脚本，本应该自动从 `ifconfig` 命令的输出中提取 IP 地址。但脚本并没有正常工作，因为书籍写作完成后，有人更改了
    `ifconfig` 代码，导致输出格式发生了变化。
- en: I had to modify the script to make it work, and I used either `expand` or `unexpand`
    as part of the fix. (That was long ago, so I don’t remember which one I used.
    But, that doesn’t matter.) So, it goes to show that you just never know. (Yes,
    I am a poet.)
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我不得不修改脚本才能使其正常工作，并且我使用了 `expand` 或 `unexpand` 作为修复的一部分。（那是很久以前的事了，所以我不记得具体用了哪个。不过，这不重要。）所以，这表明你永远不知道会发生什么。（是的，我是个诗人。）
- en: Okay, enough of expanding and unexpanding. Let’s do some numbering.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，关于展开和取消展开的内容就到此为止。接下来让我们做一些编号。
- en: Using nl
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `nl`
- en: 'The `nl` utility is used for numbering lines of a text file. It’s easy to use,
    and there are only a few options that you need to remember. Let’s start by creating
    a file with ten consecutive lines, like so:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`nl` 工具用于对文本文件的行进行编号。它很容易使用，且只有少数几个选项需要记住。让我们从创建一个包含十行连续内容的文件开始，如下所示：'
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let’s number the lines in the file, like so:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按如下方式对文件中的行进行编号：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, let’s create another file just like this one, except that we’ll insert
    a few blank lines.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们创建另一个与此相同的文件，唯一的区别是我们插入了一些空行。
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Again, we’ll number this file without specifying any options.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将对这个文件进行编号，但不指定任何选项。
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If you don’t specify any options, only the non-blank lines will be numbered.
    Use the `-b` switch with the appropriate options to change that behavior. With
    the `a` option, you can number all lines, including the blanks. (By the way, the
    `-b` switch stands for **body**. In other words, this switch sets the way in which
    `nl` numbers lines in the body of the file. In just a moment, I’ll show you how
    this comes into play.)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有指定任何选项，只有非空行会被编号。使用 `-b` 开关和适当的选项可以改变这一行为。通过 `a` 选项，你可以编号所有的行，包括空白行。（顺便说一下，`-b`
    开关代表**正文**。换句话说，这个开关设置了 `nl` 在文件正文中对行进行编号的方式。稍后我会展示这个开关如何发挥作用。）
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `-bt` option causes `nl` to only number non-empty lines in the text file
    body, while the `-bn` option tells `nl` not to number lines at all in the text
    file body. This may sound a bit strange to you, since the first option defines
    what is already default behavior, and the second option seems to defeat the whole
    purpose of using `nl`. I’ll clarify all of this in just a moment.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`-bt`选项使`nl`只对文本文件正文中非空的行进行编号，而`-bn`选项则告诉`nl`不对文本文件正文中的行进行编号。这可能对你来说有点奇怪，因为第一个选项定义了已经是默认行为的内容，而第二个选项似乎完全违背了使用`nl`的目的。稍后我会对此进行澄清。'
- en: When you create a text file, you can use a special set of delimiters to define
    a header, a body, and a footer that will be used by `nl`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建文本文件时，可以使用一组特殊的分隔符来定义一个头部、正文和页脚，这些将由`nl`使用。
- en: As you can see in the following diagram, you do this by placing the appropriate
    series of backslashes and colons at the start of each section.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如下图所示，你可以通过在每个部分的开头放置适当的反斜杠和冒号来实现这一点。
- en: '![](img/B21693_07_01.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21693_07_01.png)'
- en: 'Figure 7.1: The header, body, and footer sections of a text file'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1：文本文件的头部、正文和页脚部分
- en: 'Three of each character defines the header, two of each defines the body, and
    one of each defines the footer. The `nl` utility allows you to number each of
    these sections in its own way. Put this to the test by creating your own three-section
    text file, which will look like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 每个字符出现三次定义了头部，两个字符定义了正文，一个字符定义了页脚。`nl`工具允许你以不同的方式对这些部分进行编号。通过创建你自己的三部分文本文件来验证这一点，文件将如下所示：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When using `nl` without specifying any options, only the non-blank lines in
    the body will get numbered, as you see here:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`nl`而不指定任何选项时，只有正文中非空的行会被编号，像这样：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To number lines in the header and footer, you would use the `-h` and the `-f`
    switches. The options that go with those switches are the same as the ones that
    go with the `-b` switch. So, to number all lines in the header as well as the
    non-blank lines in the body, you would use the `-ha` option, like so:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要对头部和页脚中的行进行编号，你需要使用`-h`和`-f`开关。这些开关的选项与`-b`开关的选项相同。因此，要对头部中的所有行以及正文中非空行进行编号，你可以使用`-ha`选项，如下所示：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To number only non-blank lines in the header and non-blank lines in the body,
    use the `-ht` option, like so:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要仅对头部和正文中的非空行进行编号，使用`-ht`选项，如下所示：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, let’s number all lines in the footer, like so:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们为页脚中的所有行进行编号，如下所示：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This time, the footer got numbered, but the header didn’t. In both cases, the
    non-blank lines in the body got numbered, even though I didn’t specify for `nl`
    to do that. To prevent `nl` from numbering lines in the body while numbering all
    lines in both the header and footer, include the `-bn` option, like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，页脚被编号了，但头部没有。在这两种情况下，正文中的非空行被编号了，尽管我并没有指定让`nl`这么做。为了防止`nl`在编号页头和页脚的同时编号正文中的行，可以加上`-bn`选项，像这样：
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can also have `nl` search for lines that contain a certain text string,
    and number only those lines. For this, you would use the `p` option. Let’s take
    our first text file, which we’ll call `lines.txt`, and number only the line that
    contains the word `seven`. (Note that you can’t have a space between the `p` and
    the string for which you’re searching.) It will look something like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以让`nl`搜索包含特定文本字符串的行，并只对这些行进行编号。为此，你需要使用`p`选项。我们以第一个文本文件为例，称之为`lines.txt`，并仅对包含单词`seven`的行进行编号。（请注意，`p`和你要搜索的字符串之间不能有空格。）它的效果如下所示：
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now, let’s create a file that’s a tad bit more realistic. We’ll even go all
    out and give it header, body, and footer.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个稍微更现实的文件。我们甚至会做得更完整，给它加上头部、正文和页脚。
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, number every line in the body that contains the word `MacGruder`, like
    this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对正文中包含单词`MacGruder`的每一行进行编号，像这样：
- en: '[PRE25]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If you specify for `nl` to only number the `MacGruder` lines for the header
    and/or the footer without specifying anything for the body, `nl` will also number
    all non-blank body lines by default, as you see here:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你指定`nl`只对头部和/或页脚中的`MacGruder`行进行编号，而没有指定正文部分，`nl`仍会按默认方式对正文中所有非空行进行编号，如下所示：
- en: '[PRE26]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Include the `-bn` option to only number the `MacGruder` lines in the header
    and/or footer, like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 包含`-bn`选项，仅对头部和/或页脚中的`MacGruder`行进行编号，像这样：
- en: '[PRE27]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: And now, you’re wondering when you would ever create a text file with these
    `nl`-style headers and footers. Well, the answer is--drum-roll, please--I have
    no idea. After some rather extensive research, I’ve not found any other utility
    that displays these headers and footers as actual headers and footers. In fact,
    the utilities I’ve found that convert text files to other formats can insert their
    own headers and footers, but they’ll display the `nl`-style headers and footers
    as just part of the normal document.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能会想，什么时候你会创建一个带有`nl`风格头部和脚本的文本文件呢？答案是——请鼓掌——我也不知道。经过相当广泛的研究，我没有找到任何其他工具会像`nl`一样显示这些头部和脚本。事实上，我找到的一些将文本文件转换为其他格式的工具可以插入自己的头部和脚本，但它们会将`nl`风格的头部和脚本显示为普通文档的一部分。
- en: However, `nl` is still useful for times when you need to insert line numbers
    into files that consist of nothing but a body. Also, if you plan to take a Linux
    certification exam, you’ll need to know about the header, body, and footer concept
    of `nl`-style text files, because you just might see some questions about it.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`nl`在需要向只有正文的文件插入行号时仍然有用。如果你计划参加Linux认证考试，你需要了解`nl`风格文本文件的头部、正文和脚本概念，因为你可能会看到相关的问题。
- en: 'The man page for `nl` is seriously deficient, so you’ll instead want to consult
    the info page for more `nl` information and options. The command to run for that
    is:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`nl`的手册页非常简略，所以你应该查看info页面，以获取更多关于`nl`的信息和选项。要查看info页面，可以运行以下命令：'
- en: '[PRE28]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: That does it for `nl`. Let’s move on ahead.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`nl`的内容。接下来我们继续。
- en: Using head
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用head
- en: If you only want to view a certain number of lines from the beginning of a text
    file, use the `head` utility. To demonstrate, I’ll be showing you files that are
    here on my Fedora workstation. If you don’t have the same exact files on your
    own machine, feel free to use others.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想查看文本文件开头的某些行，可以使用`head`命令。为了演示，我将展示一些在我Fedora工作站上的文件。如果你自己电脑上没有完全相同的文件，随时可以使用其他文件。
- en: By default, `head` displays the first ten lines of a file. I’ll show you in
    just a bit how to change that.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`head`会显示文件的前十行。稍后我会向你展示如何更改这一点。
- en: 'Let’s start by entering the `/var/log/` directory, and looking at the first
    ten lines of the `boot.log` file, like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从进入`/var/log/`目录开始，然后查看`boot.log`文件的前十行，如下所示：
- en: '[PRE29]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Use the `-n` switch to change the number of lines that you want to see. To
    only see the first five lines, enter this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-n`开关可以更改你想查看的行数。要仅查看前五行，可以输入以下命令：
- en: '[PRE30]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In this case, the `-n` is optional. You’ll get the same results by running
    the command like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`-n`是可选的。你可以通过以下命令得到相同的结果：
- en: '[PRE31]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The dash in front of the number means that the number is an option. It doesn’t
    mean that the number is negative. But, as you’ll see in a moment, some commands
    will require you to use the `-n`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 数字前面的破折号意味着该数字是一个选项，并不表示数字是负数。但正如你很快会看到的那样，某些命令要求你使用`-n`。
- en: You can choose to view the first lines from more than one file at the same time
    by including multiple filenames in your command. Here, we’re looking at the first
    five lines of the `boot.log` file and the `cron` file.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在命令中包含多个文件名，选择同时查看多个文件的前几行。在这里，我们查看的是`boot.log`文件和`cron`文件的前五行。
- en: '[PRE32]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Use the `-q` option to enable quiet mode. That way, when you view lines from
    more than one file at a time, you won’t see the header lines for the files. (This
    could come in handy if you’re running `head` from within a shell script.)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-q`选项启用静默模式。这样，当你同时查看多个文件的行时，就不会看到文件的头部行。（如果你从脚本中运行`head`，这可能会很有用。）
- en: 'Also, note how you can combine options with only one dash. In this case, use
    of the `-n` is mandatory if you want to set the number of lines that you want
    to see. Here’s what it looks like:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，请注意你可以使用一个破折号来组合选项。在这种情况下，如果你想设置要查看的行数，使用`-n`是必须的。以下是它的样子：
- en: '[PRE33]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Use the `-n` option with a negative number to see all but the last `n` lines
    of a file. If you want to see all but the last 20 lines of the `boot.log` file,
    enter this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-n`选项和负数，可以查看文件中除最后`n`行之外的所有内容。如果你想查看`boot.log`文件中除了最后20行之外的所有行，可以输入以下命令：
- en: '[PRE34]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Again, in this case, use of the `-n` is mandatory.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，在这种情况下，使用`-n`是必须的。
- en: 'You can look at a number of either bytes, kilobytes, or megabytes from the
    beginning of a file with the `-c` option. Here, we’re looking at the first 30
    bytes of the `boot.log` file:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `-c` 选项查看文件开头的字节数、千字节数或兆字节数。这里，我们查看的是 `boot.log` 文件的前 30 个字节：
- en: '[PRE35]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You see that the `-c` option has a slight quirk to it. For some reason, the
    newline command isn’t issued, and your new command prompt will end up on the same
    line as your output.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现 `-c` 选项有一个小怪癖。由于某些原因，换行命令没有发出，你的新命令提示符会与输出显示在同一行。
- en: 'Now, let’s look at the first two kilobytes of `boot.log` by placing a `k` after
    the `2`, like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们通过在 `2` 后面加上一个 `k`，来查看 `boot.log` 文件的前两个千字节，像这样：
- en: '[PRE36]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To view the first two megabytes of this file, you would have placed an `m`
    after the `2`, like this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看文件的前两个兆字节，你只需在 `2` 后加上一个 `m`，像这样：
- en: '[PRE37]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If you’re wondering why a `c` is used to denote the number of bytes, it’s because
    *c* stands for *character*. One character just happens to be one byte in size.
    So, when you tell `head` or `tail` how many bytes you want to see, you’re really
    telling it how many characters you want to see.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在想为什么使用 `c` 来表示字节数，那是因为 *c* 代表 *字符*。一个字符正好是一个字节。因此，当你告诉 `head` 或 `tail` 你想查看多少字节时，实际上是在告诉它你想查看多少个字符。
- en: That’s all for `head`. Let’s move back to the `tail`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 `head` 的所有内容。接下来，让我们回到 `tail`。
- en: Using tail
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `tail`
- en: 'As you may have guessed, `tail` allows you to view lines from the end of a
    file. By default, it will display the last ten lines. Let’s take another look
    at the `boot.log` file:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜测的，`tail` 允许你查看文件的最后几行。默认情况下，它会显示最后十行。让我们再看看 `boot.log` 文件：
- en: '[PRE38]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: To specify the number of lines or bytes that you want to see, just use the same
    options that you used for `head`. There are however, a few options that `head`
    doesn’t have. For example, if you place a `+` in front of a number, you’ll be
    able to start your display from a certain line. Here, I’ve decided to view everything
    from line 33 to the end of the file.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定你想查看的行数或字节数，只需使用你为 `head` 使用的相同选项。不过，`head` 还有一些没有的选项。例如，如果你在数字前面加上一个 `+`，你就可以从某一行开始显示内容。在这里，我决定查看从第
    33 行到文件末尾的所有内容。
- en: '[PRE39]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note that the `-n` is mandatory for this.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`-n` 参数是必需的。
- en: 'You can use the same trick to start the display at two kilobytes into the file,
    like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用相同的技巧，从文件中的两个千字节开始显示内容，像这样：
- en: '[PRE40]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If you’re wondering why a `c` is used to denote the number of bytes, it’s because
    *c* stands for *character*. One character just happens to be one byte in size.
    So, when you tell `head` or `tail` how many bytes you want to see, you’re really
    telling it how many characters you want to see.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在想为什么使用 `c` 来表示字节数，那是因为 *c* 代表 *字符*。一个字符正好是一个字节。因此，当你告诉 `head` 或 `tail` 你想查看多少字节时，实际上是在告诉它你想查看多少个字符。
- en: 'The last option for tail is the `-f` option, which stands for *follow*. This
    option provides a running, changing display of a log file. For example, to view
    the last ten lines of the `secure` log file here on my Fedora machine, with the
    display changing as new events are added, I would enter:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`tail` 的最后一个选项是 `-f` 选项，代表 *follow*（跟踪）。这个选项提供了一个实时更新的日志文件显示。例如，要查看我在 Fedora
    机器上的 `secure` 日志文件的最后十行，并且随着新事件的添加而实时更新显示，我会输入：'
- en: '[PRE41]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: When you’re through, just hit *Ctrl-c* to exit.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成时，只需按 *Ctrl-c* 退出。
- en: This could come in handy if you suspect that some nefarious activity may be
    taking place on your system, because it allows you to constantly monitor for security
    events as they pop up. Or, if you need to troubleshoot something, use this option
    to monitor your normal system log.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你怀疑系统中可能发生了某些不良活动，这个功能可能会派上用场，因为它允许你不断监控安全事件的发生。或者，如果你需要进行故障排除，可以使用此选项来监控正常的系统日志。
- en: For our next trick, let’s see about using `head` and `tail` together.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的技巧是一起使用 `head` 和 `tail`。
- en: Using Head And Tail Together
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `head` 和 `tail` 一起
- en: You’ve seen how to use `head` to view lines from the beginning of a file, and
    how to use `tail` to view lines from the end of a file.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到如何使用 `head` 从文件的开头查看行，以及如何使用 `tail` 从文件的末尾查看行。
- en: That’s all well and good, but what if you want to view selected lines from somewhere
    in the middle of a file? That’s easy. Just use `head` and `tail` together. Here’s
    how it works.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都没问题，但如果你想查看文件中间某个位置的选定行怎么办？这很简单。只需一起使用 `head` 和 `tail`。下面是它的使用方法。
- en: 'Let’s say that you want to view lines 11 through 20 of a file with 39 lines.
    Just enter:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想查看一个有 39 行的文件的第 11 到第 20 行，只需输入：
- en: '[PRE42]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You can use `nl` to prove that you’re really seeing lines 11 through 20, like
    so:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`nl`来证明你确实在查看第11到第20行，像这样：
- en: '[PRE43]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You can make a lot of other combinations besides this one. (Again I say, you’re
    only limited by your own imagination.) If you want to look at lines 10 through
    15 of `boot.log`, enter this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个组合，你还可以做很多其他组合。（我再次强调，你的想象力是唯一的限制。）如果你想查看`boot.log`的第10到第15行，输入以下内容：
- en: '[PRE44]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Again, you can use `nl` to prove that you’re looking at the correct lines,
    like so:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你可以使用`nl`来证明你正在查看正确的行，像这样：
- en: '[PRE45]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: And, that does it for `head` and `tail`. Let’s now have some real fun by doing
    some octal dumping.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`head`和`tail`的用法。接下来，让我们通过做一些八进制转储来真正玩得开心。
- en: Using od
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`od`
- en: The **octal dump** (`od`) utility has a lot of options, and it would require
    quite a few pages to fully explore them. But, unless you’re a hard-core programmer,
    you’ll probably have need for only a very few of these options.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**八进制转储**（`od`）工具有很多选项，完全探究它们需要不少页数。但除非你是硬核程序员，否则你可能只会使用其中的少数选项。'
- en: If you take a Linux certification exam, you may see a question or two about
    `od`. However, you probably won’t see any questions that cover `od` in any amount
    of depth. So for now, I’ll just cover the basics.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你参加Linux认证考试，你可能会看到一两个关于`od`的问题。但是，你可能不会看到任何涉及`od`的深度问题。所以现在，我只介绍基础知识。
- en: The name of this utility is a bit misleading. It does, by default, display file
    contents as octal byte-code. But, that’s not all that it does. By using the appropriate
    option switches, you can also use `od` to display file contents in several other
    formats. `od` is normally used to display the contents of binary files, but you
    can also use it to display non-printing characters in normal text files.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工具的名称有点误导。它默认情况下以八进制字节码的形式显示文件内容。但这并不是它的全部功能。通过使用适当的选项开关，你还可以使用`od`以其他几种格式显示文件内容。`od`通常用于显示二进制文件的内容，但你也可以用它来显示普通文本文件中的非打印字符。
- en: 'You can display the contents of an entire file, or limit the amount of the
    file contents that you want to display. If you choose to display an entire file,
    you may want to either pipe the output into `less`, or redirect the output to
    a new text file. Let’s start by looking at part of the `od` output from the `echo`
    binary file:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以显示整个文件的内容，或者限制你想要显示的文件内容的数量。如果你选择显示整个文件，你可能希望将输出通过管道传递给`less`，或者将输出重定向到一个新的文本文件。我们首先来看一下来自`echo`二进制文件的`od`输出的一部分：
- en: '[PRE46]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note how the left column starts at zero, and increments by 20 (octal) from one
    line to the next. Think of this column as the address column. The addresses can
    be used to mark and later find some particular data within the file. The rest
    of each line represents the actual data.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，左侧列从零开始，并且从一行到下一行按20（八进制）递增。可以将这一列视为地址列。这些地址可以用于标记并稍后找到文件中的某些特定数据。每一行的其余部分表示实际的数据。
- en: 'To view the file in other formats, use the `-t` switch with the appropriate
    option. For example, you can view the `echo` binary in hexadecimal format like
    this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要以其他格式查看文件，可以使用`-t`开关并选择适当的选项。例如，你可以这样查看`echo`二进制文件的十六进制格式：
- en: '[PRE47]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note how the first column remained the same. Only the other columns changed.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，第一列保持不变，只有其他列发生了变化。
- en: If you’re a normal user, you may not need `od` for much else besides viewing
    non-printing characters in text files. You may need, for example, to find new-line
    or carriage return characters. For this, you can use the `-tc` option and look
    for characters that are preceded with a backslash. In the example that we’re about
    to examine, `\n` represents newline characters, and `\r` represents carriage return
    characters.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是普通用户，除了查看文本文件中的非打印字符之外，你可能不需要`od`做其他事情。例如，你可能需要查找换行符或回车符。在这种情况下，你可以使用`-tc`选项，查找前面带有反斜杠的字符。在我们即将查看的示例中，`\n`代表换行符，`\r`代表回车符。
- en: 'I’ll be performing the demos with a Project Gutenberg ebook file that’s titled,
    *How to Speak and Write Correctly*. You can download it from here: [https://www.gutenberg.org/cache/epub/6409/pg6409.txt](https://www.gutenberg.org/cache/epub/6409/pg6409.txt)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用一本名为*《如何正确说话和写作》*的Project Gutenberg电子书文件进行演示。你可以从这里下载：[https://www.gutenberg.org/cache/epub/6409/pg6409.txt](https://www.gutenberg.org/cache/epub/6409/pg6409.txt)
- en: Or, you can also just get it from the Github repository. Either way, the filename
    will be `pg6409.txt`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以直接从Github仓库获取。无论哪种方式，文件名都将是`pg6409.txt`。
- en: 'Now, let’s look at the first ten lines of our file, like this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下文件的前十行，像这样：
- en: '[PRE48]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: You see that there are multiple `\n` and `\r` characters in this file. But,
    what does that mean? First, it means that the file was created with a Windows-based
    text editor, such as Notepad or Wordpad. For some bizarre reason, Windows text
    editors insert both newline characters (`\n`) and carriage return characters (`\r`)
    at the end of each line.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到文件中有多个`\n`和`\r`字符。那么，这意味着什么呢？首先，它意味着这个文件是用基于Windows的文本编辑器创建的，比如记事本或写字板。出于某种奇怪的原因，Windows文本编辑器在每一行的末尾都插入了换行符（`\n`）和回车符（`\r`）。
- en: Unix and Linux text editors only insert a newline character at the end of each
    line. If you’re on a Unix or Linux machine and just want to read a text file that
    has carriage return characters, everything will work just fine. But, if you want
    to search for something in the text file, the carriage return characters might
    prevent the search from performing correctly.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Unix和Linux文本编辑器只会在每一行末尾插入一个换行符。如果你在Unix或Linux机器上，只是想读取一个包含回车符的文本文件，一切会正常工作。但如果你想在文本文件中搜索某些内容，回车符可能会导致搜索无法正确执行。
- en: Also, Unix and Linux operating systems won’t correctly read shell scripts or
    configuration files if they contain any carriage returns.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Unix和Linux操作系统如果遇到包含回车符的shell脚本或配置文件，无法正确读取它们。
- en: 'You can use the `-ta` option to view non-printable characters by their official
    ASCII names, like this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`-ta`选项来查看不可打印字符的官方ASCII名称，像这样：
- en: '[PRE49]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This time, the newlines and carriage returns are represented by `nl` and `cr`
    instead of by `\n` and `\r`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，换行符和回车符由`nl`和`cr`表示，而不是`\n`和`\r`。
- en: 'If you want to begin the display from somewhere other than the beginning of
    the file, use the `-j` switch. For example, if you want to begin viewing from
    address `0000640,` enter:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想从文件的某个位置开始显示，而不是从文件开头，使用`-j`选项。例如，如果你想从地址`0000640`开始查看，输入：
- en: '[PRE50]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'If you want to read in only a certain portion of the file, use the `-N` switch.
    Here, I’m reading in the first `0000640` bytes worth of our text file:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想读取文件的某个部分，可以使用`-N`选项。这里，我正在读取我们文本文件的前`0000640`字节：
- en: '[PRE51]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Finally, let’s combine these two options. Let’s start at address `0000400`
    and read in `0000640` bytes worth of the file, like so:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们将这两个选项结合起来。让我们从地址`0000400`开始，读取`0000640`字节的文件，如下所示：
- en: '[PRE52]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Keep in mind that the numbers in the address column are in octal format. That’s
    why you need to use something like `0000640` in the addressing options. If you
    were to use `640` instead, `od` would look at it as a decimal number, and would
    give you different results from what you expected.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，地址列中的数字是八进制格式的。这就是为什么你需要在地址选项中使用类似`0000640`的数字。如果你使用`640`，`od`将把它视为十进制数，并给出与预期不同的结果。
- en: '[PRE53]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '`A`s you see, this isn’t what you want.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这并不是你想要的。
- en: 'Here’s an example of how you might be able to use `od`. Suppose that you have
    a couple of text files that you need to `cat` together, but they just don’t line
    up correctly. To demonstrate, create a text file that has tabs at the beginning
    of several lines, like so:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子，展示如何使用`od`。假设你有几个文本文件需要用`cat`命令合并，但它们没有正确对齐。为了演示，创建一个文本文件，其中几行的开头有制表符，如下所示：
- en: '[PRE54]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Create a second file just like it, except without the tabs, like so:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个与之相同的第二个文件，只是去掉了制表符，如下所示：
- en: '[PRE55]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, pretend that you don’t know about the tabs that are in the first file.
    Furthermore, pretend that it’s such a large file that you haven’t been able to
    look through it in order to notice the tabs. With that in mind, try to `cat` the
    two files together, like this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你不知道第一个文件中有制表符。此外，假设它是一个如此大的文件，你没有机会浏览它以注意到这些制表符。考虑到这一点，试着将这两个文件通过`cat`命令合并，像这样：
- en: '[PRE56]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'So now, you’re scratching your head, wondering why things aren’t lining up
    correctly. A quick way to find out what’s going on would be to pipe the output
    through `od` with the `-ta` switch, like this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能有些困惑，想知道为什么文件没有正确对齐。一个快速的办法是通过`od`命令并使用`-ta`选项，将输出结果传递管道，像这样：
- en: '[PRE57]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: All of the `ht` instances you see indicate the presence of a hard tab, which
    gives you a clue about how to fix the alignment issues. You can also `od` each
    file separately to find where you need to edit.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 所有你看到的`ht`实例表示硬制表符的存在，这为你提供了关于如何修正对齐问题的线索。你也可以分别使用`od`命令查看每个文件，以找出需要编辑的地方。
- en: There are still more `od` options that you might find useful. To see them, consult
    either the `od` man page or the `od` info page.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多`od`选项可能对你有用。要查看它们，可以参考`od`的手册页或`od`的信息页面。
- en: In real life, you can use od to help troubleshoot problems with either shell
    scripts or Linux/Unix configuration files. Remember that if scripts or configuration
    files contain any carriage return characters, the operating system won’t be able
    to read them. Also, Linux operating systems have begun making more extensive use
    of .yaml files in recent years. In addition to the carriage return problem, `.yaml`
    files also require that each line be indented in a specific way. Using `od` can
    help determine if each line is indented with the correct number of tabs or spaces.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，你可以使用 `od` 来帮助排查 shell 脚本或 Linux/Unix 配置文件中的问题。记住，如果脚本或配置文件包含任何回车符，操作系统将无法读取它们。此外，近年来
    Linux 操作系统开始更多地使用 .yaml 文件。除了回车符问题，`.yaml` 文件还要求每一行必须按照特定的方式缩进。使用 `od` 可以帮助确定每一行是否按照正确的制表符或空格数进行缩进。
- en: Next, let’s look at something that’s uniquely different.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看一些独特的不同之处。
- en: Using uniq
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 uniq
- en: 'Use the `uniq` utility with files that have consecutive, identical lines. Its
    default behavior is to only show one copy of any line that is duplicated. Let’s
    begin by creating the `fruit.txt` file, like so:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `uniq` 工具处理包含连续重复行的文件。它的默认行为是只显示任何重复行中的一行。我们从创建 `fruit.txt` 文件开始，如下所示：
- en: '[PRE58]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Using `uniq` without any options gives you this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用没有任何选项的 `uniq` 会得到如下结果：
- en: '[PRE59]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This got rid of the duplicates that were identical in case. But you still have
    some consecutive words that are the same, except for case. Use the `-i` switch
    to make this operation case-insensitive, like this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这去除了那些在大小写上相同的重复行。但你仍然会有一些连续的单词，它们除了大小写不同外是相同的。使用 `-i` 开关可以让此操作不区分大小写，像这样：
- en: '[PRE60]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Of the two duplicate pairs, whichever word was on top was the one that stayed.
    In the `Peach` pair, the upper-case `Peach` was on top, so it stayed. In the `Apricot`
    pair, the lower-case `apricot` was on top, so it stayed.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个重复的对中，无论哪个单词在上面，它就会保留下来。在 `Peach` 对中，`Peach` 大写字母排在上面，因此它保留了下来。在 `Apricot`
    对中，`apricot` 小写字母排在上面，因此它保留下来。
- en: 'You can get a count of how many consecutive duplicate lines there are with
    the `-c` switch. Combine it with the `-i` switch to make the count case-insensitive.
    Here’s how that works:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `-c` 开关获取有多少连续的重复行。将其与 `-i` 开关结合，可以使计数不区分大小写。操作方法如下：
- en: '[PRE61]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The `-u` switch allows you to only display lines that aren’t repeated. You
    can also make this case-insensitive by combining it with the `-i` switch. Here’s
    what that looks like:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`-u` 开关允许你仅显示没有重复的行。你还可以将其与 `-i` 开关结合使用，使其不区分大小写。如下所示：'
- en: '[PRE62]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Use the `-d` switch to show one copy of each line that is repeated, and to
    not show any line that isn’t repeated. Again, you can combine this with the `-i`
    switch, like so:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `-d` 开关可以显示每一行的一个副本，如果该行重复，并且不显示任何不重复的行。同样，你可以将其与 `-i` 开关结合使用，如下所示：
- en: '[PRE63]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'You can also have `uniq` perform its comparisons on partial lines, instead
    of whole lines. To demo this, create a file of two sets of statements. Have some
    of the statements differ in only the first word, like so:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以让 `uniq` 对部分行而不是整行进行比较。为了演示这一点，创建一个包含两组语句的文件。其中一些语句仅在第一个词上有所不同，如下所示：
- en: '[PRE64]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'A default `uniq` operation would yield this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的 `uniq` 操作会得到如下结果：
- en: '[PRE65]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Use the `-f` switch to tell `uniq` to ignore fields in its comparison. In this
    case, a field is a word in a sentence. The number after the `-f` tells `uniq`
    how many fields to ignore. For now, let’s make `uniq` ignore the first word, like
    so:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `-f` 开关告诉 `uniq` 在比较时忽略字段。在这种情况下，字段是句子中的一个单词。`-f` 后面的数字告诉 `uniq` 忽略多少个字段。现在，让我们让
    `uniq` 忽略第一个单词，如下所示：
- en: '[PRE66]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: You can use the `-c` switch in the same manner, except that it would have `uniq`
    skip a number of characters, instead of fields. This could be handy if you have
    lines with leading blank spaces.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以以相同的方式使用 `-c` 开关，区别在于它会让 `uniq` 跳过一些字符，而不是跳过字段。如果行中有前导空格，这个功能可能会很有用。
- en: If you want `uniq` to end its comparisons before it gets to the end of the lines,
    use the `-w` switch. The number after the `-w` tells `uniq` how many characters
    into the line to perform its comparison. If a `-c` or a `-f` switch is specified,
    the count doesn’t begin until after the `-c` or `-f` switch is satisfied.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望 `uniq` 在行末之前就停止比较，可以使用 `-w` 开关。`-w` 后面的数字告诉 `uniq` 在行的多少字符内进行比较。如果指定了
    `-c` 或 `-f` 开关，计数将从满足 `-c` 或 `-f` 开关之后才开始。
- en: 'To demo this, create yet another text file that will look like this:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，再创建一个文本文件，内容如下：
- en: '[PRE67]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This time, we want our comparison to begin on the second word of each sentence,
    and to end on the 14^(th) character of the comparison. Here’s how that works:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们希望比较从每个句子的第二个单词开始，到比较的第14个字符结束。以下是具体操作方法：
- en: '[PRE68]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Okay, easy enough so far, right?
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，到目前为止很简单，对吧？
- en: 'For the next demo, create a pair of files so that you can use `join` and `uniq`
    together. First, create the `actorfile_9.txt` file, which will look like this:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的演示中，创建一对文件，以便你可以将`join`和`uniq`一起使用。首先，创建`actorfile_9.txt`文件，内容如下所示：
- en: '[PRE69]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Next, create the `actorfile_10.txt` file, which will look like this:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建`actorfile_10.txt`文件，内容如下所示：
- en: '[PRE70]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Join the two files together to see what happens:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 将这两个文件合并，看看会发生什么：
- en: '[PRE71]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Notice that when the key field is the same on two consecutive lines, `join`
    thinks that it has to list each of those lines twice in the combined output. You
    can take care of that by piping the output through `uniq`, like so:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到当关键字段在两行连续的行中相同时，`join`会认为它必须在合并输出中列出每一行两次。你可以通过将输出通过`uniq`管道处理来解决这个问题，如下所示：
- en: '[PRE72]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Okay, that’s it for `uniq`. Let’s now do some counting.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，`uniq`部分就到这里。现在我们来做一些计数。
- en: Using wc
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `wc`
- en: This easy-to-use utility gives you a quick way to count the number of lines,
    words, and/or bytes in a text file. So, if you’re typing a document that can only
    contain a certain number of words, you don’t have to sit there and manually try
    to count the words as you scroll the document up your screen. Just use `wc`, instead.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这个易于使用的工具为你提供了一种快速计数文本文件中行数、单词数和/或字节数的方法。因此，如果你正在编写一个只能包含特定单词数量的文档，你不必坐在那里手动数单词，随着文档在屏幕上滚动。直接使用`wc`即可。
- en: 'The default output for `wc` shows you the number of lines, followed by the
    number of words, and then by the number of bytes. Finally, it shows the name of
    the input file. Here’s how that looks:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`wc`的默认输出会显示行数、接着是单词数，然后是字节数。最后，它会显示输入文件的名称。以下是输出示例：'
- en: '[PRE73]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: So, the `actorfile_1.txt` file contains five lines, ten words, and 67 bytes.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，`actorfile_1.txt`文件包含五行、十个单词和67个字节。
- en: 'If you specify more than one file, `wc` will tell give you information for
    each individual file, and the total for all of the files, which looks like this:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你指定了多个文件，`wc`会分别为每个文件提供信息，并显示所有文件的总数，像这样：
- en: '[PRE74]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Use the `-l` (that’s a lower-case L) switch if you only want to see the number
    of lines in your files. Here’s how that looks:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想查看文件中的行数，可以使用`-l`（小写L）选项。以下是输出示例：
- en: '[PRE75]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The `-w` switch shows the number of words in a file, like this:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`-w`选项显示文件中的单词数，像这样：'
- en: '[PRE76]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Use the `-c` switch to show only the number of bytes, like so:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-c`选项只显示字节数，如下所示：
- en: '[PRE77]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'To see the numbers of characters in a file, use `-m`, like this:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看文件中字符的数量，使用`-m`，如下所示：
- en: '[PRE78]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Theoretically, the `-c` and the `-m` outputs should be identical as you see
    above, because one character is one byte in size. However, the outputs might differ
    slightly for large text files, as you see here:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，`-c`和`-m`的输出应该是相同的，如上所示，因为一个字符的大小就是一个字节。然而，对于大型文本文件，输出可能会略有不同，正如你在这里看到的那样：
- en: '[PRE79]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: I have no idea of why that is, because I’ve never found any explanation about
    it.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我不知道为什么会这样，因为我从未找到任何相关的解释。
- en: 'The last switch is the `-L` switch, which shows you the length of the longest
    line in your input file, like this:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个选项是`-L`，它显示输入文件中最长行的长度，如下所示：
- en: '[PRE80]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'You can combine `wc` with other utilities. Suppose that you have a text file
    that contains a lot of duplicate lines. Combine `wc` with `uniq` to see how eliminating
    the blank lines would affect the size of the `pg6409.txt` file that you downloaded
    from Project Gutenberg, like so:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将`wc`与其他工具结合使用。假设你有一个包含许多重复行的文本文件。将`wc`与`uniq`结合使用，以查看删除空白行会如何影响你从古腾堡计划下载的`pg6409.txt`文件的大小，如下所示：
- en: '[PRE81]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: You see that `uniq` has reduced the number of lines, but the word count remains
    the same. This tells us that all of the duplicate lines are blank lines. The byte-count
    has also gone down, because even empty spaces count as characters, which are one
    byte in size.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到`uniq`减少了行数，但单词数保持不变。这告诉我们所有重复的行都是空白行。字节数也减少了，因为即使是空格也算作字符，每个字符占一个字节。
- en: If you’re a systems administrator, you can use `wc` to help with your security
    audits. If you know how many users are supposed to be authorized for your system,
    you can periodically check the number of lines in the `/etc/passwd` file. (Remember,
    each line represents one user.) This gives you a good way to recognize if a user
    has been added behind your back.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是系统管理员，可以使用 `wc` 来帮助你进行安全审计。如果你知道系统中应该授权多少用户，你可以定期检查 `/etc/passwd` 文件中的行数。（记住，每一行代表一个用户。）这样你就能很容易地发现是否有用户未经授权被添加。
- en: All righty, we’re through counting. It’s time now to do some formatting.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们完成了计数。现在是时候进行一些格式化了。
- en: Using fmt
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 fmt
- en: The `fmt` utility works by attempting to make all non-blank lines in a text
    file the same length. Its default action is to set a target length of 75 characters
    for each line. However, you can change that if your file is either too narrow
    or too wide to display properly. The slight catch is that it doesn’t work well
    with every file. If your file has things like tables, indices, or tables of contents,
    `fmt` can mess up their formatting. (That’s ironic, considering that `fmt` is
    short for *format*.) You would then have to go back and manually edit them to
    make them look right.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`fmt` 工具的工作原理是尝试使文本文件中所有非空行的长度相同。它的默认行为是将每行的目标长度设置为 75 个字符。不过，如果你的文件过窄或过宽，无法正确显示，你可以更改这个设置。唯一的问题是，它并不适用于所有文件。如果你的文件中有表格、索引或目录，`fmt`
    可能会弄乱它们的格式。（这很讽刺，因为 `fmt` 代表的是 *format* 的缩写。）在这种情况下，你需要手动编辑它们，以使它们看起来正确。'
- en: I should point out for all of these examples to work on a virtual machine, you’ll
    need to have the virtual machine window set to a wider-than-default width. You
    can do that by opening the Virtualbox **View** menu for the virtual machine, and
    selecting the **Scaled Mode** option. That will allow you to resize the virtual
    machine window to suit your needs.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我应该指出，为了使这些示例在虚拟机上运行，你需要将虚拟机窗口的宽度设置为比默认宽度更宽。你可以通过打开虚拟机的 **视图** 菜单，选择 **缩放模式**
    选项来做到这一点。这样你就可以根据需要调整虚拟机窗口的大小。
- en: Another option is to just remotely log into the virtual machine from your host
    machine’s terminal. You’ll then be able to resize the terminal window as you desire.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是直接从主机机器的终端远程登录到虚拟机。然后你可以根据需要调整终端窗口的大小。
- en: 'We’ll start by looking at an excerpt from the `pg6409.txt` ebook file that
    you’ve already downloaded from the Project Gutenberg site. Here’s what the unformatted
    excerpt file looks like:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先来看一下你已经从 Project Gutenberg 网站下载的 `pg6409.txt` 电子书文件的一个摘录。以下是未格式化的摘录文件的样子：
- en: '![B21693_7_2](img/B21693_07_02.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![B21693_7_2](img/B21693_07_02.png)'
- en: 'Figure 7.2: The unformatted text'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2：未格式化文本
- en: 'I’ve decided that that’s a bit too wide, so I’ll use `fmt` with its default
    target setting of 75 characters per line, like so:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我决定这有点宽，所以我将使用 `fmt`，它的默认目标设置为每行 75 个字符，如下所示：
- en: '![B21693_7_3](img/B21693_07_03.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![B21693_7_3](img/B21693_07_03.png)'
- en: 'Figure 7.3: Using fmt with the default width'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3：使用 fmt 与默认宽度
- en: 'It still seems a bit too wide. So, let’s use the `-w` switch to narrow it down
    to a width of 60 characters, like so:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来还是有点宽。所以，我们使用 `-w` 开关将宽度缩小到 60 个字符，如下所示：
- en: '![B21693_7_4](img/B21693_07_04.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![B21693_7_4](img/B21693_07_04.png)'
- en: 'Figure 7.4: Setting a width of 60 characters'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4：设置 60 个字符的宽度
- en: 'On second thought, let’s try it with a line width of 90 characters, like this:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 再想想，咱们试试将行宽设置为 90 个字符，如下所示：
- en: '![B21693_7_5](img/B21693_07_05.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![B21693_7_5](img/B21693_07_05.png)'
- en: 'Figure 7.5: Setting a width of 90 characters'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5：设置 90 个字符的宽度
- en: 'The `-u` switch ensures that you always have one space between each word, and
    two spaces between each sentence, which looks like this:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`-u` 开关确保每个单词之间始终有一个空格，每个句子之间有两个空格，效果如下所示：'
- en: '![B21693_7_6](img/B21693_07_06.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![B21693_7_6](img/B21693_07_06.png)'
- en: 'Figure 7.6: Using the -u option'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6：使用 -u 选项
- en: 'Use the `-s` switch if you want to make long lines shorter, but you don’t want
    to make short lines longer. (Note that you can use a single dash to combine switches.)
    Here’s how that looks:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想让长行变短，但不想让短行变长，可以使用 `-s` 开关。（注意，你可以使用一个短划线来组合多个开关。）效果如下所示：
- en: '[PRE82]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Yeah, the `-s` doesn’t work so well with this particular file, and I’ve never
    really found a use for it myself. But, that doesn’t mean that you’ll never find
    a use for it.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，`-s` 在这个特定的文件中效果不太好，我自己也从来没找到过用它的地方。不过，这并不意味着你永远不会找到用它的情况。
- en: 'Once you’ve finally decided that you like what you see, use a redirector to
    save the output to a new file, like this:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你最终决定喜欢看到的内容，使用重定向器将输出保存到新文件中，像这样：
- en: '[PRE83]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Now that we’ve had enough of formatting, let’s do some splitting.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经做够了格式化，现在开始做一些分割吧。
- en: Using split
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `split`
- en: 'You can use `split` to break one large text file into two or more smaller ones.
    By default, it takes a large file and splits it into smaller files of 1,000 lines
    each. (Of course, the last file may be smaller.) Also by default, the names of
    these new small files will be `xaa`, `xab`, `xac`, and so on. Let’s begin by looking
    at the line-count of the public-domain ebook file that you downloaded from Project
    Gutenberg, like so:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `split` 将一个大的文本文件分割成两个或更多较小的文件。默认情况下，它会将一个大文件分割成每个文件包含1,000行的小文件。（当然，最后一个文件可能会更小。）同样，默认情况下，这些新小文件的名称会是
    `xaa`、`xab`、`xac` 等等。让我们开始看一下你从古腾堡计划下载的公共领域电子书文件的行数，像这样：
- en: '[PRE84]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Since there are 6,019 lines in this file, `split` will break it into six files
    of 1,000 lines each, and one file of only 19 lines. Here’s how it works:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 由于该文件有6,019行，`split` 会将它分成六个包含1,000行的文件，以及一个仅包含19行的文件。它是这样工作的：
- en: '[PRE85]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'To verify that this works, use `wc` to perform a line-count of each file:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证这个方法，使用 `wc` 执行每个文件的行数统计：
- en: '[PRE86]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Use the `-a` option to change the length of the new filenames. The following
    command will give you a five-character suffix for the filenames.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `-a` 选项来改变新文件名的长度。以下命令将为文件名提供五个字符的后缀。
- en: '[PRE87]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'You can also change the filename prefix from `x` to whatever you want. Just
    add the desired prefix to the end of the command, like this:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将文件名的前缀从 `x` 改为你想要的任何内容。只需将所需的前缀添加到命令的末尾，像这样：
- en: '[PRE88]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'If you don’t want to use letters for the filename suffixes, use the `-d` option
    to use numeric prefixes. (Again, notice how you can combine switches with only
    a single dash.) Do it like this:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想使用字母作为文件名的后缀，使用 `-d` 选项来使用数字前缀。（再一次，注意你可以将开关合并，只使用一个短横线。）像这样做：
- en: '[PRE89]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'But, what if 1,000 lines is too long for your files? Then, use the `-l` switch
    to change it to something else. Here, I’m creating files of 400 lines each:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果1,000行对你的文件来说太长了怎么办？那就使用 `-l` 选项来将其改为其他值。在这里，我将每个文件设置为400行：
- en: '[PRE90]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Note that whenever you use two or more option switches that each take a numeric
    option, you have to use a separate dash for each option.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每当你使用两个或更多需要数字选项的选项开关时，你必须为每个选项使用单独的短横线。
- en: 'You can use the `-b` switch to create files that are a specific number of bytes
    in size. Here, I’m breaking the file into chunks of 900 bytes each:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `-b` 选项来创建特定字节大小的文件。在这里，我将文件分割成每个900字节的小块：
- en: '[PRE91]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Add either a `k` or an `m` after the numeric option for the `-b` switch, and
    you can specify either kilobytes or megabytes, instead of the default bytes. In
    this example, I’m going back in time and pretending that I have to divide the
    file into two parts so that I can store it on two old-fashioned 180-Kbyte floppy
    disks:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在数字选项后面加上 `k` 或 `m`，你就可以指定千字节或兆字节，而不是默认的字节。在这个例子中，我假装回到过去，我必须将文件分成两部分，这样我才能将它存储在两个老式的180-Kbyte软盘上：
- en: '[PRE92]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: I’ll wrap up the `split` write-up by making a confession, in order to unburden
    my soul. As I hinted in the previous paragraph, the original purpose of `split`
    was to split up text files that are too large to store on a single old-fashioned
    floppy disk.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我要结束 `split` 的介绍了，我要做一个告白，以便卸下我的心灵负担。正如我在前一段中提到的，`split` 的最初目的是分割那些太大，无法存储在单一老式软盘上的文本文件。
- en: In the modern age, we have hard drives and solid-state drives that have multiple
    Terabytes of capacity, and USB memory sticks that have multiple Gigabytes of capacity.
    So, you’ll likely find that `split` isn’t as useful as it used to be. But, do
    keep it in mind if you plan to take a Linux certification exam, because you just
    might see some questions about it.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代，我们拥有多达几个TB容量的硬盘和固态硬盘，以及容量达到几个GB的USB闪存盘。所以，你可能会发现 `split` 已经不像以前那样有用了。但如果你打算参加Linux认证考试，还是要记住它，因为你很可能会遇到一些关于它的问题。
- en: Okay, we’ve had enough of splitting, so let’s do some translating.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，我们已经做够了分割，现在开始做一些翻译吧。
- en: Using tr
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `tr`
- en: You can use `tr` for a variety of translation chores. (After all, `tr` does
    stand for *translate*.) Rather than translating from one language to another,
    `tr` translates from one character to another, from a range of characters to another,
    or from one class of characters to another. You can also delete selected characters
    from a file or eliminate duplicate characters.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `tr` 来处理各种转换任务。（毕竟，`tr` 代表 *translate*）。`tr` 不像从一种语言翻译到另一种语言，而是将一个字符转换为另一个字符，或将一组字符转换为另一组字符，或者将一种字符类别转换为另一种字符类别。你还可以从文件中删除选定的字符或消除重复字符。
- en: Compared to the utilities that we’ve looked at so far, there’s a big difference
    with how `tr` operates. The other utilities that we’ve looked at so far can get
    their input from arguments that you would supply on the command-line. So, you
    don’t need to use the `stdin` redirector with them. The `tr` utility can’t use
    arguments, so you’ll either have to use a `stdin` redirector or pipe its input
    in from another command.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们到目前为止所查看的其他工具相比，`tr` 的操作方式有很大的不同。我们到目前为止查看的其他工具可以通过你在命令行中提供的参数来获取输入。因此，使用这些工具时，你不需要使用
    `stdin` 重定向器。`tr` 工具无法使用参数，因此你必须使用 `stdin` 重定向器，或者通过管道从另一个命令传递输入。
- en: 'For the first example, create the file `translation.txt`, and use `tr` to change
    every occurrence of a single character. Make the file look like this:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个示例，创建文件 `translation.txt`，并使用 `tr` 更改每个字符的出现方式。让文件看起来像这样：
- en: '[PRE93]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Now, let’s do the actual translation, like so:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们像这样进行实际转换：
- en: '[PRE94]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: After the `tr`, I placed two text strings within single quotes. The first string
    represents what I want to find and change. The second string represents what we
    want the first string to become. In this case, I want to change all lower-case
    a’s into upper-case A’s.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `tr` 后，我将两个文本字符串放在单引号内。第一个字符串表示我要查找并更改的内容，第二个字符串表示我们希望第一个字符串变成什么样。在这个例子中，我希望将所有的小写字母
    a 转换为大写字母 A。
- en: You can translate multiple characters by either listing them individually or
    by specifying ranges of characters. In this next example, I’ve chosen to convert
    a’s to A’s and l’s to L’s.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过列出字符或指定字符范围来转换多个字符。在下一个示例中，我选择将 a 转换为 A，将 l 转换为 L。
- en: '[PRE95]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Separate the characters with a dash to specify a range of characters, like
    so:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 使用短横线分隔字符来指定字符范围，例如：
- en: '[PRE96]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'You can specify more than one range, like this:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以指定多个范围，如下所示：
- en: '[PRE97]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Other types of conversion are also possible. Here, I’m converting the letters
    a through e to the numbers 1 through 5:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 其他类型的转换也是可能的。在这里，我将字母 a 到 e 转换为数字 1 到 5：
- en: '[PRE98]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'As is the case with many of these utilities, `tr` gives you multiple ways to
    perform certain operations. For example, to convert all lower-case letters in
    a file to upper-case letters, you can specify the ranges ‘a-z’ and ‘A-Z’ in your
    command, like this:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多这些工具一样，`tr` 提供了多种方法来执行某些操作。例如，要将文件中的所有小写字母转换为大写字母，你可以在命令中指定范围‘a-z’和‘A-Z’，如下所示：
- en: '[PRE99]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'You can also use character classes to perform this conversion. A **character
    class** consists of the name of a type of characters placed within the square
    bracket and colon characters. For example, the character class for lower-case
    characters is represented by `[:lower:]`, and the character class for upper-case
    letters is represented by `[:upper:]`. So, the preceding command could be typed
    in like this:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用字符类来执行此转换。**字符类** 由字符类型的名称组成，并置于方括号和冒号字符之间。例如，小写字母的字符类表示为 `[:lower:]`，而大写字母的字符类表示为
    `[:upper:]`。因此，上述命令可以这样输入：
- en: '[PRE100]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Here’s a table of the rest of the character classes.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这是其余字符类别的表格。
- en: '| **Class Name** | **What It Means** |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| **类别名称** | **含义** |'
- en: '| `[:alnum:]` | Letters and digits. (In other words, alphanumeric.) |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| `[:alnum:]` | 字母和数字。（换句话说，字母数字混合。） |'
- en: '| `[:alpha:]` | Letters |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| `[:alpha:]` | 字母 |'
- en: '| `[:blank:]` | Whitespace |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| `[:blank:]` | 空格 |'
- en: '| `[:cntrl:]` | Control characters |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| `[:cntrl:]` | 控制字符 |'
- en: '| `[:digit:]` | Digits |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| `[:digit:]` | 数字 |'
- en: '| `[:graph:]` | All printable characters except for spaces |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| `[:graph:]` | 所有可打印字符，但不包括空格 |'
- en: '| `[:lower:]` | All lower-case letters |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| `[:lower:]` | 所有小写字母 |'
- en: '| `[:print:]` | All printable characters, including spaces |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| `[:print:]` | 所有可打印字符，包括空格 |'
- en: '| `[:punct:]` | All punctuation characters |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| `[:punct:]` | 所有标点符号字符 |'
- en: '| `[:space:]` | Either veritcal or horizontal whitespace |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| `[:space:]` | 垂直或水平空白字符 |'
- en: '| `[:upper:]` | All upper-case letters |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| `[:upper:]` | 所有大写字母 |'
- en: '| `[:xdigit:]` | Hexadecimal digits |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| `[:xdigit:]` | 十六进制数字 |'
- en: 'Table 7.1: Character classes'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.1：字符类
- en: 'This looks easy enough, right? Unfortunately though, there’s a bit of a catch.
    Watch what happens when I try to translate digits to hexadecimal digits:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很简单，对吧？但不幸的是，这里有一些小问题。看看当我尝试将数字转换为十六进制数字时会发生什么：
- en: '[PRE101]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: The answer to this dilemma is in the `tr` man page, where it says that “while
    translating, `[:lower:]` and `[:upper:]` may be used in pairs to specify case
    conversion”. Granted, it doesn’t say that *only* `[:lower:]` and `[:upper:]` can
    be used in pairs, but that is the implication. However, you can use these other
    character classes in other types of `tr` operations, which we’ll get to in just
    a bit.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这个难题的答案在`tr`的手册页中，其中提到“在转换时，`[:lower:]`和`[:upper:]`可以成对使用来指定大小写转换”。当然，它并没有明确说只有`[:lower:]`和`[:upper:]`可以成对使用，但这是它的含义。然而，你可以在其他类型的`tr`操作中使用这些字符类，稍后我们会讨论到。
- en: If you want to delete certain characters from a text stream, use the `-d` switch.
    In this example, I’ll delete all vowels from the text.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想从文本流中删除某些字符，使用`-d`选项。在这个例子中，我将删除文本中的所有元音字母。
- en: Note that with the `-d` switch, you only need to specify one text string or
    character class.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在使用`-d`选项时，你只需要指定一个文本字符串或字符类。
- en: 'Here’s how that looks:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这种情况的效果：
- en: '[PRE102]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Add the `-c` switch, and you can make `tr` operate on everything except what
    you specify. Here, I’ll remove all the consonants, punctuation, spaces, and newline
    characters. That is, I’ll remove everything that isn’t a vowel. Prepare to be
    amazed at what you’re about to see:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 添加`-c`选项后，你可以让`tr`操作所有内容，除了你指定的部分。在这里，我将删除所有辅音字母、标点符号、空格和换行符。也就是说，我将删除所有不是元音的字符。准备好，你将看到的效果非常神奇：
- en: '[PRE103]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: When I say that this removes everything but the vowels, I do mean *everything*,
    including the invisible newline characters. This explains why all of the vowels
    are on one line, and why the command prompt is now on the same line as the output.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 当我说这将删除除元音字母以外的所有内容时，我确实是指*所有内容*，包括不可见的换行符。这也解释了为什么所有元音字母都在同一行，以及为什么命令提示符现在与输出在同一行。
- en: 'You can do the same things by specifying character classes instead of characters
    or ranges of characters. In this example, I’m removing everything except for lower-case
    letters:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过指定字符类，而不是字符或字符范围，来做同样的事情。在这个例子中，我正在删除除小写字母之外的所有内容：
- en: '[PRE104]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'This time, let’s remove all of the non-printable control characters, like this:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，让我们去除所有不可打印的控制字符，像这样：
- en: '[PRE105]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Of course, the only control characters in this file are newline characters,
    but that’s okay. If you have a file that also contained other types of control
    characters, and you only want to delete all of the newline characters, just do
    this:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个文件中唯一的控制字符是换行符，但没关系。如果你有一个文件，也包含了其他类型的控制字符，而你只想删除所有换行符，只需这样做：
- en: '[PRE106]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'If you have sequential occurrences of a given character or character class,
    you can use the `-s` switch to replace them with only a single occurrence. Here’s
    how that looks:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有连续出现的某个字符或字符类，可以使用`-s`选项将它们替换为单个出现。下面是这种情况的示例：
- en: '[PRE107]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'If you specify two strings with the `-s` switch, `tr` will first replace the
    characters in the first string with the characters in the second string. Then,
    it will squeeze out the resultant consecutive characters. As before, prepare to
    be amazed at what you’ll see here:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你指定了两个字符串，并使用了`-s`选项，`tr`会首先将第一个字符串中的字符替换成第二个字符串中的字符。然后，它会挤压出连续出现的字符。如前所述，准备好惊讶吧，你将看到的效果是这样的：
- en: '[PRE108]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: So, I turned *tennessee* into *serene*. (Perform this trick at your next party
    in case you need to liven things up a bit.)
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我把*tennessee*变成了*serene*。（下次派对上可以用这个技巧，给气氛带来一点活力。）
- en: 'You can combine `tr` with other text-stream utilities, which would look something
    like this:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将`tr`与其他文本流工具结合使用，像这样：
- en: '[PRE109]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Here’s a more practical use for `tr`. Let’s say that you’ve been given a text
    file of columnar data that you need to format for printing. But, the columns are
    all separated with a single space and nothing lines up correctly, as you see here:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`tr`的一个更实用的例子。假设你得到了一个列式数据的文本文件，需要将其格式化以便打印。但这些列之间都是用一个空格分开的，导致一切都没有正确对齐，就像你在这里看到的：
- en: '[PRE110]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: You can’t use `unexpand` to replace the spaces with tabs, because you need at
    least two spaces between the columns for `unexpand` to work.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能使用`unexpand`来将空格替换为制表符，因为你需要至少两个空格才能让`unexpand`起作用。
- en: In this case, you can use `tr` to replace the spaces with tabs. (Note that there
    is a blank space between the first set of single quotes. So yes, you can quote
    spaces.)
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你可以使用`tr`将空格替换为制表符。（注意，单引号之间有一个空格。所以，是的，你可以引号包括空格。）
- en: '[PRE111]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Even if you do have more than one space between the columns, `unexpand` still
    might not be the best choice. Here, I’ve placed two spaces between the columns:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你在列之间有多个空格，`unexpand`仍然可能不是最好的选择。在这里，我在列之间放了两个空格：
- en: '[PRE112]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'I’ll use `unexpand` with the `-t2` switch so that it will only take two spaces
    to make a tab, like so:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 我会使用`unexpand`和`-t2`选项，这样它只需要两个空格就能表示一个制表符，就像这样：
- en: '[PRE113]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'That’s somewhat better, but things still look a bit ragged. So, I’ll use `tr`
    to replace the spaces with tabs, like this:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 这样稍微好一点了，但看起来还是有点凌乱。所以，我会使用`tr`将空格替换为制表符，像这样：
- en: '[PRE114]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Much nicer, eh? But, since there were originally two spaces between columns,
    I now have two tabs between columns. I only want one tab between columns, so I’ll
    use the `-s` switch to squeeze out the excess tabs, like this:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 更好一点吧？但是，由于原来列之间有两个空格，所以现在列之间有两个制表符。我只想要一个制表符在列之间，所以我会使用`-s`选项来去除多余的制表符，就像这样：
- en: '[PRE115]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'For the final example, consider the Project Gutenberg file that I showed you
    earlier. Remember that it contains carriage return characters, indicating that
    it was created on a Windows computer. Here’s how that looks:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最后一个例子，考虑一下我之前给你看的Project Gutenberg文件。记得它包含回车符，表示它是在Windows电脑上创建的。它看起来像这样：
- en: '[PRE116]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'As I pointed out before, each `\r` represents a carriage return. Now, let’s
    pretend that this is a Linux configuration file, and that we need to strip out
    the carriage returns so that Linux will properly read it. Save the output to a
    new file, like so:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前指出的，每个`\r`表示一个回车符。现在，我们假设这是一个Linux配置文件，需要去除回车符，以便Linux能够正确读取它。将输出保存到一个新文件中，像这样：
- en: '[PRE117]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Did it work? Let’s see:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 成功了吗？我们来看看：
- en: '[PRE118]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: I don’t see any carriage returns, so it worked just fine.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有看到任何回车符，所以它工作得很好。
- en: In reality, most people just use the `dos2unix` utility to strip out the carriage
    returns. But, if you plan to take any Linux certification exams, you might also
    want to know how to do it with `tr`.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，大多数人只会使用`dos2unix`工具来去除回车符。但如果你打算参加任何Linux认证考试，你可能也想知道如何使用`tr`来完成这项工作。
- en: The next utility we’ll look at will make you want to talk like a pirate.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要看的工具会让你想要像海盗一样说话。
- en: Using xargs
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用xargs
- en: It’s fitting that I’m writing this on *International Talk Like a Pirate Day*,
    because when you pronounce the name of this utility just right, it really does
    sound like something that a pirate would say. So, all together now, in your best
    pirate voice. . .
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 我写这篇文章的时机恰到好处，因为今天是*国际海盗日*，而当你正确地发音这个工具的名字时，真的听起来像是海盗会说的那样。所以，现在大家一起用你最好的海盗语气来念一下……
- en: '*Xaaaaarrrrrgs!*'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '*Xaaaaarrrrrgs!*'
- en: Okay, enough silliness. Let’s get to work.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，够了，别再胡闹了。我们开始工作吧。
- en: Seriously, `xargs` is a handy utility that can be used in a few different ways.
    Since the current topic is text-stream filters though, we’ll only look at it in
    that context for the time being. Later on, I’ll show you other uses for it.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 说真的，`xargs`是一个非常方便的工具，可以以几种不同的方式使用。不过，由于当前的话题是文本流过滤器，我们暂时只在这个上下文中讨论它。稍后，我会向你展示它的其他用法。
- en: '`xargs` doesn’t work by itself, and is always used with another utility. Its
    purpose is to take output from one source and use it as arguments for the other
    command. It works somewhat like the `-exec` option with `find`, but with a few
    differences. That is, `xargs` can be used with other utilities besides `find`,
    it has more options, and it’s more efficient. Let’s look at a few examples.'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '`xargs`本身不能独立工作，它总是与其他工具一起使用。它的目的是从一个源获取输出，并将其用作另一个命令的参数。它的工作方式有点像`find`命令的`-exec`选项，但也有一些不同之处。也就是说，`xargs`不仅可以与`find`一起使用，还可以与其他工具结合使用，它有更多的选项，且效率更高。我们来看几个例子。'
- en: 'If you want to sort multiple files, you can list them all on the command-line
    when you invoke `sort`. To demo this, let’s review the `actorfile_1.txt` file
    and the `actorfile_6.txt` file that I already had you create:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想对多个文件进行排序，你可以在调用`sort`时将它们都列出。为了演示这一点，让我们回顾一下我之前让你创建的`actorfile_1.txt`文件和`actorfile_6.txt`文件：
- en: '[PRE119]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Now, let’s sort them together, like so:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们把它们一起排序，就像这样：
- en: '[PRE120]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: That works fine if you only have two files to sort. But, what if you have a
    whole bunch of files that you want to sort? And, what if you need to update those
    files on a regular basis and sort them again after each update? Listing every
    file in a `sort` command would soon become tiresome and a bit unwieldy. To simplify
    the job, you can either write a shell script with the names of all of the files,
    or use `xargs` with a list of all the files. Since we haven’t yet looked at writing
    shell scripts, let’s look at `xargs`.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只有两个文件需要排序，这个方法很好用。但如果你有一堆文件需要排序呢？而且，如果你需要定期更新这些文件并在每次更新后重新排序该怎么办？在`sort`命令中列出每个文件很快就会变得繁琐且不方便。为了简化工作，你可以编写一个包含所有文件名的shell脚本，或者使用`xargs`配合所有文件的列表。由于我们还没有学习如何编写shell脚本，让我们先看看`xargs`。
- en: 'First, create a file with a list of the files that you want to sort, like so:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个包含你要排序的文件列表的文件，如下所示：
- en: '[PRE121]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: As you see, the filenames can all be on the same line, with only a single space
    between them. Or, if you prefer, you can place each filename on its own line.
    Either way works equally well.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，所有文件名可以都放在同一行，之间只用一个空格分开。或者，如果你愿意，你也可以将每个文件名放在单独的一行。无论哪种方式，都能正常工作。
- en: 'Now, use `xargs` and `sort` to read in the list of files, and then to sort
    the actual files, like so:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用`xargs`和`sort`读取文件列表，然后对实际文件进行排序，如下所示：
- en: '[PRE122]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: As I said, this would be handy if you have a lot of files that you have to update
    and sort on a frequent basis. Just build the list of the files that you need to
    sort, so that you don’t always have to type the names of all of the files.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 如我所说，如果你有很多需要频繁更新并排序的文件，这个方法非常方便。只需建立一个需要排序的文件列表，这样你就不必每次都输入所有文件的名称。
- en: 'Let’s now create a file with a list of names, and use `xargs` to feed the list
    into the `echo` command, like this:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个包含名称列表的文件，并使用`xargs`将列表传递给`echo`命令，如下所示：
- en: '[PRE123]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Pretty slick, eh? (I know that you’re just dying to show this trick at your
    next party.) But, there’s more.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来挺酷的吧？（我知道你一定很想在下次聚会上展示这个技巧。）不过，还有更多内容。
- en: You can use the `-i` switch and a set of curly braces to place the arguments
    wherever you want in the output string.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`-i`选项和一组大括号，将参数放置在输出字符串中的任何位置。
- en: Note that for this example to work properly, each name will have to be on its
    own line in the input file. That’s because `-i` also causes the command to invoke
    once for each line in the input file.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为了确保这个示例能够正常工作，每个名字必须单独占一行输入文件。这是因为`-i`也会导致命令对输入文件中的每一行调用一次。
- en: 'Anyway, here’s how it works:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，下面是它的工作原理：
- en: '[PRE124]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: If we use the `-n num` switch, we can tell `xargs` to execute the associated
    command once for every *num* lines of input.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`-n num`选项，我们可以告诉`xargs`在每`num`行输入后执行相关的命令一次。
- en: '[PRE125]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: That didn’t work out so well, so let’s try with `-n2` to see if it makes a difference.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 那个方法没有奏效，所以让我们试试`-n2`，看看是否有差别。
- en: '[PRE126]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: That looks much better.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来好多了。
- en: Finally, we can use the `-l num` switch to determine the number of lines we
    want for our output. Here, we’re creating two lines of output.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用`-l num`选项来确定输出的行数。在这里，我们创建了两行输出。
- en: '[PRE127]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: That’s about it for now. There are still other uses for `xargs`, which I’ll
    cover a bit later. Next, let’s add some final polish to your important text files.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 目前就这些。`xargs`还有其他用法，我稍后会详细介绍。接下来，让我们为你重要的文本文件做一些最后的润色。
- en: Using pr
  id: totrans-422
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用pr
- en: You’ve been working hard, using various text-stream filters to extract meaningful
    data from your text files, and creating formatted reports. Now, it’s time to make
    that hard work pay off by committing your work to paper. Sure, you can print your
    files without using `pr`. But for a nice professional look, `pr` can give you
    just the right finishing touch.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 你一直在努力工作，使用各种文本流过滤器从文本文件中提取有意义的数据，并生成格式化报告。现在，是时候通过将工作提交到纸面上来回报你的辛勤付出了。当然，你可以在不使用`pr`的情况下打印文件。但是，为了更专业的外观，`pr`可以为你提供完美的修饰。
- en: With `pr`, you can effortlessly prepare your files for printing by breaking
    them into pages, and by adding headers and page numbers. In that regard, it’s
    better than using a regular text editor. In fact, it’s almost like using a mini
    word processor. It also gives you other formatting options that text editors won’t
    give you. (You’ll see some examples in just a few moments.)
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pr`，你可以轻松地将文件准备好进行打印，通过将它们分成几页，并添加标题和页码。在这方面，它比使用常规文本编辑器更好。实际上，它几乎像是使用一个小型文字处理器。它还提供了其他文本编辑器无法提供的格式化选项。（稍后你会看到一些例子。）
- en: Once you’ve used `pr` to perform your final formatting, you can print directly
    from the command-line by either piping `pr`'s output into the `lpr` utility, or
    by invoking `lpr` with your filename as an argument. (I’ll tell you more about
    `lpr` in just a bit.) There are a few reasons why you want to know how to do that.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: If you work with a Linux or Unix server that doesn’t have a GUI installed, you
    will need to know how to print from the command-line, because text-mode text editors
    don’t include a print function. Also, if you know how to print from the command-line,
    you’ll be able to set up batch jobs that can print multiple files at once, and
    automate your printing by setting print jobs up with either a `cron` job or a
    `systemd` timer. That could come in handy if you need to automatically print log
    files or reports on a nightly basis.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, `pr` breaks your files into single-spaced pages of 66 lines each.
    It also places the file’s last modification date and time, the filename, and the
    page number into the header of every page, which is followed by a trailer of blank
    lines. With the appropriate switches however, all of this can be changed. Let’s
    start by looking at an example of `pr`''s default behavior. Here’s an excerpt
    from the public-domain e-book, *How to Speak and Write Correctly*:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: '![B21693_7_7](img/B21693_07_07.png)'
  id: totrans-428
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.7: Using pr with default settings'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: What I can’t show you due to book formatting concerns is that there are a lot
    of blank lines after the last line of text. That’s because `pr` recognizes that
    this short excerpt doesn’t fill the page.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `-h` option to replace the filename with a header of your choice,
    like so:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: '![B21693_7_8](img/B21693_07_08.png)'
  id: totrans-432
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.8: Setting a custom header with pr'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don’t need to place headers in your output but still need to use `pr`''s
    other features, use the `-t` switch to omit the header, like this:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: '![B21693_7_9](img/B21693_07_09.png)'
  id: totrans-435
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.9: Using the -t option'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: 'The `-d` option will double-space your output:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: '![B21693_7_10](img/B21693_07_10.png)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.10: Using the -d option'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `-o` option with a number to set the left margin. (The number represents
    the number of spaces to indent the left margin.) Here, I’m setting a margin of
    eight spaces:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: '![B21693_7_11](img/B21693_07_11.png)'
  id: totrans-441
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.11: Setting the left margin'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: 'As I’ve already said, the default page length is 66 lines. You can change that
    with the `-l` option. To set a page length of 80 lines, enter:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'By default, `pr` separates pages by inserting multiple newline characters at
    the end of each page. Use the `-f` option to insert a single form-feed character
    between pages, instead. If you need to insert line numbers, use the `-n` option.
    Here, I’m combining both of these options with a single dash:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '![B21693_7_12](img/B21693_07_12.png)'
  id: totrans-446
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.12: Using form feeds and adding line numbers'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: 'To work with a range of pages, just place a `+` in front of the first page
    number, and prefix the last page number with a colon. Here, I’ve chosen to look
    at pages 10 through 12 of the full `pg6409.txt` file:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'If you omit the last page number, you’ll see everything from the first page
    until the end of the file. Here, I’m looking at everything from page 103 until
    the end:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: I’ve saved the columns and merge options until last, because they’re the trickiest
    to use.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: 'The columns option allows you to output your text in multiple columns. You
    set it by using a `-` followed by a number. The trick is, that you’ll first have
    to format your text so that it’s not too wide for the columns. Here’s what you
    get if you try to output our sample text as a two-column page:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: '![B21693_7_13](img/B21693_07_13.png)'
  id: totrans-454
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.13: The first attempt at using two columns'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see that that’s not real useful, because too much got left out. The
    easiest way to handle this is to change the line width with `fmt`, and then pipe
    the output to `pr`, like so:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: '![B21693_7_14](img/B21693_07_14.png)'
  id: totrans-457
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.14: Combining fmt and pr'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you might have to experiment with the line-width until you get what
    you want.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll have the same problem with the merge option. Here, I’m using the `-m`
    switch to show two files side-by-side:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: '![B21693_7_15](img/B21693_07_15.png)'
  id: totrans-461
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.15: First attempt at merging two files'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, you see that the lines are too wide to fit properly in two columns.
    The best way to handle this is to narrow the lines with `fmt`, but save the output
    to two intermediate files. Then, use `pr` to merge the two new files. Here what
    that process looks like:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '![B21693_7_16](img/B21693_07_16.png)'
  id: totrans-465
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.16: Merging the two formatted files'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: Once you have everything looking good on-screen, you’re ready to redirect your
    `pr` output into a new text file, and then print it.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: Printing from the Command-line
  id: totrans-468
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As I’ve already mentioned a few times, it is possible to print text files from
    the command-line. (Actually, you can also print PostScript files, `.pdf` files,
    image files, and a few other types of document files from the command line. For
    now though, we’re only interested in printing text files.) To do this, your Linux,
    Unix, or Unix-like machine needs to have the following two things installed on
    it:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: '**Common Unix Printing Software** (**CUPS**): This is normally installed by
    default on desktop implementations of Linux, but not on text-mode server implementations
    of Linux.'
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The proper driver for your printer**: CUPS includes a wide-range of printer
    drivers that are ready to go. However, your particular printer might not be included.
    If that’s the case, you’ll need to obtain the proper driver from the printer manufacturer
    and follow their instructions for installing it.'
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Installing CUPS is generally quite easy, because it’s included in the repositories
    of most Linux distros. On any type of Red Hat-style machine, such as Fedora, AlmaLinux,
    Rocky Linux, Oracle Linux, or RHEL, just do:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'On Debian or any of its derivatives, you’ll need two packages. To install them,
    just do:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: Next, you’ll need to find out if CUPS includes the driver for your printer.
    Do that with the `lpinfo -m` command on a Red Hat-type system, and with the `sudo
    lpinfo -m` command on a Debian-type system.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: 'You can pipe the output into `less` if you want to scroll through the whole
    list. Or, pipe it into `grep` if you want to search for a specific printer manufacturer,
    which will look something like this:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'So, the Debian implementation of CUPS doesn’t include drivers for any Brother
    printer. But, as you see here, CUPS on my Fedora workstation has quite a wide
    selection of Brother printer drivers:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'The only catch was that the Fedora workstation didn’t have the drivers for
    my Brother MFC7460DN printer, so I had to download the driver from the Brother
    website and install it myself. (The driver that I installed is represented by
    the last two items in this list.) The `lpstat -p -d` command shows me the status
    of my printer, as you see here:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Cool. It’s ready to go.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve set everything up, you’re ready to print with either `lp` or `lpr`.
    (They’re two different utilities that both do the same thing, but with different
    option switches. To make things simple, I’m just going to show you `lpr`.) To
    print to a specific printer, do something like this:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'The `-P` option directs the print job to the desired printer. If you don’t
    want to always have to specify a printer, you can set a default printer, like
    this:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: (Note that this will require `sudo` privileges on a Debian-type system. )
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve assigned a default printer, you can run a print job like this:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'If you have multiple files that you need to print out, there’s no need to issue
    multiple `lpr` commands. Instead, just place the names of the files that you want
    to print into a separate text file, and then use `xargs` to read the list. That
    will look something like this:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Easy, right? Well, there are actually a lot more print options that you can
    use with either `lp` or `lpr`, but for now we’ll just go with the basics. To see
    a complete tutorial on printing with `lp` and `lpr`, your best bet is to pull
    up a web browser on a Linux desktop machine, and navigate to `http://localhost:631`.
    In addition to the tutorial, you’ll see that you can also perform certain administrative
    functions from the web interface.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: All right, I think that will do for this chapter. Let’s wrap things up and move
    on.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-495
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, I showed you a lot more utilities that you can use to format
    text files as either you or your employer might require. Finally, at the end,
    I showed you the basics of setting up a printer on a text-mode server.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: The beauty of all this is that you can create shell scripts that will automatically
    obtain information from various sources, create properly-formatted text files,
    and then print them. You can even have the scripts run automatically by creating
    either a `cron` job or a `systemd` timer.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: Oh, but I haven’t shown you how to create a shell script, have I? That’s okay,
    because that will be the subject of the next chapter. I’ll see you there.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-499
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which two of the following commands would you use to see if a text file contains
    carriage return characters? (Select two.)
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`od -tx filename.txt`'
  id: totrans-501
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`od -tc filename.txt`'
  id: totrans-502
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`od -ta filename.txt`'
  id: totrans-503
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`od -td filename.txt`'
  id: totrans-504
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: You’ve created a text file that contains a list of other text files. And now,
    you want to sort all of the files that are contained in that list, and save the
    output to one new file. Which of the following commands would you use for that?
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`sort sort_list.txt > combined_sorted.txt`'
  id: totrans-506
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`xargs sort sort_list.txt > combined_sorted.txt`'
  id: totrans-507
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`xargs sort < sort_list.txt > combined_sorted.txt`'
  id: totrans-508
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`sort < sort_list.txt > combined_sorted.txt`'
  id: totrans-509
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following commands will number all lines in the body of a text
    file?
  id: totrans-510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`nl -a file.txt`'
  id: totrans-511
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`nl file.txt`'
  id: totrans-512
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`nl -bn file.txt`'
  id: totrans-513
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`nl -ba file.txt`'
  id: totrans-514
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which utility would you most likely use for the final step of preparing a text
    file for printing?
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`fmt`'
  id: totrans-516
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`pr`'
  id: totrans-517
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`lp`'
  id: totrans-518
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`lpr`'
  id: totrans-519
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following commands would you use to verify that the driver for
    your printer is installed on your computer?
  id: totrans-520
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`lpinfo -m`'
  id: totrans-521
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`lpstat -p -d`'
  id: totrans-522
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`lpr -i`'
  id: totrans-523
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`lp -i`'
  id: totrans-524
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Further Reading
  id: totrans-525
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'nl Command in Linux with Examples: [https://linuxconfig.org/nl](https://linuxconfig.org/nl)'
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'head Command in Linux (5 Essential Examples: [https://linuxhandbook.com/head-command/](https://linuxhandbook.com/head-command/
    )'
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using od to See How Text isFormatted: [https://bash-prompt.net/guides/od/](https://bash-prompt.net/guides/od/)'
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'wc Command in Linux with Examples: [https://www.geeksforgeeks.org/wc-command-linux-examples/](https://www.geeksforgeeks.org/wc-command-linux-examples/)'
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'tr Command in Linux with Examples: [https://linuxize.com/post/linux-tr-command/](https://linuxize.com/post/linux-tr-command/)'
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How to use the Linux tr Command: [https://www.howtogeek.com/886723/how-to-use-the-linux-tr-command/](https://www.howtogeek.com/886723/how-to-use-the-linux-tr-command/)'
  id: totrans-531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Talk Like a Pirate Day: [https://nationaltoday.com/talk-like-a-pirate-day/](https://nationaltoday.com/talk-like-a-pirate-day/)'
  id: totrans-532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How to Use the xargs Command on Linux: [https://www.howtogeek.com/435164/how-to-use-the-xargs-command-on-linux/](https://www.howtogeek.com/435164/how-to-use-the-xargs-command-on-linux/)'
  id: totrans-533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How I use the Linux fmt command to format text: [https://opensource.com/article/22/7/fmt-trivial-text-formatter](https://opensource.com/article/22/7/fmt-trivial-text-formatter)'
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'pr command in Linux: [https://www.geeksforgeeks.org/pr-command-in-linux/](https://www.geeksforgeeks.org/pr-command-in-linux/)'
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Master the Linux “pr” Command: A Comprehensive Guide: [https://hopeness.medium.com/master-the-linux-pr-command-a-comprehensive-guide-b166865c933e](https://hopeness.medium.com/master-the-linux-pr-command-a-comprehensive-guide-b166865c933e)'
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精通 Linux “pr” 命令：全面指南：[https://hopeness.medium.com/master-the-linux-pr-command-a-comprehensive-guide-b166865c933e](https://hopeness.medium.com/master-the-linux-pr-command-a-comprehensive-guide-b166865c933e)
- en: Answers
  id: totrans-537
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: b and c
  id: totrans-538
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b 和 c
- en: c
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: c
- en: d
  id: totrans-540
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: d
- en: b
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b
- en: a
  id: totrans-542
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a
- en: Join our community on Discord!
  id: totrans-543
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们在 Discord 上的社区！
- en: Read this book alongside other users, Linux experts, and the author himself.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、Linux 专家以及作者本人一起阅读本书。
- en: Ask questions, provide solutions to other readers, chat with the author via
    Ask Me Anything sessions, and much more. Scan the QR code or visit the link to
    join the community.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 提问、为其他读者提供解决方案、通过“问我任何问题”环节与作者交流，等等。扫描二维码或访问链接加入社区。
- en: '[https://packt.link/SecNet](https://packt.link/SecNet)'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/SecNet](https://packt.link/SecNet)'
- en: '![](img/QR_Code10596186092701843.png)'
  id: totrans-547
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code10596186092701843.png)'
