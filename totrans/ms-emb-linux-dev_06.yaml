- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building a Root Filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The root filesystem is the fourth element of embedded Linux. Once you have read
    this chapter, you will be able to build, boot, and run a simple embedded Linux
    system.
  prefs: []
  type: TYPE_NORMAL
- en: The techniques described here are broadly known as **roll your own**, or **RYO**.
    Back in the early days of embedded Linux, this was the only way to create a root
    filesystem. There are still some use cases where an RYO root filesystem is applicable
    – for example, when the amount of RAM or storage is very limited, for quick demonstrations,
    or for any case in which your requirements are not easily covered by the standard
    build system tools. However, these cases are quite rare.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of this chapter is educational. It is not meant to be a recipe for
    building everyday embedded systems. Use the tools described in the next chapter
    for this.
  prefs: []
  type: TYPE_NORMAL
- en: Our first objective is to create a minimal root filesystem that will give us
    a shell prompt. Then, using this as a base, we will add scripts to start up other
    programs and configure a network interface and user permissions. There are examples
    for both the BeaglePlay and QEMU targets. Knowing how to build the root filesystem
    from scratch is a useful skill. It will help you to understand what is going on
    when we look at more complex examples in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What should be in the root filesystem?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transferring the root filesystem to the target
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a boot `initramfs`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`init` program'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring user accounts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A better way of managing device nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating filesystem images with device tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mounting the root filesystem using NFS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using TFTP to load the kernel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow along with the examples, make sure you have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An Ubuntu 24.04 or later LTS host system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A microSD card reader and card
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A microSD card prepared for the BeaglePlay from [*Chapter 4*](Chapter_04.xhtml#_idTextAnchor096)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `Image` file for QEMU from [*Chapter 4*](Chapter_04.xhtml#_idTextAnchor096)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A USB to TTL serial cable with a 3.3V logic level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A BeaglePlay
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 5V USB-C power supply capable of delivering 3A
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code used in this chapter can be found in the `Chapter05` folder in the
    book’s GitHub repository: [https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter05](https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter05).'
  prefs: []
  type: TYPE_NORMAL
- en: What should be in the root filesystem?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The kernel gets a root filesystem either as an `initramfs` passed as a pointer
    from the bootloader, or by mounting the block device given on the kernel command
    line with the `root=` parameter. Once it has a root filesystem, the kernel executes
    the first program – by default, named `init`, as described in the *Early user
    space* section from [*Chapter 4*](Chapter_04.xhtml#_idTextAnchor096). Then, as
    far as the kernel is concerned, its job is complete. It is up to the `init` program
    to start other programs and bring the system to life.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make a minimal root filesystem, you need these components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**init**: This is the program that starts everything off, usually by running
    a series of scripts. I will describe how `init` works in much more detail in [*Chapter
    13*](Chapter_13.xhtml#_idTextAnchor431).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**shell**: Gives you a command prompt and (more importantly) runs the shell
    scripts called by `init` and other programs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**daemons**: These are background programs that provide services to others.
    Good examples are the system log daemon (`syslogd`) and the secure shell daemon
    (`sshd`). The `init` program must start the initial population of daemons to support
    the main system applications. In fact, `init` is itself a daemon. It is the daemon
    that provides the service of launching other daemons.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**shared libraries**: Most programs are linked with shared libraries, so they
    must be present in the root filesystem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**configuration files**: These are a series of text files, usually stored in
    the `/etc` directory, that configure `init` and other daemons.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**device nodes**: These are the special files that give access to various device
    drivers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**proc and sys**: These are two pseudo filesystems that represent kernel data
    structures as a hierarchy of directories and files. Many programs and library
    functions depend on `/proc` and `/sys`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**kernel modules**: Need to be installed in the root filesystem, usually in
    `/lib/modules/<kernel version>`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, there are the device-specific applications that make the device
    do the job it is intended for and the runtime data files that they generate.
  prefs: []
  type: TYPE_NORMAL
- en: '**IMPORTANT NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In some cases, you could condense most of the above programs into a single
    statically linked program and start that program instead of `init`. For example,
    if your program was named `/myprog`, you would add the following command to the
    kernel command line: `init=/myprog`.'
  prefs: []
  type: TYPE_NORMAL
- en: I have come across such a configuration only once in a secure system in which
    the fork system call had been disabled, thus making it impossible for any other
    program to be started. The downside of this approach is that you can’t make use
    of the many tools that normally go into an embedded system. You have to do everything
    yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Directory layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Linux kernel does not care about the layout of files and directories beyond
    the existence of the program named by `init=` or `rdinit=`, so you are free to
    put things wherever you like. For example, compare the file layout of a device
    running Android to that of a desktop Linux distribution. They are almost completely
    different.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, many programs expect certain files to be in certain places, and it
    helps us developers if devices use a similar layout. The basic layout of most
    Linux systems is defined in the **Filesystem Hierarchy Standard** (**FHS**), which
    is available at [https://refspecs.linuxfoundation.org/fhs.shtml](https://refspecs.linuxfoundation.org/fhs.shtml).
    The FHS covers all implementations of Linux operating systems, from the largest
    to the smallest. Embedded devices tend to use a subset based on their needs, but
    each usually includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/bin`: Programs essential for all users'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/dev`: Device nodes and other special files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/etc`: System configuration files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/lib`: Essential shared libraries, including those that make up the C library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/proc`: Information about processes represented as virtual files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/sbin`: Programs essential to the system administrator'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/sys`: Information about devices and their drivers, represented as virtual
    files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/tmp`: A place to put temporary or volatile files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/usr`: Additional programs, libraries, and system administrator utilities
    stored in the directories `/usr/bin`, `/usr/lib`, and `/usr/sbin`, respectively'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IMPORTANT NOTE**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `/usr` directory contains all system-wide, read-only files that are installed
    or provided by the operating system. In the distant past, `/bin` , `/sbin`, and
    `/lib` only contained executables and libraries required for booting, while `/usr/bin`,
    `/usr/sbin`, and `/usr/lib` contained all the other executables and binaries.
    That distinction has since blurred, culminating in a modern movement that merges
    `/bin`, `/sbin`, and `/lib` into `/usr/bin`, `/usr/sbin`, and `/usr/lib`. Nowadays,
    the files in `/bin`, `/sbin`, and `/lib` are just symbolic links to their `/usr`
    counterparts. The `/usr/sbin` directory, like the `/sbin` directory, is for commands
    that can only be executed by the `root` user.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`/var`: a hierarchy of files and directories that can be modified at runtime,
    like log messages, some of which must be retained after boot'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are some subtle distinctions here. The difference between `/bin` and `/sbin`
    is simply that the latter need not be included in the search path for non-root
    users. Users of Red Hat-derived distributions will be familiar with this.
  prefs: []
  type: TYPE_NORMAL
- en: Staging directory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You should begin by creating a **staging** directory on your host computer
    where you can assemble the files that will eventually be transferred to the target.
    In the following examples, I have used `~/rootfs`. You need to create a skeleton
    directory structure in it. Look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To see the directory hierarchy more clearly, you can use the handy `tree` command
    with the `-d` option to show only the directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Not all directories have the same file permissions, and the individual files
    inside a directory can have stricter permissions than the directory itself.
  prefs: []
  type: TYPE_NORMAL
- en: POSIX file access permissions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every process or running program belongs to a user and one or more groups. The
    user is represented by a 32-bit number called the **user ID** or **UID**. Information
    about users, including the mapping from a UID to a name, is kept in `/etc/passwd`.
    Likewise, groups are represented by a **group ID** or **GID**, with information
    kept in `/etc/group`. There is always a `root` user with a UID of 0 and a `root`
    group with a GID of 0\. The `root` user is also called the **superuser** because,
    in a default configuration, it bypasses most permission checks and can access
    all the resources in the system. Security in Linux-based systems is mainly about
    restricting access to the root account.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each file and directory also has an owner and belongs to exactly one group.
    The level of access a process has to a file or directory is controlled by a set
    of access permission flags called the **mode** of the file. There are three collections
    of three bits: the first collection applies to the *owner* of the file, the second
    to the *members* of the same group as the file, and the last to *everyone else*
    – the rest of the world. The bits are for **read** (`r`), **write** (`w`), and
    **execute** (`x`) permissions on the file. Three bits result in 2³ = 8 possible
    values, represented as octal digits from 0 to 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '0: No permissions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '1: Execute only (--x)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '2: Write only (-w-)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '3: Write and execute (-wx)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '4: Read only (r--)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '5: Read and execute (r-x)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '6: Read and write (rw-)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '7: Read, write, and execute (rwx)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since three bits fit neatly into an octal digit, file access permissions are
    usually represented in octal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some common file modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '600: Owner - rw-, Group - ---, and Others - ---'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '644: Owner - rw-, Group - r--, and Others - r--'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '666: Owner - rw-, Group - rw-, and Others - rw-'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '700: Owner - rwx, Group - ---, and Others - ---'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '755: Owner - rwx, Group - r-x, and Others - r-x'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '775: Owner - rwx, Group - rwx, and Others - r-x'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '777: Owner - rwx, Group - rwx, and Others - rwx'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first (leftmost) bit of an octal digit is a value of 4, the second (center)
    bit is a value of 2, and the third (rightmost) bit is a value of 1, as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – File access permissions](img/B18466_05_01.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – File access permissions
  prefs: []
  type: TYPE_NORMAL
- en: If all three bits in a collection are set, then the octal value of that collection
    is 4 + 2 + 1 = 7\. Each row in the above diagram comprises 3 collections for a
    total of 9 bits.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a fourth preceding octal digit whose value has special significance:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SUID (4)**: If the file is executable, it changes the effective UID of the
    process to that of the file owner when the program is run.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SGID (2)**: Like SUID, this changes the effective GID of the process to that
    of the group of the file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sticky (1)**: In a directory, this restricts deletion so that one user cannot
    delete files that are owned by another user. This is usually set on `/tmp` and
    `/var/tmp`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The SUID bit is probably used most often. It gives non-root users a temporary
    privilege escalation to superuser to perform a task. The `ping` program is a good
    example: `ping` opens a raw socket, which is a privileged operation. The `ping`
    executable is owned by user `root` and has the SUID bit set so that when you run
    `ping`, it executes with UID 0 regardless of your UID.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To set this leading octal digit, use values of either `4`, `2`, and `1` with
    the `chmod` command. For example, to set SUID on `/bin/ping` in your staging root
    directory, you would prepend `4` to a mode of `755` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note that the second `ls` command shows the first three bits of the mode to
    be `rws`, whereas previously, they had been `rwx`. That `s` indicates that the
    SUID bit is set.
  prefs: []
  type: TYPE_NORMAL
- en: File ownership permissions in the staging directory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For security and stability reasons, it is important to pay attention to the
    ownership and permissions of the files that will be placed on the target device.
    In general, you want to restrict sensitive resources to be accessible only by
    the `root` user and run as few programs using non-root users as possible. It is
    best to run programs using non-root users so that if they are compromised by an
    outside attack, they offer as few system resources to the attacker as possible.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the device node called `/dev/mem` gives access to system memory,
    which is necessary in some programs. But if it is readable and writeable by everyone,
    then there is no security because everyone can access everything in memory. So
    `/dev/mem` should be owned by `root`, belong to the `root` group, and have a mode
    of `600` that denies read and write access to all but the owner.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there is a problem with the staging directory. The files you create
    there will be owned by you. But when they are installed on the device, they should
    belong to specific owners and groups, mostly the `root` user. An obvious fix is
    to change the ownership to `root` at this stage, with the commands shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**IMPORTANT NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: Do not run the preceding `sudo chown -R root:root *` command. You could damage
    your filesystem irreparably.
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that you need `root` privileges to run the `chown` command. And
    from that point onward, you will need to be `root` to modify any files in the
    staging directory. Before you know it, you are doing all your development logged
    in as `root`, which is not a good idea. This is a problem that we will revisit
    when creating a standalone `initramfs`.
  prefs: []
  type: TYPE_NORMAL
- en: Programs for the root filesystem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, it is time to start populating the root filesystem with the essential programs
    and the supporting libraries, configuration, and data files they need to operate.
    I will begin with an overview of the types of programs you will need.
  prefs: []
  type: TYPE_NORMAL
- en: init program
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`init` is the first program to be run, so it is an essential part of the root
    filesystem. In this chapter, we will use the simple `init` program provided by
    BusyBox.'
  prefs: []
  type: TYPE_NORMAL
- en: Shell
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We need a shell to run scripts and to give us a command prompt so that we can
    interact with the system. An interactive shell is probably not necessary in a
    production device, but it is useful for development, debugging, and maintenance.
    There are various shells in common use on embedded systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bash`: This is the big beast that we all know and love from desktop Linux.
    It is a superset of the Unix Bourne shell with many extensions or bashisms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ash`: This is also based on the Bourne shell and has a long history with the
    BSD variants of Unix. BusyBox has a version of `ash` that has been extended to
    make it more compatible with `bash`. It is much smaller than `bash`, and hence,
    it is a very popular choice for embedded systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hush`: This is a very small shell that we briefly looked at in [*Chapter 3*](Chapter_03.xhtml#_idTextAnchor061).
    It is useful on devices with very little memory. There is a version of `hush`
    in BusyBox.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TIP**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you are using `ash` or `hush` as the shell on the target, make sure that
    you test your shell scripts on the target. It is very tempting to test them only
    on the host using `bash` and then be surprised that they don’t work when you copy
    them to the target.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Utilities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The shell is just a way of launching other programs. A shell script is little
    more than a list of programs to run with some flow control and a means of passing
    information between them. To make a shell useful, you need the utility programs
    that the Unix command line is based on. Even a basic root filesystem needs approximately
    50 utilities. This presents two problems. Firstly, tracking down the source code
    for each one and cross-compiling all of it is a big job. Secondly, the resulting
    collection of programs takes up several tens of megabytes. This was a real problem
    in the early days of embedded Linux when a few megabytes were all you had. BusyBox
    was created expressly to solve this problem.
  prefs: []
  type: TYPE_NORMAL
- en: BusyBox to the rescue!
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The genesis of BusyBox had nothing to do with embedded Linux. Bruce Perens started
    the project in 1996 for the Debian installer so that he could boot Linux from
    a 1.44 MB floppy disk. Coincidentally, this was about the size of the storage
    on contemporary devices so the embedded Linux community quickly took it up. BusyBox
    has been at the heart of embedded Linux ever since.
  prefs: []
  type: TYPE_NORMAL
- en: 'BusyBox was written from scratch to perform the essential functions of those
    essential Linux utilities. The developers took advantage of the 80/20 rule: the
    most useful 80% of a program is implemented in 20% of the code. Hence, BusyBox
    tools implement a subset of the functionality of their desktop equivalents, but
    they do enough to be useful in most cases.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another trick BusyBox employs is to combine all the tools together into a single
    binary, making it easy to share code between them. It works like this: BusyBox
    is a collection of applets, each of which exports its `main` function in the form
    `<applet>_main`. For example, the `cat` command is implemented in `coreutils/cat.c`
    and exports `cat_main`. The `main` function of BusyBox dispatches the call to
    the correct applet, based on the command-line arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To read a file, you can launch BusyBox with the name of the applet you want
    to run, followed by any arguments that the applet expects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You can also run BusyBox with no arguments to get a list of all the applets
    that have been compiled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using BusyBox in this way is rather clumsy. A better way to get BusyBox to
    run the `cat` applet is to create a symbolic link from `/bin/cat` to `/bin/busybox`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When you type `cat` at the command line, BusyBox is the program that actually
    runs. BusyBox only has to check the path to the executable (`/bin/cat`) passed
    in via `argv[0]`, extract the application name (`cat`), and do a table lookup
    to match `cat` with `cat_main`. All this is expressed in this slightly simplified
    section of code from `libbb/appletlib.c`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: BusyBox has over 300 applets, including an `init` program, several shells with
    varying levels of complexity, and utilities for most admin tasks. There is even
    a simple version of the `vi` editor so that you can change text files on your
    device. A typical BusyBox binary will only enable several dozen applets.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, a typical installation of BusyBox consists of a single program,
    with a symbolic link for each applet but which behaves exactly as if it were a
    collection of individual applications.
  prefs: []
  type: TYPE_NORMAL
- en: Building BusyBox
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'BusyBox uses the same `Kconfig` and `Kbuild` system as the kernel, so cross-compiling
    is straightforward. Get the source by cloning the BusyBox Git repo and checking
    out the version you want (`1_36_1` was the latest in August 2024):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You can also download the corresponding TAR file from [https://busybox.net/downloads/](https://busybox.net/downloads/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Configure BusyBox with the default configuration, which enables pretty much
    all of the features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, you probably want to run `make menuconfig` to fine-tune the
    configuration. For example, you almost certainly want to set the install path
    in **Settings | Installation Options (“make install” behavior) | Destination path
    for ‘make install’** to point to the staging directory. Then, you can cross-compile
    in the usual way. If your intended target is the BeaglePlay, use these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You can cross-compile BusyBox for the 64-bit Arm generic virtual platform emulated
    by QEMU in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: In either case, the result is the `busybox` executable. For a default configuration
    build like this, the size is about 1,100 KB. If this is too big for you, then
    you can slim it down by changing the configuration to leave out the utilities
    you don’t need.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install BusyBox in the staging area, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This will copy the binary to the directory configured in **Destination path
    for ‘make install’** and create all the symbolic links to it.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at an alternative to Busybox, known as ToyBox.
  prefs: []
  type: TYPE_NORMAL
- en: ToyBox – an alternative to BusyBox
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: BusyBox is not the only game in town. There is also ToyBox, which you can find
    at [https://landley.net/toybox/](https://landley.net/toybox/). The project was
    started by Rob Landley, who was previously a maintainer of BusyBox. ToyBox has
    the same aim as BusyBox but with more emphasis on complying with standards (especially
    POSIX-2008 and LSB 4.1) and less on compatibility with GNU extensions to those
    standards. ToyBox is smaller than BusyBox, partly because it implements fewer
    applets.
  prefs: []
  type: TYPE_NORMAL
- en: The license for ToyBox is BSD rather than GPL v2, making it compatible with
    operating systems that have a BSD-licensed user space such as Android. Hence,
    ToyBox ships with all new Android devices. As of the 0.8.3 release, Toybox’s `Makefile`
    can build a full Linux system that boots to a shell prompt when given just the
    Linux and ToyBox sources.
  prefs: []
  type: TYPE_NORMAL
- en: Libraries for the root filesystem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Programs are linked with libraries. You can link them all statically so that
    no libraries reside on the target device. This takes up an unnecessarily large
    amount of storage if you have more than two or three programs. To reduce the size
    of your programs, you need to copy shared libraries from the toolchain to the
    staging directory. But how do you know which libraries to copy?
  prefs: []
  type: TYPE_NORMAL
- en: One option is to copy all the `.so` files from the `sysroot` directory of your
    toolchain. Instead of trying to predict which libraries to include, just assume
    that your image will eventually need them all. This is certainly logical, and
    if you are creating a platform to be used by others for a range of applications,
    it would be the correct approach. However, be aware that a full glibc is quite
    large. In the case of Buildroot’s build of glibc, the libraries, locales, and
    other supporting files come to 22 MB. You can cut that down considerably by using
    musl or uClibc-ng.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another option is to cherry-pick only those libraries that you require. To
    do that, you need a means of discovering library dependencies. Let’s use the `readelf`
    command from [*Chapter 2*](Chapter_01.xhtml#_idTextAnchor028) for this task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The first `readelf` command searches the `busybox` binary for lines containing
    `program interpreter`. The second `readelf` command searches the `busybox` binary
    for lines containing `Shared library`. Now, you need to find these files in the
    toolchain `sysroot` directory and copy them to the staging directory. Remember
    that you can find `sysroot` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To reduce typing, keep a copy of the `sysroot` path in a shell variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at `/lib/ld-linux-aarch64.so.1` in `sysroot`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Repeat the exercise for `libc.so.6`, `libm.so.6` and `libresolv.so.2` so that
    you end up with a list of four files. Now, copy each one to your `rootfs` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: These are just the shared libraries needed by `busybox`. Repeat this procedure
    for each program you wish to add to your `rootfs` directory.
  prefs: []
  type: TYPE_NORMAL
- en: '**TIP**'
  prefs: []
  type: TYPE_NORMAL
- en: It is only worth doing this to get the very smallest embedded footprint possible.
    There is a danger that you will miss libraries that are loaded through `dlopen(3)`
    calls–plugins mostly. We will look at an example with the **name service switch**
    (**NSS**) libraries when we come to configure network interfaces later on in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Reducing size by stripping
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Libraries and programs are often compiled with some information stored in symbol
    tables to aid with debugging and tracing. You seldom need these in a production
    system. A quick and easy way to save space is to strip the binaries of symbol
    tables. This example shows `libc` before stripping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s see the result of stripping debug information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we saved 532,616 bytes, or about 28% of the size of the file,
    before stripping.
  prefs: []
  type: TYPE_NORMAL
- en: '**TIP**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Be careful about stripping kernel modules. Some symbols are required by the
    module loader to relocate the module code, so the module will fail to load if
    they are stripped out. Use this command to remove debug symbols while keeping
    those used for relocation: `strip --strip-unneeded <module name>`.'
  prefs: []
  type: TYPE_NORMAL
- en: Device nodes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most devices in Linux are represented by device nodes in accordance with the
    Unix philosophy that *everything is a file* (except network interfaces, which
    are sockets). A device node may refer to a block device or a character device.
    Block devices are mass storage devices such as SD cards or hard drives. A character
    device is pretty much anything else (again, except for network interfaces).
  prefs: []
  type: TYPE_NORMAL
- en: The conventional place for device nodes is the `/dev` directory. For example,
    a serial port can be represented by a device node called `/dev/ttyS0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Device nodes are created using the program named `mknod` (short for make node):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The parameters for `mknod` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**name** is the name of the device node that you want to create.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**type** is either c for character devices or b for a block device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**major** and **minor** are a pair of numbers that are used by the kernel to
    route file requests to the appropriate device driver code. There is a list of
    standard major and minor numbers in the kernel source file: `Documentation/admin-guide/devices.txt`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will need to create device nodes for all the devices that you want to access
    on your system. You can do so manually using the `mknod` command illustrated here,
    or you can create them automatically at runtime using one of the device managers
    mentioned later.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a minimal root filesystem, you need just two nodes to boot with BusyBox:
    `console` and `null`. The `console` only needs to be accessible to `root`, the
    owner of the device node, so the access permissions are `600` (`rw-------`). The
    `null` device should be readable and writable by everyone, so the mode is `666`
    (`rw-rw-rw-`). Use the `-m` option for `mknod` to set the `mode` when creating
    the node. You need to be `root` to create device nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You can delete device nodes using the standard `rm` command. There is no `rmnod`
    command because, once created, they are just files.
  prefs: []
  type: TYPE_NORMAL
- en: Proc and sysfs filesystems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`proc` and `sysfs` are two pseudo filesystems that offer a window into the
    inner workings of the kernel. They both represent kernel data as files in a hierarchy
    of directories. When you read one of these files, the contents you see do not
    come from disk storage. Instead, it is formatted on the fly by a function in the
    kernel. Some files are also writable, meaning that a kernel function is called
    with the new data you have written. If the data is formatted correctly and you
    have sufficient permissions, then the function modifies the value stored in the
    kernel’s memory. In other words, `proc` and `sysfs` provide another way to interact
    with device drivers and other kernel code.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IMPORTANT NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: The following `mount` commands are meant to be run on an embedded target device,
    like the BeaglePlay or Versatile Express (QEMU). Do not run them on your host
    machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `proc` and `sysfs` filesystems should be mounted on the `/proc` and `/sys`
    directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Although very similar in concept, the two perform different functions. `proc`
    has been part of Linux since the early days. Its original purpose was to expose
    information about processes to user space, hence the name. To this end, there
    is a directory for each process named `/proc/<PID>`, which contains information
    about its state. The process list command (`ps`) reads these files to generate
    its output.
  prefs: []
  type: TYPE_NORMAL
- en: There are also files that give information about other parts of the kernel.
    For example, `/proc/cpuinfo` tells you about the CPU, `/proc/interrupts` has information
    about interrupts, and so on. Lastly, `/proc/sys` contains files that display and
    control the state and behavior of kernel subsystems, especially scheduling, memory
    management, and networking. The manual page is the best reference for the files
    found in the `proc` directory. You can see this information by typing `man 5 proc`.
  prefs: []
  type: TYPE_NORMAL
- en: The role of `sysfs` is to present the kernel **driver model** to user space.
    It exports a hierarchy of files relating to devices and how they are connected
    to each other. I will go into more detail on the Linux driver model when I describe
    the interaction with device drivers in [*Chapter 11*](Chapter_11.xhtml#_idTextAnchor373).
  prefs: []
  type: TYPE_NORMAL
- en: Mounting filesystems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `mount` command allows us to attach one filesystem to a directory within
    another, forming a hierarchy of filesystems. The one at the top, which was mounted
    by the kernel when it booted, is called the **root filesystem**. The format of
    the `mount` command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The parameters to `mount` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**vfstype** is the type of filesystem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**options** is a comma-separated list of mount options.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**device** is the block device node that the filesystem resides on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**directory** is the directory that you want to mount the filesystem to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are various options you can give after `-o`. Have a look at the manual
    page `mount(8)` for more information. Type the following if you want to mount
    an SD card containing an ext4 filesystem in the first partition onto the directory
    named `/mnt:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Assuming that the mount succeeds, you will see the files stored on the SD card
    in the `/mnt` directory. In some cases, you can leave out the filesystem type
    and let the kernel probe the device to find out what is stored there. If mounting
    fails, you may first need to unmount the partition if your Linux distro is configured
    to automount all the partitions on an SD card when it is inserted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice something odd in the following examples of mounting the `proc` filesystem?
    There is no device node such as `/dev/proc`, since it is a pseudo filesystem and
    not a real one. But the `mount` command requires a device parameter. Consequently,
    we have to provide a string where a device would go, but it does not matter much
    what that string is. These two commands achieve exactly the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `procfs` and `nodevice` strings are ignored by the `mount` command. It is
    common to use the filesystem type in the place of the device when mounting pseudo
    filesystems.
  prefs: []
  type: TYPE_NORMAL
- en: Kernel modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have kernel modules, they need to be installed into the root filesystem
    using the `modules_install` kernel make target, as we saw in [*Chapter 4*](Chapter_04.xhtml#_idTextAnchor096).
    This will copy them into the `/lib/modules/<kernel version>` directory, together
    with the configuration files needed by the `modprobe` command.
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that you have just created a dependency between the kernel and the
    root filesystem. If you update one, then you will have to update the other.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to mount a filesystem from an SD card, let’s look at the
    different options for mounting a root filesystem. The alternatives (a ramdisk
    and NFS) may surprise you, especially if you are new to embedded Linux. A ramdisk
    protects the original source image from corruption and wear. We’ll learn more
    about flash wear in [*Chapter 9*](Chapter_09.xhtml#_idTextAnchor293). A network
    filesystem allows for more rapid development because file changes propagate instantly
    to the target(s).
  prefs: []
  type: TYPE_NORMAL
- en: Transferring the root filesystem to the target
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After creating a skeleton root filesystem in your staging directory, the next
    step is to transfer it to the target. There are three possibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '**initramfs**: This is a filesystem image that is loaded into RAM by the bootloader.
    Ramdisks are easy to create and have no dependencies on mass storage drivers.
    They can be used in fallback maintenance mode when the main root filesystem needs
    updating. They can even be used as the main root filesystem in smaller embedded
    devices. Ramdisks are also commonly used as the early user space in mainstream
    Linux distributions. Remember that the contents of a root filesystem on ramdisk
    are volatile, so any changes made to the root filesystem at runtime are lost when
    the system reboots. You need another storage type to store permanent data such
    as configuration parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**disk image**: A copy of the root filesystem that is formatted and ready to
    be loaded onto a mass storage device on the target. It can be an image in the
    ext4 format, ready to be copied onto an SD card, or it can be in jffs2 format,
    ready to be loaded into flash memory via the bootloader. Creating a disk image
    is probably the most common option. There is more information about the different
    types of mass storage in [*Chapter 9*](Chapter_09.xhtml#_idTextAnchor293).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**network filesystem**: This is when the staging directory is exported to the
    network via an NFS server and mounted by the target at boot time. This is often
    done during development as opposed to repeated cycles of creating a disk image
    and reloading it onto the mass storage device, which gets tedious quickly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I will start with `intiramfs` and use it to illustrate a few refinements to
    the root filesystem, like adding usernames and a device manager to create device
    nodes automatically. Then, I will show you how to create a disk image and how
    to use NFS to mount the root filesystem over a network.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a boot initramfs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An initial RAM filesystem or `initramfs` is a compressed cpio archive. cpio
    is an old Unix archive format like TAR and ZIP, but it is easier to decode and
    so requires less code in the kernel. You need to configure your kernel with `CONFIG_BLK_DEV_INITRD`
    to support `initramfs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three different ways to create a boot ramdisk: as a standalone cpio
    archive, as a cpio archive embedded in the kernel image, and as a device table
    that the kernel build system processes as part of the build. The first option
    gives the most flexibility because we can mix and match kernels and ramdisks to
    our heart’s content. However, it means having to deal with two files instead of
    one, and not all bootloaders have the facility to load a separate ramdisk.'
  prefs: []
  type: TYPE_NORMAL
- en: Standalone initramfs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following sequence of instructions creates the archive, compresses it,
    and adds a U-Boot header to load onto the target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we run `cpio` with the option `--owner root:root`. This is a quick
    fix for the file ownership problem mentioned earlier in the *File ownership permissions
    in the staging directory* section. It makes everything in the cpio archive have
    a UID and GID of 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final size of the uRamdisk file is about 1.9 MB, with no kernel modules.
    Add to that 9.8 MB for the kernel Image.gz file and 1,061 KB for U-Boot. This
    gives us a total of 13 MB of storage needed to boot this board. We are way off
    from the 1.44 MB floppy that started it all. If size is a real problem, then you
    can use one of these options:'
  prefs: []
  type: TYPE_NORMAL
- en: Make the kernel smaller by leaving out drivers and functions you don’t need.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make BusyBox smaller by leaving out utilities you don’t need.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use musl libc or uClibc-ng in place of glibc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compile BusyBox statically.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Booting an initramfs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The simplest thing we can do is to run a shell on the console so that we can
    interact with the target. We can do that by adding `rdinit=/bin/sh` to the kernel
    command line. The next two sections demonstrate how to do that for both QEMU and
    the BeaglePlay.
  prefs: []
  type: TYPE_NORMAL
- en: Booting with QEMU
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'QEMU has a `-initrd` option to load an `initramfs` into memory. You should
    already have an `Image` file compiled with the `aarch64-buildroot-linux-gnu` toolchain
    from [*Chapter 4*](Chapter_04.xhtml#_idTextAnchor096). From this chapter, you
    should have created an `initramfs`, which includes BusyBox compiled with the same
    toolchain. Now, you can launch QEMU using the script in `MELD/Chapter05/run-qemu-initramfs.sh`
    or this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You should get a `root` shell with a `#` prompt.
  prefs: []
  type: TYPE_NORMAL
- en: Booting the BeaglePlay
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For the BeaglePlay, we need the microSD card prepared in [*Chapter 4*](Chapter_04.xhtml#_idTextAnchor096),
    plus a root filesystem built using the `aarch64-buildroot-linux-gnu` toolchain.
    Copy the `uRamdisk` you created earlier in this section to the boot partition
    on the microSD card. Boot the BeaglePlay to the point where you get a U-Boot prompt.
    Then, enter these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: If all goes well, you will get a `root` shell with a `#` prompt on the serial
    console. After this is done, we will need to mount `proc` on both platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Mounting proc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You will find that the `ps` command does not work on either platform. This
    is because the `proc` filesystem has not been mounted yet. Try mounting it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Run `ps` again, and you will see the process listing.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an improvement, let’s write a shell script that mounts `proc` and anything
    else that needs to be done at bootup. Then, you can run this script instead of
    `/bin/sh` at boot. The following snippet illustrates how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `/bin/sh` on the last line launches a new shell that gives you an interactive
    `root` shell prompt. Using a shell as `init` in this way is very handy for quick
    hacks – for example, when you want to rescue a system with a broken `init` program.
    However, in most cases, you would use an `init` program, which we will cover in
    the next section of this chapter. Before that, I want to look at two other ways
    to load `initramfs`.
  prefs: []
  type: TYPE_NORMAL
- en: Building an initramfs into the kernel image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have created a compressed `initramfs` as a separate file and used
    the bootloader to load it into memory. Some bootloaders do not have the ability
    to load an `initramfs` file in this way. To cope with these situations, Linux
    can be configured to incorporate `initramfs` into the kernel image. To do this,
    change the kernel configuration and set `CONFIG_INITRAMFS_SOURCE` to the full
    path of the compressed `initramfs.cpio.gz` archive file you created earlier for
    your standalone `initramfs`. If you are using `menuconfig`, that field can be
    found in **General setup | Initramfs source file(s)**.
  prefs: []
  type: TYPE_NORMAL
- en: Once these changes have been made, build the kernel. Booting is the same as
    before, except there is no `-initrd` option and ramdisk file to pass in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter this command for QEMU:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'For the BeaglePlay, enter these commands at the U-Boot prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember to regenerate the `initramfs.cpio` archive, and recompress the `initramfs.cpio.gz`
    file each time you change the contents of your staging directory and then rebuild
    the kernel:'
  prefs: []
  type: TYPE_NORMAL
- en: '**TIP**'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you experience the following kernel panic on boot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Make sure that the `dev/null` and `dev/console` device nodes exist in your staging
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: Building an initramfs using a device table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **device table** is a text file that lists the files, directories, device
    nodes, and links that go into an archive or filesystem image. The overwhelming
    advantage is that it allows you to create entries in the archive file that are
    owned by the `root` user, or any other UID, without having `root` privileges yourself.
    You can even create device nodes without needing to have `root` privileges. All
    this is possible because the archive is just a data file. It is only when it is
    expanded by Linux at boot time that real files and directories get created using
    the attributes you specified.
  prefs: []
  type: TYPE_NORMAL
- en: The kernel has a feature that allows us to use a device table when creating
    an `initramfs`. You write the device table file and then point `CONFIG_INITRAMFS_SOURCE`
    at it. Then, when you build the kernel, it creates the cpio archive from the instructions
    in the device table. At no point do you need `root` access.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a device table for our simple root filesystem. To make it manageable,
    it is missing most of the symbolic links to BusyBox:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntax is fairly obvious:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dir <name> <mode> <uid> <gid>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`file <name> <location> <mode> <uid> <gid>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nod <name> <mode> <uid> <gid> <dev_type> <maj> <min>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`slink <name> <target> <mode> <uid> <gid>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The commands `dir`, `nod`, and `slink` create a filesystem object in the cpio
    archive with the name, mode, user ID, and group ID given. The `file` command copies
    the file from the source location into the archive and sets the mode, user ID,
    and group ID.
  prefs: []
  type: TYPE_NORMAL
- en: The task of creating an `initramfs`.`cpio` archive from scratch is made easier
    by a script found in the kernel source code, named `gen_initramfs.sh`. First,
    this script generates a device table from the contents of the input directory.
    Then, it translates this device table into the finished cpio archive.
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate an `initramfs.cpio` archive from your `rootfs` directory and change
    the ownership of all files owned by user ID `1000` and group ID `1000` to user
    ID `0` and group ID `0`, enter these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Old initrd format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is an older format for a Linux ramdisk known as `initrd`. It was the only
    format available before Linux 2.6 and is still needed if you are using uClinux,
    the MMU-less variant of Linux. It is pretty obscure, so I will not cover it here.
  prefs: []
  type: TYPE_NORMAL
- en: Once our `initramfs` boots, the system then needs to start running programs.
    The first program that runs is the `init` program.
  prefs: []
  type: TYPE_NORMAL
- en: init program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Running a shell or even a shell script at boot time is fine for simple cases,
    but really, you need something more flexible. Normally, Unix systems run a program
    called `init` that starts up and monitors other programs. Over the years, there
    have been many `init` programs, some of which I will describe in [*Chapter 13*](Chapter_13.xhtml#_idTextAnchor431).
    For now, I will briefly introduce BusyBox `init`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `init` program begins by reading the `/etc/inittab` configuration file.
    Here is a simple example, which is adequate for our needs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The first line runs a shell script named `rcS` when `init` is started. The second
    line prints the message **Please press Enter to activate this console** to the
    console and starts a shell when you press *Enter*. The leading `-` before `/bin/ash`
    means that it will become a login shell, which sources `/etc/profile` and `$HOME/.profile`
    before displaying the shell prompt.
  prefs: []
  type: TYPE_NORMAL
- en: One of the advantages of launching the shell like this is that job control is
    enabled. The most immediate effect is that you can use *Ctrl + C* to terminate
    the current program. Maybe you didn’t notice it before, but wait until you run
    the `ping` program and find you can’t stop it!
  prefs: []
  type: TYPE_NORMAL
- en: BusyBox `init` provides a default `inittab` if none is present in the root filesystem.
    It is a little more extensive than the preceding one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The script called `/etc/init.d/rcS` is the place to put initialization commands
    that need to be performed at boot, like mounting the `proc` and `sysfs` filesystems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure that you make the preceding `rcS` script executable like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'You can try `init` out on QEMU by changing the `-append` parameter like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'For the BeaglePlay, you need to set the `bootargs` variable in U-Boot as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s take a closer look at the `inittab` read by `init` during startup.
  prefs: []
  type: TYPE_NORMAL
- en: Starting a daemon process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Typically, you want to run certain background processes at startup. Take `syslogd`
    (the log daemon), for example. The purpose of `syslogd` is to accumulate log messages
    from other programs, mostly other daemons. Naturally, BusyBox has an applet for
    that!
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting the daemon is as simple as adding a line like this to `etc/inittab`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '`respawn` means that if the program terminates, it will be automatically restarted.
    `-n` means that it should run as a foreground process. The log is written to `/var/log/messages`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IMPORTANT NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: You may also want to start `klogd` in the same way. `klogd` sends kernel log
    messages to `syslogd` so that they can be logged to permanent storage.
  prefs: []
  type: TYPE_NORMAL
- en: So far, all the processes I have mentioned run as `root`, but that is less than
    ideal.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring user accounts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As I already said, it is bad practice to run all programs as `root` because
    if one program is compromised by an outside attack then the whole system is at
    risk. It is better to create unprivileged user accounts and use them where full
    `root` is not necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usernames are configured in `/etc/passwd`. There is one line per user with
    seven fields of information separated by colons. These are, in order:'
  prefs: []
  type: TYPE_NORMAL
- en: The login name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The hash code used to verify the password or, more usually, an `x` to indicate
    that the password is stored in `/etc/shadow`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The UID or user ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The GID or group ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The comment field (often left blank)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user’s home directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The shell this user will use (optional)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a simple example in which we have the user `root` with UID 0 and the
    user `daemon` with UID 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Setting the shell for the user `daemon` as `/bin/false` ensures that any attempt
    to log on with that name will fail.
  prefs: []
  type: TYPE_NORMAL
- en: Various programs have to read `/etc/passwd` to look up usernames and UIDs, so
    the file has to be world-readable. This is a problem if the password hashes are
    stored in there as well because a malicious program can take a copy and discover
    the actual passwords, using a variety of cracker programs. To reduce the exposure
    of this sensitive information, the passwords are stored in `/etc/shadow`, and
    `x` is placed in the password field to indicate that this is the case. The `/etc/shadow`
    file only needs to be accessed by `root`, so as long as the `root` user is not
    compromised, the passwords are safe.
  prefs: []
  type: TYPE_NORMAL
- en: 'The shadow password file consists of one entry per user, made up of nine fields.
    Here is an example that mirrors the password file shown in the preceding paragraph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The first two fields are the username and the password hash. The remaining seven
    fields are related to password aging, which is usually not a concern on embedded
    devices. If you are curious about the full details, refer to the manual page for
    `shadow(5)`.
  prefs: []
  type: TYPE_NORMAL
- en: In the example, the password for `root` is empty meaning that `root` can log
    on without providing a password. Having an empty password for `root` is useful
    during development but not for production. You can generate or change a password
    hash by running the `passwd` command on the target, which will write a new hash
    to `/etc/shadow`. If you want all subsequent root filesystems to have this same
    password, you could copy this file back to the staging directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Group names are stored similarly in `/etc/group`. There is one line per group,
    consisting of four fields separated by colons. The fields are:'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the group
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The group password or, more usually, an `x` to indicate that there is no group
    password
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The GID or group ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A comma-separated list of users who belong to this group (optional)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Adding user accounts to the root filesystem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, add the files `etc/passwd`, `etc/shadow`, and `etc/group` to your staging
    directory, as shown in the preceding section. Make sure that the permissions of
    `etc/shadow` are `0600`. Next, initiate the login procedure by starting a program
    called `getty`. There is a version of `getty` in BusyBox. You launch it from your
    `inittab` using the keyword `respawn`, which restarts `getty` when a login shell
    is terminated. Your `inittab` should read like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Then, rebuild the ramdisk, and try it out using QEMU or the BeaglePlay, as before.
  prefs: []
  type: TYPE_NORMAL
- en: Earlier in this chapter, we learned how to create device nodes using the `mknod`
    command. Now, let’s look at some easier ways to create device nodes.
  prefs: []
  type: TYPE_NORMAL
- en: A better way of managing device nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating device nodes statically with `mknod` is hard work and inflexible.
    However, there are other ways to create device nodes automatically on demand:'
  prefs: []
  type: TYPE_NORMAL
- en: '`devtmpfs`: This is a pseudo filesystem that you mount over `/dev` at boot
    time. The kernel populates it with device nodes for all the devices that the kernel
    currently knows about. The kernel also creates nodes for new devices as they are
    detected at runtime. The nodes are owned by `root` and have default permissions
    of `0600`. Some well-known device nodes, such as `/dev/null` and `/dev/random`,
    override the default to `0666`. To see exactly how this is done, look at the `drivers/char/mem.c`
    file in the Linux source tree and observe how `struct memdev` is initialized.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mdev`: This is a BusyBox applet that is used to populate a directory with
    device nodes and create new nodes as needed. There is an `/etc/mdev.conf` configuration
    file that contains rules for the ownership and mode of the nodes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`udev`: This is the mainstream equivalent of `mdev`. You will find it on desktop
    Linux and in some embedded devices. It is very flexible and a good choice for
    higher-end embedded devices. It is now part of `systemd`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IMPORTANT NOTE**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Although both `mdev` and `udev` create the device nodes themselves, it is easier
    to just let `devtmpfs` do the job and use `mdev/udev` as a layer on top to implement
    the policy for setting ownership and permissions. The `devtmpfs` approach is the
    only maintainable way to generate device nodes prior to user space startup.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After introducing `devtmpfs`, I will describe how `mdev` is used to assign ownership
    and permissions to device nodes on startup.
  prefs: []
  type: TYPE_NORMAL
- en: Using devtmpfs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Support for the `devtmpfs` filesystem is controlled by the `CONFIG_DEVTMPFS`
    kernel configuration variable. It is not enabled in the default configuration
    of the 64-bit Arm generic virtual platform, so if you want to try `devtmpfs` out
    on QEMU, you will have to go back to your kernel configuration and enable this
    option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter this command to mount `devtmpfs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'You will notice that there are many more device nodes in `/dev` afterward.
    To mount `devtmpfs` on startup, add the preceding command to `/etc/init.d/rcS`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: If you enable `CONFIG_DEVTMPFS_MOUNT` in your kernel configuration, the kernel
    will automatically mount `devtmpfs` just after mounting the root filesystem. However,
    this option has no effect when booting `initramfs`, as we are doing here.
  prefs: []
  type: TYPE_NORMAL
- en: Using mdev
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While `mdev` is a bit more complex to set up, it does allow you to modify the
    permissions of device nodes as they are created. You begin by running `mdev` with
    the `-s` option, which causes it to scan the `/sys` directory looking for information
    about current devices. From this information, it populates the `/dev` directory
    with the corresponding nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to keep track of new devices coming online and create nodes for
    them as well, you need to make `mdev` a hot plug client by writing to `/proc/sys/kernel/hotplug`.
    Add two more lines to `/etc/init.d/rcS`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The default mode is `660` and the ownership is `root:root`. You can change
    this by adding rules in `/etc/mdev.conf`. For example, to give the `null`, `random`,
    and `urandom` devices their correct modes, you would add this to `/etc/mdev.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The format is documented in the BusyBox source code in `docs/mdev.txt`, and
    there are more examples in the directory named `examples`.
  prefs: []
  type: TYPE_NORMAL
- en: Are static device nodes so bad after all?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Statically created device nodes have one advantage over running a device manager:
    they don’t take any time to create during boot. If minimizing boot time is a priority,
    then using statically created device nodes will save a measurable amount of time.'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, let’s look at some basic network configurations so that we can communicate
    with the outside world. I assume that there is an Ethernet interface (`eth0`)
    and that we only need a simple IPv4 configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'These examples use the network utilities that are part of BusyBox, which are
    sufficient for our simple use case. All we need are the old-but-reliable `ifup`
    and `ifdown` programs. You can read the manual pages for both to get the details.
    The main network configuration is stored in `/etc/network/interfaces`. You will
    need to create these directories in the staging directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is `/etc/network/interfaces` for a static IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is `/etc/network/interfaces` for a dynamic IP address, allocated using
    DHCP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: You also need to configure a DHCP client program. BusyBox has one named `udchpcd`.
    It requires a shell script that goes in `/usr/share/udhcpc/default.script`. There
    is a suitable default at `examples/udhcp/simple.script` within the BusyBox source
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Network components for glibc
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'glibc uses a mechanism known as the **name service switch** (**NSS**) to control
    the way that names are resolved to numbers for networking and users. Usernames
    can be resolved to UIDs via the `/etc/passwd` file, and network services such
    as HTTP can be resolved to service port numbers via `/etc/services`. All this
    is configured by `/etc/nsswitch.conf`; see the `nss(5)` manual page for full details.
    Here is a simple example that will suffice for most embedded Linux implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Everything is resolved by the correspondingly named file in `/etc`, except for
    host names, which can be resolved by a DNS lookup if they are not in `/etc/hosts`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this work, you need to populate `/etc` with those files. Networks,
    protocols, and services are the same across all Linux systems, so they can be
    copied from `/etc` on your development machine. At the very least, `/etc/hosts`
    should contain the loopback address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The other files (`passwd`, `group`, and `shadow`) were described in the *Configuring
    user accounts* section earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last piece of the puzzle is the libraries that perform the name resolution.
    They are plugins that are loaded as needed, based on the contents of `nsswitch.conf`.
    That means they do not show up as dependencies when you use `readelf` or `ldd`.
    You will simply have to copy them from the toolchain’s `sysroot`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: At last, our staging directory is complete. Let’s generate a filesystem from
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating filesystem images with device tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We saw in the earlier *Creating a boot initramfs* section that the kernel has
    the option to create `initramfs`, using a device table. Device tables are really
    useful because they allow a non-root user to create device nodes and allocate
    arbitrary UID and GID values to any file or directory. The same concept has been
    applied to tools that create other filesystem image formats, as shown in this
    mapping from the filesystem format to tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '**jffs2**: `mkfs.jffs2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ubifs**: `mkfs:ubifs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ext2**: `genext2fs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will cover jffs2 and ubifs in [*Chapter 9*](Chapter_09.xhtml#_idTextAnchor293),
    when we look at filesystems for flash memory. ext2 is a format commonly used for
    managed flash memory, including SD cards. The example that follows uses ext2 to
    create a disk image that can be copied to an SD card.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin with, you need to install the `genext2fs` tool on your host. On Ubuntu,
    the package to install is named `genext2fs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '`genext2fs` takes a device table file with the format `<name> <type> <mode>
    <uid> <gid> <major> <minor> <start> <inc> <count>`. The meanings of the fields
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**name**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**type**: one of the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`f`: regular file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d`: directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`c`: character device file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`b`: block device file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`p`: FIFO (named pipe)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**uid**: UID of the file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**gid**: GID of the file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**major** and **minor**: device numbers (device nodes only)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**start**, **inc**, and **count**: allows you to create a group of device nodes
    starting from the minor number in start (device nodes only)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You do not have to specify these for every file as you do with the kernel `initramfs`
    table. You just need to point at a directory—the staging directory—and list the
    changes and exceptions you need to make in the final filesystem image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple example that populates static device nodes for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can use `genext2fs` to generate a filesystem image of 8 MB (8,192
    blocks of the default size, 1,024 bytes):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Now, you can copy the resulting `rootfs.ext2` image to an SD card or similar,
    as we will do next.
  prefs: []
  type: TYPE_NORMAL
- en: Booting the BeaglePlay
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The script named `MELD/format-sdcard.sh` creates two partitions on the microSD
    card: one for the boot files and one for the root filesystem. Assuming you have
    created the root filesystem image, as shown in the previous section, you can use
    the `dd` command to write it to the second partition.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IMPORTANT NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: As always, when copying files directly to storage devices like this, make absolutely
    sure that you know which device is the microSD card.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, I am using a built-in card reader, which is the device called
    `/dev/mmcblk0`, so the command is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Note that the card reader on your host system may have a different name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Insert the microSD card into the BeaglePlay and set the kernel command line
    to `root=/dev/mmcblk1p2`. Unlike previous Beagles, the eMMC is the `mmcblk0` device
    and the microSD is the `mmcblk1` device on the BeaglePlay. Here is the complete
    sequence of U-Boot commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This is an example of mounting an ext2 filesystem from a normal block device,
    such as an SD card. The same principles apply to other filesystem types. We will
    look at these in more detail when we get to [*Chapter 9*](Chapter_09.xhtml#_idTextAnchor293).
    Now, let’s switch gears and look at how to mount a filesystem over a network.
  prefs: []
  type: TYPE_NORMAL
- en: Mounting the root filesystem using NFS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If your device has a network interface, you can mount the root filesystem over
    the network for rapid development using **Network File System** (**NFS**). This
    gives you access to almost unlimited storage on your host machine, so you can
    add debug tools and executables with large symbol tables. As a bonus, updates
    made to the root filesystem on your development machine are available on the target
    instantly. You can also access all the target’s log files from the host.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, you need to install and configure an NFS server on your host machine.
    The package to install on Ubuntu is named `nfs-kernel-server`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The NFS server needs to be told which directories are being exported to the
    network. This is controlled by `/etc/exports`. There is one line for each export.
    The format is described in the `exports(5)` manual page. To export the root filesystem,
    the `exports` file on my host contains this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '`*` exports the directory to any address on my local network. If you wish,
    you can specify a single IP address or a range at this point. A list of options
    enclosed in parentheses follows. There must not be any spaces between `*` and
    the opening parenthesis. The options are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`rw`: Exports the directory as read-write.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sync`: Selects the synchronous version of the NFS protocol, which is more
    robust but a little slower than the async option.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`no_subtree_check`: Disables subtree checking, which has mild security implications
    but can improve reliability in some circumstances.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`no_root_squash`: Allows requests from user ID 0 to be processed without squashing
    to a different user ID. It is necessary for the target to correctly access the
    files owned by `root`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Having made changes to `/etc/exports`, restart the NFS server to pick them
    up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, set up the target to mount the root filesystem over NFS. For this to work,
    configure your kernel with `CONFIG_ROOT_NFS`. Then, configure Linux to do the
    mount at boot time by adding the following to the kernel command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The options are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`rw`: Mounts the root filesystem read-write.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nfsroot`: Specifies the IP address of the host, followed by the path to the
    exported root filesystem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ip`: This is the IP address to be assigned to the target. Usually, network
    addresses are assigned at runtime, as we saw in the *Configuring the network*
    section. However, in this case, the interface has to be configured before the
    root filesystem is mounted and `init` has started. Hence, it is configured on
    the kernel command line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IMPORTANT NOTE**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There is more information about NFS root mounts in the kernel source in `Documentation/admin-guide/nfs/nfsroot.rst`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Testing with the BeaglePlay
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Boot your BeaglePlay from the microSD card and enter these commands at the
    U-Boot prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Replace `<path to staging directory>` with the full path to your staging directory,
    and change the `serverip` and `ipaddr` values to match the IP addresses of your
    Linux host and BeaglePlay. Make sure that the BeaglePlay can ping the `serverip`
    before attempting this exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Problems with file permissions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The files that you copied into the staging directory will be owned by the UID
    of the user you are logged on as (typically `1000`). However, the target has no
    knowledge of this user. What’s more, any files created by the target will be owned
    by users configured by the target (often the root user). The whole thing is a
    mess. Unfortunately, there is no simple way out.
  prefs: []
  type: TYPE_NORMAL
- en: The best solution is to make a copy of the staging directory and change ownership
    to UID and GID to `0`, using the command `sudo chown -R 0:0 *`. Then, export this
    directory as the NFS mount. This removes the convenience of having just one copy
    of the root filesystem shared between development and target systems, but at least
    the file ownership will be correct.
  prefs: []
  type: TYPE_NORMAL
- en: It’s not uncommon in embedded Linux to link device drivers statically to the
    kernel, rather than load them dynamically from the root filesystem as modules
    at runtime. So how do we reap the same benefits of rapid iteration provided by
    NFS when modifying kernel source code or DTBs? The answer is TFTP.
  prefs: []
  type: TYPE_NORMAL
- en: Using TFTP to load the kernel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know how to mount the root filesystem over a network using NFS,
    you may be wondering if there is a way to load the kernel, device tree, and `initramfs`
    over the network as well. If we can do this, then the only component that needs
    to be written to storage on the target is the bootloader. Everything else could
    be loaded from the host machine. This would save time, since you would not need
    to keep reflashing the target. You could even get work done while the flash storage
    drivers are still being developed (it happens).
  prefs: []
  type: TYPE_NORMAL
- en: The **Trivial File Transfer Protocol** (**TFTP**) is the answer. TFTP is a very
    simple file transfer protocol that is designed for easy implementation with bootloaders
    such as U-Boot.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, you need to install a TFTP daemon on your host machine. The package
    to install on Ubuntu is named `tftpd-hpa`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify the contents of `/etc/default/tftpd-hpa` as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `/var/lib/tftpboot` directory with the necessary ownership and permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Having made changes to `/etc/default/tftpd-hpa`, restart the TFTP server to
    pick them up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'With `tftpd-hpa` installed and running, copy the files you want loaded on the
    target to `/var/lib/tftpboot`. For the BeaglePlay, these would be `Image` and
    `k3-am625-beagleplay.dtb`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, enter these commands at the U-Boot prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace `<path to staging directory>` with the full path to your staging directory,
    and change the `serverip` and `ipaddr` values to match the IP addresses of your
    Linux host and BeaglePlay. You may find that the `tftp` command hangs endlessly,
    printing out the letter `T`, which means that the TFTP requests time out. There
    are a number of reasons why this happens. The most common ones are:'
  prefs: []
  type: TYPE_NORMAL
- en: An incorrect IP address for `serverip`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The TFTP daemon is not running on the server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The firewall on the server is blocking the TFTP protocol. Most firewalls block
    TFTP port 69 by default.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you have resolved the connectivity problem, U-Boot loads the files from
    the host machine and boots in the usual way.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the strengths of Linux is that it supports a variety of root filesystems,
    so it can be tailored for a wide range of needs. We have seen how it is possible
    to construct a simple root filesystem manually with just a small number of components.
    BusyBox is especially useful in this regard.
  prefs: []
  type: TYPE_NORMAL
- en: By going through the process one step at a time, we gained insight into some
    of the basic workings of Linux systems, including network configuration and user
    accounts. However, the task rapidly becomes unmanageable as devices get more complex.
    Plus, there is the ever-present worry that there may be a security hole in the
    implementation that we did not notice.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, I will show you how using an embedded build system can
    make the process of creating an embedded Linux system much easier and more reliable.
    I will start by looking at Buildroot and then go on to look at the more complex,
    yet powerful, Yocto Project.
  prefs: []
  type: TYPE_NORMAL
- en: Further study
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Filesystem Hierarchy Standard, Version 3.0*: [https://refspecs.linuxfoundation.org/fhs.shtml](https://refspecs.linuxfoundation.org/fhs.shtml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ramfs, rootfs and initramfs*, by Rob Landley, part of the Linux source at
    [Documentation/filesystems/ramfs-rootfs-initramfs.rst](https://Documentation/filesystems/ramfs-rootfs-initramfs.rst)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers: https://packt.link/embeddedsystems'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code12308107448340296.png)'
  prefs: []
  type: TYPE_IMG
