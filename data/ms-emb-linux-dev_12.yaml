- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Creating a Storage Strategy
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建存储策略
- en: The mass storage options for embedded devices have a great impact on the rest
    of the system in terms of the robustness, speed, and methods used for in-field
    updates. Most devices employ flash memory in some form or another. Flash memory
    has become much less expensive over the past few years as storage capacities have
    increased from tens of megabytes to tens of gigabytes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式设备的海量存储选项对系统的其他部分有很大影响，特别是在系统的稳健性、速度和现场更新方法方面。大多数设备都以某种形式使用闪存。随着存储容量从几十兆字节增加到几十千兆字节，闪存的价格在过去几年中大幅下降。
- en: In this chapter, we will begin with a detailed look at the technology behind
    flash memory as well as how different memory organization strategies affect the
    low-level driver software that has to manage it, including the Linux **memory
    technology device** (**MTD**) layer.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将详细介绍闪存技术，并探讨不同的内存组织策略如何影响必须管理它的低级驱动程序软件，包括 Linux **内存技术设备**（**MTD**）层。
- en: For each flash technology, there are different choices when it comes to the
    filesystem. I will describe those most commonly found on embedded devices and
    complete the survey by providing a summary of choices for each type of flash memory.
    Finally, we will consider some techniques that make the best use of flash memory
    and draw everything together into a coherent storage strategy.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 每种闪存技术都有不同的文件系统选择。我将描述在嵌入式设备上最常见的那些，并通过总结每种闪存类型的选择来完成这项调查。最后，我们将考虑一些技术，使闪存得到最佳利用，并将所有内容整合成一个连贯的存储策略。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Storage options
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储选项
- en: Accessing flash memory from the bootloader
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从启动加载程序访问闪存
- en: Accessing flash memory from Linux
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 Linux 访问闪存
- en: Filesystems for flash memory
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闪存文件系统
- en: Filesystems for NOR and NAND flash memory
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NOR 和 NAND 闪存文件系统
- en: Filesystems for managed flash
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理闪存的文件系统
- en: Read-only compressed filesystems
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只读压缩文件系统
- en: Temporary filesystems
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 临时文件系统
- en: Making the root filesystem read-only
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使根文件系统只读
- en: Filesystem choices
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件系统选择
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with the examples, make sure you have the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随示例，请确保你已准备好以下内容：
- en: A Linux-based host system with `e2fsprogs`, `genext2fs`, `mtd-utils`, `squashfs-tools`,
    and `util-linux` or their equivalents installed
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台安装有 `e2fsprogs`、`genext2fs`、`mtd-utils`、`squashfs-tools` 和 `util-linux` 或其等效工具的基于
    Linux 的主机系统
- en: A microSD card reader and card
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 microSD 卡读卡器和卡片
- en: balenaEtcher for Linux
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用于 Linux 的 balenaEtcher
- en: The U-Boot source tree from [*Chapter 3*](Chapter_03.xhtml#_idTextAnchor061)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自 [*第 3 章*](Chapter_03.xhtml#_idTextAnchor061) 的 U-Boot 源代码树
- en: The Linux kernel source tree from [*Chapter 4*](Chapter_04.xhtml#_idTextAnchor096)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自 [*第 4 章*](Chapter_04.xhtml#_idTextAnchor096) 的 Linux 内核源代码树
- en: A USB to TTL serial cable with 3.3V logic-level pins
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一条带有 3.3V 逻辑电平引脚的 USB 到 TTL 串口电缆
- en: A BeaglePlay
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台 BeaglePlay
- en: A 5V USB-C power supply capable of delivering 3A
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一款能够提供 3A 电流的 5V USB-C 电源
- en: You should have already downloaded and built U-Boot for the BeaglePlay back
    in [*Chapter 3*](Chapter_03.xhtml#_idTextAnchor061). You should have obtained
    the Linux kernel source tree from [*Chapter 4*](Chapter_04.xhtml#_idTextAnchor096).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经在 [*第 3 章*](Chapter_03.xhtml#_idTextAnchor061) 中为 BeaglePlay 下载并构建了 U-Boot。你也应该已经获得了来自
    [*第 4 章*](Chapter_04.xhtml#_idTextAnchor096) 的 Linux 内核源代码树。
- en: 'Ubuntu provides packages for most of the tools needed to create and format
    various filesystems. To install the tools on an Ubuntu 24.04 LTS system, use the
    following command:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Ubuntu 提供了创建和格式化各种文件系统所需工具的大部分软件包。要在 Ubuntu 24.04 LTS 系统上安装这些工具，请使用以下命令：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `mtd-utils` package includes `mtdinfo`, `mkfs.jffs2`, `sumtool`, `nandwrite`,
    and the UBI command-line tools.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`mtd-utils` 包含 `mtdinfo`、`mkfs.jffs2`、`sumtool`、`nandwrite` 和 UBI 命令行工具。'
- en: Storage options
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储选项
- en: Embedded devices need storage that takes little power and is physically compact,
    robust, and reliable over a lifetime of perhaps tens of years. In almost all cases,
    this means solid-state storage. Solid-state storage was introduced many years
    ago with **read-only memory** (**ROM**), but for the past 20 years, it has been
    flash memory of some kind. There have been several generations of flash memory
    in that time, progressing from NOR to NAND to managed flash such as eMMC.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式设备需要低功耗、物理紧凑、稳健且在可能达到几十年生命周期的情况下可靠的存储。几乎所有情况下，这意味着使用固态存储。固态存储在许多年前通过 **只读存储器**（**ROM**）引入，但过去
    20 年里，它一直是某种类型的闪存。在这段时间里，闪存经历了多个发展阶段，从 NOR 到 NAND，再到像 eMMC 这样的管理闪存。
- en: NOR flash is expensive but reliable and can be mapped into the CPU address space,
    allowing you to execute code directly from flash. NOR flash chips are low capacity,
    ranging from a few megabytes to a gigabyte or so.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: NOR 闪存价格昂贵，但可靠，可以映射到 CPU 地址空间，从而允许你直接从闪存中执行代码。NOR 闪存芯片的容量较小，通常从几兆字节到大约一吉字节。
- en: NAND flash memory is much cheaper than NOR and is available in higher capacities
    from tens of megabytes to tens of gigabytes. However, it needs a lot of hardware
    and software support to turn it into a useful storage medium.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: NAND 闪存比 NOR 闪存便宜得多，并且具有从数十兆字节到数十吉字节不等的更高容量。然而，它需要大量的硬件和软件支持才能将其转化为有用的存储介质。
- en: Managed flash memory consists of one or more NAND flash chips packaged with
    a controller that handles the complexities of flash memory and presents a hardware
    interface similar to that of a hard disk. The attraction is that it removes complexity
    from the driver software and insulates the system designer from the frequent changes
    in flash technology.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 管理型闪存由一个或多个 NAND 闪存芯片组成，配备了一个控制器，该控制器处理闪存的复杂性，并提供类似硬盘的硬件接口。其吸引力在于，它将复杂性从驱动程序软件中移除，并使系统设计师免于应对闪存技术的频繁变化。
- en: SD cards, eMMC chips, and USB flash drives fit into this category. Almost all
    the current generations of smartphones and tablets have eMMC storage and this
    trend is likely to progress with other categories of embedded devices.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: SD 卡、eMMC 芯片和 USB 闪存驱动器都属于这一类别。几乎所有当前一代的智能手机和平板电脑都配备了 eMMC 存储，这一趋势可能会扩展到其他类型的嵌入式设备。
- en: Hard drives are seldom found in embedded systems. One exception is digital video
    recording in set-top boxes and smart TVs where a large amount of storage is needed
    with fast write times.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式系统中很少使用硬盘驱动器。一个例外是机顶盒和智能电视中的数字视频录制，它们需要大量存储并具有快速写入时间。
- en: 'In all cases, robustness is of prime importance: you want the device to boot
    and reach a functional state despite power failures and unexpected resets. You
    should choose filesystems that behave well under such circumstances. Your choice
    of storage device technology limits your choice of filesystems.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有情况下，可靠性至关重要：你希望设备能够在电力故障和意外重启的情况下启动并进入功能状态。你应该选择在此类情况下表现良好的文件系统。你的存储设备技术选择将限制你对文件系统的选择。
- en: In this section, we will learn the difference between NOR and NAND flash and
    consider our options when choosing a managed flash technology.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将学习 NOR 闪存和 NAND 闪存之间的差异，并在选择管理型闪存技术时考虑我们的选择。
- en: NOR flash
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NOR 闪存
- en: The memory cells in NOR flash chips are arranged into erase blocks of, for example,
    128 KB. Erasing a block sets all the bits to 1\. It can be programmed one word
    at a time (8, 16, or 32 bits depending on the data bus width). Each erase cycle
    damages the memory cells slightly and after a number of cycles, the erase block
    becomes unreliable and cannot be used anymore. The maximum number of erase cycles
    should be given in the data sheet for the chip but is usually in the range of
    1 K to 1 M.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: NOR 闪存芯片中的存储单元被排列成擦除块，例如 128 KB。擦除一个块会将所有位设置为 1。它可以一次编程一个字（根据数据总线宽度，8、16 或 32
    位）。每个擦除周期都会轻微损坏存储单元，经过一定次数的周期后，擦除块将变得不可靠，无法再使用。芯片的数据表中应提供最大擦除周期数，但通常在 1 K 到 1
    M 之间。
- en: The data can be read word by word. The chip is usually mapped into the CPU address
    space, meaning that you can execute code directly from NOR flash. This makes it
    a convenient place to put the bootloader code as it needs no initialization beyond
    hardwiring the address mapping. SoCs that support NOR flash in this way have configurations
    that provide a default memory mapping so that it encompasses the reset vector
    of the CPU.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 数据可以逐字读取。芯片通常被映射到 CPU 地址空间，这意味着你可以直接从 NOR 闪存中执行代码。这使得它成为放置引导加载程序代码的一个方便位置，因为它只需要硬接地址映射，不需要额外的初始化。因此，支持这种
    NOR 闪存的 SoC 通常会提供默认的内存映射，使其涵盖 CPU 的重置向量。
- en: The kernel, and even the root filesystem, can also be located in flash memory,
    avoiding the need for copying them into RAM and thus creating devices with small
    memory footprints. This technique is known as **Execute-in-Place** or **XIP**.
    It is very specialized, and I will not examine it further here. I have included
    some references at the end of this chapter in the *Further study* section.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 内核，甚至根文件系统，也可以位于闪存中，这样就避免了将它们复制到 RAM 中，从而创建了具有小内存占用的设备。这种技术被称为**就地执行**或**XIP**。它非常专业，我在这里不会进一步讨论。章节末尾的*进一步学习*部分包含了一些参考资料。
- en: There is a standard register-level interface for NOR flash chips called the
    **Common Flash Interface** or **CFI**, which all modern chips support. The CFI
    is described in standard JESD68, which you can get from [https://www.jedec.org/](https://www.jedec.org/).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: NOR闪存芯片有一个标准的寄存器级接口，称为**通用闪存接口**（**CFI**），所有现代芯片都支持该接口。CFI在标准JESD68中进行了描述，您可以从[https://www.jedec.org/](https://www.jedec.org/)获取。
- en: Now that we have learned what NOR flash is, let’s look at NAND flash.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了什么是NOR闪存，接下来让我们来看一下NAND闪存。
- en: NAND flash
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NAND闪存
- en: NAND flash is much cheaper than NOR flash and has a higher capacity. First-generation
    NAND chips stored one bit per memory cell in what is now known as a **single-level
    cell** (**SLC**) organization. Later generations moved on to two bits per cell
    in **multi-level cell** (**MLC**) chips and now to three bits per cell in **tri-level
    cell** (**TLC**) chips. As the number of bits per cell increased, the reliability
    of the storage decreased, requiring more complex controller hardware and software
    to compensate for this. Where reliability is a concern, you should make sure you
    are using SLC NAND flash chips.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: NAND闪存比NOR闪存便宜得多，且容量更大。第一代NAND芯片在现在所称的**单层单元**（**SLC**）组织中，每个存储单元存储一个比特。后来的几代芯片在**多层单元**（**MLC**）芯片中，每个存储单元存储两个比特，而现在的**三层单元**（**TLC**）芯片每个存储单元存储三个比特。随着每个存储单元存储比特数的增加，存储的可靠性下降，因此需要更复杂的控制器硬件和软件来补偿这一点。当可靠性成为问题时，应确保使用SLC
    NAND闪存芯片。
- en: As with NOR flash, NAND flash is organized into erase blocks ranging in size
    from 16 KB to 512 KB and, once again, erasing a block sets all the bits to 1\.
    However, the number of erase cycles is lower before the block becomes unreliable.
    There are typically as few as 1 K cycles for TLC chips and up to 100 K for SLC.
    NAND flash can only be read and written in pages (usually of 2 or 4 KB). Since
    they cannot be accessed byte by byte, they cannot be mapped into the address space,
    so code and data have to be copied into RAM before they can be accessed.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 与NOR闪存类似，NAND闪存也被组织成多个擦除块，大小范围从16 KB到512 KB，再次地，擦除一个块会将所有位设置为1。但是，在块变得不可靠之前，擦除周期的次数较少。TLC芯片通常只有大约1K次擦除周期，而SLC芯片可高达100K次。NAND闪存只能以页面（通常为2
    KB或4 KB）的形式进行读写。由于它们无法按字节逐一访问，因此无法映射到地址空间中，所以代码和数据必须先被复制到RAM中，才能进行访问。
- en: Data transfers to and from the chip are prone to bit flips, which can be detected
    and corrected using **error-correction codes** (**ECC**s). SLC chips generally
    use a simple **hamming code**, which can be implemented efficiently in software
    and can correct a single-bit error in a page read. MLC and TLC chips need more
    sophisticated codes such as **Bose-Chaudhuri-Hocquenghem** (**BCH**), which can
    correct up to 8-bit errors per page. Correcting that many errors requires hardware
    support inside the flash controller.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 数据传输到芯片以及从芯片传输的过程中容易发生比特翻转，这可以通过使用**错误修正码**（**ECC**）来检测和修正。SLC芯片通常使用简单的**汉明码**，可以在软件中高效实现，并能修正页面读取中的单比特错误。MLC和TLC芯片需要更复杂的代码，如**Bose-Chaudhuri-Hocquenghem**（**BCH**）码，可以修正每页最多8比特的错误。修正如此多的错误需要闪存控制器内部的硬件支持。
- en: 'The ECCs need to be stored somewhere, so there is an extra area of memory per
    page known as the **out-of-band** (**OOB**) area or the spare area. SLC designs
    usually have 1 byte of OOB per 32 bytes of main storage. So, for a 2 KB page device,
    the OOB is 64 bytes per page, and for a 4 KB page, it is 128 bytes. MLC and TLC
    chips have proportionally larger OOB areas to accommodate more complex ECCs. The
    following diagram shows the organization of a chip with a 128 KB erase block and
    2 KB pages:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ECC需要存储在某个地方，因此每页会有一个额外的存储区域，称为**带外**（**OOB**）区域或备用区域。SLC设计通常每32字节主存储会有1字节OOB。因此，对于一个2
    KB页面设备，OOB为每页64字节，对于一个4 KB页面，OOB为每页128字节。MLC和TLC芯片具有相对更大的OOB区域，以容纳更复杂的ECC。以下图展示了一个具有128
    KB擦除块和2 KB页面的芯片组织：
- en: '![Figure 9.1 – OOB area](img/B18466_09_01.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – OOB区域](img/B18466_09_01.png)'
- en: Figure 9.1 – OOB area
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – OOB区域
- en: During production, the manufacturer tests all the blocks and marks any that
    fail by setting a flag in the OOB area of each page in the block. It is not uncommon
    to find that brand-new chips have up to 2% of their blocks marked bad in this
    way. Saving OOB information for analysis before erasing the area can be useful
    when there is a problem. Furthermore, it is within the specification for a similar
    proportion of blocks to give errors on erase before the erase cycle limit is reached.
    The NAND flash driver should detect this and mark it as bad.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产过程中，制造商会测试所有的块，并通过在每个块的页面的OOB区域中设置标志来标记任何失败的块。发现全新芯片中有多达2%的块以这种方式标记为坏是很常见的。在擦除区域之前保存OOB信息以进行分析在出现问题时是有用的。此外，在达到擦除周期限制之前，类似比例的块给出擦除错误是符合规范的。NAND闪存驱动程序应检测到并标记其为坏块。
- en: 'Once space has been made in the OOB area for a bad block flag and ECC bytes,
    there are still some bytes left. Some flash filesystems make use of these free
    bytes to store filesystem metadata. Consequently, many parts of the system are
    interested in the layout of the OOB area: the SoC ROM boot code, the bootloader,
    the kernel MTD driver, the filesystem code, and the tools to create filesystem
    images. There is not much standardization, so it is easy to get into a situation
    in which the bootloader writes data using an OOB format that cannot be read by
    the kernel MTD driver. It is up to you to make sure that they all agree.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在OOB区域为坏块标志和ECC字节留出空间后，仍然有一些字节剩余。一些闪存文件系统利用这些空闲字节来存储文件系统元数据。因此，系统的许多部分对OOB区域的布局感兴趣：SoC
    ROM引导代码、引导加载程序、内核MTD驱动程序、文件系统代码以及创建文件系统映像的工具。由于标准化程度不高，因此很容易出现引导加载程序使用无法被内核MTD驱动程序读取的OOB格式的情况。您需要确保它们彼此一致。
- en: Access to NAND flash chips requires a NAND flash controller, which is usually
    part of the SoC. You will need the corresponding driver in the bootloader and
    kernel. The NAND flash controller handles the hardware interface for the chip
    transferring data to and from pages and may include hardware for error correction.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 访问NAND闪存芯片需要一个NAND闪存控制器，通常是SoC的一部分。您需要引导加载程序和内核中对应的驱动程序。NAND闪存控制器处理芯片的硬件接口，传输页面的数据，可能包括用于错误校正的硬件。
- en: There is a standard register-level interface for NAND flash chips known as the
    **Open NAND Flash Interface** or **ONFI**, which most modern chips adhere to.
    See [https://onfi.org/](https://onfi.org/) for more information.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: NAND闪存芯片有一个称为**开放NAND闪存接口**（Open NAND Flash Interface，ONFI）的标准寄存器级接口，大多数现代芯片都遵循这一标准。有关更多信息，请参阅[https://onfi.org/](https://onfi.org/)。
- en: Modern NAND flash technology is complicated. Pairing NAND flash memory with
    a controller is no longer enough. We also need an interface to the hardware that
    abstracts most of the technical details such as error correction away.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现代NAND闪存技术非常复杂。仅仅将NAND闪存存储器与控制器配对已不再足够。我们还需要一个接口来抽象掉大部分技术细节，例如错误校正。
- en: Managed flash
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理型闪存
- en: The burden of supporting flash memory in the operating system – NAND in particular
    – becomes smaller if there is a well-defined hardware interface and a standard
    flash controller that hides the complexities of the memory. This is managed flash
    memory, and it is becoming more and more common. In essence, it means combining
    one or more flash chips with a microcontroller that offers an ideal storage device
    with a small sector size and that is compatible with conventional filesystems.
    The most important types of chips for embedded systems are **Secure Digital**
    (**SD**) cards and the embedded variant known as eMMC.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作系统中支持闪存存储器的负担变小了，特别是对于NAND闪存而言，如果有一个明确定义的硬件接口和一个隐藏存储器复杂性的标准闪存控制器。这就是管理型闪存存储器，它越来越普遍。实质上，它意味着将一个或多个闪存芯片与提供理想存储设备的微控制器结合起来，具有小的扇区大小，并且与传统文件系统兼容。嵌入式系统中最重要的芯片类型是**安全数字**（Secure
    Digital，SD）卡及其嵌入式变体称为eMMC。
- en: The MultiMediaCard and Secure Digital cards
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多媒体卡（MultiMediaCard）和安全数字卡（Secure Digital cards）
- en: 'The **MultiMediaCard** (**MMC**) was introduced in 1997 by SanDisk and Siemens
    as a form of packaged storage using flash memory. Shortly after, in 1999, SanDisk,
    Matsushita, and Toshiba created the SD card, which is based on MMC but adds encryption
    and **Digital Rights Management** (**DRM**), hence the “secure” part of the name.
    Both were intended for consumer electronics such as digital cameras, music players,
    and similar devices. Currently, SD cards are the dominant form of managed flash
    for consumer and embedded electronics even though the encryption features are
    seldom used. Newer versions of the SD specification allow smaller packaging (miniSD
    and microSD) and larger capacities: high capacity SDHC up to 32 GB and extended
    capacity SDXC up to 2 TB.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**多媒体卡**（**MMC**）由SanDisk和西门子于1997年推出，是一种使用闪存的封装存储形式。随后，在1999年，SanDisk、松下和东芝共同创建了SD卡，它基于MMC，但增加了加密和**数字版权管理**（**DRM**）功能，因此才有了“安全”这一名称部分。这两种卡都是为了消费类电子产品，如数码相机、音乐播放器和类似设备而设计的。目前，SD卡是消费类和嵌入式电子产品中占主导地位的管理型闪存，尽管加密功能很少被使用。SD规范的新版本允许更小的封装（miniSD和microSD）和更大的容量：高容量的SDHC最高可达32GB，扩展容量的SDXC可达2TB。'
- en: The hardware interface for MMC and SD cards is very similar. It is possible
    to use full-sized MMC cards in full-sized SD card slots (but not the other way
    around). Early incarnations used a 1-bit **Serial Peripheral Interface** (**SPI**).
    More recent cards use a 4-bit interface.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: MMC和SD卡的硬件接口非常相似。可以在全尺寸的SD卡插槽中使用全尺寸的MMC卡（但反过来不可行）。早期的版本使用了1位的**串行外设接口**（**SPI**）。更近期的卡片使用了4位接口。
- en: 'There is a command set for reading and writing memory in sectors of 512 bytes.
    Inside the package is a microcontroller and one or more NAND flash chips, as shown
    in the following diagram:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令集用于读取和写入512字节的扇区内存。封装内部包含一个微控制器和一个或多个NAND闪存芯片，具体如下图所示：
- en: '![Figure 9.2 – SD card package](img/B18466_09_02.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – SD卡封装](img/B18466_09_02.png)'
- en: Figure 9.2 – SD card package
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – SD卡封装
- en: 'The microcontroller implements the command set and manages the flash memory,
    performing the function of a flash translation layer, as described later in this
    chapter. They are preformatted with a FAT filesystem: FAT16 on SDSC cards, FAT32
    on SDHC, and exFAT on SDXC. The quality of the NAND flash chips and the software
    on the microcontroller varies greatly between cards. It is questionable whether
    any of them are sufficiently reliable for deep embedded use. Certainly not with
    a FAT filesystem, which is prone to file corruption. Remember that the prime use
    case for MMC and SD cards is for removable storage on cameras, tablets, and phones.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 微控制器实现了指令集并管理闪存，执行闪存翻译层的功能，如本章后续所述。它们已经预格式化为FAT文件系统：SDSC卡使用FAT16，SDHC卡使用FAT32，SDXC卡使用exFAT。NAND闪存芯片的质量以及微控制器上的软件在不同卡片之间差异很大。是否有卡片足够可靠以供深度嵌入使用仍存疑，尤其是使用FAT文件系统时，它容易导致文件损坏。请记住，MMC和SD卡的主要使用场景是作为数码相机、平板电脑和手机的可移动存储。
- en: eMMC
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: eMMC
- en: '**Embedded MMC** or **eMMC** is simply MMC memory that’s been packaged so that
    it can be soldered onto the motherboard using a 4- or 8-bit interface for data
    transfer. However, they are intended to be used as storage for an operating system,
    so the components are capable of performing that task. The chips are usually not
    preformatted with any filesystem.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**嵌入式MMC**或**eMMC**实际上是将MMC存储芯片封装成可以通过4位或8位接口焊接到主板上的存储器。它们通常用作操作系统的存储，因此这些组件能够执行该任务。芯片通常没有预格式化任何文件系统。'
- en: Other types of managed flash
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他类型的管理型闪存
- en: One of the first managed flash technologies was **CompactFlash** (**CF**), which
    uses a subset of the **Personal Computer Memory Card International Association**
    (**PCMCIA**) hardware interface. CF exposes memory through a **Parallel Advanced
    Technology Attachment** (**PATA**) interface and appears to the operating system
    as a standard hard disk. They were common in x86-based single-board computers
    and professional video and camera equipment.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个管理型闪存技术之一是**紧凑型闪存**（**CF**），它使用了**个人计算机内存卡国际协会**（**PCMCIA**）硬件接口的一个子集。CF通过**并行先进技术附件**（**PATA**）接口暴露内存，并且在操作系统中表现为标准硬盘。它们曾广泛应用于基于x86的单板计算机和专业视频及摄影设备中。
- en: One other format that we use every day is the **USB flash drive**. In this case,
    memory is accessed through a USB interface and the controller implements the USB
    mass storage specification as well as the flash translation layer and interface
    to the flash chip or chips. The USB mass storage protocol is based on the SCSI
    disk command set. As with MMC and SD cards, they are usually preformatted with
    a FAT filesystem. Their main use case in embedded systems is to exchange data
    with PCs.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们每天使用的另一种格式是**USB闪存驱动器**。在这种情况下，内存是通过USB接口访问的，控制器实现了USB大容量存储规范以及闪存转换层和与闪存芯片的接口。USB大容量存储协议基于SCSI磁盘命令集。与MMC和SD卡一样，它们通常预格式化为FAT文件系统。它们在嵌入式系统中的主要用例是与PC交换数据。
- en: A recent addition to the list of options for managed flash storage is **Universal
    Flash Storage** (**UFS**). Like eMMC, it is packaged in a chip that is mounted
    on the motherboard. It has a high-speed serial interface and can achieve data
    rates greater than eMMC. It supports an SCSI disk command set.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，作为一种新的管理型闪存存储选项，**通用闪存存储**（**UFS**）被加入到列表中。与eMMC类似，它是一个封装在芯片中的存储单元，安装在主板上。它具有高速串行接口，并且可以实现比eMMC更高的传输速率。它支持SCSI磁盘命令集。
- en: Now that we know what types of flash are available, let’s learn how U-Boot loads
    a kernel image from each of them.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了可用的闪存类型，让我们学习一下U-Boot如何从每种闪存中加载内核镜像。
- en: Accessing flash memory from the bootloader
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从引导加载程序访问闪存内存
- en: In [*Chapter 3*](Chapter_03.xhtml#_idTextAnchor061) I mentioned the need for
    the bootloader to load kernel binaries and other images from various flash devices
    and to perform system maintenance tasks such as erasing and reprogramming flash
    memory. It follows that the bootloader must have the drivers and infrastructure
    needed to support read, erase, and write operations on the type of memory you
    have, whether it be NOR, NAND, or managed. I will use U-Boot in the following
    examples. Other bootloaders follow a similar pattern.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第3章*](Chapter_03.xhtml#_idTextAnchor061)中，我提到了引导加载程序需要从各种闪存设备中加载内核二进制文件和其他镜像，并执行系统维护任务，如擦除和重新编程闪存内存。因此，引导加载程序必须具备支持读取、擦除和写入操作的驱动程序和基础设施，无论你使用的是NOR、NAND还是管理型内存。接下来的示例中我将使用U-Boot。其他引导加载程序遵循类似的模式。
- en: U-Boot and NOR flash
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: U-Boot和NOR闪存
- en: 'U-Boot has drivers for NOR CFI chips in `drivers/mtd` and utilizes various
    `erase` commands to erase memory and `cp.b` to copy data byte by byte onto the
    flash cells. Suppose that you have NOR flash memory mapped from `0x40000000` to
    `0x48000000`, of which 4 MB, starting at `0x40040000`, is a kernel image. Here,
    you would load a new kernel into flash using these U-Boot commands:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: U-Boot在`drivers/mtd`中有NOR CFI芯片的驱动程序，并使用各种`erase`命令擦除内存，通过`cp.b`命令逐字节将数据复制到闪存单元。如果你的NOR闪存内存从`0x40000000`映射到`0x48000000`，其中4MB的内存从`0x40040000`开始用于存储内核镜像。此时，你可以使用这些U-Boot命令将新的内核加载到闪存中：
- en: '[PRE1]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `filesize` variable in the preceding example is set by the `tftpboot` command
    to the size of the file just downloaded.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例中的`filesize`变量由`tftpboot`命令设置为刚刚下载的文件的大小。
- en: U-Boot and NAND flash
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: U-Boot和NAND闪存
- en: For NAND flash, you need a driver for the NAND flash controller on your SoC,
    which you can find in the U-Boot source code in the `drivers/mtd/nand` directory.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于NAND闪存，你需要一个NAND闪存控制器的驱动程序，通常可以在U-Boot源代码中的`drivers/mtd/nand`目录找到。
- en: 'You can use the `nand` command to manage memory using its `erase`, `write`,
    and `read` sub-commands. This example shows a kernel image being loaded into RAM
    at `0x82000000` and then placed into flash starting at the `0x280000` offset:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`nand`命令来管理内存，使用它的`erase`、`write`和`read`子命令。这个例子展示了一个内核镜像被加载到`0x82000000`的RAM中，然后再从`0x280000`偏移位置开始写入到闪存中：
- en: '[PRE2]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: U-Boot can also read files stored in the JFFS2, YAFFS2, and UBIFS filesystems.
    `nand write` will skip blocks that are marked as bad.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: U-Boot还可以读取存储在JFFS2、YAFFS2和UBIFS文件系统中的文件。`nand write`会跳过标记为坏的块。
- en: '**Important note**'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: If the data you’re writing is for a filesystem, make sure that the filesystem
    also skips bad blocks.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在写入的数据属于文件系统，请确保文件系统也会跳过坏块。
- en: U-Boot and MMC, SD, and eMMC
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: U-Boot和MMC、SD以及eMMC
- en: U-Boot has drivers for several MMC controllers in `drivers/mmc`. You can access
    raw data using `mmc read` and `mmc write` at the user interface level, allowing
    you to handle raw kernel and filesystem images.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: U-Boot在`drivers/mmc`中有多个MMC控制器的驱动程序。你可以通过用户界面级别使用`mmc read`和`mmc write`访问原始数据，从而处理原始内核和文件系统镜像。
- en: U-Boot can also read files from the FAT32 and ext4 filesystems on MMC storage.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: U-Boot还可以从MMC存储上的FAT32和ext4文件系统中读取文件。
- en: U-Boot needs drivers to access NOR, NAND, and managed flash. Which driver you
    should use depends on your choice of NOR chip or the flash controller on your
    SoC. Accessing raw NOR and NAND flash from Linux involves additional layers of
    software.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: U-Boot 需要驱动程序来访问 NOR、NAND 和管理闪存。你应使用哪个驱动程序取决于你选择的 NOR 芯片或 SoC 上的闪存控制器。从 Linux
    访问原始 NOR 和 NAND 闪存涉及额外的软件层。
- en: Accessing flash memory from Linux
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 Linux 访问闪存
- en: Raw NOR and NAND flash memory is handled by the **Memory Technology Device**
    (**MTD**) subsystem, which provides you with basic interfaces to read, erase,
    and write blocks of flash memory. In the case of NAND flash, there are also functions
    that handle the OOB area and are used to identify bad blocks.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的 NOR 和 NAND 闪存由**内存技术设备**（**MTD**）子系统处理，该子系统为你提供了基本接口来读取、擦除和写入闪存块。对于 NAND
    闪存，还有处理 OOB 区域的功能，用于识别坏块。
- en: For managed flash, you need drivers to handle a particular hardware interface.
    MMC/SD cards and eMMC use the `mmcblk` driver. While CompactFlash and hard drives
    use the `sd` SCSI disk driver. USB flash drives use the `usb_storage` driver together
    with the `sd` driver.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于管理闪存，你需要驱动程序来处理特定的硬件接口。MMC/SD 卡和 eMMC 使用 `mmcblk` 驱动程序。而 CompactFlash 和硬盘则使用
    `sd` SCSI 磁盘驱动程序。USB 闪存驱动器使用 `usb_storage` 驱动程序，并与 `sd` 驱动程序一起使用。
- en: Memory technology devices
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存技术设备
- en: 'The MTD subsystem was started by David Woodhouse in 1999 and has been extensively
    developed over the intervening years. In this section, I will concentrate on the
    way it handles the two main technologies, NOR and NAND flash.MTD consists of three
    layers: a core set of functions, a set of drivers for various types of chips,
    and user-level drivers that present the flash memory as a character device or
    a block device:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: MTD 子系统由 David Woodhouse 于 1999 年启动，并在这期间得到了广泛的发展。在本节中，我将重点介绍它如何处理两种主要技术，NOR
    和 NAND 闪存。MTD 包含三层：一组核心功能、用于各种类型芯片的驱动程序集合以及以字符设备或块设备形式呈现闪存的用户级驱动程序：
- en: '![Figure 9.3 – MTD layers](img/B18466_09_03.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.3 – MTD 层](img/B18466_09_03.png)'
- en: Figure 9.3 – MTD layers
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 – MTD 层
- en: The chip drivers are at the lowest level and interface with flash chips. Only
    a small number of drivers are needed for NOR flash chips, enough to cover the
    CFI standard and variations, plus a few non-compliant chips, which are now mostly
    obsolete. For NAND flash, you will need a driver for the NAND flash controller
    you are using. This is usually supplied as part of the board support package.
    There are drivers for about 40 of them in the current mainline kernel in the `drivers/mtd/nand`
    directory.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 芯片驱动程序处于最低层，与闪存芯片进行接口。NOR 闪存芯片只需要少数几个驱动程序，足以涵盖 CFI 标准和变种，以及一些不符合标准的芯片，这些芯片现在大多已过时。对于
    NAND 闪存，你需要一个用于你所使用的 NAND 闪存控制器的驱动程序。这个驱动程序通常作为板级支持包的一部分提供。目前主线内核的 `drivers/mtd/nand`
    目录中大约有 40 个相关驱动程序。
- en: MTD partitions
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MTD 分区
- en: 'In most cases, you will want to partition the flash memory into a number of
    areas, for example, to provide space for a bootloader, a kernel image, or a root
    filesystem. In MTD, there are several ways to specify the size and location of
    partitions, with the main ones being as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，你可能希望将闪存分区成多个区域，例如，提供引导加载程序、内核镜像或根文件系统的空间。在 MTD 中，有几种方法可以指定分区的大小和位置，主要的几种方法如下：
- en: Through the kernel command line using `CONFIG_MTD_CMDLINE_PARTS`
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过内核命令行使用 `CONFIG_MTD_CMDLINE_PARTS`
- en: Via the device tree using `CONFIG_MTD_OF_PARTS`
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过设备树使用 `CONFIG_MTD_OF_PARTS`
- en: With a platform-mapping driver
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用平台映射驱动程序
- en: 'In the case of the first option, the kernel command-line option to use is `mtdparts`,
    which is defined within the Linux source code inside `drivers/mtd/parsers/cmdlinepart.c`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个选项中，内核命令行选项为 `mtdparts`，该选项在 Linux 源代码中的 `drivers/mtd/parsers/cmdlinepart.c`
    文件内定义：
- en: '[PRE3]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Perhaps an example will help. Imagine that you have one flash chip of 128 MB
    that is to be divided into five partitions. A typical command line would be this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 或许一个例子能帮助理解。假设你有一个128 MB的闪存芯片，需要将其分成五个分区。一个典型的命令行如下：
- en: '[PRE4]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first element before the colon is `mtd-id`, which identifies the flash chip
    either by number or by the name assigned by the board support package. If there
    is only one chip, as is the case here, it can be left empty. If there is more
    than one chip, the information for each is separated by a semicolon. Then, for
    each chip, there is a comma-separated list of partitions each with a size in bytes,
    KB (`k`) or MB (`m`), and a name in parentheses. The `ro` suffix makes the partition
    read-only to MTD and is often used to prevent accidental overwriting of the bootloader.
    The size of the last partition for the chip may be replaced by a dash (`-`) indicating
    that it should take up all the remaining space.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号前面的第一个元素是`mtd-id`，它通过数字或板支持包分配的名称来标识闪存芯片。如果只有一个芯片，如这里的情况，可以留空。如果有多个芯片，每个芯片的信息由分号分隔。然后，对于每个芯片，有一个逗号分隔的分区列表，每个分区都有以字节、KB（`k`）或MB（`m`）为单位的大小和一个括号中的名称。`ro`后缀使分区对MTD只读，通常用于防止意外覆盖引导加载程序。芯片的最后一个分区的大小可能会被一个破折号（`-`）替代，表示它应该占用剩余的所有空间。
- en: 'You can see a summary of the configuration at runtime by reading `/proc/mtd`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过读取`/proc/mtd`来查看运行时的配置摘要：
- en: '[PRE5]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There is more detailed information for each partition in `/sys/class/mtd`,
    including the erase block size and the page size. It is nicely summarized using
    `mtdinfo`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 每个分区在`/sys/class/mtd`中有更详细的信息，包括擦除块大小和页面大小。可以通过`mtdinfo`来很好的总结：
- en: '[PRE6]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Another way of specifying MTD partitions is through the device tree. Here is
    an example that creates the same partitions as the command-line example:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种指定MTD分区的方法是通过设备树。下面是一个例子，它创建了与命令行示例相同的分区：
- en: '[PRE7]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'A third alternative is to code the partition information as platform data in
    an `mtd_partition` structure as shown in this example taken from `arch/arm/mach-omap2/board-omap3beagle.c`
    (`NAND_BLOCK_SIZE` is defined elsewhere as 128 KB):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种替代方法是将分区信息作为平台数据编码在`mtd_partition`结构中，如下面从`arch/arm/mach-omap2/board-omap3beagle.c`中提取的示例所示（`NAND_BLOCK_SIZE`在其他地方定义为128
    KB）：
- en: '[PRE8]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Platform data is deprecated: you will only find it used in BSPs for old SoCs
    that have not been updated to use a device tree.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 平台数据已被弃用：你只能在未更新以使用设备树的旧SoC的BSP中找到它。
- en: MTD device drivers
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MTD设备驱动
- en: 'The upper level of the MTD subsystem contains a pair of device drivers:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: MTD子系统的上层包含一对设备驱动：
- en: 'A character device with a major number of `90`. There are two device nodes
    per MTD partition number, N: `/dev/mtdN` (minor number=N*2) and `/dev/mtdNro`
    (minor number=(N*2 + 1)). The latter is just a read-only version of the former.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个主设备号为`90`的字符设备。每个MTD分区号N有两个设备节点：`/dev/mtdN`（次设备号=N*2）和`/dev/mtdNro`（次设备号=(N*2
    + 1)）。后者只是前者的只读版本。
- en: A block device with a major number of `31` and a minor number of N. The device
    nodes are in the form `/dev/mtdblockN`.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个主设备号为`31`，次设备号为N的块设备。设备节点形式为`/dev/mtdblockN`。
- en: Let’s look at the character device first since it is the most commonly used
    of the two. Character devices behave much like files on storage in the sense that
    you can easily read text from and write text to them.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 首先来看字符设备，因为它是两者中最常用的。字符设备的行为类似于存储中的文件，你可以轻松地从中读取文本并向其写入文本。
- en: The MTD character device, mtd
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MTD字符设备，mtd
- en: 'The character devices are the most important: they allow you to access the
    underlying flash memory as an array of bytes so that you can read and write (program)
    the flash. It also implements a number of `ioctl` functions that allow you to
    erase blocks and manage the OOB area on NAND chips. The following list has been
    taken from `include/uapi/mtd/mtd-abi.h`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 字符设备是最重要的：它们允许你将底层闪存内存作为字节数组进行访问，从而能够读取和写入（编程）闪存。它还实现了一些`ioctl`函数，允许你擦除块并管理NAND芯片上的OOB区域。以下列表摘自`include/uapi/mtd/mtd-abi.h`：
- en: '`MEMGETINFO`: Gets basic MTD characteristic information.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MEMGETINFO`：获取基本的MTD特性信息。'
- en: '`MEMERASE`: Erases blocks in the MTD partition.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MEMERASE`：擦除MTD分区中的块。'
- en: '`MEMWRITEOOB`: Writes out-of-band data for the page.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MEMWRITEOOB`：写入页面的带外数据。'
- en: '`MEMREADOOB`: Reads out-of-band data for the page.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MEMREADOOB`：读取页面的带外数据。'
- en: '`MEMLOCK`: Locks the chip (if supported).'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MEMLOCK`：锁定芯片（如果支持）。'
- en: '`MEMUNLOCK`: Unlocks the chip (if supported).'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MEMUNLOCK`：解锁芯片（如果支持）。'
- en: '`MEMGETREGIONCOUNT`: Gets the number of erase regions: non-zero if there are
    erase blocks of differing sizes in the partition, which is common for NOR flash
    but rare on NAND.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MEMGETREGIONCOUNT`：获取擦除区域的数量：如果分区中有不同大小的擦除块（这在NOR闪存中很常见，但在NAND中很少见），则返回非零值。'
- en: '`MEMGETREGIONINFO`: Can be used to get the offset, size, and block count of
    each region if `MEMGETREGIONCOUNT` is non-zero.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MEMGETREGIONINFO`：如果`MEMGETREGIONCOUNT`非零，则可用于获取每个区域的偏移量、大小和块数。'
- en: '`MEMGETOOBSEL`: Deprecated.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MEMGETOOBSEL`：已弃用。'
- en: '`MEMGETBADBLOCK`: Gets the bad block flag.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MEMGETBADBLOCK`：获取坏块标志。'
- en: '`MEMSETBADBLOCK`: Sets the bad block flag.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MEMSETBADBLOCK`：设置坏块标志。'
- en: '`OTPSELECT`: Sets OTP (one-time programmable) mode if the chip supports it.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OTPSELECT`：如果芯片支持，则设置OTP（一次性可编程）模式。'
- en: '`OTPGETREGIONCOUNT`: Gets the number of OTP regions.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OTPGETREGIONCOUNT`：获取OTP区域的数量。'
- en: '`OTPGETREGIONINFO`: Gets information about an OTP region.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OTPGETREGIONINFO`：获取OTP区域的信息。'
- en: '`ECCGETLAYOUT`: Deprecated.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ECCGETLAYOUT`：已弃用。'
- en: 'There is a set of utility programs known as `mtd-utils` for manipulating flash
    memory that makes use of these `ioctl` functions. The source can be found at `git://git.infradead.org/mtd-utils.git`
    and is available as a package in The Yocto Project and Buildroot. The essential
    tools are shown in the following list. The package also contains utilities for
    the JFFS2 and UBI/UBIFS filesystems, which I will cover later. For each of these
    tools, the MTD character device is one of the following parameters:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 有一组称为`mtd-utils`的实用程序，用于操作闪存内存，这些实用程序使用这些`ioctl`函数。源代码可以在`git://git.infradead.org/mtd-utils.git`找到，并且在Yocto项目和Buildroot中作为包提供。基本工具在以下列表中列出。该包还包含JFFS2和UBI/UBIFS文件系统的实用程序，我将在后面介绍。对于这些工具中的每一个，MTD字符设备是以下参数之一：
- en: '`flash_erase`: Erases a range of blocks.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flash_erase`：擦除一系列块。'
- en: '`flash_lock`: Locks a range of blocks.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flash_lock`：锁定一系列块。'
- en: '`flash_unlock`: Unlocks a range of blocks.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flash_unlock`：解锁一系列块。'
- en: '`nanddump:` Dumps memory from NAND flash, optionally, including the OOB area.
    Skips bad blocks.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nanddump:` 从NAND闪存转储内存，可以选择性地包括OOB区域。跳过坏块。'
- en: '`nandtest`: Tests and performs diagnostics for NAND flash.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nandtest`：测试并执行NAND闪存的诊断。'
- en: '`nandwrite`: Writes (programs) data from a file into NAND flash, skipping bad
    blocks.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nandwrite`：将数据从文件写入NAND闪存，跳过坏块。'
- en: '**Tip**'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**提示**'
- en: You must always erase flash memory before writing new content to it.
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在写入新内容之前，您必须始终擦除闪存。
- en: '`flash_erase` is the command that does this.'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`flash_erase` 是执行此操作的命令。'
- en: To program NOR flash, you simply copy bytes to the MTD device node using a file
    copy command such as cp.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要编程NOR闪存，您只需使用类似cp的文件复制命令将字节复制到MTD设备节点。
- en: Unfortunately, this doesn’t work with NAND memory as the copy will fail at the
    first bad block. Instead, use `nandwrite`, which skips over any bad blocks. To
    read back NAND memory, you should use `nanddump`, which also skips bad blocks.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这在NAND闪存上不起作用，因为在第一个坏块时复制会失败。相反，使用`nandwrite`，它会跳过任何坏块。要读取NAND闪存，您应该使用`nanddump`，它也会跳过坏块。
- en: The MTD block device, mtdblock
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MTD块设备，mtdblock
- en: The `mtdblock` driver isn’t used often. Its purpose is to present flash memory
    as a block device you can use to format and mount a filesystem. However, it has
    severe limitations because it does not handle bad blocks in NAND flash, it does
    not do wear leveling, and it does not handle the mismatch in size between filesystem
    blocks and flash erase blocks. In other words, it does not have a flash translation
    layer, which is essential for reliable file storage. The only case where the `mtdblock`
    device is useful is for mounting read-only file systems such as SquashFS on top
    of reliable flash memory such as NOR.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`mtdblock` 驱动程序不常使用。它的作用是将闪存呈现为一个块设备，您可以用它来格式化并挂载文件系统。然而，它有严重的限制，因为它不处理NAND闪存中的坏块，不进行磨损均衡，也不处理文件系统块与闪存擦除块之间的大小不匹配。换句话说，它没有闪存转换层，而闪存转换层对可靠的文件存储至关重要。`mtdblock`设备唯一有用的情况是将只读文件系统（如SquashFS）挂载在可靠的闪存上，如NOR闪存。'
- en: '**Tip**'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: If you want a read-only filesystem on NAND flash, you should use the UBI driver
    as described later in this chapter.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要在NAND闪存上使用只读文件系统，应该使用本章后面描述的UBI驱动程序。
- en: Logging kernel oops to MTD
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将内核异常日志记录到MTD
- en: A kernel error or oops is normally logged via the `klogd` and `syslogd` daemons
    to a circular memory buffer or a file. After a reboot, the log will be lost in
    the case of a ring buffer. Even in the case of a file, it may not have been properly
    written to before the system crashed. A more reliable method is to write oops
    and kernel panics to an MTD partition as a circular log buffer. You can enable
    it with `CONFIG_MTD_OOPS` and add `console=ttyMTDN` to the kernel command line
    with `N` being the MTD device number to write the messages to.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 内核错误或崩溃通常通过 `klogd` 和 `syslogd` 守护进程记录到一个循环内存缓冲区或文件中。在重启之后，如果是环形缓冲区，日志会丢失。即便是文件，也可能在系统崩溃之前未能正确写入。更可靠的方法是将崩溃和内核恐慌信息写入一个
    MTD 分区作为一个循环日志缓冲区。你可以通过启用 `CONFIG_MTD_OOPS` 并将 `console=ttyMTDN` 添加到内核命令行来启用它，`N`
    是 MTD 设备编号，用于将信息写入该设备。
- en: Simulating NAND memory
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模拟 NAND 内存
- en: The NAND simulator emulates a NAND chip using system RAM. Its main use is to
    test code that has to be NAND-aware without access to physical NAND memory. The
    ability to simulate bad blocks, bit flips, and other errors allows you to test
    code paths that are difficult to exercise using real flash memory. For more information,
    the best place to look is in the code itself, which provides a comprehensive description
    of the ways you can configure the driver. The code is in `drivers/mtd/nand/nandsim.c`.
    Enable it with the `CONFIG_MTD_NAND_NANDSIM` kernel configuration.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: NAND 模拟器通过系统 RAM 模拟 NAND 芯片。其主要用途是测试必须了解 NAND 的代码，而没有访问物理 NAND 内存的能力。模拟坏块、位翻转和其他错误的功能使你能够测试一些难以通过真实闪存内存进行的代码路径。更多信息可以参考代码本身，它提供了关于如何配置驱动程序的全面描述。代码位于
    `drivers/mtd/nand/nandsim.c`。通过 `CONFIG_MTD_NAND_NANDSIM` 内核配置来启用它。
- en: The MMC block driver
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MMC 块驱动
- en: MMC/SD cards and eMMC chips are accessed using the `mmcblk` block driver. You
    need a host controller to match the MMC adapter you are using, which is part of
    the board support package. The drivers are in the Linux source code under `drivers/mmc/host`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: MMC/SD 卡和 eMMC 芯片使用 `mmcblk` 块驱动访问。你需要一个主机控制器来匹配你所使用的 MMC 适配器，它是板支持包的一部分。驱动程序位于
    Linux 源代码中的 `drivers/mmc/host` 下。
- en: MMC storage is partitioned using a partition table in exactly the same way you
    would for hard disks. That is, by using `fdisk` or a similar utility.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: MMC 存储使用分区表进行分区，方式与硬盘完全相同。也就是说，通过使用 `fdisk` 或类似的工具。
- en: We now know how Linux accesses each type of flash. Next, we will look at the
    problems intrinsic to flash memory and how Linux deals with them, either by way
    of the filesystem or the block device driver.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道了 Linux 如何访问每种类型的闪存。接下来，我们将查看闪存固有的问题以及 Linux 如何通过文件系统或块设备驱动来处理它们。
- en: Filesystems for flash memory
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 闪存内存的文件系统
- en: 'There are several challenges when it comes to making efficient use of flash
    memory for mass storage: the mismatch between the size of an erase block and a
    disk sector, the limited number of erase cycles per erase block, and the need
    for bad block handling on NAND chips. These differences are resolved by a **flash
    translation layer** (**FTL**).'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在有效利用闪存作为大容量存储时面临几个挑战：擦除块的大小与磁盘扇区的大小不匹配、每个擦除块的擦除周期有限以及 NAND 芯片上需要处理坏块。这些差异通过
    **闪存翻译层**（**FTL**）来解决。
- en: Flash translation layers
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 闪存翻译层
- en: 'A flash translation layer has the following features:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 闪存翻译层具有以下特点：
- en: '**Sub allocation**: Filesystems work best with a small allocation unit, traditionally
    a 512-byte sector. This is much smaller than a flash erase block of 128 KB or
    more. Therefore, erase blocks need to be subdivided into smaller units to avoid
    wasting large amounts of space.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**子分配**：文件系统在使用较小的分配单元时表现最佳，传统上是 512 字节的扇区。这个大小远小于一个 128 KB 或更大的闪存擦除块。因此，擦除块需要被细分为更小的单元，以避免浪费大量空间。'
- en: '**Garbage collection**: A consequence of sub allocation is that an erase block
    will contain a mixture of good data and stale data once the filesystem has been
    in use for a while. Since we can only free up whole erase blocks, the only way
    to reclaim this free space is to coalesce the good data into one place and then
    return the now empty erase block to the free list. This is known as garbage collection,
    and it is usually implemented as a background thread.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**垃圾回收**：子分配的一个结果是，一旦文件系统使用了一段时间，擦除块将包含良好的数据和陈旧的数据的混合体。由于我们只能释放整个擦除块，因此回收这些空闲空间的唯一方法是将好的数据合并到一个地方，然后将现在空的擦除块返回到空闲列表中。这就是所谓的垃圾回收，通常它作为一个后台线程实现。'
- en: '**Wear leveling**: There is a limit on the number of erase cycles for each
    block. To maximize the lifespan of a chip, it is important to move data around
    so that each block is erased roughly the same number of times.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**磨损均衡**：每个块的擦除次数是有限制的。为了最大化芯片的使用寿命，重要的是要移动数据，以便每个块的擦除次数大致相同。'
- en: '**Bad block handling**: On NAND flash chips, you must avoid using any block
    marked bad and also mark good blocks as bad if they cannot be erased.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**坏块处理**：在 NAND 闪存芯片上，必须避免使用任何标记为坏的块，如果某个块无法擦除，也需要将其标记为坏块。'
- en: '**Robustness**: Embedded devices may be powered off or reset without warning.
    Any filesystem should be able to cope without corruption, usually by incorporating
    a journal or a log of transactions.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**鲁棒性**：嵌入式设备可能会在没有预警的情况下断电或重启。任何文件系统都应该能够在不损坏的情况下应对，通常通过集成日志或事务日志来实现。'
- en: 'There are several ways to deploy the flash translation layer:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 部署闪存转换层有几种方式：
- en: '**In the filesystem**: As with JFFS2, YAFFS2, and UBIFS.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在文件系统中**：如 JFFS2、YAFFS2 和 UBIFS。'
- en: '**In the block device driver**: The UBI driver, which UBIFS depends on implements
    some aspects of a flash translation layer.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在块设备驱动程序中**：UBIFS 所依赖的 UBI 驱动程序实现了闪存转换层的一些方面。'
- en: '**In the device controller**: As with managed flash devices.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在设备控制器中**：如在管理闪存设备中。'
- en: When the flash translation layer is in the filesystem or the block driver, the
    code is part of the kernel so we can see how it works and expect that it will
    be improved over time. On the other hand, if the FTL is inside a managed flash
    device, it is hidden from view, and we cannot verify whether it works as we want.
    Not only that but putting the FTL into the disk controller means that it misses
    out on useful information that is held at the filesystem layer, like which sectors
    belong to files that have been deleted. The latter problem is solved by adding
    commands that pass this information between the filesystem and the device. I will
    describe how this works later, in the section on the `TRIM` command. However,
    the question of code visibility remains. If you are using managed flash, you just
    have to choose a manufacturer you can trust.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当闪存转换层位于文件系统或块设备驱动程序中时，代码是内核的一部分，因此我们可以看到它的工作原理，并预期它会随着时间的推移得到改进。另一方面，如果 FTL
    在一个管理的闪存设备内部，它就被隐藏起来，我们无法验证它是否按照我们的需求工作。不仅如此，将 FTL 放入磁盘控制器意味着它会错过文件系统层所持有的有用信息，比如哪些扇区属于已删除的文件。后者的问题通过添加命令来解决，这些命令可以在文件系统和设备之间传递这些信息。我将在稍后的
    `TRIM` 命令部分描述它是如何工作的。然而，代码可见性的问题依然存在。如果你使用的是管理闪存，你只能选择一个你信任的制造商。
- en: Now that we know the motivation behind filesystems, let’s look at which filesystems
    are best suited for which types of flash.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了文件系统的动机，接下来看看哪些文件系统最适合哪种类型的闪存。
- en: Filesystems for NOR and NAND flash memory
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NOR 和 NAND 闪存存储器的文件系统
- en: 'To use raw flash chips for mass storage, you have to use a filesystem that
    understands the peculiarities of the underlying technology. There are three such
    filesystems:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用原始闪存芯片进行大规模存储，必须使用能够理解底层技术特性的文件系统。有三种这样的文件系统：
- en: '**JFFS2** (**Journaling Flash File System 2**): This was the first flash filesystem
    for Linux and is still in use today. It works for NOR and NAND memory but is notoriously
    slow during mount.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JFFS2**（**日志闪存文件系统 2**）：这是第一个用于 Linux 的闪存文件系统，至今仍在使用。它适用于 NOR 和 NAND 存储器，但在挂载时速度较慢。'
- en: '**YAFFS2** (**Yet Another Flash File System 2**): This is like JFFS2 but specifically
    for NAND flash memory. It was adopted by Google as the preferred raw flash filesystem
    on Android devices.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**YAFFS2**（**另一个闪存文件系统 2**）：这类似于 JFFS2，但专门用于 NAND 闪存存储器。它被 Google 作为 Android
    设备上首选的原始闪存文件系统。'
- en: '**UBIFS** (**Unsorted Block Image File System**): This works in conjunction
    with the UBI block driver to create a reliable flash filesystem. It works well
    with both NOR and NAND memory. Since it generally offers better performance than
    JFFS2 or YAFFS2 it should be the preferred solution for new designs.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UBIFS**（**无序块映像文件系统**）：它与 UBI 块驱动程序配合使用，创建一个可靠的闪存文件系统。它适用于 NOR 和 NAND 存储器。由于它通常比
    JFFS2 或 YAFFS2 提供更好的性能，因此应该是新设计中的首选解决方案。'
- en: All of these use MTD as the common interface to flash memory.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都使用 MTD 作为与闪存存储的公共接口。
- en: JFFS2
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JFFS2
- en: The **Journaling Flash File System** had its beginnings in the software for
    the Axis 2100 network camera back in 1999\. For many years, it was the only flash
    filesystem for Linux and has been deployed on many different types of devices.
    Today, it is not the best choice, but I will cover it first because it shows the
    beginning of the evolutionary path.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**日志闪存文件系统**起源于1999年为Axis 2100网络摄像头开发的软件。多年来，它是Linux上唯一的闪存文件系统，并已在许多不同类型的设备上部署。今天，它已不再是最佳选择，但我会首先介绍它，因为它展示了演变路径的开始。'
- en: JFFS2 is a log-structured filesystem that uses MTD to access flash memory. In
    a log-structured filesystem, changes are written sequentially as nodes to flash
    memory. A node may contain changes to a directory, such as the names of files
    created and deleted, or it may contain changes to file data. After a while, a
    node may be superseded by information contained in subsequent nodes and become
    an obsolete node. Both NOR and NAND flash are organized as erase blocks. Erasing
    a block sets all its bits to 1.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: JFFS2是一个日志结构文件系统，使用MTD来访问闪存。在日志结构文件系统中，变更按顺序写入闪存作为节点。一个节点可能包含目录的变更，比如创建和删除的文件名，或者包含文件数据的变更。经过一段时间后，节点可能会被后续节点中的信息所替代，从而成为过时节点。NOR和NAND闪存都被组织为擦除块。擦除一个块会将其所有位设置为1。
- en: 'JFFS2 categorizes erase blocks into three types:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: JFFS2将擦除块分类为三种类型：
- en: '**Free**: Contains no nodes at all.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**空闲的**：完全不包含任何节点。'
- en: '**Clean**: Only contains valid nodes.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**干净的**：只包含有效节点。'
- en: '**Dirty**: Contains at least one obsolete node.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**脏的**：至少包含一个过时的节点。'
- en: At any one time, there is one block receiving updates, which is called the open
    block. If power is lost or the system is reset, the only data that can be lost
    is the last write to the open block. In addition, nodes are compressed as they
    are written, increasing the effective storage capacity of the flash chip, which
    is important if you are using expensive NOR flash memory.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何时候，只有一个块正在接收更新，这个块被称为开放块。如果电源丢失或系统重置，唯一可能丢失的数据是对开放块的最后一次写入。此外，节点在写入时会被压缩，从而增加闪存芯片的有效存储容量，如果你使用的是昂贵的NOR闪存内存，这一点非常重要。
- en: When the number of free blocks falls below a certain threshold, a garbage collector
    kernel thread is started, which scans for dirty blocks, copies the valid nodes
    into the open block, and then frees up the dirty block.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当空闲块的数量降到某个阈值以下时，会启动一个垃圾回收内核线程，它会扫描脏块，将有效节点复制到开放块中，然后释放脏块。
- en: At the same time, the garbage collector provides a crude form of wear leveling
    because it cycles valid data from one block to another. The way that the open
    block is chosen means that each block is erased roughly the same number of times
    as long as it contains data that changes from time to time. Sometimes, a clean
    block is chosen for garbage collection to make sure that blocks containing static
    data that is seldom written are also wear-leveled.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，垃圾回收器提供了一种粗略的磨损均衡形式，因为它将有效数据从一个块循环到另一个块。开放块的选择方式意味着，只要一个块包含会时常变化的数据，它就会被大致擦除相同次数。有时，垃圾回收会选择一个干净的块，以确保那些包含静态数据且很少写入的块也能实现磨损均衡。
- en: 'JFFS2 filesystems have a write-through cache, meaning that writes are written
    to the flash memory synchronously as if they have been mounted with the `-o` sync
    option. While improving reliability, this approach increases the time to write
    data. There is a further problem with small writes: if the length of a write is
    comparable to the size of the node header (40 bytes), the overhead becomes high.
    A well-known corner case is log files like those produced by `syslogd`.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: JFFS2文件系统具有写透缓存，这意味着写入操作会同步地写入闪存，好像它们已经使用`-o` sync选项挂载。虽然这种方式提高了可靠性，但也增加了写入数据的时间。小写入存在一个额外问题：如果写入的长度与节点头部的大小（40字节）相当，开销会变得很高。一个著名的极限情况是类似`syslogd`产生的日志文件。
- en: Summary nodes
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 汇总节点
- en: 'There is one overriding disadvantage to JFFS2: since there is no on-chip index,
    the directory’s structure has to be deduced at mount time by reading the log from
    start to finish. At the end of the scan, you have a complete picture of the directory
    structure of the valid nodes, but the mount time taken is proportional to the
    size of the partition. It is not uncommon to see mount times of the order of one
    second per megabyte, leading to total mount times of tens or hundreds of seconds.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: JFFS2有一个显著的缺点：由于没有片上索引，目录结构必须在挂载时通过从头到尾读取日志来推导出来。在扫描结束时，你可以得到一个完整的有效节点目录结构的图像，但挂载时间与分区大小成正比。通常可以看到每兆字节挂载时间大约为一秒，这会导致总挂载时间达到几十秒或几百秒。
- en: Summary nodes became an option in Linux 2.6.15 for reducing the time to scan
    during a mount. A summary node is written at the end of the open erase block,
    just before it is closed. The summary node contains all of the information needed
    for the mount-time scan, thereby reducing the amount of data to process during
    the scan. Summary nodes can reduce mount times by a factor of between two and
    five at the expense of an overhead of about 5% of the storage space. They are
    enabled with the `CONFIG_JFFS2_SUMMARY` kernel configuration.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 总结节点在Linux 2.6.15中成为一个可选项，用于减少挂载时扫描的时间。总结节点在打开的擦除块末尾写入，在它被关闭之前。总结节点包含挂载时扫描所需的所有信息，从而减少扫描时需要处理的数据量。总结节点可以通过牺牲约5%的存储空间，减少挂载时间的2到5倍。它们通过`CONFIG_JFFS2_SUMMARY`内核配置来启用。
- en: Clean markers
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 清洁标记
- en: An erased block with all its bits set to 1 is indistinguishable from a block
    that has been written with 1s, but the latter has not had its memory cells refreshed
    and cannot be programmed again until it is erased. JFFS2 uses a mechanism called
    **clean markers** to distinguish between these two situations. After a successful
    block erase, a clean marker is written either to the beginning of the block or
    to the OOB area of the first page of the block. If the clean marker exists, then
    it must be a clean block.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 一个已擦除的块，所有位都设置为1，无法与一个已经写入1的块区分开来，但后者的内存单元没有刷新，直到它被擦除后才能再次编程。JFFS2使用一种名为**清洁标记**的机制来区分这两种情况。在成功擦除块后，清洁标记会被写入块的起始位置或块的第一页的OOB区域。如果存在清洁标记，则该块必须是清洁块。
- en: Creating a JFFS2 filesystem
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建JFFS2文件系统
- en: 'Creating an empty JFFS2 filesystem at runtime is as simple as erasing an MTD
    partition with clean markers and then mounting it. There is no formatting step
    because a blank JFFS2 filesystem consists entirely of free blocks. For example,
    to format MTD partition 6, you would enter these commands on the device:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时创建一个空的JFFS2文件系统与擦除带有清洁标记的MTD分区，然后挂载它一样简单。没有格式化步骤，因为空的JFFS2文件系统完全由空闲块组成。例如，要格式化MTD分区6，你可以在设备上输入以下命令：
- en: '[PRE9]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `-j` option to `flash_erase` adds the clean markers and mounting with the
    `jffs2` type presents the partition as an empty filesystem. Note that the device
    to be mounted is given as `mtd6`, not `/dev/mtd6`. Alternatively, you can give
    the block the `/dev/mtdblock6` device node. This is just a peculiarity of JFFS2\.
    Once mounted, you can treat it like any other filesystem.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`-j`选项添加清洁标记，挂载时使用`jffs2`类型将分区呈现为空文件系统。请注意，挂载的设备应指定为`mtd6`，而不是`/dev/mtd6`。或者，你可以使用`/dev/mtdblock6`设备节点。这只是JFFS2的一个特殊性。一旦挂载，你就可以像使用其他文件系统一样使用它。'
- en: You can create a filesystem image directly from the staging area of your development
    system using `mkfs.jffs2` to write out the files in JFFS2 format and `sumtool`
    to add the summary nodes. Both of these are part of the `mtd-utils` package.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以直接从开发系统的暂存区创建文件系统镜像，使用`mkfs.jffs2`将文件写出为JFFS2格式，并使用`sumtool`添加总结节点。这两者都属于`mtd-utils`包的一部分。
- en: 'As an example, to create an image of the files in `rootfs` for a NAND flash
    device with an erase block size of 128 KB (`0x20000`) and with summary nodes,
    you would use these two commands:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要创建一个包含`rootfs`文件的镜像，目标是一个擦除块大小为128 KB（`0x20000`）并带有总结节点的NAND闪存设备，你可以使用以下两个命令：
- en: '[PRE10]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `-p` option adds padding at the end of the image file to make it a whole
    number of erase blocks. The `-n` option suppresses the creation of clean markers
    in the image, which is normal for NAND devices as the clean marker is in the OOB
    area. For NOR devices, you would leave out the `-n` option. You can use a device
    table with `mkfs.jffs2` to set the permissions and the ownership of files by adding
    `-D <device table>`. Of course, Buildroot and The Yocto Project will do all this
    for you.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`-p` 选项会在镜像文件的末尾添加填充，以使其成为一个完整的擦除块数量。`-n` 选项会抑制在镜像中创建干净标记，这对于 NAND 设备来说是正常的，因为干净标记位于
    OOB 区域。对于 NOR 设备，则可以省略 `-n` 选项。你可以使用设备表和 `mkfs.jffs2` 来设置文件的权限和所有权，方法是添加 `-D <device
    table>`。当然，Buildroot 和 Yocto Project 会为你自动完成这一切。'
- en: 'You can program the image into flash memory from your bootloader. For example,
    if you have loaded a filesystem image into RAM at address `0x82000000` and you
    want to load it into a flash partition that begins at `0x163000` bytes from the
    start of the flash chip and is `0x7a9d000` bytes long, the U-Boot commands for
    this would be:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从引导加载程序将镜像写入闪存。例如，如果你已将一个文件系统镜像加载到地址 `0x82000000` 的 RAM 中，并且想将其加载到从闪存芯片起始位置
    `0x163000` 字节开始的闪存分区，该分区长度为 `0x7a9d000` 字节，你可以使用以下 U-Boot 命令：
- en: '[PRE11]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can do the same thing from Linux using the `mtd` driver like this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过 Linux 使用 `mtd` 驱动程序来执行相同的操作，如下所示：
- en: '[PRE12]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To boot with a JFFS2 root filesystem, you need to pass the `mtdblock` device
    on the kernel command line for the partition and a `rootfstype` since JFFS2 cannot
    be auto-detected:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 JFFS2 根文件系统启动，你需要在内核命令行中传递 `mtdblock` 设备的分区信息，并且指定 `rootfstype`，因为 JFFS2
    不能自动检测：
- en: '[PRE13]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Shortly after JFFS2 was introduced, another log-structured filesystem appeared.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JFFS2 引入后不久，另一种日志结构文件系统出现了。
- en: YAFFS2
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: YAFFS2
- en: The YAFFS filesystem was written by Charles Manning starting in 2001 to handle
    NAND flash chips at a time when JFFS2 did not. Subsequent changes to handle larger
    (2 KB) page sizes resulted in YAFFS2\. The website for YAFFS is [https://yaffs.net/](https://yaffs.net/).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: YAFFS 文件系统由 Charles Manning 于 2001 年编写，用于处理当时 JFFS2 无法处理的 NAND 闪存芯片。之后，为了处理更大（2
    KB）页面大小的变化，开发出了 YAFFS2。YAFFS 的官方网站是 [https://yaffs.net/](https://yaffs.net/)。
- en: YAFFS is also a log-structured filesystem that follows the same design principles
    as JFFS2\. The different design decisions mean that it has a faster mount-time
    scan, simpler and faster garbage collection, and no compression, which speeds
    up reads and writes at the expense of less efficient use of storage.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: YAFFS 也是一个日志结构文件系统，遵循与 JFFS2 相同的设计原则。不同的设计决策意味着它具有更快的挂载时间扫描、更简单且更快速的垃圾回收，并且没有压缩，这提高了读写速度，但牺牲了存储利用效率。
- en: 'YAFFS is not limited to Linux. It has been ported to a wide range of operating
    systems. It has a dual license: GPLv2 (compatible with Linux) and a commercial
    license for other operating systems. Unfortunately, the YAFFS code has never been
    merged into mainline Linux so you will have to patch your kernel.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: YAFFS 并不限于 Linux，它已经移植到多种操作系统。它有双重许可：GPLv2（与 Linux 兼容）和适用于其他操作系统的商业许可证。不幸的是，YAFFS
    代码从未合并到主线 Linux 中，因此你需要为内核打补丁。
- en: 'To get YAFFS2 and patch a kernel, do the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取 YAFFS2 并为内核打补丁，请执行以下操作：
- en: '[PRE14]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Then, you can configure the kernel with `CONFIG_YAFFS_YAFFS2`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以通过 `CONFIG_YAFFS_YAFFS2` 配置内核。
- en: Creating a YAFFS2 filesystem
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 YAFFS2 文件系统
- en: 'As with JFFS2, to create a YAFFS2 filesystem at runtime, you only need to erase
    the partition and mount it, but note that in this case, you do not enable clean
    markers:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 与 JFFS2 一样，要在运行时创建 YAFFS2 文件系统，你只需要擦除分区并挂载它，但请注意，在这种情况下，你不会启用干净标记：
- en: '[PRE15]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To create a filesystem image, the simplest thing to do is use the `mkyaffs2`
    tool from [https://code.google.com/archive/p/yaffs2utils/](https://code.google.com/archive/p/yaffs2utils/):'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建文件系统镜像，最简单的方式是使用 [https://code.google.com/archive/p/yaffs2utils/](https://code.google.com/archive/p/yaffs2utils/)
    中的 `mkyaffs2` 工具：
- en: '[PRE16]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, `-c` is the page size and `-s` is the OOB size. There is a tool named
    `mkyaffs2image` that is part of the YAFFS code, but it has a couple of drawbacks.
    Firstly, the page and OOB size are hard coded in the source, so you will have
    to edit and recompile if you have memory that does not match the defaults of 2,048
    and 64\. Secondly, the OOB layout is incompatible with MTD, which uses the first
    two bytes as a bad block marker, whereas `mkyaffs2image` uses those bytes to store
    part of the YAFFS metadata.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`-c`是页大小，`-s`是OOB大小。有一个名为`mkyaffs2image`的工具，它是YAFFS代码的一部分，但有一些缺点。首先，页大小和OOB大小是硬编码在源代码中的，因此如果你的内存与默认的2,048和64不匹配，你将需要编辑并重新编译。其次，OOB布局与MTD不兼容，MTD使用前两个字节作为坏块标记，而`mkyaffs2image`则用这些字节存储部分YAFFS元数据。
- en: 'To copy the image to the MTD partition from a Linux shell prompt on the target,
    follow these steps:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 要从目标设备上的Linux shell提示符将映像复制到MTD分区，请按照以下步骤操作：
- en: '[PRE17]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To boot with a YAFFS2 root filesystem, add the following to the kernel command
    line:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用YAFFS2根文件系统启动，请在内核命令行中添加以下内容：
- en: '[PRE18]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: While we are on the topic of filesystems for raw NOR and NAND flash, let’s look
    at one of the more modern options. This filesystem runs on top of the UBI driver.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论原始NOR和NAND闪存的文件系统时，让我们来看一下其中一种更现代的选项。这个文件系统运行在UBI驱动程序之上。
- en: UBI and UBIFS
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UBI和UBIFS
- en: The **Unsorted Block Image** (**UBI**) driver is a volume manager for flash
    memory that takes care of bad block handling and wear leveling. It was implemented
    by Artem Bityutskiy and first appeared in Linux 2.6.22\. In parallel with that,
    engineers at Nokia were working on a filesystem that would take advantage of the
    features of UBI, which they called UBIFS. It appeared in Linux 2.6.27\. Splitting
    the flash translation layer in this way makes the code more modular and also allows
    other filesystems to take advantage of the UBI driver, as we shall see later on.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**未排序块映像**（**UBI**）驱动程序是一个闪存卷管理器，负责坏块处理和磨损均衡。它由Artem Bityutskiy实现，并首次出现在Linux
    2.6.22中。与此同时，诺基亚的工程师们正在开发一个文件系统，旨在利用UBI的特性，称之为UBIFS。它出现在Linux 2.6.27中。通过这种方式分离闪存转换层，使得代码更加模块化，也允许其他文件系统利用UBI驱动程序，正如我们稍后将看到的。'
- en: UBI
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UBI
- en: UBI provides an idealized, reliable view of a flash chip by mapping **physical
    erase blocks** (**PEBs**) to **logical erase blocks** (**LEBs**). Bad blocks are
    not mapped to LEBs and so are never used. If a block cannot be erased, it is marked
    as bad and dropped from the mapping. UBI keeps a count of the number of times
    each PEB has been erased in the header of the LEB and then changes the mapping
    to ensure that each PEB is erased the same number of times.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: UBI通过将**物理擦除块**（**PEB**）映射到**逻辑擦除块**（**LEB**），提供了一个理想化、可靠的闪存芯片视图。坏块不会映射到LEB，因此永远不会使用。如果一个块无法擦除，它将被标记为坏块，并从映射中删除。UBI在LEB的头部记录每个PEB被擦除的次数，然后更改映射，确保每个PEB被擦除相同的次数。
- en: 'UBI accesses the flash memory through the MTD layer. As an extra feature, it
    can divide an MTD partition into several UBI volumes, which improves wear leveling
    as follows. Imagine that you have two filesystems: one containing fairly static
    data, such as a root filesystem, and the other containing data that is constantly
    changing.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: UBI通过MTD层访问闪存。作为额外功能，它可以将MTD分区划分为多个UBI卷，从而改善磨损均衡。假设你有两个文件系统：一个包含相对静态的数据，如根文件系统，另一个包含不断变化的数据。
- en: 'If they are stored in separate MTD partitions, the wear leveling only impacts
    the second one. Whereas if you choose to store them in two UBI volumes in a single
    MTD partition, the wear leveling takes place over both areas of the storage, and
    the lifetime of the flash memory is increased. The following diagram illustrates
    this situation:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它们存储在单独的MTD分区中，磨损均衡只会影响第二个分区。而如果选择将它们存储在同一个MTD分区中的两个UBI卷中，磨损均衡将覆盖存储的两个区域，从而延长闪存的使用寿命。下图展示了这种情况：
- en: '![Figure 9.4 – UBI volumes](img/B18466_09_04.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![图9.4 – UBI卷](img/B18466_09_04.png)'
- en: Figure 9.4 – UBI volumes
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 – UBI卷
- en: 'In this way, UBI fulfills two of the requirements of a flash translation layer:
    wear leveling and bad-block handling.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，UBI实现了闪存转换层的两个要求：磨损均衡和坏块处理。
- en: 'To prepare an MTD partition for UBI, you don’t use `flash_erase` as with JFFS2
    and YAFFS2\. Instead, you use the `ubiformat` utility, which preserves the erase
    counts that are stored in the PEB headers. `ubiformat` needs to know the minimum
    unit of I/O, which for most NAND flash chips is the page size, but some chips
    allow reading and writing in subpages that are a half or a quarter of the page
    size. Consult the chip data sheet for details and, if in doubt, use the page size.
    This example prepares `mtd6` using a page size of 2048 bytes:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备一个 MTD 分区用于 UBI，你不需要像在 JFFS2 和 YAFFS2 中那样使用 `flash_erase`。相反，你需要使用 `ubiformat`
    工具，它会保留存储在 PEB 头部的擦除计数。`ubiformat` 需要知道 I/O 的最小单位，对于大多数 NAND 闪存芯片来说是页面大小，但一些芯片允许在子页（页面的一半或四分之一）中读取和写入。有关详细信息，请参考芯片的数据手册，如果不确定，请使用页面大小。此示例使用
    2048 字节的页面大小准备 `mtd6`：
- en: '[PRE19]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, you can use the `ubiattach` command to load the UBI driver on an MTD
    partition that has been prepared in this way:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用 `ubiattach` 命令来加载 UBI 驱动程序到一个已经按照这种方式准备好的 MTD 分区上：
- en: '[PRE20]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This creates the `/dev/ubi0` device node through which you can access the UBI
    volumes. You can use `ubiattach` on several MTD partitions, in which case they
    can be accessed through `/dev/ubi1`, `/dev/ubi2`, and so on. Note that since each
    LEB has a header containing the meta information used by UBI, the LEB is smaller
    than the PEB by two pages. For example, a chip with a PEB size of 128 KB and 2
    KB pages would have an LEB of 124 KB. This is important information that you will
    need when creating a UBIFS image.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这会创建 `/dev/ubi0` 设备节点，你可以通过它访问 UBI 卷。你可以在多个 MTD 分区上使用 `ubiattach`，这样它们可以通过 `/dev/ubi1`、`/dev/ubi2`
    等进行访问。请注意，由于每个 LEB 都有一个包含 UBI 使用的元信息的头部，因此 LEB 比 PEB 小两个页面。例如，一个 PEB 大小为 128 KB，页面大小为
    2 KB 的芯片，其 LEB 大小为 124 KB。这是创建 UBIFS 映像时需要了解的重要信息。
- en: The PEB-to-LEB mapping is loaded into memory during the attach phase, a process
    that takes time proportional to the number of PEBs, typically a few seconds. A
    new feature was added in Linux 3.7, called the UBI fastmap, which checkpoints
    the mapping to flash from time to time and so reduces the attach time. The kernel
    configuration option for this is `CONFIG_MTD_UBI_FASTMAP`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: PEB 到 LEB 的映射会在附加阶段加载到内存中，这个过程的时间与 PEB 的数量成正比，通常需要几秒钟。在 Linux 3.7 中添加了一个新功能，叫做
    UBI 快速映射，它会定期将映射信息检查点保存到闪存中，从而减少了附加时间。与此相关的内核配置选项是 `CONFIG_MTD_UBI_FASTMAP`。
- en: 'The first time you attach to an MTD partition after a `ubiformat`, there will
    be no volumes. You can create volumes using `ubimkvol`. For example, suppose you
    have a 128 MB MTD partition, and you want to split it into two volumes. The first
    is to be 32 MB in size and the second will take up the remaining space:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次附加到一个经过 `ubiformat` 格式化的 MTD 分区时，将没有卷。你可以使用 `ubimkvol` 创建卷。例如，假设你有一个 128
    MB 的 MTD 分区，想将其分割为两个卷。第一个卷的大小为 32 MB，第二个卷将占用剩余的空间：
- en: '[PRE21]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, you have a device with two nodes: `/dev/ubi0_0` and `/dev/ubi0_1`. You
    can confirm this using `ubinfo`:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你有一个包含两个节点的设备：`/dev/ubi0_0` 和 `/dev/ubi0_1`。你可以使用 `ubinfo` 来确认这一点：
- en: '[PRE22]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: At this point, you have a 128 MB MTD partition containing two UBI volumes of
    sizes 32 MB and 88.8 MB. The total storage available is 32 MB plus 88.8 MB, which
    equals 120.8 MB. The remaining space, 7.2 MB, is taken up by the UBI headers at
    the start of each PEB, and space is reserved for mapping out blocks that go bad
    during the lifetime of the chip.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 到这个时候，你有一个 128 MB 的 MTD 分区，包含两个 UBI 卷，大小分别为 32 MB 和 88.8 MB。总可用存储空间为 32 MB 加
    88.8 MB，总计为 120.8 MB。剩余空间 7.2 MB 被 UBI 头部占用，这些头部位于每个 PEB 的开头，同时空间还为在芯片生命周期中可能损坏的块进行预留。
- en: UBIFS
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UBIFS
- en: UBIFS uses a UBI volume to create a robust filesystem. It adds sub-allocation
    and garbage collection to create a complete flash translation layer. Unlike JFFS2
    and YAFFS2, it stores index information on-chip, so mounting is fast, although
    don’t forget that attaching the UBI volume beforehand may take a significant amount
    of time. It also allows write-back caching as in a normal disk filesystem, so
    writes are much faster, but data that has not been flushed to flash memory is
    lost in the event of power down. You can resolve this problem by making careful
    use of the `fsync(2)` and `fdatasync(2)` functions to force a flush of file data
    at crucial points.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: UBIFS 使用 UBI 卷来创建一个强大的文件系统。它通过添加子分配和垃圾回收功能，构建了一个完整的闪存转换层。与 JFFS2 和 YAFFS2 不同，它将索引信息存储在芯片上，因此挂载速度非常快，尽管不要忘记，事先附加
    UBI 卷可能会耗费相当多的时间。它还允许像普通磁盘文件系统一样进行写回缓存，这样写入速度会更快，但在断电的情况下，未刷新到闪存的数据将会丢失。你可以通过小心使用
    `fsync(2)` 和 `fdatasync(2)` 函数，在关键时刻强制刷新文件数据来解决这个问题。
- en: UBIFS has a journal for fast recovery in the event of power down. The minimum
    size of the journal is 4 MB so UBIFS is not suitable for very small flash devices.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: UBIFS 具有日志功能，可以在断电时快速恢复。日志的最小大小为 4 MB，因此 UBIFS 不适用于非常小的闪存设备。
- en: 'Once you have created the UBI volumes, you can mount them using the device
    node for the volume, such as `/dev/ubi0_0`, or by using the device node for the
    whole partition plus the volume name, as shown here:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了 UBI 卷后，你可以使用卷的设备节点来挂载它们，例如 `/dev/ubi0_0`，或通过使用整个分区的设备节点加上卷名称来挂载，如下所示：
- en: '[PRE23]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Creating a filesystem image for UBIFS is a two-stage process. First, you create
    a UBIFS image using `mkfs.ubifs`, and then embed it into a UBI volume using `ubinize`.
    For the first stage, `mkfs.ubifs` needs to be informed of the page size with `-m`,
    the size of the UBI LEB with `-e`, and the maximum number of erase blocks in the
    volume with `-c`. If the first volume is 32 MB and an erase block is 128 KB, then
    the number of erase blocks is 256\. So, to take the contents of the `rootfs` directory
    and create a UBIFS image named `rootfs.ubi`, type the following:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 为 UBIFS 创建文件系统镜像是一个两阶段的过程。首先，使用 `mkfs.ubifs` 创建一个 UBIFS 镜像，然后使用 `ubinize` 将其嵌入到
    UBI 卷中。在第一阶段，`mkfs.ubifs` 需要通过 `-m` 参数告知页面大小，通过 `-e` 参数指定 UBI LEB 的大小，通过 `-c`
    参数指定卷中最大擦除块的数量。如果第一个卷为 32 MB，且擦除块大小为 128 KB，那么擦除块的数量为 256。因此，要将 `rootfs` 目录的内容创建为名为
    `rootfs.ubi` 的 UBIFS 镜像，可以输入以下命令：
- en: '[PRE24]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The second stage requires you to create a configuration file for `ubinize`
    that describes the characteristics of each volume in the image. The help page
    (`ubinize -h`) provides details about the format. This example creates two volumes
    (`vol_1` and `vol_2`):'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 第二阶段要求你为 `ubinize` 创建一个配置文件，描述镜像中每个卷的特性。帮助页面（`ubinize -h`）提供了关于格式的详细信息。此示例创建了两个卷（`vol_1`
    和 `vol_2`）：
- en: '[PRE25]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The second volume has an auto-resize flag and so will expand to fill the remaining
    space on the MTD partition. Only one volume can have this flag. From this information,
    `ubinize` will create an image file named by the `-o` parameter, with the PEB
    size as `-p`, the page size as `-m`, and the sub-page size as `-s`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个卷具有自动调整大小的标志，因此会扩展以填满 MTD 分区上的剩余空间。只有一个卷可以拥有这个标志。从这些信息中，`ubinize` 将创建一个由
    `-o` 参数指定的镜像文件，PEB 大小为 `-p`，页面大小为 `-m`，子页面大小为 `-s`：
- en: '[PRE26]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To install this image on the target, you would enter these commands on the
    target:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此镜像安装到目标设备上，你可以在目标设备上输入以下命令：
- en: '[PRE27]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If you want to boot with a UBIFS root filesystem, you will need to provide
    these kernel command-line parameters:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用 UBIFS 根文件系统启动，你需要提供以下内核命令行参数：
- en: '[PRE28]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: UBIFS completes our survey of filesystems for raw NOR and NAND flash memory.
    Next, we’ll look at filesystems for managed flash.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: UBIFS 完成了对原始 NOR 和 NAND 闪存文件系统的调查。接下来，我们将研究托管闪存的文件系统。
- en: Filesystems for managed flash
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 托管闪存的文件系统
- en: As the trend toward managed flash technologies continues, particularly eMMC,
    we need to consider how to use them effectively. While they appear to have the
    same characteristics as hard disk drives, the underlying NAND flash chips have
    the limitations of large erase blocks with limited erase cycles and bad block
    handling. We also need robustness in the event of power loss.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 随着托管闪存技术的趋势不断发展，特别是 eMMC，我们需要考虑如何有效地使用它们。虽然它们看起来具有与硬盘驱动器相同的特性，但底层的 NAND 闪存芯片存在大擦除块、擦除周期有限和坏块处理等限制。我们还需要在断电情况下确保系统的鲁棒性。
- en: It is possible to use any of the normal disk filesystems, but we should try
    to choose one that reduces disk writes and has a fast restart after an unscheduled
    shutdown.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用任何常见的磁盘文件系统，但我们应该尝试选择一个能够减少磁盘写入并且在非计划性关机后能够快速重启的文件系统。
- en: Flashbench
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Flashbench
- en: To make optimum use of the underlying flash memory, you need to know the erase
    block size and page size. Manufacturers do not publish these numbers as a rule,
    but it is possible to deduce them by observing the behavior of the chip or card.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用底层的闪存存储器，你需要知道擦除块大小和页面大小。通常，制造商不会公布这些数字，但通过观察芯片或卡的行为，可以推测出这些参数。
- en: Flashbench is one such tool. It was initially written by Arnd Bergman as described
    in the LWN article available at [https://lwn.net/Articles/428584](https://lwn.net/Articles/428584).
    You can get the code from [https://github.com/bradfa/flashbench](https://github.com/bradfa/flashbench).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: Flashbench 就是这样一个工具。最初由 Arnd Bergman 编写，详细信息可以参阅 [https://lwn.net/Articles/428584](https://lwn.net/Articles/428584)
    中的 LWN 文章。你可以从 [https://github.com/bradfa/flashbench](https://github.com/bradfa/flashbench)
    获取代码。
- en: 'Here is a typical run on a SanDisk 4 GB SDHC card:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在 SanDisk 4 GB SDHC 卡上的典型运行：
- en: '[PRE29]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this case, `flashbench` reads blocks of 1,024 bytes just before and just
    after various power-of-two boundaries. As you cross a page or erase a block boundary,
    the reads after the boundary take longer. The rightmost column shows the difference
    and is the one that is most interesting. Reading from the bottom, there is a big
    jump at 4 KB, which is the most likely size of a page. There is a second jump
    from 52.4µs to 349µs at 8 KB. This is fairly common and indicates that the card
    can use multi-plane access to read two 4 KB pages at the same time. Beyond that,
    the differences are less well marked, but there is a clear jump from 485µs to
    805µs at 512 KB, which is probably the erase block’s size. Given that the card
    being tested is quite old, these are the sort of numbers you would expect.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`flashbench` 会在不同的二次幂边界前后读取 1,024 字节的块。当你跨越一个页面或擦除一个块边界时，边界后的读取时间会更长。最右边的列显示的是差异，也是最值得关注的地方。从底部开始，在
    4 KB 时有一个大跳跃，这很可能是一个页面的大小。8 KB 处有第二次跳跃，从 52.4 微秒跳到 349 微秒。这是相当常见的，表明卡片可以使用多平面访问同时读取两个
    4 KB 页面。之后，差异不再那么明显，但在 512 KB 处，差异从 485 微秒跳到 805 微秒，这可能是擦除块的大小。考虑到所测试的卡片相当陈旧，这些数字是可以预期的。
- en: Discard and TRIM
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 丢弃和 TRIM
- en: Usually, when you delete a file, only the modified directory node is written
    to storage while the sectors containing the file’s contents remain unchanged.
    When the flash translation layer is in the disk controller, as with managed flash,
    it does not know that this group of disk sectors no longer contains useful data
    and so it ends up copying stale data.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当你删除一个文件时，只有修改后的目录节点会被写入存储，而包含文件内容的扇区保持不变。当闪存翻译层位于磁盘控制器中时，像受控闪存一样，它并不知道这组磁盘扇区不再包含有效数据，因此它最终会复制过时的数据。
- en: In the last few years, the addition of transactions that pass information about
    deleted sectors down to the disk controller has improved this situation. The SCSI
    and SATA specifications have a `TRIM` command, and MMC has a similar command named
    `ERASE`. In Linux, this feature is known as **discard**.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几年里，通过向磁盘控制器传递有关已删除扇区的信息的事务的增加，改善了这种情况。SCSI 和 SATA 规范有一个 `TRIM` 命令，MMC 也有一个类似的命令，称为
    `ERASE`。在 Linux 中，这个功能被称为 **discard**。
- en: To make use of discard, you need a storage device that supports it – most current
    eMMC chips do – and a Linux device driver to match. You can check this by looking
    at the block system queue parameters in `/sys/block/<block device>/queue/`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 要利用丢弃功能，你需要一个支持它的存储设备——大多数当前的 eMMC 芯片都支持——以及一个匹配的 Linux 设备驱动程序。你可以通过查看 `/sys/block/<block
    device>/queue/` 中的块系统队列参数来检查。
- en: 'The ones of interest are as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 关注的项如下：
- en: '`discard_granularity`: The size of the internal allocation unit of the device.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`discard_granularity`：设备的内部分配单元的大小。'
- en: '`discard_max_bytes`: The maximum number of bytes that can be discarded in one
    go.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`discard_max_bytes`：一次可以丢弃的最大字节数。'
- en: '`discard_zeroes_data`: If this is set to `1`, discarded data will be set to
    0.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`discard_zeroes_data`：如果设置为 `1`，丢弃的数据将被设置为 0。'
- en: 'If the device or the device driver does not support discard, these values will
    all be set to `0`. As an example, these are the parameters you will see from the
    2 GB eMMC chip on my BeagleBone Black:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设备或设备驱动程序不支持丢弃，这些值将全部设置为 `0`。举个例子，这些是我在 BeagleBone Black 上看到的 2 GB eMMC 芯片的参数：
- en: '[PRE30]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: More information can be found in the `Documentation/block/queue-sysfs.txt` kernel
    documentation file.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息可以在 `Documentation/block/queue-sysfs.txt` 内核文档文件中找到。
- en: You can enable discard when mounting a filesystem by adding the `-o` discard
    option to the mount command. Both ext4 and F2FS support it.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在挂载文件系统时添加 `-o` discard 选项来启用丢弃。ext4 和 F2FS 都支持此功能。
- en: '**Tip**'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: Make sure that the storage device supports discard before using the `-o` discard
    mount option as data loss can occur.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `-o` discard 挂载选项之前，确保存储设备支持丢弃，因为数据丢失可能会发生。
- en: 'It is also possible to force discard from the command line independently of
    how the partition is mounted using the `fstrim` command, which is part of the
    `util-linux` package. Typically, you would run this command periodically to free
    up unused space. `fstrim` operates on a mounted filesystem so to trim the root
    filesystem, you would type the following:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以通过命令行强制丢弃，无论分区如何挂载，使用 `fstrim` 命令，它是 `util-linux` 包的一部分。通常，你会定期运行这个命令来释放未使用的空间。`fstrim`
    在已挂载的文件系统上操作，因此要修剪根文件系统，你需要输入以下命令：
- en: '[PRE31]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The preceding example uses the `-v` verbose option so that it prints out the
    number of bytes that have been potentially freed up. In this case, 2,061,000,704
    is the approximate amount of free space in the filesystem, so it is the maximum
    amount of storage that could have been trimmed.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例使用了`-v`详细模式选项，以便打印出已释放的字节数。在这种情况下，2,061,000,704是文件系统中大约可用的空闲空间，因此它是可能已被修剪的最大存储量。
- en: Ext4
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ext4
- en: The **extended filesystem** (**ext**) has been the main filesystem for Linux
    desktops since 1992\. The current version (**ext4**) is very stable, well-tested,
    and has a journal that makes recovering from an unscheduled shutdown fast and
    mostly painless. It is a good choice for managed flash devices, and you will find
    that it is the preferred filesystem for Android devices that have eMMC storage.
    If the device supports discard, you can mount an ext4 filesystem on it with the
    `-o` discard option.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '**扩展文件系统**（**ext**）自1992年以来一直是Linux桌面的主要文件系统。目前的版本（**ext4**）非常稳定，经过充分测试，并且拥有一个日志系统，可以在未计划的关机后快速且基本无痛地恢复。它是管理闪存设备的良好选择，你会发现它是配备eMMC存储的Android设备的首选文件系统。如果设备支持丢弃，你可以在其上通过`-o`
    discard选项挂载ext4文件系统。'
- en: 'To format and create an ext4 filesystem at runtime, type the following:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 要在运行时格式化并创建ext4文件系统，输入以下命令：
- en: '[PRE32]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To create a filesystem image at build time, you can use the `genext2fs` utility
    available from [https://github.com/bestouff/genext2fs](https://github.com/bestouff/genext2fs).
    In this example, I have specified the block size with `-B` and the number of blocks
    in the image with `-b`:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 要在构建时创建文件系统镜像，可以使用来自[https://github.com/bestouff/genext2fs](https://github.com/bestouff/genext2fs)的`genext2fs`工具。在这个示例中，我使用`-B`选项指定了块大小，使用`-b`选项指定了镜像中的块数：
- en: '[PRE33]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`genext2fs` can make use of a device table to set the file permissions and
    ownership as described in [*Chapter 5*](Chapter_05.xhtml#_idTextAnchor138) with
    `-D <file table>`.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`genext2fs`可以使用设备表来设置文件权限和所有权，具体操作参见[*第5章*](Chapter_05.xhtml#_idTextAnchor138)，使用`-D
    <文件表>`选项。'
- en: 'As the name implies, this will generate an image in ext2 format. You can upgrade
    to ext4 using tune2fs as follows (details of the command’s options can be found
    on the `tune2fs(8)` manual page):'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，这将生成一个ext2格式的镜像。你可以通过如下方式使用`tune2fs`命令将其升级为ext4（命令选项的详细信息可以在`tune2fs(8)`手册页中找到）：
- en: '[PRE34]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Both The Yocto Project and Buildroot use exactly these steps when creating images
    in ext4 format.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: Yocto项目和Buildroot在创建ext4格式镜像时完全按照这些步骤操作。
- en: While a journal is an asset for devices that may power down without warning,
    it does add extra write cycles to each write transaction, wearing out the flash
    memory. If the device is battery-powered, especially if the battery is not removable,
    the chances of an unscheduled power down are small, so you may want to leave the
    journal out.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然日志是防止设备在没有预警的情况下关机时的资产，但它确实会为每次写入事务增加额外的写入周期，导致闪存逐渐磨损。如果设备是电池供电，尤其是当电池不可拆卸时，意外关机的几率较小，因此你可能希望不启用日志功能。
- en: Even with journaling, filesystem corruption can occur on unexpected power loss.
    In many devices, holding down the power button, unplugging the power cord, or
    pulling out the battery can result in immediate shutdown.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 即使启用了日志系统，文件系统在意外断电时仍可能发生损坏。在许多设备中，长按电源按钮、拔掉电源线或取出电池都可能导致设备立即关机。
- en: Due to the nature of buffered I/O, data being written out to flash may be lost
    if the power goes out before the write is done flushing to storage. For these
    reasons, it is good to run `fsck` non-interactively on a user partition to check
    for and repair any filesystem corruption before mounting. Otherwise, the corruption
    can compound over time until it becomes a serious issue.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 由于缓冲I/O的特性，在写入数据到闪存时，如果在写入完成之前断电，数据可能会丢失。出于这些原因，在挂载之前，最好以非交互方式运行`fsck`检查用户分区，修复任何文件系统损坏。否则，损坏可能会随着时间的推移积累，直到成为严重问题。
- en: F2FS
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: F2FS
- en: The **Flash-Friendly File System** (**F2FS**) is a log-structured filesystem
    designed for managed flash devices, especially eMMC chips and SD cards. It was
    written by Samsung and was merged into mainline Linux in 3.8\. It is marked as
    experimental, indicating that it has not been extensively deployed yet, but it
    seems that some Android devices are using it.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '**Flash友好文件系统**（**F2FS**）是一种日志结构文件系统，专为管理闪存设备设计，尤其是eMMC芯片和SD卡。它由三星开发，并在Linux
    3.8中合并到主线内核。它被标记为实验性，这意味着它尚未广泛部署，但似乎一些Android设备已经在使用它。'
- en: F2FS takes into account the page and erase block sizes and then tries to align
    data on these boundaries. The log format provides resilience in the face of power
    down and also provides good write performance. In some tests, F2FS shows a twofold
    improvement over ext4\. There is a good description of the design of F2FS in the
    `Documentation/filesystems/f2fs.txt` kernel documentation file and there are references
    at the end of this chapter in the *Further study* section.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: F2FS考虑了页面和擦除块的大小，并尽量在这些边界上对数据进行对齐。日志格式能够在断电情况下提供恢复能力，并且提供良好的写入性能。在一些测试中，F2FS比ext4提高了两倍的性能。在`Documentation/filesystems/f2fs.txt`内核文档中有关于F2FS设计的详细描述，另外在本章的*进一步学习*部分也有相关参考资料。
- en: 'The `mkfs.f2fs` utility creates an empty F2FS filesystem with the `-l` label:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`mkfs.f2fs`工具通过`-l`标签创建一个空的F2FS文件系统：'
- en: '[PRE35]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: There isn’t a tool you can use to create F2FS filesystem images offline yet.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 目前没有工具可以用来离线创建F2FS文件系统镜像。
- en: FAT16/32
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FAT16/32
- en: The old Microsoft filesystems (FAT16 and FAT32) continue to be important as
    a common format understood by most operating systems. When you buy an SD card
    or USB flash drive, it is almost certain to be formatted as FAT32, and, in some
    cases, the on-card microcontroller is optimized for FAT32 access patterns. Also,
    some boot ROMs require a FAT partition for the second-stage bootloader. However,
    FAT formats are definitely not suitable for storing critical files because they
    are prone to corruption and make poor use of the storage space.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 旧的Microsoft文件系统（FAT16和FAT32）继续作为大多数操作系统都能识别的常见格式发挥着重要作用。当你购买SD卡或USB闪存驱动器时，它几乎可以确定会被格式化为FAT32，在某些情况下，卡上的微控制器是为FAT32访问模式进行优化的。此外，某些引导ROM要求使用FAT分区作为第二阶段引导加载程序。然而，FAT格式显然不适合存储关键文件，因为它们容易损坏，且存储空间利用率差。
- en: 'Linux supports FAT16 through both the `msdos` and `vfat` filesystems, but FAT32
    is only supported through the `vfat` filesystem. To mount a device, say an SD
    card, on the second MMC hardware adapter, type this:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: Linux通过`msdos`和`vfat`文件系统支持FAT16，但FAT32仅通过`vfat`文件系统得到支持。要挂载一个设备，比如SD卡，在第二个MMC硬件适配器上，输入以下命令：
- en: '[PRE36]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '**Important note**'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: In the past, there have been licensing issues with the `vfat` driver, which
    may (or may not) infringe a patent held by Microsoft.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 过去，`vfat`驱动程序曾存在许可问题，这可能（或可能不会）侵犯微软持有的专利。
- en: FAT32 has a limitation of 32 GB on the device’s size. Devices of a larger capacity
    may be formatted using the Microsoft exFAT format and it is a requirement for
    SDXC cards. There is no kernel driver for exFAT, but it can be supported by means
    of a user space FUSE driver. Since exFAT is proprietary to Microsoft, there are
    bound to be licensing implications if you support this format on your device.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: FAT32在设备的容量上有32 GB的限制。更大容量的设备可以使用Microsoft的exFAT格式进行格式化，且这是SDXC卡的要求。exFAT没有内核驱动程序，但可以通过用户空间FUSE驱动程序来支持。由于exFAT是微软的专有格式，如果你在设备上支持该格式，必然会涉及到许可问题。
- en: 'That does it for read-write filesystems geared toward managed flash. What about
    space-saving read-only filesystems? The choice is simple: SquashFS.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是面向管理闪存的读写文件系统。那对于节省空间的只读文件系统呢？选择很简单：SquashFS。
- en: Read-only compressed filesystems
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 只读压缩文件系统
- en: 'Compressing data is useful if you don’t have quite enough storage to fit everything
    in. Both JFFS2 and UBIFS do on-the-fly data compression by default. However, if
    the files are never going to be written, as is usually the case with the root
    filesystem, you can achieve better compression ratios by using a read-only compressed
    filesystem. Linux supports several of these: `romfs`, `cramfs`, and `squashfs`.
    The first two are obsolete now, so I will only describe SquashFS.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存储空间不够用来放下所有数据，压缩数据是非常有用的。JFFS2和UBIFS默认进行即时数据压缩。然而，如果文件永远不会被写入，通常根文件系统就是这种情况，你可以通过使用只读压缩文件系统来实现更好的压缩比。Linux支持几种这种文件系统：`romfs`、`cramfs`和`squashfs`。前两者现在已经过时，因此我只描述SquashFS。
- en: SquashFS
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SquashFS
- en: 'The SquashFS filesystem was written by Phillip Lougher in 2002 as a replacement
    for `cramfs`. It existed as a kernel patch for a long time, eventually being merged
    into mainline Linux in version 2.6.29 in 2009\. It is very easy to use. You create
    a filesystem image using `mksquashfs` and install it to the flash memory:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: SquashFS文件系统由Phillip Lougher在2002年编写，作为`cramfs`的替代品。它长期作为内核补丁存在，最终在2009年被合并到Linux主线版本2.6.29中。它非常易于使用。你可以通过`mksquashfs`创建一个文件系统镜像并将其安装到闪存中：
- en: '[PRE37]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The resulting filesystem is read-only so there is no mechanism for modifying
    any of the files at runtime. The only way to update a SquashFS filesystem is to
    erase the whole partition and program in a new image.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 结果文件系统是只读的，因此没有机制可以在运行时修改任何文件。更新SquashFS文件系统的唯一方法是擦除整个分区并编程一个新的镜像。
- en: 'SquashFS is not bad-block aware so it must be used with reliable flash memory
    such as NOR flash. However, it can be used on NAND flash as long as you use UBI
    to create an emulated, reliable MTD. You have to enable the `CONFIG_MTD_UBI_BLOCK`
    kernel configuration, which will create a read-only MTD block device for each
    UBI volume. The following diagram shows two MTD partitions, each with accompanying
    `mtdblock` devices. The second partition is also used to create a UBI volume that
    is exposed as a third, reliable `mtdblock` device, which you can use for any read-only
    filesystem that is not bad-block aware:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: SquashFS并不具备坏块感知能力，因此必须与可靠的闪存（如NOR闪存）一起使用。不过，只要使用UBI来创建一个模拟的可靠MTD，它也可以用于NAND闪存。你需要启用`CONFIG_MTD_UBI_BLOCK`内核配置，它会为每个UBI卷创建一个只读的MTD块设备。以下图示展示了两个MTD分区，每个分区都有相应的`mtdblock`设备。第二个分区还用来创建一个UBI卷，该卷作为第三个可靠的`mtdblock`设备暴露，你可以将其用于任何不具备坏块感知的只读文件系统：
- en: '![Figure 9.5 – UBI volume](img/B18466_09_05.png)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.5 – UBI卷](img/B18466_09_05.png)'
- en: Figure 9.5 – UBI volume
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5 – UBI卷
- en: A read-only filesystem is great for immutable contents, but what about temporary
    files that don’t need to persist across reboots? This is where a RAM disk comes
    in handy.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 只读文件系统非常适合不可变的内容，但对于那些不需要在重启后保留的临时文件怎么办呢？这时RAM磁盘就派上用场了。
- en: Temporary filesystems
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 临时文件系统
- en: There are always some files that have a short lifetime or have no significance
    after a reboot. Many such files are put into `/tmp`, so it makes sense to keep
    these files from reaching permanent storage.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 总是有一些文件，它们的生命周期很短或在重启后没有意义。许多这样的文件被放入`/tmp`中，因此避免这些文件进入永久存储是有意义的。
- en: 'The temporary filesystem (`tmpfs`) is ideal for this purpose. You can create
    a temporary RAM-based filesystem by simply mounting `tmpfs`:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 临时文件系统（`tmpfs`）非常适合这个目的。你可以通过简单地挂载`tmpfs`来创建一个基于RAM的临时文件系统：
- en: '[PRE38]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As with `procfs` and `sysfs`, there is no device node associated with `tmpfs`,
    so you have to supply a placekeeper string, which is `tmp_files` in the preceding
    example.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 和`procfs`及`sysfs`一样，`tmpfs`没有关联的设备节点，因此你必须提供一个占位符字符串，前面的示例中是`tmp_files`。
- en: 'The amount of memory used will grow and shrink as files are created and deleted.
    The default maximum size is half the physical RAM. In most cases, it would be
    a disaster if `tmpfs` grew to be that large, so it is a very good idea to cap
    it with the `-o` size parameter. The parameter can be given in bytes, KB (k),
    MB (m), or GB (g) like this for example:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的内存量会随着文件的创建和删除而增减。默认的最大大小是物理RAM的一半。在大多数情况下，如果`tmpfs`的大小达到那么大，那将是一场灾难，因此最好使用`-o`大小参数来限制它。该参数可以用字节、KB（k）、MB（m）或GB（g）来指定，例如：
- en: '[PRE39]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In addition to `/tmp`, some subdirectories of `/var` contain volatile data
    and it is good practice to use `tmpfs` for them as well, either by creating a
    separate filesystem for each or, more economically, using symbolic links. Buildroot
    does this like so:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`/tmp`，`/var`的一些子目录也包含易失数据，通常做法是使用`tmpfs`来处理它们，方法可以是为每个子目录创建一个单独的文件系统，或者更经济地使用符号链接。Buildroot就是这样做的：
- en: '[PRE40]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In The Yocto Project, `/run` and `/var/volatile` are `tmpfs` mounts with symbolic
    links pointing to them as shown:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在Yocto项目中，`/run`和`/var/volatile`是`tmpfs`挂载点，并有符号链接指向它们，如下所示：
- en: '[PRE41]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: It is not uncommon to load the root filesystem into RAM on embedded Linux systems.
    That way, any damage to its contents that may occur at runtime is not permanent.
    The root filesystem does not need to reside on SquashFS or `tmpfs` to be protected.
    You just need to make sure the root filesystem is read-only.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌入式Linux系统中，将根文件系统加载到RAM中并不罕见。这样，运行时可能发生的任何文件损坏都不会是永久性的。根文件系统不一定需要保存在SquashFS或`tmpfs`中以便得到保护。你只需要确保根文件系统是只读的。
- en: Making the root filesystem read-only
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使根文件系统只读
- en: 'You need to make your target device able to survive unexpected events, including
    file corruption, and still be able to boot and achieve at least a minimum level
    of functionality. Making the root filesystem read-only is a key part of achieving
    this ambition because it eliminates accidental overwrites. Making it read-only
    is easy. Replace `rw` with `ro` on the kernel command line or use an inherently
    read-only filesystem such as SquashFS. However, you will find that there are a
    few files and directories that are traditionally writable:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要确保目标设备能够应对意外事件，包括文件损坏，并且仍然能够启动并实现至少最低水平的功能。将根文件系统设置为只读是实现这一目标的关键部分，因为它消除了意外覆盖的风险。将其设置为只读非常简单，只需在内核命令行上将
    `rw` 替换为 `ro`，或者使用本身为只读的文件系统，例如 SquashFS。然而，你会发现一些文件和目录传统上是可写的：
- en: '`/etc/resolv.conf`: This file is written by network configuration scripts to
    record the addresses of DNS name servers. The information is volatile so you simply
    have to make it a symlink to a temporary directory like `/etc/resolv.conf -> /var/run/resolv.conf`.'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/etc/resolv.conf`：该文件由网络配置脚本写入，用来记录 DNS 名称服务器的地址。此信息是易失性的，因此你只需将其作为符号链接指向临时目录，例如
    `/etc/resolv.conf -> /var/run/resolv.conf`。'
- en: '`/etc/passwd`: This file, along with `/etc/group`, `/etc/shadow`, and `/etc/gshadow`,
    stores user and group names and passwords. They need to be symbolically linked
    to an area of persistent storage.'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/etc/passwd`：此文件与 `/etc/group`、`/etc/shadow` 和 `/etc/gshadow` 一起存储用户和组的名称及密码。它们需要与持久存储区域建立符号链接。'
- en: '`/var/lib`: Many applications expect to be able to write to this directory
    and to keep permanent data here as well. One solution is to copy a base set of
    files to a `tmpfs` filesystem at boot time and then bind mount `/var/lib` to the
    new location. You can do this by putting a sequence of commands such as these
    into one of the boot scripts:'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/var/lib`：许多应用程序期望能够写入该目录并在此处保持永久数据。一种解决方案是在启动时将一组基本文件复制到 `tmpfs` 文件系统中，然后将
    `/var/lib` 绑定挂载到新位置。你可以通过将一系列命令添加到启动脚本中来实现这一点：'
- en: '[PRE42]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`/var/log`: This is the place where `syslogd` and other daemons keep their
    logs. Generally, logging to flash memory is not desirable because of the many
    small write cycles it generates. A simple solution is to mount `/var/log` using
    `tmpfs` making all log messages volatile. In the case of `syslogd`, BusyBox has
    a version that can log to a circular ring buffer.'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/var/log`：这是 `syslogd` 和其他守护进程保存日志的地方。通常不建议将日志记录到闪存中，因为这会产生许多小的写入周期。一个简单的解决方法是使用
    `tmpfs` 挂载 `/var/log`，使所有日志消息都为易失性数据。对于 `syslogd`，BusyBox 有一个可以将日志记录到循环环形缓冲区的版本。'
- en: If you are using The Yocto Project, you can create a read-only root filesystem
    by adding `IMAGE_FEATURES = "read-only-rootfs"` to `conf/local.conf` or to your
    image recipe.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 Yocto 项目，你可以通过在 `conf/local.conf` 或你的镜像配方中添加 `IMAGE_FEATURES = "read-only-rootfs"`
    来创建一个只读根文件系统。
- en: Filesystem choices
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件系统选择
- en: 'So far, we have looked at the technology behind solid-state memory and at the
    many types of filesystems. Now it is time to summarize the options that are available.
    In most cases, you will be able to divide your storage requirements into these
    three categories:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看过固态存储器背后的技术以及多种类型的文件系统。现在是时候总结可用的选择了。在大多数情况下，你将能够将存储需求分为以下三类：
- en: '**Permanent, read-write data**: Runtime configuration, network parameters,
    passwords, data logs, and user data'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**永久性可读写数据**：运行时配置、网络参数、密码、数据日志和用户数据'
- en: '**Permanent, read-only data**: Programs, libraries, and configurations files
    that are constant; for example, the root filesystem'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**永久性只读数据**：常量的程序、库和配置文件；例如，根文件系统'
- en: '**Volatile data**: Temporary storage; for example, `/tmp`'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易失性数据**：临时存储；例如，`/tmp`'
- en: 'The choices for read-write storage are as follows:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 可读写存储的选择如下：
- en: '**NOR**: UBIFS or JFFS2'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NOR**：UBIFS 或 JFFS2'
- en: '**NAND**: UBIFS, JFFS2, or YAFFS2'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NAND**：UBIFS、JFFS2 或 YAFFS2'
- en: '**eMMC**: ext4 or F2FS'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**eMMC**：ext4 或 F2FS'
- en: 'For read-only storage, you can use any of these mounted with the `ro` attribute.
    Additionally, if you want to save space, you could use SquashFS. Finally, for
    volatile storage, there is only one choice: `tmpfs`.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 对于只读存储，你可以使用任何带有 `ro` 属性的挂载方式。此外，如果你想节省空间，可以使用 SquashFS。最后，对于易失性存储，只有一个选择：`tmpfs`。
- en: Summary
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Flash memory has been the storage technology of choice for embedded Linux from
    the beginning. Over the years, Linux has gained very good flash memory support
    from low-level drivers up to flash-aware filesystems, with the latest being UBIFS.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 从一开始，闪存就成为了嵌入式 Linux 的首选存储技术。多年来，Linux 在从低级驱动程序到闪存感知文件系统的各个方面获得了非常好的闪存支持，最新的文件系统是
    UBIFS。
- en: As the rate at which new flash technologies are introduced increases, it is
    becoming harder to keep pace with the changes at the top end. System designers
    are increasingly turning to managed flash in the form of eMMC to provide a stable
    hardware and software interface that is independent of the memory chips inside.
    Embedded Linux developers are beginning to get to grips with these new chips.
    Support for `TRIM` in ext4 and F2FS is well-established, and it is slowly finding
    its way into the chips themselves. Also, the appearance of new filesystems that
    have been optimized to manage flash, such as F2FS, is a welcome step forward.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 随着新型闪存技术的引入速度不断加快，跟上顶端技术的变化变得越来越困难。系统设计师越来越多地转向使用 eMMC 形式的托管闪存，以提供一种稳定的硬件和软件接口，该接口与内部的内存芯片无关。嵌入式
    Linux 开发者开始逐步掌握这些新型芯片。`TRIM` 在 ext4 和 F2FS 中的支持已经非常成熟，并且慢慢地开始进入芯片本身。此外，针对闪存优化的新文件系统的出现，例如
    F2FS，标志着向前迈出了可喜的一步。
- en: However, the fact remains that flash memory is not the same as a hard disk drive.
    You have to be careful when you’re minimizing the number of filesystem writes
    – especially as the higher density TLC chips may be able to support as few as
    1,000 erase cycles.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，事实依然是，闪存并不等同于硬盘驱动器。在减少文件系统写入次数时必须小心，尤其是当较高密度的 TLC 芯片可能仅支持 1,000 次擦除周期时。
- en: In the next chapter, we will continue with the theme of storage options as we
    consider different ways to keep software up to date on devices that may be deployed
    to remote locations.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续讨论存储选项的主题，并考虑在可能部署到远程位置的设备上保持软件更新的不同方法。
- en: Further study
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入研究
- en: '*XIP: The past, the present... the future?*, by Vitaly Wool – [https://archive.fosdem.org/2007/slides/devrooms/embedded/Vitaly_Wool_XIP.pdf](https://archive.fosdem.org/2007/slides/devrooms/embedded/Vitaly_Wool_XIP.pdf)'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*XIP：过去、现在……未来？*，作者：Vitaly Wool – [https://archive.fosdem.org/2007/slides/devrooms/embedded/Vitaly_Wool_XIP.pdf](https://archive.fosdem.org/2007/slides/devrooms/embedded/Vitaly_Wool_XIP.pdf)'
- en: '*Optimizing Linux with cheap flash drives*, by Arnd Bergmann – [https://lwn.net/Articles/428584/](https://lwn.net/Articles/428584/)'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用廉价闪存驱动器优化 Linux*，作者：Arnd Bergmann – [https://lwn.net/Articles/428584/](https://lwn.net/Articles/428584/)'
- en: '*eMMC/SSD File System Tuning Methodology*, Cogent Embedded, Inc. – [https://elinux.org/images/b/b6/EMMC-SSD_File_System_Tuning_Methodology_v1.0.pdf](https://elinux.org/images/b/b6/EMMC-SSD_File_System_Tuning_Methodology_v1.0.pdf)'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*eMMC/SSD 文件系统调优方法*，Cogent Embedded, Inc. – [https://elinux.org/images/b/b6/EMMC-SSD_File_System_Tuning_Methodology_v1.0.pdf](https://elinux.org/images/b/b6/EMMC-SSD_File_System_Tuning_Methodology_v1.0.pdf)'
- en: '*Flash-Friendly File System (F2FS)*, by Joo-Young Hwang – [https://elinux.org/images/1/12/Elc2013_Hwang.pdf](https://elinux.org/images/1/12/Elc2013_Hwang.pdf)'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*闪存友好文件系统 (F2FS)*，作者：Joo-Young Hwang – [https://elinux.org/images/1/12/Elc2013_Hwang.pdf](https://elinux.org/images/1/12/Elc2013_Hwang.pdf)'
- en: '*An F2FS teardown*, by Neil Brown – [https://lwn.net/Articles/518988/](https://lwn.net/Articles/518988/)'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*F2FS 拆解*，作者：Neil Brown – [https://lwn.net/Articles/518988/](https://lwn.net/Articles/518988/)'
