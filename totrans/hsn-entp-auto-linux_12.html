<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Patching with Katello</h1>
                </header>
            
            <article>
                
<p>In <a href="56007c92-a39b-4e56-9b01-a137eab2369d.xhtml" target="_blank">Chapter 8</a>, <em>Enterprise Repository Management with Pulp</em>, we explored the Pulp software package and how it lends itself to automated, repeatable, controllable patching in an enterprise setting. In this chapter, we will build on this by taking a look at a product called <strong>Katello</strong>, which is complementary to Pulp and lends itself to not just patching but complete infrastructure management.</p>
<p>Katello is a GUI-driven tool that provides advanced solutions for enterprise infrastructure management, and in many ways can be considered to be the successor to the venerable Spacewalk product that many are familiar with. We will explore why you would choose Katello for this purpose and then proceed with hands-on examples of how to build a Katello server and perform patching.</p>
<p>The following topics will specifically be covered in this chapter:</p>
<ul>
<li>Introduction to Katello</li>
<li>Installing a Katello server</li>
<li>Patching with Katello</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>The minimum requirements for completing the hands-on exercises in this chapter are a single CentOS 7 server with around 80 GB of disk space allocated, 2 CPU cores (virtual or physical), and 8 GB of memory. Although we will only look at a subset of the Katello features in this chapter, it should be noted that Foreman in particular (which is installed under Katello) is capable of acting as a DHCP server, DNS server, and PXE boot host and, as such, if configured incorrectly could cause issues if deployed on a production network.</p>
<p>For this reason, it is recommended that all exercises are performed in an isolated network suitable for testing. Where Ansible code is given, it will have been developed and tested in Ansible 2.8. For testing patching from Katello, you will need a CentOS 7 virtual machine.</p>
<p><span>All example code discussed in this book is available from GitHub at:</span><span> <a href="https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux">https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux</a>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction to Katello</h1>
                </header>
            
            <article>
                
<p>Katello is not actually a single product in isolation, but a union of several open source infrastructure management products into one cohesive infrastructure management solution. Where Pulp is solely focused on the efficient, controllable storage of packages (and other important content for infrastructure management), Katello brings together the following:</p>
<ul>
<li><strong>Foreman</strong>: This is an open source product designed to handle the provisioning and configuration of both physical and virtual servers. Foreman includes a rich web-based GUI, a RESTful API, and a CLI tool called <strong>Hammer</strong>, providing a rich and varied means of management. It also provides integration with several automation tools, originally just Puppet but more recently also Ansible.</li>
<li><strong>Katello</strong>: Katello is actually a plugin for Foreman and provides additional features such as the rich version control of content (more so than Pulp alone) and subscription management.</li>
<li><strong>Candlepin</strong>: Provides software subscription management, especially integration with environments such as the <strong>Red Hat Subscription Management</strong> (<strong>RHSM</strong>) model. Although it is possible to mirror Red Hat repositories in Pulp, the process is cumbersome, and you risk violating your license terms because there is no visibility on the number of systems you are managing or their relationship to your Red Hat subscriptions.</li>
<li><strong>Pulp</strong>: This is the very same Pulp software that we explored in the last chapter, now integrated into one fully featured project.</li>
<li><strong>Capsule</strong>: A proxy service for distributing content and controlling updates across a geographically diverse infrastructure while maintaining a single management console.</li>
</ul>
<p>The use of Katello hence provides several advantages over using Pulp alone, and even if you use it just for patch management (as we will explore in this chapter, in the section entitled <em>Patching with Katello</em>), the rich web GUI, CLI, and API lend itself to integration with enterprise systems. Beyond this though, Katello (and more specifically Foreman, which underpins it) provides many other benefits such as being able to dynamically PXE boot servers and control both container and virtualization systems, and it can even act as both the DNS and DHCP servers for your network. Indeed, it is fair to say that the combination of Katello/Foreman is designed to sit at the heart of your network, although it will only perform the functions you ask of it, so those with existing DNS and DHCP infrastructures need not fear.</p>
<p>It is worth mentioning that Katello also features tight integration with the Puppet automation tool. The original project was sponsored by Red Hat, and before their acquisition of Ansible, Red Hat and Puppet had a strategic alliance, which led to it becoming heavily featured in the Katello project (which is available commercially as Red Hat Satellite 6). Given the Ansible acquisition, while the Puppet integration still remains in Katello, support for integration with Ansible, especially through Ansible Tower/AWX, has evolved rapidly and it is entirely up to the user which automation tool they wish to use.</p>
<p>At this stage, the venerable <strong>Spacewalk</strong> software tool deserves an honorable mention. Spacewalk is the upstream open source version of Red Hat Satellite 5 and is still being actively developed and maintained. There is a huge degree of overlap between the two systems in terms of high-level functionality; however, Katello/Satellite 6 is a complete from-the-ground-up rewrite of the platform and so there is no clear upgrade path between the two. Given that Red Hat's contribution to the Spacewalk program is likely to decrease when they end-of-life their Satellite 5 product, our focus in this book will be on Katello. </p>
<p>Indeed, it is fair to say that Katello deserves a book of its own, so rich is its feature set. Our goal in this chapter is simply to raise awareness of the Katello platform and to demonstrate how it lends itself to patching in an enterprise environment. Many of the additional features, such as the PXE booting of servers, require an understanding of the concepts we have already covered in this book, and hence it is hoped that, should you decide upon Katello or Satellite 6 as a platform for managing your infrastructure, then you will be able to build on the foundation that this book provides and explore additional resources to take you further.</p>
<p>Let's get started by taking a practical look in the next section at how to install a simple standalone Katello server so that we can explore this more fully.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing a Katello server</h1>
                </header>
            
            <article>
                
<p>This is a hands-on book, so without further ado, let's get started and set up our very own Katello server. Alongside the advantages of Katello already discussed, another is the packaging of the product. When we set up our Pulp server, there were many individual components where we had to make decisions (for example, RabbitMQ versus Qpid) and then additional setup to perform (for example, SSL transport for MongoDB). Katello has even more <em>moving parts</em> than Pulp (if Pulp is considered as just a component of the Katello platform), and hence installing it by hand would be a vast and complex task.</p>
<p>Thankfully, Katello provides an installation system that can get you up and running with just a few commands, which we will explore in the next section of this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Preparing to install Katello</h1>
                </header>
            
            <article>
                
<p>Katello, as with Pulp, only installs (at the time of writing) on Enterprise Linux 7 variants—so here, <span>again,</span><span> </span><span>we will use the latest stable release of CentOS 7. The requirements for Katello change from time to time as the product grows, and it is always worth reviewing the installation documentation for yourself before proceeding. At the time of writing, version 3.12 is the latest stable release, and the installation documentation can be found here: </span><a href="https://theforeman.org/plugins/katello/3.12/installation/index.html">https://theforeman.org/plugins/katello/3.12/installation/index.html</a>. Now, let's follow these steps:</p>
<ol>
<li>As before, our biggest concern is ensuring we have sufficient disk space allocated, and just as for a standalone Pulp installation, we must ensure that we have enough disk space allocated in<span> </span><kbd>/var/lib/pulp</kbd><span> </span>and<span> </span><kbd>/var/lib/mongodb</kbd><span> </span>for all of the Linux distributions we may wish to mirror. Again, as with Pulp, they should be separate from the root volume to ensure that if one fills up, the entire server does not die.</li>
<li>With the filesystem set up, our first step is to install the required repositories so that all required packages for installation can be downloaded—this requires setting up several external repositories that provide packages not included by default with CentOS 7. The following commands set up the repositories for Katello, Foreman, Puppet 6, and the EPEL repository before actually installing the Foreman release package tree:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ yum -y localinstall https://fedorapeople.org/groups/katello/releases/yum/3.12/katello/el7/x86_64/katello-repos-latest.rpm</strong><br/><strong>$ yum -y localinstall https://yum.theforeman.org/releases/1.22/el7/x86_64/foreman-release.rpm</strong><br/><strong>$ yum -y localinstall https://yum.puppet.com/puppet6-release-el-7.noarch.rpm</strong><br/><strong>$ yum -y localinstall https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm</strong><br/><strong>$ yum -y install foreman-release-scl</strong></pre>
<ol start="3">
<li>From here, it is recommended to bring the base system fully up to date:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ yum -y update</strong></pre>
<ol start="4">
<li>The final step before the actual installation is to install the Katello package and its dependencies:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ yum -y install katello</strong></pre>
<ol start="5">
<li>From here on, all installation tasks are performed with the<span> </span><kbd>foreman-installer</kbd><span> </span>command—there are a huge plethora of options that can be specified and, with most of them, if you need to change your decision, you can run the installer again with the different flags and it will perform the changes without any data loss. To see all possible options, run the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ foreman-installer --scenario katello --help</strong></pre>
<ol start="6">
<li>To build our demo server, the defaults will mostly suffice—however, if you explore the options, you will see that many will need to be specified in an enterprise setting. For example, SSL certificates can be specified at install time (rather than relying on self-signed ones that will be generated otherwise), default secrets for underlying transports are set, and so on. It is highly recommended that you review the output of the preceding command for yourself when installing in a production setting. For now, we will issue the following installation command to initiate the installation:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ foreman-installer --scenario katello --foreman-initial-admin-password=password --foreman-initial-location='London' --foreman-initial-organization='HandsOn'</strong></pre>
<p style="padding-left: 60px">This is probably the simplest possible installation case for a Katello server, and it <span>perfectly </span>serves our examples in this book. However, in a <kbd>Production</kbd> environment, I highly recommend that you explore the more advanced installation features to ensure that the server will meet your requirements, especially where security and availability are concerned. This is left as an exercise for you to explore.</p>
<div class="packt_tip">Note that, in this scenario, the installer checks several prerequisites, including that the forward and reverse DNS lookups for the Katello server name resolve correctly and that the machine has 8 GB of RAM available. The installer will refuse to proceed if these prerequisites are not met.</div>
<ol start="7">
<li>The Katello installation should run to completion provided all prerequisites have been met, and once completed, you should be presented with a screen similar to the one shown in the following screenshot, detailing the login details, as well as other pertinent information such as how to set up a proxy server for another network if required:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7b0081da-0a67-47b5-83a7-eb956c158af3.png"/></p>
<ol start="8">
<li>The only task not completed by the installer is setting up the local firewall on the CentOS 7 machine. Luckily, there is a FirewallD service definition included with Katello that covers all of the services likely to be required—this derives its named from the commercial Red Hat Satellite 6 product and can be enabled by running the following commands as root:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ firewall-cmd --permanent --zone=public --add-service=RH-Satellite-6</strong><br/><strong>$ firewall-cmd --reload</strong></pre>
<ol start="9">
<li>With those steps completed, it will be possible to load the web interface of Katello and log in with the details shown:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2efc4b2c-99c0-4107-ac5f-32be6f56a440.png" style="width:43.33em;height:17.50em;"/></p>
<p>Technically speaking, Katello is a module that sits on top of Foreman and provides important features that we will look at later in this chapter—for example, a web UI for the Pulp repository management system that is also installed behind the scenes. Hence, the Foreman branding of the code stands out, and you will find the name comes up frequently. Once logged in, you should be presented with the default dashboard page, and we can start to configure some repositories for patching purposes, which we will commence in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Patching with Katello</h1>
                </header>
            
            <article>
                
<p>As Katello is built around technologies we have already explored, such as Pulp, it carries with it the same limitations we have already seen regarding DEB packages. For instance, although repositories of DEB packages can be built up easily in Katello, and even the appropriate GPG public keys imported, the resulting published repositories do not feature an<span> </span><kbd>InRelease</kbd><span> </span>or<span> </span><kbd>Release.gpg</kbd><span> </span>file and so must be implicitly trusted by all hosts that use these. Similarly, although there is a complete subscription management framework available for RPM-based hosts consisting of the<span> </span><kbd>subscription-manager</kbd><span> </span>tool and the Pulp Consumer agent, again, no such equivalent exists for DEB hosts and so these must be configured manually.</p>
<p>Although it would be entirely possible to configure RPM-based hosts to use the built-in technologies, DEB-based ones would have to be configured with Ansible, just as for Pulp, and given the importance of commonality across environments in an enterprise, configuring all servers in the same manner rather than using two contrasting solutions for two different host types <span>is advised</span>.</p>
<p>One of the advantages that Katello brings over Pulp, other than the web user interface, is the concept of lifecycle environments. This feature acknowledges that most businesses will have separate technology environments for differing purposes. For example, your enterprise may well have a <kbd>Development</kbd> environment for developing new software and testing bleeding edge packages, then a <kbd>Testing</kbd> environment for testing releases, and finally, a <kbd>Production</kbd> environment where the most stable builds exist and services for customers and clients are run.</p>
<p>Let's now explore some hands-on examples of building up repositories in Katello for patching purposes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Patching RPM-based systems with Katello</h1>
                </header>
            
            <article>
                
<p>Let's consider the use of Katello to build repositories for our CentOS 7 system across multiple lifecycle environments. As Katello supports the key-based validation of RPMs, our first task is to install the GPG public key for the RPMs. A copy of this is freely downloadable from the CentOS project and can be found on most CentOS 7 systems in<span> </span><kbd>/etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7</kbd>:</p>
<ol>
<li>To add this public key to Katello, navigate to<span> </span><span class="packt_screen">Content </span>| <span class="packt_screen">Content Credentials</span><span> </span>from the menu bar. Then, click<span> </span><span class="packt_screen">Create Content Credential</span>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/297245cc-1c18-46cb-b391-c47095891413.png" style="width:66.33em;height:20.92em;"/></p>
<ol start="2">
<li>Give the key a suitable name and either upload the key file or copy and paste the contents of it into the textbox on the screen. Click<span> </span><span class="packt_screen">Save </span>when done:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a08c3782-45cf-4c7a-976c-9fb87a8dd655.png" style="width:46.00em;height:40.17em;"/></p>
<ol start="3">
<li>Next, we will create a<span> p</span>roduct—in Katello, a product is a logical grouping of repositories, and this is incredibly useful for creating manageable scalable configurations. For our example here, we will only mirror the CentOS 7 OS repository, but when you start mirroring the updates and any other related repositories, it would make sense to group these together under a single product. Navigate to<span class="packt_screen"> Content</span> | <span class="packt_screen">Products</span> from the menu bar, and then click on the <span class="packt_screen">Create Product</span> button:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/35a8669c-fb85-4020-a09d-a1c2e687ed71.png" style="width:68.33em;height:19.75em;"/></p>
<ol start="4">
<li>Now, define the high-level product definition—for a simple CentOS 7 repository mirror, we simply need to create<span> </span><span class="packt_screen">Name </span>and <span class="packt_screen">Label </span>and associate the GPG key we uploaded previously. The various SSL options are for upstream repositories that feature two-way SSL validation. Note also that all<span> p</span>roducts can be synced according to a<span> </span><span class="packt_screen">Sync Plan</span><span> </span>(essentially a schedule)—however, for this example, we will simply perform a manual sync. The screen should look something like the following screenshot when completed:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/26931f94-8f42-41be-9c41-d5328fbe124c.png" style="width:39.58em;height:33.67em;"/></p>
<ol start="5">
<li class="mce-root">With the high-level<span> p</span>roduct definition completed, we can now create our CentOS 7 repository under it by clicking on the <span class="packt_screen">New Repository</span><span> </span>button:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/53cbc588-6d07-44f0-a1ec-ff3ce5e81332.png" style="width:42.25em;height:16.92em;"/></p>
<ol start="6">
<li>Complete the repository details on the screen provided. Set the<span> </span><span class="packt_screen">Type </span>field as <kbd>yum</kbd> and enter the URL of the upstream repository in the appropriate field (this is the same as the<span> </span><kbd>--feed</kbd><span> </span>parameter when using Pulp from the command line):</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6b7704b4-a791-4ba9-871e-4539265262f9.png" style="width:49.33em;height:43.33em;"/></p>
<ol start="7">
<li>Scrolling down the same screen, ensure that <span class="packt_screen">Publish via HTTP</span> is ticked and associate the GPG uploaded previously, as shown in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ea8ad6ad-0fce-4b3e-a56f-ddf7fa4a9ff8.png" style="width:51.75em;height:45.58em;"/></p>
<ol start="8">
<li>For our example, we'll immediately kick off a sync of this repository by putting a tick against it in the table of repositories, and then clicking on the<span> </span><span class="packt_screen">Sync Now</span><span> </span>button, as shown in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1006c286-cd1b-469c-af25-1546fbaa4dff.png" style="width:44.50em;height:24.92em;"/></p>
<ol start="9">
<li>The synchronization begins in the background immediately—you can always check on its progress (and kick off further manual synchronizations) by navigating to the<span> </span><span class="packt_screen">Content</span> | <span class="packt_screen">Sync Status</span><span> </span>page:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/dcefb4f6-f7b2-4545-9218-c0e984eebb2c.png" style="width:44.50em;height:17.58em;"/></p>
<ol start="10">
<li>While the sync process completes, let's go and create some lifecycle environments.</li>
</ol>
<div class="packt_infobox" style="padding-left: 60px">Note that while you can have discrete products and separate repositories within them, lifecycle environments are global and apply to everything. In an enterprise context, this makes sense, as you would most likely still have a <kbd>Development</kbd>, <kbd>Test</kbd>, and <kbd>Production</kbd> environment regardless of which underlying technologies you use.</div>
<p style="padding-left: 60px">From the menu bar, navigate to <span class="packt_screen">Content</span> | <span class="packt_screen">Lifecycle Environments Paths</span>, and then click the <span class="packt_screen">Create Environment Path</span> button:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/bd7a5ecb-7368-4d01-9e73-ecfe76fa169d.png" style="width:71.25em;height:15.08em;"/></p>
<ol start="11">
<li>Create an initial environment called<span> </span><kbd>Development</kbd><span> </span>by following the instructions onscreen. You should be presented with a screen such as the one shown in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d6ce37b6-e0e3-4a2f-af0d-07e59c850993.png" style="width:60.92em;height:22.67em;"/></p>
<ol start="12">
<li>Now, we'll add<span> </span><kbd>Testing</kbd><span> </span>and<span> </span><kbd>Production</kbd><span> </span>environments so that our example enterprise has a logical flow through these three environments. Click the <span class="packt_screen">Add New Environment</span> button, and then add each in turn, ensuring they have the correct<span> </span><span class="packt_screen">Prior Environment</span><span> </span>set to maintain the correct sequence. The following screenshot shows an example of creating the<span> </span><kbd>Production</kbd><span> </span>environment as the next step from the <kbd>Testing</kbd> one:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/df0d5feb-c081-4af8-8c3b-b6ff16887dfe.png" style="width:55.00em;height:36.67em;"/></p>
<ol start="13">
<li>The final configuration should look like the following example screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d85fad6a-be3a-4d09-8015-c6600e48d68b.png" style="width:55.83em;height:20.50em;"/></p>
<p>Once our sync process has completed and we have created our environments, we can proceed to the final part of our RPM repository setup—<kbd>Content Views</kbd>. In Katello, a<span> c</span>ontent view<span> </span>is a user-defined amalgamation of the various content forms that can be ingested, version-controlled, and distributed to a given environment. This is best explained through a practical example.</p>
<p>When we used Pulp alone, we created a repository called<span> </span><kbd>centos7-07aug19</kbd>. When we wanted to test out an update released a day later, we then created a second repository called <kbd>centos7-08aug19</kbd>. Although this works, and we demonstrated how Pulp deduplicates packages and saves on disk space while neatly publishing apparently separate repositories, you can quickly see how this mechanism for content management could become unwieldy, especially at enterprise scale, with numerous environments and some months (or years) worth of snapshots to manage. </p>
<p>This is where<span> </span><kbd>Content Views</kbd><span> </span>come to the rescue. Although we have mirrored the CentOS 7<span> </span>OS<span> </span>repository here, suppose we had mirrored the updates one. With<span> </span><kbd>Content Views</kbd>, we don't need to create a new product or repository to test out updates. Instead, the workflow is, at a high level, as follows:</p>
<ol>
<li>Create a product and a corresponding repository and perform sync (for example, on August 7, 2019).</li>
<li>Create a content view<span> </span>containing the repository created in the previous step.</li>
<li>Publish<span> </span>the<span> c</span>ontent view<span> </span>on August 7, 2019—this creates a version-numbered snapshot of this repository on this date (for example, version<span> </span><kbd>1.0</kbd>).</li>
</ol>
<ol start="4">
<li>Promote<span> </span>the<span> co</span>ntent view<span> </span>to the<span> </span><kbd>Development</kbd><span> </span>environment. Perform testing, and when validated,<span> p</span>romote<span> </span>it to<span> t</span>esting. Repeat the cycle to reach<span> </span><kbd>Production</kbd>. This can all happen asynchronously to the next steps.</li>
<li>On August 8, perform another sync of the repository created in <em>step 1</em> (if you have an overnight sync happening automatically through<span> </span><kbd>Sync Plan</kbd>, this will already be done for you on the morning of the 8th).</li>
<li>Publish<span> </span>the<span> c</span>ontent view<span> </span>on August 8, 2019, following the sync. This creates a <kbd>+1</kbd> version of the repository for this date (for example, version 2.0).</li>
<li>Now, at this stage, you have snapshots of the CentOS 7 channel on both August 7 and 8. However, all servers will still receive updates from the August 7 channel.</li>
<li>Promote the <kbd>Development</kbd><span> </span>environment to version 2.0. The machines in the<span> </span><kbd>Development</kbd> environment now receive (with no additional configuration required on them) the repository snapshot of August 8.</li>
<li>The<span> </span><kbd>Testing</kbd><span> </span>and<span> </span><kbd>Production</kbd><span> </span>environments, which were not promoted to this version, still receive packages from the August 7 snapshot.</li>
</ol>
<p>In this way, Katello makes managing numerous versions (snapshots) of repositories easy across differing environments, with the added bonus that the repository configuration on each host always remains the same, removing the need to push new repository information through Ansible as we did with Pulp.</p>
<p>Let's step through an example of the preceding process in our demo Katello environment:</p>
<ol>
<li>First of all, create a new<span> c</span>ontent view<span> </span>for the preceding process.</li>
<li>Navigate to<span> </span><span class="packt_screen">Content</span> | <span class="packt_screen">Content Views</span> and click on the <span class="packt_screen">Create New View</span><span> </span>button:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b349a091-5436-4619-9626-6d551074b7de.png" style="width:65.33em;height:18.33em;"/></p>
<ol start="3">
<li>For our purposes, the new<span> c</span>ontent view<span> </span>only requires a<span> </span><span class="packt_screen">Name </span>and a<span> </span><span class="packt_screen">Label</span>, such as those shown in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/40de9c68-22df-4e22-86ad-2779beea0b59.png" style="width:45.58em;height:41.58em;"/></p>
<ol start="4">
<li>Once you have clicked on the<span> </span><span class="packt_screen">Save </span>button, navigate to the<span class="packt_screen"> Yum Content</span><span> </span>tab within the new<span> c</span>ontent view, and ensure the<span> </span><span class="packt_screen">Add </span>sub-tab is selected. Tick the repositories you want to add to the<span> c</span>ontent view<span> </span>(in our simple demo, we only have one CentOS 7 repository, so select that), and click on the<span> </span><span class="packt_screen">Add Repositories</span><span> </span>button:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f2e6291c-668a-4c9a-bddc-38ecf5fdde73.png" style="width:57.75em;height:33.08em;"/></p>
<ol start="5">
<li>Now, navigate back to the<span> </span><span class="packt_screen">Versions </span>tab and click the<span> </span><span class="packt_screen">Publish New Version</span><span> </span>button. This creates the hypothetical August 7 version we discussed earlier. Note that<span> </span><kbd>Publish</kbd><span> </span>and<span> </span><kbd>Promote</kbd><span> </span>operations take an enormous amount of disk I/O and will be very slow, especially on slow mechanically-backed storage arrays. Although there are no published requirements for I/O performance for either Katello or Red Hat Satellite 6, they perform best on flashbacked storage, or if this is not available, fast mechanical storage that is not shared with other devices. The following screenshot shows the <span class="packt_screen">Publish New Version</span> button being clicked for the <span class="packt_screen">CentOS7-CV</span> content view:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/18d3d821-672a-438b-a2d0-31eb509e2743.png" style="width:50.33em;height:23.00em;"/></p>
<ol start="6">
<li>The<span> </span><kbd>Publish</kbd><span> </span>operation is asynchronous and you can see it complete on this screen, although if you navigate away, it will still complete. You can see that it is automatically numbered<span> </span><kbd>Version 1.0</kbd>—this numbering is, at the time of writing, automatic and you cannot choose your own version numbering. You can, however, add notes to each published version, which can be incredibly useful to track which version is which and why they were created. This is highly recommended. The following screenshot shows the promotion in progress on our <span class="packt_screen">Version 1.0</span> environment:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a3085c99-6872-424c-85d1-6139960f698f.png" style="width:48.83em;height:25.92em;"/></p>
<ol start="7">
<li>Once the<span> </span><kbd>Publish</kbd><span> </span>operation is completed, the<span> </span><span class="packt_screen">Promote </span>button (shown grayed out in the preceding screenshot) will become active. You will note that this version is automatically published to the<span> </span><kbd>Library</kbd><span> </span>environment—the latest version of any<span> c</span>ontent view<span> </span>is always automatically promoted to this environment.</li>
</ol>
<ol start="8">
<li>To simulate the August 8 snapshot we discussed earlier, let's perform a second<span> p</span>ublish<span> </span><span>of this</span><span> c</span>ontent view<span>. This will produce a</span><span> </span><kbd>Version 2.0</kbd><span> </span><span>environment, which can then be promoted to the</span><span> </span><kbd>Development</kbd><span> </span><span>environment by clicking on the</span><span> </span><span class="packt_screen">Promote </span><span>button and selecting the required environment. The following screenshot shows our two versions, with</span><span> </span><kbd>Version 1.0</kbd><span> </span><span>available to only the</span><span> </span><kbd>Production</kbd><span> </span><span>environment and</span><span> </span><kbd>Version 2.0</kbd><span> </span><span>available to the</span><span> </span><kbd>Development</kbd><span> </span><span>environment (and the built-in</span><span> </span><kbd>Library</kbd><span> </span><span>one). Note that as we have not promoted the</span><span> </span><kbd>Testing</kbd><span> </span><span>environment to either version and that no packages are available to machines in the</span><span> </span><kbd>Testing</kbd><span> </span><span>environment. You must promote it to all environments that require packages—the following screenshot shows the two versions we have published and which environments are associated with which versions:</span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/36dbb6a8-4951-4c14-9e87-23849b449769.png" style="width:53.33em;height:30.58em;"/></p>
<ol start="9">
<li>In the following screenshot, the promotion process is shown for reference—this is how you would promote the<span> </span><kbd>Production</kbd><span> </span>environment to <kbd>Version 2.0</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ac078f46-00c1-49c2-baae-24a7300a57c0.png" style="width:46.00em;height:30.33em;"/></p>
<p>The one remaining piece of the puzzle here is to configure the clients to receive packages from the Katello server. Here, we will perform a simple manual integration, as this method is common to both DEB- and RPM-based packages and hence supports a common approach across the enterprise. The process for distributing RPM packages from Katello using the <kbd>subscription-manager</kbd> tool and the Katello agent is well documented and is left as an exercise for you.</p>
<div class="packt_tip">The official Katello documentation for Activation Keys is a good place to start: <a href="https://theforeman.org/plugins/katello/3.12/user_guide/activation_keys/index.html">https://theforeman.org/plugins/katello/3.12/user_guide/activation_keys/index.html</a></div>
<p>To make use of the content we have published in this example, machines in the <kbd>Development</kbd> environment would have a repository file with content such as this:</p>
<pre>[centos-os]<br/>name=CentOS-os<br/>baseurl=http://katello.example.com/pulp/repos/HandsOn/Development/CentOS7-CV/custom/CentOS7/CentOS7-os/<br/>gpgcheck=1<br/>gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7</pre>
<p>Your base URL will surely vary—at the very least, your Katello hostname will be different. RPM-based repositories published and promoted in Katello are generally available at the following path:</p>
<pre>http://KATELLOHOSTNAME/pulp/repos/ORGNAME/LIFECYCLENAME/CONTENTVIEWNAME/custom/PRODUCT/REPO</pre>
<p>Here, we have the following:</p>
<ul>
<li><kbd>KATELLOHOSTNAME</kbd><span>:</span> The hostname of your Katello server (or nearest Capsule/Proxy if you are using them)</li>
<li><kbd>ORGNAME</kbd>: The name of the Katello organization in which your<span> </span><kbd>Content View</kbd><span> </span>lives—we defined ours as<span> </span><kbd>HandsOn</kbd><span> </span>during the installation process</li>
<li><kbd>LIFECYCLENAME</kbd>: The name of the<span> </span><kbd>Lifecycle Environment</kbd><span>, </span>for example,<span> </span><kbd>Development</kbd></li>
<li><kbd>CONTENTVIEWNAME</kbd><span>:</span> The name you gave your<span> </span><kbd>Content View</kbd></li>
<li><kbd>PRODUCT</kbd>: The name you gave your<span> </span><kbd>Product</kbd></li>
<li><kbd>REPO</kbd>: The name you gave to your repository within the <kbd>Product</kbd></li>
</ul>
<p>This makes the URLs entirely predictable and easy to deploy to target machines using Ansible, just as we did in the previous chapter regarding Pulp. Note that accessing the repositories over HTTPS from Katello requires the installation of SSL certificates for trust validation, which is beyond the scope of this chapter—instead, we will simply make use of plain HTTP. </p>
<p>As the lifecycle environment name remains constant, no matter whether we sync, publish, or promote an environment, the repository URL, as shown previously, remains constant and hence we never have to perform client configuration work even when a new package repository snapshot is published. This is a significant advantage over Pulp, where we would have to push a new configuration using Ansible every time a new version is created.</p>
<p>Once the repository configuration has been built as shown previously, you can patch your systems in the normal manner. This can be done as follows:</p>
<ul>
<li>Manually, using a command such as <kbd>yum update</kbd> on each machine</li>
<li>Centrally, using an Ansible playbook</li>
<li>From the Katello user interface, if the <kbd>katello-agent</kbd> package is installed on your target machines</li>
</ul>
<p>Given the varied nature of the tools available, we won't go into any greater depth in this chapter but will instead leave this as an exercise for you. Experience has shown that central deployment using Ansible is the most robust method, but you are welcome to experiment and find the path that best suits you.</p>
<p>That concludes our brief tour of RPM-based patching with Katello, though it is hoped that it has shown you enough to give you a taste of how it might prove valuable in your enterprise. In the next section, we will look at the process of patching DEB-based systems with Katello.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Patching DEB-based systems with Katello</h1>
                </header>
            
            <article>
                
<p>The patching of DEB-based systems such as Ubuntu through Katello is broadly similar to the RPM-based process, save for a few changes in the GUI, and the limitations around package signing discussed earlier in this chapter, in the section entitled <em>Patching with Katello</em>. Let's briefly walk through an example now for Ubuntu Server 18.04:</p>
<ol>
<li>First, create a new<span> p</span>roduct<span> </span>for our Ubuntu package repositories:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8a9cd793-af6b-4363-bde9-1078af389a4a.png" style="width:54.00em;height:42.08em;"/></p>
<p style="padding-left: 60px">It is important to state here that importing the Ubuntu signing public key makes no impact on the published repository and so can be specified or ignored as you prefer. The resulting repository will not have a signed<span> </span><kbd>Release</kbd><span> </span>file and so must be treated as implicitly trusted.</p>
<ol start="2">
<li>Once the<span> p</span>roduct<span> </span>is saved, create a new repository within it to contain the packages—the package mirror creation requires the same parameters we used on the command line with Pulp, as shown in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/fd1b6d35-33e7-467d-b114-97ceb2bad4cb.png" style="width:55.42em;height:49.75em;"/></p>
<p style="padding-left: 60px">Sync the newly created repository as before, and ensure this has completed successfully before proceeding to the<span> c</span>ontent view<span> </span>creation.</p>
<ol start="3">
<li>Once it has, create a separate<span> c</span>ontent view for our Ubuntu content—the following screenshot shows the content view creation in progress:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0d780fe5-028d-40bf-b06b-f3f149b67d91.png" style="width:51.58em;height:47.25em;"/></p>
<ol start="4">
<li>This time, navigate to the<span> </span><span class="packt_screen">Apt Repositories</span><span> </span>tab and select the appropriate Ubuntu repositories—again, in our simple example here, we only have one, and the following screenshot shows the process of our lone <kbd>Ubuntu 18.04 base</kbd> repository being added to the <span class="packt_screen">Ubuntu1804-CV</span> content view:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2bc88f84-14e4-4c39-bbb2-575f236c5213.png" style="width:58.50em;height:33.17em;"/></p>
<ol start="5">
<li>From here, our new content view is published and promoted just as we did for the RPM-based one. The resulting repository is accessible again at a predictable URL, this time being of the following pattern:</li>
</ol>
<pre style="padding-left: 60px">http://KATELLOHOSTNAME/pulp/deb/ORGNAME/LIFECYCLENAME/CONTENTVIEWNAME/custom/PRODUCT/REPO</pre>
<p>As can be seen, this is almost identical to the RPM-based example, save for the initial path. An appropriate entry for<span> </span><kbd>/etc/apt/sources.list</kbd><span> </span>to match the<span> c</span>ontent view<span> </span>we just created in this example might look like this:</p>
<pre>deb [trusted=yes] http://katello.example.com/pulp/deb/HandsOn/Development/Ubuntu1804-CV/custom/Ubuntu_18_04_Server/Ubuntu_18_04_base/ bionic main</pre>
<p>As before, this URL remains constant regardless of when we might sync, publish, or promote this content view and so it need only be deployed once to target systems to ensure they can receive packages from the Katello server. Again, you can perform this patching manually through the <kbd>apt update</kbd> and <kbd>apt upgrade</kbd> commands on the end systems, or centrally through Ansible.</p>
<div class="packt_infobox">Note that there is no <kbd>katello-agent</kbd> package for Debian/Ubuntu-based systems at the time of writing.</div>
<p>In this chapter, we have barely scratched the surface of all that Katello can do, yet this example alone demonstrates how effective a tool it is for enterprise patch management. It is highly recommended that you explore this further to establish whether it meets your wider infrastructure needs.</p>
<p>It must be stressed that, in this chapter, we have really only scratched the surface of what Katello can do—however, it is hoped that the work we have done so far gives you enough to make an informed decision on whether to proceed with this incredibly powerful and versatile platform as part of your Linux architecture.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Katello is actually an amalgamation of several incredibly powerful open source infrastructure management tools, including Pulp, which we have already explored. It is incredibly adept at patch management in an infrastructure setting, offering numerous advantages over a standalone Pulp installation and can handle most build and maintenance tasks from a single pane of glass—more than we have had space to cover!</p>
<p>In this chapter, you gained an understanding of what the Katello project actually is and the components that it is comprised of. You then learned how to perform a standalone installation of Katello for patching purposes and then how to build out repositories suitable for patching both RPM- and DEB-based Linux distributions and the basics of integrating these two operating systems with Katello content views.</p>
<p class="mce-root">In the next chapter, we will explore how Ansible can be effectively employed in an enterprise for user management.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>Why would you want to use Katello over a product such as Pulp?</li>
<li>What is a Product in Katello terms?</li>
<li>What is a content view in Katello?</li>
<li>Can Foreman (which underpins Katello) assist with the PXE booting of bare-metal servers?</li>
<li>How would you use lifecycle environments in Katello?</li>
<li>What is the difference between the <kbd>Publish</kbd> and <kbd>Promote</kbd> operations on a content view?</li>
<li>When would you want to perform a <kbd>Promote</kbd> operation on a previously published content view?</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p>For a greater understanding of Katello, please refer to the official Red Hat Satellite 6 documentation as this is the commercial version of Katello and all of the documentation is usually written for this platform—however, the features and menu structure are almost identical (<a href="https://access.redhat.com/documentation/en-us/red_hat_satellite/">https://access.redhat.com/documentation/en-us/red_hat_satellite/</a>).</p>


            </article>

            
        </section>
    </body></html>