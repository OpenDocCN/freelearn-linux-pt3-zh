<html><head></head><body>
<div class="Basic-Text-Frame" id="_idContainer035">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">2</span></h1>
<h1 class="chapterTitle" id="_idParaDest-42"><span class="koboSpan" id="kobo.2.1">Working with Processes</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">As a developer, you are already intuitively familiar with processes. </span><span class="koboSpan" id="kobo.3.2">They are the fruits of your labor: after writing and debugging code, your program finally executes, transforming into a beautiful operating system process!</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4.1">A process on</span><a id="_idIndexMarker044"/><span class="koboSpan" id="kobo.5.1"> Linux can be a long-running application, a quick shell command like </span><code class="inlineCode"><span class="koboSpan" id="kobo.6.1">ls</span></code><span class="koboSpan" id="kobo.7.1">, or anything that the kernel spawns to do some work on the system. </span><span class="koboSpan" id="kobo.7.2">If something is getting done in Linux, a process is doing it. </span><span class="koboSpan" id="kobo.7.3">Your web browser, text editor, vulnerability scanner, and even things like reading files and the commands you’ve learned so far all spawn a process.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.8.1">Linux’s process model is important to </span><a id="_idIndexMarker045"/><span class="koboSpan" id="kobo.9.1">understand because the abstraction it gives you – the Linux process – is what all the commands and tools you’ll use to manage processes depend on. </span><span class="koboSpan" id="kobo.9.2">Gone are the details you’re used to seeing from a developer’s perspective: variables, functions, and threads have all been encapsulated as “a process.” </span><span class="koboSpan" id="kobo.9.3">You’re left with a different, external set of knobs to manipulate and gauges to check: process ID, status, resource usage, and all the other process attributes we’ll be covering in this chapter.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.10.1">First, we’ll take a close look at the process abstraction itself, and then we’ll dive into useful, practical things you can do with Linux processes. </span><span class="koboSpan" id="kobo.10.2">While we’re covering the practical aspects, we’ll pause to add detail to a few aspects that are a common source of problems, like permissions, and give you some heuristics for troubleshooting processes.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.11.1">In this chapter, you’ll learn about the following topics:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.12.1">What a Linux process is, and how to see the processes currently running on your system</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.13.1">The attributes a process has, so you know what information you can gather while troubleshooting</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.14.1">Common commands for viewing and finding processes</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.15.1">More advanced topics that can come in handy for a developer actually writing programs that </span><a id="_idIndexMarker046"/><span class="koboSpan" id="kobo.16.1">execute as Linux processes: Signals and inter-process communication, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.17.1">/proc</span></code><span class="koboSpan" id="kobo.18.1"> virtual filesystem, seeing open file handles with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.19.1">lsof</span></code><span class="koboSpan" id="kobo.20.1"> command, and how processes are created in Linux</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.21.1">You’ll also get a practical review of everything you’ve learned in an example troubleshooting session that uses the theory and commands we cover in this chapter. </span><span class="koboSpan" id="kobo.21.2">Now, let’s dive into what exactly a Linux process is.</span></p>
<h1 class="heading-1" id="_idParaDest-43"><span class="koboSpan" id="kobo.22.1">Process basics</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.23.1">When we refer to a “process” in Linux, we’re referring to the operating system’s internal model of what exactly a</span><a id="_idIndexMarker047"/><span class="koboSpan" id="kobo.24.1"> running program </span><em class="italic"><span class="koboSpan" id="kobo.25.1">is</span></em><span class="koboSpan" id="kobo.26.1">. </span><span class="koboSpan" id="kobo.26.2">Linux needs a general abstraction that works for </span><em class="italic"><span class="koboSpan" id="kobo.27.1">all</span></em><span class="koboSpan" id="kobo.28.1"> programs, which can encapsulate the things the operating system cares about. </span><span class="koboSpan" id="kobo.28.2">A process is that abstraction, and it enables the OS to track some of the important context around programs that are executing; namely:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.29.1">Memory usage</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.30.1">Processor time used</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.31.1">Other system resource usage (disk access, network usage)</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.32.1">Communication between processes</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.33.1">Related processes that a program starts, for example, firing off a shell command</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.34.1">You can get a listing of all system processes (at least the ones your user is allowed to see) by running the </span><code class="inlineCode"><span class="koboSpan" id="kobo.35.1">ps</span></code><span class="koboSpan" id="kobo.36.1"> program with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.37.1">aux</span></code><span class="koboSpan" id="kobo.38.1"> flags:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.39.1"><img alt="" role="presentation" src="../Images/B19251_02_01.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.40.1">Figure 2.1: List of system processes</span></p>
<p class="normal"><span class="koboSpan" id="kobo.41.1">We’ll cover the attributes </span><a id="_idIndexMarker048"/><span class="koboSpan" id="kobo.42.1">most relevant to your work as a developer in this chapter.</span></p>
<h2 class="heading-2" id="_idParaDest-44"><span class="koboSpan" id="kobo.43.1">What is a Linux process made of?</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.44.1">From the perspective of the operating system, a “process” is simply a data structure that makes it easy to access </span><a id="_idIndexMarker049"/><span class="koboSpan" id="kobo.45.1">information like:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.46.1">Process ID</span></strong><span class="koboSpan" id="kobo.47.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.48.1">PID</span></strong><span class="koboSpan" id="kobo.49.1"> in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.50.1">ps</span></code><span class="koboSpan" id="kobo.51.1"> output above). </span><span class="koboSpan" id="kobo.51.2">PID 1 is the init system – the original parent of all other processes, which </span><a id="_idIndexMarker050"/><span class="koboSpan" id="kobo.52.1">bootstraps the system. </span><span class="koboSpan" id="kobo.52.2">The kernel starts this as one of the</span><a id="_idIndexMarker051"/><span class="koboSpan" id="kobo.53.1"> first things it does after starting to execute. </span><span class="koboSpan" id="kobo.53.2">When a process is created, it gets the next available process ID, in sequential order. </span><span class="koboSpan" id="kobo.53.3">Because it is so important to the normal functioning of the operating system, init cannot be killed, even by the root user. </span><span class="koboSpan" id="kobo.53.4">Different Unix operating systems use different init systems – for example, most Linux distributions use </span><code class="inlineCode"><span class="koboSpan" id="kobo.54.1">systemd</span></code><span class="koboSpan" id="kobo.55.1">, while macOS uses </span><code class="inlineCode"><span class="koboSpan" id="kobo.56.1">launchd</span></code><span class="koboSpan" id="kobo.57.1">, and many other Unixes use SysV. </span><span class="koboSpan" id="kobo.57.2">Regardless of the specific implementation, we’ll refer to this process by the name of the role</span><a id="_idIndexMarker052"/><span class="koboSpan" id="kobo.58.1"> it fills: “init.” </span><div class="note">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.59.1">Note</span></strong></p>
<p class="normal"><span class="koboSpan" id="kobo.60.1">In containers, processes are namespaced – in the “real” environment, all container processes might be PID 3210, while that single PID maps to lots of processes (</span><code class="inlineCode"><span class="koboSpan" id="kobo.61.1">1..n</span></code><span class="koboSpan" id="kobo.62.1">, where </span><code class="inlineCode"><span class="koboSpan" id="kobo.63.1">n</span></code><span class="koboSpan" id="kobo.64.1"> is the number of running processes in the container). </span><span class="koboSpan" id="kobo.64.2">You can see this from outside but </span><a id="_idIndexMarker053"/><span class="koboSpan" id="kobo.65.1">not inside the container.</span></p>
</div>
</li>
</ul>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.66.1">Parent Process PID</span></strong><span class="koboSpan" id="kobo.67.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.68.1">PPID</span></strong><span class="koboSpan" id="kobo.69.1">). </span><span class="koboSpan" id="kobo.69.2">Each process</span><a id="_idIndexMarker054"/><span class="koboSpan" id="kobo.70.1"> is spawned by a parent. </span><span class="koboSpan" id="kobo.70.2">If the parent process dies </span><a id="_idIndexMarker055"/><span class="koboSpan" id="kobo.71.1">while the child is alive, the child becomes an “orphan.” </span><span class="koboSpan" id="kobo.71.2">Orphaned processes are re-parented to init (PID 1).</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.72.1">Status </span></strong><span class="koboSpan" id="kobo.73.1">(</span><strong class="keyWord"><span class="koboSpan" id="kobo.74.1">STAT</span></strong><span class="koboSpan" id="kobo.75.1"> in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.76.1">ps</span></code><span class="koboSpan" id="kobo.77.1"> output </span><a id="_idIndexMarker056"/><span class="koboSpan" id="kobo.78.1">above). </span><code class="inlineCode"><span class="koboSpan" id="kobo.79.1">man ps</span></code><span class="koboSpan" id="kobo.80.1"> will show you an overview:</span><ul>
<li class="bulletList"><span class="koboSpan" id="kobo.81.1">D – uninterruptible sleep (usually IO)</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.82.1">I – idle kernel thread</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.83.1">R – running or runnable (on run queue)</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.84.1">S – interruptible sleep (waiting for an event to complete)</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.85.1">T – stopped by job control signal</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.86.1">t – stopped by debugger during tracing</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.87.1">X – dead (should never be seen)</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.88.1">Z – defunct (“zombie”) process, terminated but not reaped by its parent</span></li>
</ul>
</li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.89.1">Priority </span></strong><span class="koboSpan" id="kobo.90.1">status (“niceness” – does this</span><a id="_idIndexMarker057"/><span class="koboSpan" id="kobo.91.1"> process allow other processes to take priority over it?).</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.92.1">A process </span><strong class="keyWord"><span class="koboSpan" id="kobo.93.1">Owner </span></strong><span class="koboSpan" id="kobo.94.1">(USER in </span><a id="_idIndexMarker058"/><span class="koboSpan" id="kobo.95.1">the </span><code class="inlineCode"><span class="koboSpan" id="kobo.96.1">ps</span></code><span class="koboSpan" id="kobo.97.1"> output above); the effective user ID.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.98.1">Effective </span><strong class="keyWord"><span class="koboSpan" id="kobo.99.1">Group ID</span></strong><span class="koboSpan" id="kobo.100.1"> (EGID), which</span><a id="_idIndexMarker059"/><span class="koboSpan" id="kobo.101.1"> is used.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.102.1">An </span><strong class="keyWord"><span class="koboSpan" id="kobo.103.1">address map</span></strong><span class="koboSpan" id="kobo.104.1"> of the process’s</span><a id="_idIndexMarker060"/><span class="koboSpan" id="kobo.105.1"> memory space.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.106.1">Resource usage – open files, network ports, and other resources the process is using (</span><strong class="keyWord"><span class="koboSpan" id="kobo.107.1">VSZ</span></strong><span class="koboSpan" id="kobo.108.1"> and </span><strong class="keyWord"><span class="koboSpan" id="kobo.109.1">RSS</span></strong><span class="koboSpan" id="kobo.110.1"> for memory usage in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.111.1">ps</span></code><span class="koboSpan" id="kobo.112.1"> output above).</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.113.1">(Citation: from the </span><em class="italic"><span class="koboSpan" id="kobo.114.1">Unix and Linux System Administration Handbook</span></em><span class="koboSpan" id="kobo.115.1">, </span><em class="italic"><span class="koboSpan" id="kobo.116.1">5th edition</span></em><span class="koboSpan" id="kobo.117.1">, p.91.)</span></p>
<p class="normal"><span class="koboSpan" id="kobo.118.1">Let’s take a closer look at a few of the process attributes that are most important for developers and occasional troubleshooters to understand.</span></p>
<h2 class="heading-2" id="_idParaDest-45"><span class="koboSpan" id="kobo.119.1">Process ID (PID)</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.120.1">Each process is uniquely identifiable by its </span><a id="_idIndexMarker061"/><span class="koboSpan" id="kobo.121.1">process ID, which is just a unique integer that is assigned to a process when it starts. </span><span class="koboSpan" id="kobo.121.2">Much like a relational </span><a id="_idIndexMarker062"/><span class="koboSpan" id="kobo.122.1">database with IDs that uniquely identify each row of data, the Linux operating system keeps track of each process by its PID. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.123.1">A PID is by far the most useful label for you to use when interacting with processes.</span></p>
<h2 class="heading-2" id="_idParaDest-46"><span class="koboSpan" id="kobo.124.1">Effective User ID (EUID) and Effective Group ID (EGID)</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.125.1">These determine </span><a id="_idIndexMarker063"/><span class="koboSpan" id="kobo.126.1">which system user and group your process is running as. </span><span class="koboSpan" id="kobo.126.2">Together, user</span><a id="_idIndexMarker064"/><span class="koboSpan" id="kobo.127.1"> and group permissions determine what a process is allowed to do on the system.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.128.1">As you’ll see in </span><em class="chapterRef"><span class="koboSpan" id="kobo.129.1">Chapter 5</span></em><span class="koboSpan" id="kobo.130.1">, </span><em class="italic"><span class="koboSpan" id="kobo.131.1">Introducing Files</span></em><span class="koboSpan" id="kobo.132.1">, files have</span><a id="_idIndexMarker065"/><span class="koboSpan" id="kobo.133.1"> user and group ownership set on them, which determines who their permissions apply to. </span><span class="koboSpan" id="kobo.133.2">If a file’s ownership </span><a id="_idIndexMarker066"/><span class="koboSpan" id="kobo.134.1">and permissions are essentially a lock, then a process with the right user/group permissions is like a key that opens the lock and allows access to the file. </span><span class="koboSpan" id="kobo.134.2">We’ll dive deeper into this later, when we talk about permissions.</span></p>
<h2 class="heading-2" id="_idParaDest-47"><span class="koboSpan" id="kobo.135.1">Environment variables</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.136.1">You’ve probably used environment variables </span><a id="_idIndexMarker067"/><span class="koboSpan" id="kobo.137.1">in your applications – they’re a way for the operating system environment that launches your process to pass in data that the</span><a id="_idIndexMarker068"/><span class="koboSpan" id="kobo.138.1"> process needs. </span><span class="koboSpan" id="kobo.138.2">This commonly includes things like configuration directives (</span><code class="inlineCode"><span class="koboSpan" id="kobo.139.1">LOG_DEBUG=1</span></code><span class="koboSpan" id="kobo.140.1">) and secret keys (</span><code class="inlineCode"><span class="koboSpan" id="kobo.141.1">AWS_SECRET_KEY</span></code><span class="koboSpan" id="kobo.142.1">), and every programming language has some way to read them out from the context of the program.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.143.1">For example, this Python script gets the user’s home directory from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.144.1">HOME</span></code><span class="koboSpan" id="kobo.145.1"> environment variable, and then prints it:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.146.1">import</span></span><span class="koboSpan" id="kobo.147.1"> os
home_dir = os.environ[</span><span class="hljs-string"><span class="koboSpan" id="kobo.148.1">'HOME'</span></span><span class="koboSpan" id="kobo.149.1">]
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.150.1">print</span></span><span class="koboSpan" id="kobo.151.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.152.1">"The home directory for this user is"</span></span><span class="koboSpan" id="kobo.153.1">, home_dir)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.154.1">In my case, running this </span><a id="_idIndexMarker069"/><span class="koboSpan" id="kobo.155.1">program in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.156.1">python3</span></code><span class="koboSpan" id="kobo.157.1"> REPL on a Linux machine results in the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.158.1">The home directory for this user is /home/dcohen 
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-48"><span class="koboSpan" id="kobo.159.1">Working directory</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.160.1">A process has a “current working directory,” just like your shell (which is just a process, anyway). </span><span class="koboSpan" id="kobo.160.2">Typing </span><code class="inlineCode"><span class="koboSpan" id="kobo.161.1">pwd</span></code><span class="koboSpan" id="kobo.162.1"> in your shell </span><a id="_idIndexMarker070"/><span class="koboSpan" id="kobo.163.1">prints its current working directory, and every</span><a id="_idIndexMarker071"/><span class="koboSpan" id="kobo.164.1"> process has a working directory. </span><span class="koboSpan" id="kobo.164.2">The working directory for a process can change, so don’t rely on it too much.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.165.1">This concludes our overview of the process attributes that you should know about. </span><span class="koboSpan" id="kobo.165.2">In the next section, we’ll step away from theory and look at some commands you can use to start working with processes right away.</span></p>
<h1 class="heading-1" id="_idParaDest-49"><span class="koboSpan" id="kobo.166.1">Practical commands for working with Linux processes</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.167.1">Here are some of the commands you’ll use most often:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.168.1">ps</span></code><span class="koboSpan" id="kobo.169.1"> – Shows processes on the system; you saw </span><a id="_idIndexMarker072"/><span class="koboSpan" id="kobo.170.1">an example of this command earlier in the chapter. </span><span class="koboSpan" id="kobo.170.2">Flags modify which process attributes are displayed as columns. </span><span class="koboSpan" id="kobo.170.3">This command is usually used with filters to </span><a id="_idIndexMarker073"/><span class="koboSpan" id="kobo.171.1">control how much output you get, for example, (</span><code class="inlineCode"><span class="koboSpan" id="kobo.172.1">ps aux | head –n 10</span></code><span class="koboSpan" id="kobo.173.1">) to cut your output down to just the top 10 lines. </span><span class="koboSpan" id="kobo.173.2">A few more useful tricks:</span><ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.174.1">ps –eLf</span></code><span class="koboSpan" id="kobo.175.1"> shows thread information for processes</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.176.1">ps -ejH</span></code><span class="koboSpan" id="kobo.177.1"> is useful for seeing the relationships between parent and child processes visually (children are indented under their parents)</span></li>
</ul>
<figure class="mediaobject"><span class="koboSpan" id="kobo.178.1"><img alt="" role="presentation" src="../Images/B19251_02_02.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.179.1">Figure 2.2: Examples of outputs of the ps command with flags</span></p>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.180.1">pgrep</span></code><span class="koboSpan" id="kobo.181.1"> – Find process IDs by </span><a id="_idIndexMarker074"/><span class="koboSpan" id="kobo.182.1">name. </span><span class="koboSpan" id="kobo.182.2">Can </span><a id="_idIndexMarker075"/><span class="koboSpan" id="kobo.183.1">use regular expressions.</span></li>
</ul>
<figure class="mediaobject"><span class="koboSpan" id="kobo.184.1"><img alt="" role="presentation" src="../Images/B19251_02_03.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.185.1">Figure 2.3: Examples of outputs of the pgrep command with flags</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.186.1">top</span></code><span class="koboSpan" id="kobo.187.1"> – An interactive program that polls all processes (once a second, by default) and outputs a</span><a id="_idIndexMarker076"/><span class="koboSpan" id="kobo.188.1"> sorted list of resource usage (you can configure what it sorts by). </span><span class="koboSpan" id="kobo.188.2">Also displays </span><a id="_idIndexMarker077"/><span class="koboSpan" id="kobo.189.1">total system resource usage. </span><span class="koboSpan" id="kobo.189.2">Press </span><em class="keystroke"><span class="koboSpan" id="kobo.190.1">Q</span></em><span class="koboSpan" id="kobo.191.1"> or use </span><em class="keystroke"><span class="koboSpan" id="kobo.192.1">Ctrl </span></em><span class="koboSpan" id="kobo.193.1">+ </span><em class="keystroke"><span class="koboSpan" id="kobo.194.1">C</span></em><span class="koboSpan" id="kobo.195.1"> to quit. </span><span class="koboSpan" id="kobo.195.2">You’ll see an example of this command’s output later in this chapter.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.196.1">iotop</span></code><span class="koboSpan" id="kobo.197.1"> – Like </span><code class="inlineCode"><span class="koboSpan" id="kobo.198.1">top</span></code><span class="koboSpan" id="kobo.199.1">, but for disk IO. </span><span class="koboSpan" id="kobo.199.2">Extremely</span><a id="_idIndexMarker078"/><span class="koboSpan" id="kobo.200.1"> useful for </span><a id="_idIndexMarker079"/><span class="koboSpan" id="kobo.201.1">finding IO-hungry processes. </span><span class="koboSpan" id="kobo.201.2">Not installed on all systems by default, but available via most package managers.</span></li>
</ul>
<figure class="mediaobject"><span class="koboSpan" id="kobo.202.1"><img alt="" role="presentation" src="../Images/B19251_02_04.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.203.1">Figure 2.4: Example of output of the iotop command</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.204.1">nethogs</span></code><span class="koboSpan" id="kobo.205.1"> – Like </span><code class="inlineCode"><span class="koboSpan" id="kobo.206.1">top</span></code><span class="koboSpan" id="kobo.207.1">, but for network IO. </span><span class="koboSpan" id="kobo.207.2">Groups network usage by process, which is incredibly</span><a id="_idIndexMarker080"/><span class="koboSpan" id="kobo.208.1"> convenient. </span><span class="koboSpan" id="kobo.208.2">Available </span><a id="_idIndexMarker081"/><span class="koboSpan" id="kobo.209.1">via most package managers.</span></li>
</ul>
<figure class="mediaobject"><span class="koboSpan" id="kobo.210.1"><img alt="" role="presentation" src="../Images/B19251_02_05.png"/></span></figure>
<figure class="mediaobject"><span class="koboSpan" id="kobo.211.1">Figure 2.5: Example of output of the nethogs command</span></figure>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.212.1">kill</span></code><span class="koboSpan" id="kobo.213.1"> – Allows users to </span><a id="_idIndexMarker082"/><span class="koboSpan" id="kobo.214.1">send signals to </span><a id="_idIndexMarker083"/><span class="koboSpan" id="kobo.215.1">processes, usually to stop them or make them re-read their configuration files. </span><span class="koboSpan" id="kobo.215.2">We’ll explain signals and </span><code class="inlineCode"><span class="koboSpan" id="kobo.216.1">kill</span></code><span class="koboSpan" id="kobo.217.1"> command usage later in this chapter.</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-50"><span class="koboSpan" id="kobo.218.1">Advanced process concepts and tools</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.219.1">This marks the beginning of the “advanced” section of this chapter. </span><span class="koboSpan" id="kobo.219.2">While you don’t need to master all the concepts in this </span><a id="_idIndexMarker084"/><span class="koboSpan" id="kobo.220.1">section to work effectively with Linux processes, they can be extremely helpful. </span><span class="koboSpan" id="kobo.220.2">If you have a few extra minutes, we recommend at least familiarizing yourself with each one.</span></p>
<h2 class="heading-2" id="_idParaDest-51"><span class="koboSpan" id="kobo.221.1">Signals</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.222.1">How does </span><code class="inlineCode"><span class="koboSpan" id="kobo.223.1">systemctl</span></code><span class="koboSpan" id="kobo.224.1"> tell your web server to re-read its configuration files? </span><span class="koboSpan" id="kobo.224.2">How can you politely ask a process to shut down cleanly? </span><span class="koboSpan" id="kobo.224.3">And how can you kill a malfunctioning process immediately, because it’s bringing </span><a id="_idIndexMarker085"/><span class="koboSpan" id="kobo.225.1">your production application to its knees?</span></p>
<p class="normal"><span class="koboSpan" id="kobo.226.1">In Unix and Linux, all of this is</span><a id="_idIndexMarker086"/><span class="koboSpan" id="kobo.227.1"> done with signals. </span><span class="koboSpan" id="kobo.227.2">Signals are numerical messages that can be sent between programs. </span><span class="koboSpan" id="kobo.227.3">They’re a way for processes to communicate with each other and with the operating system, allowing processes to send and receive specific messages.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.228.1">These messages can be used to communicate a variety of things to a process, for example, indicating that a particular event has happened or that a specific action or response is required.</span></p>
<h3 class="heading-3" id="_idParaDest-52"><span class="koboSpan" id="kobo.229.1">Practical uses of signals</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.230.1">Let’s look at a few examples of the </span><a id="_idIndexMarker087"/><span class="koboSpan" id="kobo.231.1">practical value that the signal mechanism enables. </span><span class="koboSpan" id="kobo.231.2">Signals can be used to implement inter-process communication; for example, one process can send a signal to another process indicating that it’s finished with a particular task and that the other process can now start working. </span><span class="koboSpan" id="kobo.231.3">This allows processes to coordinate their actions and work together in a smooth and efficient manner, much like execution threads in programming languages (but without the associated memory sharing).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.232.1">Another common application of process signals is to handle program errors. </span><span class="koboSpan" id="kobo.232.2">For example, a process can be designed to catch the </span><code class="inlineCode"><span class="koboSpan" id="kobo.233.1">SIGSEGV</span></code><span class="koboSpan" id="kobo.234.1"> signal, which indicates a segmentation fault. </span><span class="koboSpan" id="kobo.234.2">When a process receives this signal, it can trap that signal and then take action to log the error, dump core for debugging purposes, or clean up any resources that were being used before shutting down gracefully.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.235.1">Process signals can also be used to implement graceful shutdowns. </span><span class="koboSpan" id="kobo.235.2">For example, when a system is shutting</span><a id="_idIndexMarker088"/><span class="koboSpan" id="kobo.236.1"> down, a signal can be sent to all processes to give them a chance to save their state and clean up any resources they were using, via “trapping” signals.</span></p>
<h3 class="heading-3" id="_idParaDest-53"><span class="koboSpan" id="kobo.237.1">Trapping</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.238.1">Many of the signals </span><a id="_idIndexMarker089"/><span class="koboSpan" id="kobo.239.1">can be “trapped” by the processes that receive them: this is essentially the same idea as catching and handling an error in a programming language.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.240.1">If the receiving process has a handler function for the signal that’s being sent, then that handler function is run. </span><span class="koboSpan" id="kobo.240.2">That’s how programs re-read their configuration without restarting, and finish their database writes and close their file handles after receiving the shutdown signal.</span></p>
<h3 class="heading-3" id="_idParaDest-54"><span class="koboSpan" id="kobo.241.1">The kill command</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.242.1">However, it’s not just processes that </span><a id="_idIndexMarker090"/><span class="koboSpan" id="kobo.243.1">communicate via signals: the frighteningly named (and, technically speaking, incorrectly named) </span><code class="inlineCode"><span class="koboSpan" id="kobo.244.1">kill</span></code><span class="koboSpan" id="kobo.245.1"> is a program that allows users to send signals to processes, too.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.246.1">One of the most common uses of user-sent</span><a id="_idIndexMarker091"/><span class="koboSpan" id="kobo.247.1"> processes via the </span><code class="inlineCode"><span class="koboSpan" id="kobo.248.1">kill</span></code><span class="koboSpan" id="kobo.249.1"> command is to interrupt a process that is no longer responding. </span><span class="koboSpan" id="kobo.249.2">For example, if a process is stuck in an infinite loop, a “kill” signal can be sent to force it to stop.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.250.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.251.1">kill</span></code><span class="koboSpan" id="kobo.252.1"> command allows you to send a signal to a process by specifying its PID. </span><span class="koboSpan" id="kobo.252.2">If the process you’d like to terminate has PID </span><code class="inlineCode"><span class="koboSpan" id="kobo.253.1">2600</span></code><span class="koboSpan" id="kobo.254.1">, you’d run:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.255.1">kill 2600
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.256.1">This command would send signal 15 (</span><code class="inlineCode"><span class="koboSpan" id="kobo.257.1">SIGTERM</span></code><span class="koboSpan" id="kobo.258.1">, or “terminate”) to the process, which would then have a chance to trap the signal and shut down cleanly.</span></p>
<div class="note">
<p class="normal"><strong class="screenText"><span class="koboSpan" id="kobo.259.1">Note</span></strong></p>
<p class="normal"><span class="koboSpan" id="kobo.260.1">As you can see from the included table of standard signal numbers, the default signal that </span><code class="inlineCode"><span class="koboSpan" id="kobo.261.1">kill</span></code><span class="koboSpan" id="kobo.262.1"> sends is “terminate” (signal 15), not “kill” (</span><code class="inlineCode"><span class="koboSpan" id="kobo.263.1">SIGKILL</span></code><span class="koboSpan" id="kobo.264.1"> is 9). </span><span class="koboSpan" id="kobo.264.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.265.1">kill</span></code><span class="koboSpan" id="kobo.266.1"> program is not just for killing processes but also for sending any kind of signal. </span><span class="koboSpan" id="kobo.266.2">It’s really confusingly named and I’m sorry about that – it’s just one of those idiosyncrasies of Unix and Linux that you’ll get used to.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.267.1">If you don’t want to send the default signal 15, you </span><a id="_idIndexMarker092"/><span class="koboSpan" id="kobo.268.1">can specify the signal you’d like to send with a dash; to</span><a id="_idIndexMarker093"/><span class="koboSpan" id="kobo.269.1"> send a </span><code class="inlineCode"><span class="koboSpan" id="kobo.270.1">SIGHUP</span></code><span class="koboSpan" id="kobo.271.1"> to the same process, you’d run:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.272.1">kill –1 2600
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.273.1">Running </span><code class="inlineCode"><span class="koboSpan" id="kobo.274.1">man</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.275.1">signal</span></code><span class="koboSpan" id="kobo.276.1"> will give you a list of signals that you can send:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.277.1"><img alt="" role="presentation" src="../Images/B19251_02_06.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.278.1">Figure 2.6: Example of output of the man signal command</span></p>
<p class="normal"><span class="koboSpan" id="kobo.279.1">It pays – sometimes quite literally, in engineering interviews – to be familiar with a few of these:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.280.1">SIGHUP</span></code><span class="koboSpan" id="kobo.281.1"> (1) – “hangup”: interpreted</span><a id="_idIndexMarker094"/><span class="koboSpan" id="kobo.282.1"> by many applications – for example, nginx – as “re-read your configuration because I’ve made changes to it.”</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.283.1">SIGINT</span></code><span class="koboSpan" id="kobo.284.1"> (2) – “interrupt”: often interpreted the same as </span><code class="inlineCode"><span class="koboSpan" id="kobo.285.1">SIGTERM</span></code><span class="koboSpan" id="kobo.286.1"> - “please shut down cleanly.”</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.287.1">SIGTERM</span></code><span class="koboSpan" id="kobo.288.1"> (15) – “terminate”: nicely</span><a id="_idIndexMarker095"/><span class="koboSpan" id="kobo.289.1"> asks a process to shut down.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.290.1">SIGUSR1</span></code><span class="koboSpan" id="kobo.291.1"> (30) and </span><code class="inlineCode"><span class="koboSpan" id="kobo.292.1">SIGUSR2</span></code><span class="koboSpan" id="kobo.293.1"> (31) are sometimes used for application-defined messaging For example, SIGUSR1 asks nginx to re-open the log files it’s writing to, which is useful if you’ve just rotated them.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.294.1">SIGKILL</span></code><span class="koboSpan" id="kobo.295.1"> (9) – </span><code class="inlineCode"><span class="koboSpan" id="kobo.296.1">SIGKILL</span></code><span class="koboSpan" id="kobo.297.1"> cannot be trapped and handled by processes. </span><span class="koboSpan" id="kobo.297.2">If this signal is sent to a program, the operating system will kill that program immediately. </span><span class="koboSpan" id="kobo.297.3">Any cleanup code, like flushing writes or safe shutdown, is not performed, so this is generally a last resort, since it could lead to data corruption.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.298.1">If you want to explore Linux a bit deeper, feel free to poke around the </span><code class="inlineCode"><span class="koboSpan" id="kobo.299.1">/proc</span></code><span class="koboSpan" id="kobo.300.1"> directory. </span><span class="koboSpan" id="kobo.300.2">That’s definitely beyond the basics, but it’s a directory that contains a filesystem subtree for every process, where live information about the processes is looked up as you read those files.</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.301.1">/proc
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.302.1">In practice, this knowledge can come in handy during troubleshooting when you’ve identified a misbehaving (or mysterious) process and want to know exactly what it’s doing in real time.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.303.1">You can learn a lot about a process by poking around in its </span><code class="inlineCode"><span class="koboSpan" id="kobo.304.1">/proc</span></code><span class="koboSpan" id="kobo.305.1"> subdirectory and casually googling.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.306.1">Many of the tools we show you in this chapter actually use </span><code class="inlineCode"><span class="koboSpan" id="kobo.307.1">/proc</span></code><span class="koboSpan" id="kobo.308.1"> to gather process information, and only show you a subset of what’s there. </span><span class="koboSpan" id="kobo.308.2">If you want to see </span><em class="italic"><span class="koboSpan" id="kobo.309.1">everything</span></em><span class="koboSpan" id="kobo.310.1"> and do the filtering yourself, </span><code class="inlineCode"><span class="koboSpan" id="kobo.311.1">/proc</span></code><span class="koboSpan" id="kobo.312.1"> is the place to look.</span></p>
<h2 class="heading-2" id="_idParaDest-55"><span class="koboSpan" id="kobo.313.1">lsof – show file handles that a process has open</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.314.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.315.1">lsof</span></code><span class="koboSpan" id="kobo.316.1"> command shows all files that a process has opened for reading and writing. </span><span class="koboSpan" id="kobo.316.2">This is useful because it only takes one</span><a id="_idIndexMarker096"/><span class="koboSpan" id="kobo.317.1"> small bug for a program to leak file handles (internal references to files that it has requested access to). </span><span class="koboSpan" id="kobo.317.2">This can lead to resource</span><a id="_idIndexMarker097"/><span class="koboSpan" id="kobo.318.1"> usage issues, file corruption, and a long list of strange behavior.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.319.1">Thankfully, getting a list of files that a process has open is easy. </span><span class="koboSpan" id="kobo.319.2">Just run </span><code class="inlineCode"><span class="koboSpan" id="kobo.320.1">lsof</span></code><span class="koboSpan" id="kobo.321.1"> and pass the </span><code class="inlineCode"><span class="koboSpan" id="kobo.322.1">–p</span></code><span class="koboSpan" id="kobo.323.1"> flag with a PID (you’ll usually have to run this as root). </span><span class="koboSpan" id="kobo.323.2">This will return the list of files that the process (in this case, with PID 1589) has open:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.324.1">  ~ lsof -p 1589
</span></code></pre>
<figure class="mediaobject"><span class="koboSpan" id="kobo.325.1"><img alt="" role="presentation" src="../Images/B19251_02_07.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.326.1">Figure 2.7: Example of list of files opened by the 1589 process using the lsof -p 1589 command</span></p>
<p class="normal"><span class="koboSpan" id="kobo.327.1">The above is the output for an nginx web server process. </span><span class="koboSpan" id="kobo.327.2">The first line shows you the current working directory for the process: in this case, the root directory (</span><code class="inlineCode"><span class="koboSpan" id="kobo.328.1">/</span></code><span class="koboSpan" id="kobo.329.1">). </span><span class="koboSpan" id="kobo.329.2">You can also see that it has file handles open on its own binary (</span><code class="inlineCode"><span class="koboSpan" id="kobo.330.1">/usr/sbin/nginx</span></code><span class="koboSpan" id="kobo.331.1">) and various libraries in </span><code class="inlineCode"><span class="koboSpan" id="kobo.332.1">/usr/lib/</span></code><span class="koboSpan" id="kobo.333.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.334.1">Further down, you might notice a few more interesting filepaths:</span></p>
<p class="packt_figref"><span class="koboSpan" id="kobo.335.1"><img alt="" role="presentation" src="../Images/B19251_02_08.png"/></span></p>
<p class="packt_figref"><span class="koboSpan" id="kobo.336.1">Figure 2.8: Further opened files of the 1589 process</span></p>
<p class="normal"><span class="koboSpan" id="kobo.337.1">This listing includes the log files nginx is writing to, and socket files (Unix, IPv4, and IPv6) that it’s reading and writing to. </span><span class="koboSpan" id="kobo.337.2">In Unix and Linux, network sockets are just a special kind of file, which makes it easy </span><a id="_idIndexMarker098"/><span class="koboSpan" id="kobo.338.1">to use the same core toolset across a wide variety of use cases – tools that work with files are extremely powerful in an environment where almost everything is represented as a file.</span></p>
<h2 class="heading-2" id="_idParaDest-56"><span class="koboSpan" id="kobo.339.1">Inheritance</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.340.1">Except for the very first process, </span><code class="inlineCode"><span class="koboSpan" id="kobo.341.1">init</span></code><span class="koboSpan" id="kobo.342.1"> (</span><code class="inlineCode"><span class="koboSpan" id="kobo.343.1">PID 1</span></code><span class="koboSpan" id="kobo.344.1">), all processes are created by a parent process, which</span><a id="_idIndexMarker099"/><span class="koboSpan" id="kobo.345.1"> essentially makes a copy of itself and then “forks” (splits) that copy off. </span><span class="koboSpan" id="kobo.345.2">When a process is forked, it typically inherits its parent’s permissions, environment variables, and other attributes.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.346.1">Although this default behavior can be prevented and changed, it’s a bit of a security risk: software that you run manually receives the permissions of your current user (or even root privileges, if you use </span><code class="inlineCode"><span class="koboSpan" id="kobo.347.1">sudo</span></code><span class="koboSpan" id="kobo.348.1">). </span><span class="koboSpan" id="kobo.348.2">All child processes that might be created by that process – for example, during installation, compilation, and so on – inherit those permissions.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.349.1">Imagine a web server process that was started with root privileges (so it could bind to a network port) and environment variables containing cloud authentication keys (so it could grab data from the cloud). </span><span class="koboSpan" id="kobo.349.2">When this main process forks off a child process that needs neither root privileges nor sensitive environment variables, it’s an unnecessary security risk to pass those along to the child. </span><span class="koboSpan" id="kobo.349.3">As a result, dropping privileges and clearing environment variables is a common pattern in services spawning child processes.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.350.1">From a security perspective, it is important to keep this in mind to prevent situations where information such as passwords or access to sensitive files could be leaked. </span><span class="koboSpan" id="kobo.350.2">While it is outside the scope of this book to go into details of how to avoid this, it’s important to be aware of this if you’re writing software that’s going to run on Linux systems.</span></p>
<h1 class="heading-1" id="_idParaDest-57"><span class="koboSpan" id="kobo.351.1">Review – example troubleshooting session</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.352.1">Let’s look at an example troubleshooting session. </span><span class="koboSpan" id="kobo.352.2">All </span><a id="_idIndexMarker100"/><span class="koboSpan" id="kobo.353.1">we know is that one specific Linux server is running extremely slowly.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.354.1">To begin with, we want to see what’s happening on the system. </span><span class="koboSpan" id="kobo.354.2">You just learned that you can see a live view of processes running on a system by running the interactive </span><code class="inlineCode"><span class="koboSpan" id="kobo.355.1">top</span></code><span class="koboSpan" id="kobo.356.1"> command. </span><span class="koboSpan" id="kobo.356.2">Let’s try that now.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.357.1"><img alt="" role="presentation" src="../Images/B19251_02_09.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.358.1">Figure 2.9: Example of output of the top command</span></p>
<p class="normal"><span class="koboSpan" id="kobo.359.1">By default, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.360.1">top</span></code><span class="koboSpan" id="kobo.361.1"> command sorts processes by CPU usage, so we can simply look at the first listed process to </span><a id="_idIndexMarker101"/><span class="koboSpan" id="kobo.362.1">find the offending one. </span><span class="koboSpan" id="kobo.362.2">Indeed, the top process is using 94% of one CPU’s available processing time.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.363.1">As a result of running </span><code class="inlineCode"><span class="koboSpan" id="kobo.364.1">top</span></code><span class="koboSpan" id="kobo.365.1">, we’ve gotten a few useful pieces of information:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.366.1">The problem is CPU usage, as opposed to some other kind of resource contention.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.367.1">The offending process is PID 1763, and the command being run (listed in the </span><strong class="screenText"><span class="koboSpan" id="kobo.368.1">COMMAND</span></strong><span class="koboSpan" id="kobo.369.1"> column) is </span><code class="inlineCode"><span class="koboSpan" id="kobo.370.1">bzip2</span></code><span class="koboSpan" id="kobo.371.1">, which is a compression program.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.372.1">We determine that this </span><code class="inlineCode"><span class="koboSpan" id="kobo.373.1">bzip2</span></code><span class="koboSpan" id="kobo.374.1"> process doesn’t need to be running here, and we decide to stop it. </span><span class="koboSpan" id="kobo.374.2">Using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.375.1">kill</span></code><span class="koboSpan" id="kobo.376.1"> command, we ask the process to terminate:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.377.1">kill 1763
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.378.1">After waiting a few seconds, we check to see if this (or any other) </span><code class="inlineCode"><span class="koboSpan" id="kobo.379.1">bzip2</span></code><span class="koboSpan" id="kobo.380.1"> process is running:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.381.1">pgrep bzip2
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.382.1">Unfortunately, we see that the same PID is still running. </span><span class="koboSpan" id="kobo.382.2">It’s time to get serious:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.383.1">kill –9 1763
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.384.1">This orders the operating system to kill the process without allowing the process to trap (and potentially ignore) the signal. </span><span class="koboSpan" id="kobo.384.2">A </span><code class="inlineCode"><span class="koboSpan" id="kobo.385.1">SIGKILL</span></code><span class="koboSpan" id="kobo.386.1"> (signal #9) simply kills the process where it stands.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.387.1">Now that you’ve killed the offending process, the server is running smoothly again and you can start tracking down the developer who thought it was a good idea to compress large source directories on this machine.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.388.1">In this example, we</span><a id="_idIndexMarker102"/><span class="koboSpan" id="kobo.389.1"> followed the most common systems troubleshooting pattern in existence:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.390.1">We looked at resource usage (via </span><code class="inlineCode"><span class="koboSpan" id="kobo.391.1">top</span></code><span class="koboSpan" id="kobo.392.1"> in this example). </span><span class="koboSpan" id="kobo.392.2">This can be any of the other tools we discussed, depending on which resource is the one being exhausted.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.393.1">We found a PID to investigate.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.394.1">We acted on that process. </span><span class="koboSpan" id="kobo.394.2">In this example, no further investigation was necessary and we sent a signal, asking it to shut down (15, </span><code class="inlineCode"><span class="koboSpan" id="kobo.395.1">SIGTERM</span></code><span class="koboSpan" id="kobo.396.1">).</span></li>
</ol>
<h1 class="heading-1" id="_idParaDest-58"><span class="koboSpan" id="kobo.397.1">Conclusion</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.398.1">In this chapter, we took a close look at the process abstraction that Linux wraps around executing programs. </span><span class="koboSpan" id="kobo.398.2">You’ve seen the common components that all processes have and learned the basic commands you need to find and inspect running processes. </span><span class="koboSpan" id="kobo.398.3">With these tools, you’ll be able to identify when a process is misbehaving, and more importantly, </span><em class="italic"><span class="koboSpan" id="kobo.399.1">which</span></em><span class="koboSpan" id="kobo.400.1"> process is misbehaving.</span></p>
<h1 class="heading-1"><span class="koboSpan" id="kobo.401.1">Learn more on Discord</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.402.1">To join the Discord community for this book – where you can share feedback, ask questions to the author, and learn about new releases – follow the QR code below:</span></p>
<p class="normal"><a href="https://packt.link/SecNet"><span class="url"><span class="koboSpan" id="kobo.403.1">https://packt.link/SecNet</span></span></a></p>
<p class="normal"><span class="koboSpan" id="kobo.404.1"><img alt="" role="presentation" src="../Images/QR_Code1768422420210094187.png"/></span></p>
</div>
</body></html>