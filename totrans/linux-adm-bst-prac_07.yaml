- en: '*Chapter 9*: Backup and Disaster Recovery Approaches'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第9章*：备份与灾难恢复方法'
- en: 'I have said it already earlier in this book and it bears repeating no matter
    how many times it takes: nothing is as important in what we do as system administrators
    as maintaining good backups. This is our utmost priority. It is so important that
    many organizations maintain an independent system administration team that handles
    nothing but backups to make sure that it maintains constant attention.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我在本书中已经说过，并且无论多少次，都要重申：作为系统管理员，保持良好的备份是我们工作中最重要的事情。它是我们的首要任务。重要到许多组织都会维护一个独立的系统管理团队，专门负责备份工作，以确保能够持续关注这一任务。
- en: Backups are not glamorous, and they are rarely exciting. This does not just
    make them a challenge for us in the technical world to want to spend time thinking
    about them when we could be implementing new automation or something else admittedly
    more exciting, but it also means that management often does not prioritize budgets
    or prioritize around backups. This creates a potential danger for system administrators
    that our careers can be slowed if we focus on critical functions like backups
    instead of doing flashy, high-profile projects to keep the interest of management
    while at the same time often being at very high risk of being punished if the
    backups that they do not prioritize do not work flawlessly when needed.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 备份并不吸引眼球，也很少让人兴奋。这不仅仅是因为它们对我们技术人员来说是一个挑战，当我们本可以花时间实施新的自动化或者做其他更令人兴奋的事情时，我们却要花时间思考备份问题，还因为这意味着管理层往往不会优先考虑预算或将备份作为优先事项。这为系统管理员带来了潜在的风险，如果我们过于关注像备份这样的关键功能，而不是做那些炫目、高调的项目以维持管理层的兴趣，往往会面临被惩罚的高风险——如果那些他们未曾优先考虑的备份在需要时无法完美运行。
- en: Backups are moving more and more to the forefront of our consciousness, however,
    as they have moved from primarily protecting against catastrophic hardware failure
    to being on the front lines of security concern. Backups have evolved in recent
    years and now present opportunities to shine politically within our organizations
    and opportunities for renewed technical interest. The boring backup and restore
    landscape of the 1990s and 2000s is, quite literally, a thing of the past and
    today we have so many approaches, options, and products that we really must approach
    backups as a broader concern than we have in the past.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，备份越来越多地出现在我们的意识前沿，因为它们已经不再仅仅是保护免受灾难性硬件故障的手段，而是处于安全问题的前沿。近年来，备份发生了演变，现如今它们不仅提供了在我们组织中政治上发光发热的机会，也为技术上的新兴趣带来了重新点燃的机会。上世纪90年代和2000年代那个枯燥的备份与恢复的局面，简直可以说已经成为过去式。今天，我们有了那么多的备份方法、选项和产品，以至于我们必须把备份视为一个比以往更广泛的问题来处理。
- en: In this chapter we are going to cover a lot of different aspects of backups.
    We will start with a broad overview of how we take backups and what components
    exist within backup systems. Then we will look at similar technologies that are
    often used in conjunction with and might be sometimes confused with backups. Then
    we will cover in depth what we have mentioned throughout this book, the idea of
    a modern *DevOps centric backup approach* and talk extensively about that. Then
    we will explore agents and the issues with crash consistency of our data in backups.
    Finally, we tackle triage and what we can do to make restores better once a disaster
    has happened.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将涵盖备份的许多不同方面。我们将从备份的广泛概述以及备份系统中存在的组件开始。接着，我们将讨论一些常与备份一起使用、但有时可能会与备份混淆的相似技术。然后，我们将深入探讨本书中提到的概念——现代*以
    DevOps 为中心的备份方法*，并对这一方法进行详尽的讨论。接着，我们将探讨代理以及备份中数据崩溃一致性的问题。最后，我们将讨论分类以及灾难发生后如何改进恢复。
- en: Without further ado, let us begin what is assuredly our single most important
    chapter in this book. Of any book, I would assume.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 言归正传，让我们开始本书中无疑是最重要的一章。我想，任何一本书都是如此。
- en: 'In this chapter we are going to learn about the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将学习以下内容：
- en: Agents and crash consistency
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理和崩溃一致性
- en: Backup strategies and mechanisms
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 备份策略与机制
- en: Snapshots, archives, backups, and disaster recovery
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快照、档案、备份与灾难恢复
- en: Backups in a DevOps world
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DevOps 世界中的备份
- en: Triage concepts
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分类概念
- en: Agents and crash consistency
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理和崩溃一致性
- en: In the next session we are going to look at mechanisms for taking backups. Before
    we do that, I want to look at why backups are so hard to do well in the first
    place. In order to do that I will work with two examples. One is a text document
    that we create using our favorite text editor. I will assume that you are a normal
    person and love the vi editor as much as I do. And we will compare that to another
    common use case, the data file of an enterprise database system.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分，我们将探讨备份机制。在此之前，我想先讨论为什么备份本身这么难做好。为了做到这一点，我将通过两个示例来解释。一个是我们使用最爱的文本编辑器创建的文本文件。我假设你是个普通人，和我一样热爱使用vi编辑器。另一个则是企业数据库系统中的数据文件。
- en: When we talk about backups, we are talking about taking data that is stored
    on a physical medium and replicating that data somewhere that is separate from
    the original system in such a way that it is able to survive in many cases when
    the original system has failed. That is a very high-level view of the goal of
    backups. It serves our purposes. Therefore, in order to perform a backup we must
    be able to take the data that the system has, read it, move it, and write it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论备份时，我们是在谈论将存储在物理介质上的数据复制到一个与原始系统分开的地方，以便在许多情况下原始系统失败时，备份仍然能够存活下来。这是备份目标的一个高层次概述，它满足我们的需求。因此，为了执行备份，我们必须能够获取系统中的数据，读取它，移动它并将其写入。
- en: Of these steps it may seem like moving data to another location or writing the
    data somewhere would be the biggest challenges. This is incorrect. Being able
    to read the data is actually where the real problems tend to exist. Primarily
    because what data we need to read is not always clear.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些步骤中，看起来将数据移动到另一个位置或将数据写入某个地方可能是最大的挑战。这个想法是错误的。能够读取数据实际上才是问题的根源。主要是因为我们需要读取的数据并不总是明确的。
- en: How do computers store data on disk in the first place? Not every computer system
    works the same way, but there are certain basics that exist for which we know
    no alternatives. While working with data, computers hold the data in their random-access
    memory. While there it is completely volatile, but it is very fast. When the computer
    is done with a file it takes the data that is in its memory and then writes it
    onto the storage device, presumable a hard disk or SSD.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机是如何在磁盘上存储数据的呢？并不是每个计算机系统的工作方式都相同，但存在一些我们知道没有替代方法的基本原理。在处理数据时，计算机会将数据保存在随机存取内存中。在内存中，它是完全易失的，但速度非常快。当计算机处理完一个文件时，它会将内存中的数据写入存储设备，假设是硬盘或SSD。
- en: If we attempt to take a backup of a system while data is in the computer's memory
    and not yet written to disk our backup would contain none of the data in question.
    This may sound silly to say, but it is necessary to remember. It is common for
    people both technical and management to assume that data is always stored somewhere,
    even when it has only gotten into memory and not had time to be stored anywhere
    yet.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试在数据仍保存在计算机内存中并尚未写入磁盘时进行备份，我们的备份将不包含任何相关数据。听起来可能有些荒谬，但这是必须记住的。无论是技术人员还是管理人员，都常常假设数据总是被存储在某个地方，即使它只是进入了内存，还没有时间被存储到任何地方。
- en: Once data is written to the disk, and then a backup is taken, the data from
    the disk should be copied to the backup location. All is well with the world.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦数据被写入磁盘并进行备份，磁盘上的数据应当被复制到备份位置。世界一切正常。
- en: This is all well and good, but computers deal with situations far more complicated
    than just receiving files, and saving them to disk. In the real world, computers
    nearly always are reading existing files off of their storage mechanism, holding
    it in memory while manipulating the data, and then saving it again back to disk
    with the new changes incorporated into the data set. This is where things start
    to become tricky.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切听起来不错，但计算机处理的情况要比仅仅接收文件并保存到磁盘复杂得多。在现实世界中，计算机几乎总是在从存储机制中读取现有文件，将其保存在内存中并进行数据操作，然后将修改后的数据保存回磁盘。这就是事情开始变得棘手的地方。
- en: We should start using our examples now. First the case with a text file editing
    in `vi` (if you insist, you can edit in Atom or something else.) We will also
    assume that we are not creating a new file, but rather editing a configuration
    file that already exists on the disk. A great example is the `hosts` file (found
    at `/etc/hosts`.)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该开始使用我们的示例。首先是`vi`中编辑文本文件的情况（如果你坚持的话，你也可以使用Atom或其他编辑器。）我们还假设我们不是创建一个新文件，而是在编辑已经存在于磁盘上的配置文件。一个很好的例子是`hosts`文件（位于`/etc/hosts`）。
- en: If we take a backup while the file is being edited, we would get a copy of the
    old data before any edits because any edits that are happening exists only in
    memory, not on disk. The fact that the file is open at the time does not mean
    that data is being written to disk. The old data is still on the disk while the
    new data exists in memory.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在文件编辑过程中进行备份，我们将获得编辑前的旧数据副本，因为任何正在进行的编辑仅存在于内存中，而不是磁盘上。文件在打开时并不意味着数据正在写入磁盘。旧数据仍然保存在磁盘上，而新数据则存在于内存中。
- en: When the file is saved, the data is written to the disk. Once written, we can
    make our copy. Of course, there can be a short moment while the data is being
    written where what is on disk is neither the original version nor the new version
    but something in between as the data is not finished being written.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当文件被保存时，数据会被写入磁盘。写入完成后，我们可以进行复制。当然，在数据写入过程中，可能会有一个短暂的时刻，磁盘上的内容既不是原始版本，也不是新版本，而是处于两者之间的某个状态，因为数据尚未完全写入。
- en: We can attempt to lock the files, but even with a file being locked we have
    a complicated situation. The backup mechanism, whatever it is, has to decide if
    it is going to skip over a locked file, wait for the lock to be released, or ignore
    the lock and take the backup anyway. No situation is very good. We either fail
    to backup all of the files in any particular backup process, we risk a long wait
    for an event that might *never* happen, or we risk getting a file that is out
    of date or worse, corrupt. There is no completely simple answer.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试锁定文件，但即使文件被锁定，情况依然复杂。无论备份机制是什么，它必须决定是跳过锁定的文件、等待锁释放，还是忽略锁定直接进行备份。没有一种情况是理想的。我们要么无法在任何特定的备份过程中备份所有文件，要么面临长时间等待某个可能*永远*不会发生的事件，或者我们面临备份过时文件，甚至更糟，备份损坏的文件。没有完全简单的解决方案。
- en: Locking mechanisms in Linux
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Linux中的锁机制
- en: When processes are using files on Linux, and more or less on any operating system,
    there are three essential strategies that we normally see in action. The first,
    and most obvious, is to do nothing. That is correct. In many cases there is no
    locking performed whatsoever. The contents of a file are read and the file itself
    is not marked as being open. It is just read. This approach is great in that any
    other process can continue to use the file in question in whatever manner they
    desire, but it also gives us no information as to whether or not the file is about
    to be updated in some way.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当进程在Linux上使用文件时，实际上在任何操作系统上，我们通常会看到三种基本策略。第一种，也是最明显的，就是不做任何操作。是的，没错。在许多情况下，根本没有执行任何锁定操作。文件内容被读取，而文件本身并未被标记为已打开。它只是被读取。这种方法的优点是任何其他进程都可以以任意方式继续使用该文件，但它也无法提供任何关于文件是否即将以某种方式更新的信息。
- en: The primary alternative mechanism on Linux is called an advisory lock. With
    an advisory lock, the operating system marks when a file has been opened by a
    process. The locks are so called advisory because the operating system advises
    other processes that the file is in use. Another process can opt to ignore the
    lock and continue to read, or even to overwrite, the file that is locked. This
    is handy in that we can lock a file and not worry that we are completely blocking
    others from accessing it. The risk is that our lock is not honored, and race conditions
    are encountered where data is changed out of order or data that is believed to
    be saved gets overwritten. Ignoring an advisory lock to peek at a file and check
    out some old data is pretty safe. Ignoring an advisory lock to overwrite the file
    with changes without the original process knowing that it has happened is dangerous.
    Processes that fully support and honor an advisory lock are called cooperative
    processes.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Linux上的主要替代机制称为建议锁（advisory lock）。通过建议锁，操作系统会标记一个文件是否已被进程打开。这些锁被称为建议锁，因为操作系统通知其他进程该文件正在使用。其他进程可以选择忽略该锁，继续读取，甚至覆盖被锁定的文件。这种方式的好处是我们可以锁定文件而不必担心完全阻止其他人访问它。风险在于我们的锁可能不会被遵守，导致竞态条件发生，数据可能被更改顺序错误，或者本以为已保存的数据被覆盖。忽略建议锁以查看文件并检查一些旧数据是相对安全的。忽略建议锁以在没有原进程知情的情况下覆盖文件并进行更改则是危险的。完全支持并遵守建议锁的进程称为合作进程（cooperative
    processes）。
- en: The third option is a mandatory lock. As the name implies, processes have no
    option but to honor a mandatory lock. Mandatory locks are managed by the Linux
    kernel and only exist if a filesystem is specifically mounted with this form of
    locking enabled. Mandatory locks on Linux, however, suffer from implementation
    problems that make them unreliable and subject to some uncommon race conditions
    which effectively defeat the purpose of the lock. Because of this mandatory locking
    is almost always ignored on Linux systems.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个选项是强制锁（mandatory lock）。顾名思义，进程别无选择，必须遵守强制锁。强制锁由Linux内核管理，只有在文件系统特意以这种锁定方式挂载时才会存在。然而，Linux上的强制锁存在实现问题，使得它们不可靠，并且容易受到一些罕见的竞态条件的影响，这些竞态条件实际上使得锁的目的无法实现。因此，强制锁在Linux系统中几乎总是被忽视。
- en: Locking is conceptually hard. It carries risk and system overhead. The best
    way to respond to a locked file is not always clear and may vary by many different
    use cases of which the operating system is not aware. Because the operating system
    does not know how or why a file is being accessed in the first place, it has little
    means of usefully enforcing limits on secondary access. There is nearly always
    a reason that we might want to read a locked file and sometimes a good reason
    to even write to a locked file. Trusting that we will only run processes that
    will behave as needed for our use cases is our best course of action in nearly
    all cases. When more complex access is required, such as is the case with most
    database files, it is necessary to move to single process access with that process
    handling additional data access from higher in the application stack where more
    knowledge of the intended use of the file is know.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 锁定在概念上是困难的。它带来了风险和系统开销。对被锁定文件的最佳响应方式并不总是显而易见，并且可能因操作系统无法预见的各种不同用例而有所不同。由于操作系统并不知晓文件最初为何被访问，它几乎没有有效的手段来强制执行二次访问的限制。几乎总是有理由我们可能想要读取一个被锁定的文件，甚至有时有充分理由对一个被锁定的文件进行写操作。信任我们只会运行那些在我们使用场景下能够按需执行的进程，是我们在几乎所有情况下的最佳行动方案。当需要更复杂的访问时，比如大多数数据库文件的情况，就需要转向单一进程访问，由该进程处理来自应用程序栈上层的额外数据访问，因为那里的进程对文件的预期用途有更多的了解。
- en: Other than locking, the major concept that we have to understand is quiescence.
    Quiescence simply refers to the storage reaching a state of dormancy, a lack of
    fluctuation. When we say that we have achieved quiescence in our storage we mean
    that all of the data that is currently *in flight* whether actively being used
    by an application or just being held in one of any number of different cache layers
    has been written to disk. In some ways, we can think of locks as being a mechanism
    meant to warn us (or a process) as to a system not being currently quiesced.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 除了锁定，另一个我们必须理解的重要概念是静默（quiescence）。静默简单来说是指存储达到一种休眠状态，即没有波动。当我们说存储已经达到静默状态时，我们的意思是所有当前*正在传输*的数据，无论是正在被应用程序使用，还是仅仅被存储在多个缓存层中的某一层，已经被写入磁盘。从某种程度上讲，我们可以将锁定视为一种机制，用来警告我们（或一个进程）系统目前未处于静默状态。
- en: Unfortunately, there is no universal mechanism to enforce or even ensure quiescence
    on Linux. There is none on Windows either, dangerously contrary to many claims
    that VSS (the Volume Shadow Service) does this. VSS is the standard LVM on Windows
    and as such is often used in many storage operations. It is commonly said that
    VSS guarantees that all files are quiesced, but this is false. VSS has special
    hooks into common applications, primarily from Microsoft, such as SQL Server,
    Exchange, and Active Directory so that they are able to communicate effective
    with the storage layer as to the state of their quiescence. This is an amazing
    feature and incredibly handy to be integrated with the operating system automatically.
    It does not address third party applications which rarely have VSS integration
    leaving them dangerously unquiesced while many Windows administrators believe
    that VSS magically manages data flushing from all application layers that it does
    not, and cannot.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Linux 上没有通用机制来强制执行或甚至确保系统的静默状态，Windows 上也没有，尽管许多关于 VSS（卷影副本服务）能做到这一点的说法是错误的。VSS
    是 Windows 上的标准逻辑卷管理器（LVM），因此常用于许多存储操作。常有人说 VSS 保证所有文件都处于静默状态，但这不准确。VSS 与许多常见的应用程序（主要是
    Microsoft 的应用）有特殊的挂钩，例如 SQL Server、Exchange 和 Active Directory，以便它们能够有效地与存储层通信，了解自身静默状态。这是一个令人惊叹的功能，并且自动与操作系统集成非常方便。然而，它并未解决第三方应用程序的问题，这些应用程序很少有
    VSS 集成，导致它们处于危险的非静默状态，而许多 Windows 管理员认为 VSS 神奇地管理了所有应用层的数据刷新，但事实并非如此，它无法做到这一点。
- en: At the operating system level, where we typically have to work as system administrators,
    our primary tools for quiescence are snapshots from a logical volume manager (such
    as those provided by LVM or ZFS) or to freeze the filesystem itself as is possible
    with XFS. The higher up the stack (higher means closer to the application itself)
    we freeze the system, the less likely that there will be some artefact still in
    flight and not written to disk. At the end of the day, however, unless an application
    itself guarantees that it has flushed all data down to disk and left nothing in
    a cache or in process of some sort, the best that we can hope for is a best effort
    situation. This is true regardless of the operating system. It is a universal
    challenge. Computers are simply really complex things.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作系统层面，我们作为系统管理员通常需要使用的静默工具是来自逻辑卷管理器的快照（例如 LVM 或 ZFS 提供的快照），或者冻结文件系统本身，如 XFS
    所能实现的那样。我们越接近栈的上层（“上层”意味着更靠近应用程序本身），我们冻结系统的范围就越大，系统中仍在传输并未写入磁盘的数据的可能性就越小。然而，最终，无论操作系统如何，除非应用程序本身保证它已经将所有数据刷新到磁盘并且没有留下任何缓存或正在处理的数据，否则我们所能希望的最多也就是尽力而为。这是一个普遍存在的挑战。计算机本身就是非常复杂的东西。
- en: In the majority of cases, nearly all cases in fact, one or more of these quiescence
    methods will work just fine to get data safely to disk. In fact, most backups
    and most businesses rarely even rely on this much protection and typically rely
    on best effort file locks and multiple backups to provide working copies of a
    sufficient number of files on any given system. Most workloads write to the disk
    infrequently making relatively few into high-risk scenarios. But we cannot overlook
    at all of these methods leave us with no ability to truly ensure that a system
    is completely quiesced and we are always taking some degree of chance that critical
    data will be in flight in some form. If we are talking about a web server that
    only serves out static websites the risk might be so low as to simply ignore it.
    If we are talking about a critical enterprise database used for financial and
    accounting data the risk might be enormous and one that could never be undertaken
    no matter what. So, if we want to take backups at a system level, we need to consider
    our workloads, their quiescence, and what risk that creates for us.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，事实上几乎所有情况下，一种或多种静默方法都能很好地将数据安全地写入磁盘。实际上，大多数备份和企业通常很少依赖如此多的保护，通常依赖尽力而为的文件锁和多重备份来提供系统中足够数量文件的有效副本。大多数工作负载写入磁盘的频率较低，使得很少发生高风险场景。但我们不能忽视的是，这些方法中的任何一种都无法真正确保系统完全静默，并且我们始终面临某些程度的风险，关键数据可能以某种形式仍在传输中。如果我们讨论的是仅提供静态网站的
    Web 服务器，风险可能低到可以忽略不计。如果我们讨论的是用于财务和会计数据的关键企业数据库，风险可能极大，这是无论如何都不能承担的风险。因此，如果我们想要在系统层面进行备份，我们需要考虑我们的工作负载、它们的静默状态以及由此带来的风险。
- en: When we take a backup using one of these mechanisms that does not coordinate
    end to end with the application workloads to ensure that the data on physical
    media is complete and quiet, we refer to our backup as being *crash consistent*.
    This is an important term and one that is used often. Crash consistency does not
    mean that the system has actually crashed, but rather it refers to the state that
    storage is in after the abrupt crash or loss of power in a computer system.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用其中一种不与应用工作负载端到端协调以确保物理媒体上的数据完整和静默的机制进行备份时，我们称我们的备份为*崩溃一致*。这是一个重要的术语，经常使用。崩溃一致性并不意味着系统实际上已经崩溃，而是指计算机系统突然崩溃或断电后存储的状态。
- en: Crash consistency is such a critical idea that we need to really understand
    what we mean when we say it. For some it is said as a scary warning of impending
    doom. Others use it to imply a reliable system state. So, what does it really
    mean?
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 崩溃一致性是一个非常关键的概念，我们需要真正理解我们所说的意思。对于一些人来说，它被说成是一个即将到来的灾难的可怕警告。其他人则用它来暗示一个可靠的系统状态。那么，它真正意味着什么呢？
- en: When any computer crashes completely, meaning that there is no ability for recovery
    or protection after the event has occurred such as when there is catastrophic
    hardware failure or power is suddenly unavailable to the system, there is absolutely
    no mechanism to ensure that the data that is on the disk is accurate or complete.
    As any computer user is aware, sudden loss of power to a computer is generally
    not a problem, except that any unsaved changes to a file or our latest progress
    in a video game or whatever will be lost. This feels obvious and we do not normally
    think of it as being a significant problem of system design. Once in a while,
    we will find that a program or data set has become corrupted. We all fear this
    when a system returns from a crash, but rarely is it actually a problem - at least
    as an end user.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当任何计算机完全崩溃时，意味着在事件发生后没有恢复或保护能力，例如当硬件发生灾难性故障或电源突然无法提供给系统时，绝对没有机制可以确保磁盘上的数据准确或完整。正如任何计算机用户所知，计算机突然断电通常不是问题，除非文件的任何未保存更改或我们在视频游戏中的最新进展等都将丢失。这似乎是显而易见的，我们通常不会认为这是系统设计的一个重大问题。偶尔，我们会发现一个程序或数据集已经损坏。当系统从崩溃中恢复时，我们都害怕这种情况，但实际上很少是一个问题
    - 至少对于最终用户而言。
- en: This state of a system after an actual crash is essentially identical to the
    state of a system where a backup is taken without any quiescence. Any data that
    is currently being modified will be lost. Once in a while data that we thought
    was already saved to disk will be corrupted. By and large, everything will be
    there. This is why we call backups or any copy in this state crash consistent,
    meaning in the same consistency as a catastrophic crash on a physical machine.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 实际崩溃后系统的状态与没有任何静默期备份的系统状态基本相同。任何当前正在修改的数据都将丢失。偶尔会发生我们认为已保存到磁盘的数据损坏的情况。总体而言，一切都在那里。这就是为什么我们称这种状态下的备份或任何拷贝为崩溃一致，即与物理机器上的灾难性崩溃一致性相同。
- en: When talking about desktops it is easier to illustrate the point. The same risks
    exist on servers, but to a much more serious degree. With a desktop we tend to
    have a single user who has a very good idea of all data that is likely to be currently
    in flight and storage is pretty straightforward. In a server environment not only
    do we likely have lots of storage complexity with different possible and possibly
    risky mechanisms at every turn, but we likely have larger and more numerous cache
    situations throughout the stack and one or more multi-user workloads sitting on
    top that will rarely be interacting with users meaningfully at the time of a crash.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈论到桌面时，更容易说明这一点。服务器上存在相同的风险，但程度严重得多。在桌面上，我们往往只有一个用户，对当前可能正在传输的所有数据有很好的了解，并且存储比较直接。在服务器环境中，不仅可能存在大量的存储复杂性，每一个转折点都可能存在不同的可能且可能有风险的机制，而且我们很可能在整个堆栈中有更大更多的缓存情况，并且一个或多个多用户工作负载会在崩溃时很少与用户有意义地交互。
- en: Consider an example web server, a common example, with data stored in a database.
    A user has some interaction with the web page maybe entering contact details for
    sales or uploading a form or processing some banking transaction or placing an
    order. The user believes that the transaction completes as they receive feedback
    saying that their submission is complete. The user will likely not refresh the
    page or return as to them, the transaction is completely. But is it?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个典型的 Web 服务器示例，数据存储在数据库中。用户与网页进行一些交互，可能是输入销售信息、上传表单、处理银行交易或下订单。用户认为交易已完成，因为他们收到了反馈，显示提交已完成。用户很可能不会刷新页面或返回，因为对他们来说，交易已经完全完成。但真的是这样吗？
- en: The web server may have queued the transaction in memory to be handled a few
    seconds later, or left part of the data in a cache. Or it may have written the
    transaction to a database, and that database might still be holding it in a cache.
    Maybe the database has written the data to its file, but the filesystem has the
    data in a cache. Maybe the filesystem has committed the data, but the logical
    volume manager has the data in a cache. If you have hardware RAID, there is likely
    a cache there and before data gets written out to physical disks it will sit in
    that cache. The physical disks themselves can have caches which, one would hope,
    would be disabled in this situation but may not be and represent yet another place
    where data might be cached before the drive head actually puts the data physically
    onto the disk.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Web 服务器可能将交易排队在内存中，稍后几秒钟再处理，或者将部分数据保存在缓存中。或者，它可能已将交易写入数据库，而该数据库可能仍然将数据保留在缓存中。也许数据库已将数据写入文件，但文件系统仍然将数据保存在缓存中。也许文件系统已提交数据，但逻辑卷管理器还在缓存中持有数据。如果你有硬件
    RAID，那里可能会有缓存，在数据写入物理磁盘之前，它会停留在那个缓存中。物理磁盘本身也可能有缓存，虽然在这种情况下应该禁用它，但它可能没有被禁用，并且可能是另一个数据在驱动头将数据实际写入磁盘之前可能被缓存的地方。
- en: Of course, lots of mechanisms probably exist to protect against many of these
    failures. Disk caches should be disabled, RAID caches are often protected by being
    non-volatile RAM or have a battery to allow them to flush to physical disk even
    after the system experiences a power loss, databases often log transactions before
    doing their final write so have the ability to roll back if they cannot roll forward
    and applications generally do not report that all is well to the end user until
    at least some degree of certainty exists that the transaction has been recorded.
    All of those are situations that we hope exist, however, and nothing guarantees
    them except for a combination of application and system design end to end. The
    best designed application can still be fooled by a hypervisor that presents volatile
    RAM as if it were a hard drive and reports quiescence where there is no storage
    written at all. So, trust is required.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，可能存在许多机制来防止这些故障。磁盘缓存应该禁用，RAID 缓存通常通过使用非易失性内存或电池保护，以便即使系统发生断电，它们也能将数据刷新到物理磁盘，数据库通常会在进行最终写入之前记录事务，因此如果无法向前滚动，它们就有能力回滚，应用程序通常不会在至少确保某种程度的事务已记录的情况下向最终用户报告一切正常。我们希望这些情况都能存在，但没有什么能够保证它们，除非在端到端的应用程序和系统设计的结合下。即使是设计最好的应用程序，也可能会被虚拟机监控程序欺骗，它将易失性内存表现得像硬盘一样，并报告系统已空闲，但实际上没有写入任何存储数据。因此，需要信任。
- en: Dropping data in flight is only one concern. The other is corruption. Many layers
    along this path have a potential to become corrupted by an incomplete write operation.
    An individual file is often where we see corruption occur, this is the most common
    place. Twenty five years ago, we saw filesystem corruption regularly as well.
    Today this is not a common worry, but it does exist as a risk, still. Different
    filesystems carry different levels of risk for this type of scenario. In theory
    a logical volume management layer could hold some corruption risk. Certainly a
    storage layer of RAID or RAIN can become corrupted and sometimes, such as parity
    RAID, have some potential for total data loss during a corruption event.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 数据在传输过程中丢失只是一个问题，另一个问题是数据损坏。沿途的许多层可能会因写入操作不完整而发生损坏。单个文件通常是我们看到损坏发生的地方，这是最常见的地方。二十五年前，我们也经常看到文件系统损坏。今天这不再是一个常见问题，但它仍然存在风险。不同的文件系统在这种情况下的风险程度不同。理论上，逻辑卷管理层可能会存在某些损坏风险。显然，RAID
    或 RAIN 存储层可能会发生损坏，并且有时，如奇偶校验 RAID，在损坏事件发生时有可能导致数据完全丢失。
- en: All of these steps are unlikely, but all are possible. Missing or corrupt data
    will generally not happen during a normal crash. How likely a disaster is to happen
    depends on many factors. We should neither look at crash consistency level solutions
    as useless or total loss waiting to happen, but neither should we pretend that
    they do not ignore basic risks of not having any system in place to ensure consistency.
    In all cases we are simply rolling the dice and hoping for the best. I have seen
    a great many small businesses lose data with what they had thought were completely
    reliable backups because they were depending on crash consistency and a vendor
    had pretended that data corruption was not a concern. Because crash consistent
    mechanisms are cheap and simple, they get a lot of attention from vendors.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些步骤都不太可能发生，但都有可能发生。正常崩溃时通常不会发生丢失或损坏数据。灾难发生的可能性取决于许多因素。我们不应该把崩溃一致性级别的解决方案看作毫无用处或等待发生的完全损失，但我们也不应假装它们没有忽略没有任何系统确保一致性的基本风险。在所有情况下，我们只是在掷骰子并希望得到最好的结果。我见过许多小企业丢失了他们认为完全可靠的备份数据，因为他们依赖于崩溃一致性，而供应商却假装数据损坏不是一个问题。由于崩溃一致性机制便宜且简单，因此它们受到供应商的广泛关注。
- en: The alternative approach is called **application consistency**. We call it this
    because it refers to the potential state of the system when the workload application(s)
    are able to confirm that they have flushed all of their data to disk and have
    nothing currently in-flight. Applications may do this simply by confirming that
    they are quiesced currently, or they may have mechanisms to force such a state
    to occur. In either case, they avoid the problems of crash consistency by applying
    intelligence from the very top of the application stack and verifying that data
    is ready to be backed up.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 替代方法称为**应用一致性**。我们之所以这么称呼，是因为它指的是当工作负载应用程序能够确认已将所有数据刷新到磁盘，并且当前没有数据在传输中时，系统可能的状态。应用程序可以通过确认它们当前处于静默状态来简单实现这一点，或者它们可能有机制强制发生这种状态。无论哪种方式，它们通过从应用程序堆栈的最上层应用智能来避免崩溃一致性的问题，并验证数据已经准备好进行备份。
- en: This approach requires the application support providing this quiescence and
    if we want to coordinate this action with a backup mechanism, of any sort, we
    have to have some way for the backup mechanism to call the application to request
    quiescence, or for the application to call the backup mechanism. In the Windows
    world there is a standard interface in VSS as we discussed earlier than any application
    can support if they chose to do so. Linux lacks a similar standard at this time.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法要求应用程序支持提供这种静默状态，如果我们想将此操作与任何类型的备份机制协调，我们必须有一种方式让备份机制调用应用程序请求静默，或者让应用程序调用备份机制。在
    Windows 环境中，正如我们之前讨论的，VSS 提供了一个标准接口，任何应用程序都可以选择支持。如果它们愿意的话。当前 Linux 没有类似的标准。
- en: Because all of these mechanisms are complex and non-standard it presents major
    challenges when working with anything outside of a limited scope of popular services
    that are well known and supported. In reality, Windows is also similarly limited
    but the use of a smaller set of very standard services is more common there.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 因为所有这些机制都复杂且非标准化，所以在处理任何超出有限范围的流行服务时，都会遇到重大挑战，这些服务通常是广为人知且得到支持的。实际上，Windows
    也同样有限，但在那里使用一小部分非常标准的服务更为常见。
- en: Many applications choose to tackle this problem by incorporating their own backup
    services rather than attempting to depend on some other mechanism. Some may build
    an extremely robust backup mechanism that directly supports many different options
    such as built-in schedules, multiple backup levels, and storing directly to many
    different types of media. This is not very common but certainly exists.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序选择通过集成自己的备份服务来解决这个问题，而不是尝试依赖其他机制。有些可能会构建一个非常强大的备份机制，直接支持多种不同的选项，例如内置的调度、多级备份以及直接存储到多种不同类型的介质。这种情况并不常见，但确实存在。
- en: The most common option used by everything from the simplest of applications
    to enterprise databases is to simple write a backup file from the application
    directly to the local filesystem. The is extremely common and very effective.
    This produces a simple file or set of files that can be designated as a backup
    and kept from being used other than for the purposes of another backup mechanism
    using these files to then copy or send to another location.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 从最简单的应用程序到企业数据库，最常用的选项就是直接从应用程序写一个备份文件到本地文件系统。这是非常常见且有效的方法。它会生成一个简单的文件或一组文件，可以指定为备份，并防止它们被用于除另一个备份机制之外的其他用途，后者会使用这些文件来复制或发送到其他位置。
- en: A really common example of this is MySQL and MariaDB databases. Databases are
    our hardest type of application to safely backup and so nearly any database system
    will incorporate some means of safely protecting the data without having to resort
    to a drastic, brute-force step such as shutting down the databases, coping files,
    and starting it back up when completed.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个非常常见的例子是 MySQL 和 MariaDB 数据库。数据库是我们最难以安全备份的应用程序类型，因此几乎所有的数据库系统都会采用某种方式来安全地保护数据，而不必采取如关闭数据库、复制文件并在完成后重新启动等极端的暴力步骤。
- en: MySQL example with mysqldump utility
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 mysqldump 工具的 MySQL 示例
- en: Almost certainly the most well-known application level backup tool in the Linux
    ecosystem is `mysqldump` that comes with MySQL and MariaDB. This simple command
    line tool connects to a running MySQL or MariaDB database server, locks it and
    quiesces all of its data in RAM (it has no need to flush to disk), and then saves
    a copy of this data to disk. It is as simple to use as any utility could be while
    also being outrageously power. It has almost no impact on a running system and
    because it does not need to do any complicated flush to disk before taking a fully
    application-consistent copy to disk it does not need to stop read operations to
    the database and only needs to halt write applications for the briefest of moments.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎可以肯定，Linux 生态系统中最著名的应用级备份工具是随 MySQL 和 MariaDB 提供的`mysqldump`。这个简单的命令行工具连接到一个正在运行的
    MySQL 或 MariaDB 数据库服务器，锁定它并将所有数据静默到内存中（它不需要刷新到磁盘），然后将这份数据的副本保存到磁盘。它是任何工具中最简单易用的，同时也是极其强大的。它对正在运行的系统几乎没有影响，而且由于它不需要在将应用程序一致性的副本保存到磁盘之前进行任何复杂的刷新操作，所以不需要停止数据库的读取操作，只需要短暂暂停写操作。
- en: 'I will show here the simple, single command to take an easy backup of every
    database managed by a single MySQL or MariaDB instance:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我将展示一个简单的单一命令，用于轻松备份由单个 MySQL 或 MariaDB 实例管理的所有数据库：
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This example is about as basic as you can get, and yet it is so effective. You
    can run it anytime and because it takes the current time during the process it
    will not overwrite another backup file, even one takes just a minute earlier.
    You can make it write anywhere on disk that you like. You can use standard utilities
    to compress the resulting backup file while it is being written or at a later
    time very easily. Keep in mind this is a backup file, a file for the purpose of
    making a backup, but not an actual backup yet at this point.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子几乎是最基础的，你几乎无法简化得更多了，但它非常有效。你可以随时运行它，并且因为它在过程中记录当前时间，所以它不会覆盖任何其他备份文件，即使是比它早一分钟创建的文件。你可以将备份写入磁盘上的任何位置。你可以在备份文件写入时或稍后使用标准工具轻松地压缩生成的备份文件。请记住，这只是一个备份文件，是用来进行备份的文件，但到此时它还不是一个实际的备份。
- en: Once this file is stored to disk, it is safe and any backup tool can now take
    this file without worry than an application is using it or modifying it and place
    it wherever it makes sense. Total flexibility and simple application-consistency.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这个文件存储到磁盘，它就变得安全，任何备份工具现在都可以在不担心应用程序正在使用或修改它的情况下获取这个文件，并将其放置在任何合理的位置。完全灵活，且应用程序的一致性简单易懂。
- en: At this point I think we understand consistency, how locks and quiescence play
    a role, and all of the problems that we may face while trying to make a backup
    of even a single file or application (remember that not all backups involve data
    that is actually in file format on storage anywhere), let alone trying to back
    up entire filesystems or systems. Appreciating the challenge is key to understanding
    why we are concerned about different aspects of different types of backup tools
    which we will look at next together.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我认为我们理解了一致性、锁定和静止状态的作用，以及在尝试备份甚至单个文件或应用程序时可能面临的所有问题（请记住，并非所有备份都涉及存储在任何地方的文件格式数据），更不用说尝试备份整个文件系统或系统了。理解这一挑战是关键，因此我们关心不同类型的备份工具的不同方面，下面我们将一起进行探讨。
- en: Backup strategies & mechanisms
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 备份策略与机制
- en: Backups are actually far more complex animals than most people imagine. So often
    when dealing with backups we are simply told to *take a backup* as if this is
    a straightforward activity with few variables. In the real world we do have some
    stock approaches that meet the majority of needs, if only minimally. There are
    cases, however, where to do effective backups requires a lot more thought and
    deep understanding of our workloads and infrastructure to be able to get correct.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，备份比大多数人想象的要复杂得多。在处理备份时，我们经常只是被告知“进行备份”，好像这是一个简单的活动，几乎没有变数。然而，在现实世界中，我们确实有一些常规方法，可以满足大多数需求，即使只是最低限度地满足。然而，在某些情况下，要有效地进行备份需要更多的思考，并且需要深入理解我们的工作负载和基础设施，以便能够正确地进行操作。
- en: In the good old days, you know like the 1980s and 1990s, backups were almost
    always the same. They involved a simplistic agent of some sort, like the standard
    Linux `tar` command, that would run on a schedule (that we probably had to set
    manually with something like `cron`) that would take all of the files in a directory
    or, more likely, the entire system and package them up as a single file and place
    that single, large file onto a tape device. That tape device would then require
    a human to remove the tape and transport somewhere for safe keeping.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的好日子里，就像上世纪80年代和90年代那样，备份几乎总是相同的。它们涉及某种简单的代理程序，例如标准的Linux `tar`命令，该命令会按计划运行（我们可能需要手动设置类似于`cron`的计划任务），它会将一个目录中的所有文件，或更可能是整个系统，打包成一个单一文件，并将该单个大文件放置在磁带设备上。然后需要人为移除磁带并将其运输到安全地点。
- en: Over the years new technologies would come out and backups slowly became more
    robust and more complex to discuss. Tape became less popular and other backup
    targets ranging from swappable hard disks to constantly online storage emerged.
    With backup media evolving the mechanisms that took backups had an opportunity
    to move from discrete *one tape per backup* schedules to more flexible or complex
    designs. With all of this came complex backup applications and the backup world
    went from simple and basic to quite complex.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，新技术不断涌现，备份逐渐变得更加强大和复杂。磁带逐渐不受欢迎，而其他备份目标，从可交换的硬盘到始终在线的存储，也应运而生。随着备份介质的发展，备份机制有机会从离散的“每次备份一磁带”的计划转变为更灵活或更复杂的设计。伴随而来的是复杂的备份应用程序，备份领域由简单和基础的状态转变为相当复杂的情况。
- en: Because there are so many variables today, simply taking a backup is no longer
    a straightforward concept. People all have different views and ideas of what a
    backup entails based on their desires and experience. It is so varied that we
    even risk tunnel vision and thinking that all people see and experience backups
    similarly when, in reality, there are so many different ways being used in the
    real world to handle backup needs.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 由于今天涉及的变量如此之多，简单地进行备份已不再是一个简单的概念。每个人对备份的理解和需求各不相同，基于他们的期望和经验。这种多样性甚至可能导致我们产生视角狭窄的危险，认为所有人都以类似的方式看待备份，而实际上，现实世界中处理备份需求的方式有很多种。
- en: Types of backups
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 备份类型
- en: 'First, we will discuss the actual backup mechanisms that may be used. These
    generally fall into two categories: agent based and agentless (I really hate both
    of these terms) but people normally think of them as three categories with a third
    being ad-hoc scripts. All of these ideas around their identities are totally wrong,
    of course, as are so many things that people tend to say. The terms have made
    inroads and you will need to use them regardless of their inaccuracies, however.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将讨论可能使用的实际备份机制。这些通常分为两类：基于代理的和无代理的（我真的讨厌这两个术语），但人们通常会将其视为三类，其中第三类是临时脚本。关于它们身份的所有这些想法当然都是完全错误的，正如许多人常说的那样。这些术语已经得到了广泛使用，尽管它们不准确，你仍然需要使用它们。
- en: System level backups
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 系统级备份
- en: System level backups are the so-called agent-based backups. These get this name
    because typically a software agent that runs on top of the operating system is
    installed and is visible. It can be seen in an installed software list somewhere
    on the system. The agent then runs and grabs files from *inside* of the operating
    system context and send them off somewhere else to be stored. There is often additional
    processing steps such as packaging, compression, deduplication, and encryption,
    but all of those are technically optional.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 系统级备份就是所谓的基于代理的备份。这些备份之所以得名，是因为通常会在操作系统上安装一个运行的软件代理，并且该代理是可见的。你可以在系统上的某个地方看到它出现在已安装的软件列表中。然后，代理会运行并从操作系统上下文的*内部*抓取文件，并将其发送到其他地方进行存储。通常会有额外的处理步骤，如打包、压缩、去重和加密，但这些技术上都是可选的。
- en: Everything is an agent
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一切都是代理
- en: When we say that we have an agent-based backup solution it brings to mind software
    that must be purchased, downloaded, and installed onto our computers. Certainly,
    this is a very common thing that people will do.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说有一个基于代理的备份解决方案时，脑海中会浮现出必须购买、下载并安装到我们计算机上的软件。毫无疑问，这是人们常做的事情。
- en: The idea of an agent is, however, far broader. Backup agents may be complex
    backup utilities that are built into the operating system rather than obtained
    separately. In the Linux world this is just as likely to be the case as not because
    so many powerful backup options are included in the repository ecosystems of the
    typical business-class distributions.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，代理的概念要广泛得多。备份代理可能是操作系统中内置的复杂备份工具，而不是单独获得的。在Linux世界中，这种情况几乎是常见的，因为许多强大的备份选项已经包含在典型企业级发行版的仓库生态系统中。
- en: Agents get even broader still. Classic utilities like `tar` and `rsync` are,
    or at least can be, backup agents. They are installed software components that
    can be used to carry out a backup from inside of the operating system.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 代理的范围甚至更广。像`tar`和`rsync`这样的经典工具，就是，或者至少可以成为，备份代理。它们是已安装的软件组件，可以用于在操作系统内部执行备份。
- en: We can keep going. If you write your own script to move blocks or files around
    that, too, is an agent. The idea of an agent is incredibly broad and, logically,
    some component is always needed to perform a backup job and that component is
    always an agent.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续下去。如果你编写自己的脚本来移动块或文件，那也是一个代理。代理的概念非常广泛，从逻辑上讲，总是需要某个组件来执行备份任务，而这个组件永远是代理。
- en: By working from inside of the operating system, an agent located here has the
    ability to utilize obvious access methods to the data that we want to back up.
    It can access the block devices directly either by talking at a block level with
    a tool like `dd` or by using a slightly high-level logical volume tool like LVM
    which can provide robust block level handling; or it can use the filesystem layer
    to request files one by one; or it can use APIs to talk to running applications
    that can provide some type of higher level managed data access. In one or more
    of these ways an agent can access the data necessary for a backup.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在操作系统内部工作，位于此处的代理可以利用明显的访问方法来访问我们想要备份的数据。它可以通过使用像`dd`这样的工具在块级别与存储设备进行通信，或者使用像LVM这样的稍高层次的逻辑卷工具来提供强大的块级处理；或者它可以使用文件系统层逐一请求文件；或者它可以使用API与正在运行的应用程序进行交互，从而提供某种类型的高级数据访问。通过这些方式中的一种或多种，代理可以访问备份所需的数据。
- en: All of this is to say that agents have the task of talking to the operating
    system in an attempt to trigger some level of quiescence from the storage subsystem
    to increase the chances of getting a consistent backup. Some agents talk extensively
    to many applications and some talk to none.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这一切都意味着，代理程序的任务是与操作系统进行交互，尝试从存储子系统中触发某种程度的静默，以增加获得一致性备份的机会。有些代理程序会与许多应用程序进行广泛的交互，而有些则根本不与任何应用程序交互。
- en: Agents do all of the work and offer us many ways to talk to our data. But they
    have the limitation that they can only access what the operating system can access
    and they can only be used when the operating system is up and running. This last
    point means that any resources that the operating system itself is using will
    be in use at the same time that the agent needs to access them. This makes for
    a real challenge in system-wide consistency. However, we rarely are truly concerned
    with consistency on a full system scale. Of course, we would prefer it, but the
    majority of system files are of little consequence and easily replaced if lost
    or corrupted. Typically, only critical application data or maybe installed applications
    themselves are of major concern and the rest is just useful in case of a need
    to restore quickly.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 代理程序完成所有工作，并提供多种方式与我们的数据进行交互。但它们有一个局限性，那就是它们只能访问操作系统能够访问的内容，并且只有在操作系统启动并运行时才能使用。最后这一点意味着，操作系统本身正在使用的任何资源，在代理程序需要访问它们时也会处于使用状态。这就给系统范围内的一致性带来了真正的挑战。然而，我们很少真正关心整个系统范围内的一致性。当然，我们会更喜欢一致性，但大多数系统文件的影响较小，如果丢失或损坏，也能轻松恢复。通常，只有关键的应用程序数据或安装的应用程序本身才是主要关注点，其他的文件只是为了在需要快速恢复时提供帮助。
- en: Typically, but not universally, with system-level backups it is necessary when
    performing a restore operation to install an empty operating system and then install
    the restore agent and allow the agent to run against the stored backup and put
    files back into place inside the operating system. This often means that system-level
    backups are excellent at taking backups of individual files and being able to
    restore individual files but find it more difficult to deal with having to restore
    entire lost systems.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，但不是普遍的，对于系统级备份，进行恢复操作时，必须先安装一个空的操作系统，然后安装恢复代理，并允许代理对存储的备份进行操作，将文件恢复到操作系统中。这通常意味着系统级备份在备份单个文件并能够恢复单个文件方面表现优秀，但在恢复整个丢失的系统时却更加困难。
- en: There was a time when essentially all backups worked this way and the general
    assumption was that nearly all restore operations were to retrieve single lost
    files rather than to retrieve entire failed systems.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 曾经一度，几乎所有备份都是这么做的，普遍的假设是，几乎所有恢复操作都是为了检索单个丢失的文件，而不是为了恢复整个失败的系统。
- en: People just do not lose files like they used to
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 人们已经不再像以前那样丢失文件了。
- en: In writing this chapter I was struck by a massive, fundamental change in the
    computing experience for most people over the last thirty years. Through all of
    my younger years in the industry and even before simply as a computer user, the
    big concern that we always had was losing, deleting, or having an individual file
    become damaged in some way. We really all pictures the concept of backups as just
    being lots of individual files being copied somewhere, and we envisioned any restoration
    to be a process of copying those files back once we had a place to put them and
    more often than not, needing to do so when there had been no failure whatsoever.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在写这章时，我被过去三十年中计算体验的巨大根本变化所打动。在我年轻时的整个行业生涯中，甚至在我只是一个计算机用户之前，我们最大的担忧一直是丢失、删除或使某个文件以某种方式损坏。我们所有人都把备份的概念看作是将许多单独的文件复制到某个地方，我们设想任何恢复过程就是把那些文件复制回来，一旦有了存放它们的地方，而往往这种恢复操作的发生是没有任何故障的情况下进行的。
- en: This last point is what is most interesting to me. For decades it was assumed
    that people were going to accidentally overwrite or just delete critical files
    that they needed with great regularity, and it really happened. Needed to track
    down and restore an individual file that an end user deleted was a completely
    common task that was done so often that most large companies had teams dedicated
    to doing nothing else.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最后这一点是我最感兴趣的。几十年来，人们一直认为他们会经常意外覆盖或删除自己需要的关键文件，而这确实发生过。需要追踪并恢复一个终端用户删除的单个文件是一个完全常见的任务，这项工作如此频繁，以至于大多数大公司都有专门的团队来专职处理这类事务。
- en: Computing has changed such that today, this is rarely the case and the idea
    that an important file would be lost on its own does not seem impossible, but
    certainly seems unlikely. I assume users have become better educated and far more
    diligent with how files are managed, and of course a huge percentage of work that
    used to be done as individual files has moved to some sort of database of data
    stored behind an application front end that protects end users from themselves
    (this could range from Google Docs to Flickr, but even end users working with
    their own file management has decreased significantly.) Most operating systems,
    and even some applications themselves, now implement *trash* features that hold
    deleted files until they are explicitly disposed of to give end users lots of
    time to change their minds or find what was deleted accidentally. And finally
    there are features like self-service file restores included in operating systems
    or from simple add-on applications that allow files to be brought back from other
    media without needing to engage traditional backups or backup teams as the data
    is still stored somewhere locally (not to mention online backup systems that can
    be used by end users without intervention.)
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 计算已经发生了改变，今天这种情况很少见，重要文件自行丢失的想法似乎不可能，但肯定是不太可能的。我假设用户在文件管理方面变得更加有教养和更加勤奋，当然，过去作为个别文件完成的大部分工作已经转移到某种数据库或者数据存储在应用程序前端背后的地方，这保护了最终用户免受自己的伤害（这可能从Google
    Docs到Flickr，但即使是最终用户自己管理文件的工作也显著减少）。大多数操作系统，甚至一些应用程序本身，现在都实施了*回收站*功能，这些功能将删除的文件保留，直到它们被明确处理，以便最终用户有足够的时间改变主意或找回意外删除的内容。最后，像操作系统自带的自助文件恢复功能或者简单的附加应用程序都可以让文件从其他媒体恢复回来，而无需引入传统的备份或者备份团队，因为数据仍然本地存储（更不用说可以被最终用户使用的在线备份系统了）。
- en: It is simply interesting to note that something that had become such a common
    problem that it drove most of an industry not that many years ago is effectively
    gone today. The days of computers being seen as file management and manipulation
    devices are gone and have given way to being online data consumption devices where
    most users are not even file-aware any longer. Many younger users can even be
    confused at the concept of file and storage management today.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，值得注意的是，曾经成为一个常见问题，甚至推动整个行业发展的问题，如今在今天已经基本消失了。计算机被视为文件管理和操作设备的时代已经过去，现在已经变成了在线数据消费设备，大多数用户甚至不再关注文件。今天的许多年轻用户甚至可能对文件和存储管理的概念感到困惑。
- en: Platform level backups
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 平台级备份
- en: The alternative approach is to take a backup from the platform level, that is
    from the layer underneath the operating system. In practical terms this means
    the virtualization layer which would entail typically the hypervisor, but in some
    cases can be limited to external (to the operating system) storage virtualization,
    this would be especially common if using a SAN device, for example.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是从平台级别进行备份，即从操作系统下层进行备份。在实际操作中，这意味着虚拟化层，通常是指虚拟化监控程序，但在某些情况下可能仅限于操作系统外部的存储虚拟化，例如，如果使用SAN设备，这种情况尤其常见。
- en: This approach became all the rage with the advent of virtualization. New backup
    vendors entered the market with new technology aimed at making extra-operating
    system backups easier and faster. Backups at this level, of course, do not have
    access to things like the filesystem or application APIs to communicate with those
    components or to have knowledge of the data layout. So backups taken at this level
    must do so by talking directly to the block devices or to hypervisor level storage
    abstraction layers, which are essentially block devices themselves, leaving us
    generally blind to what the data is that we are actually getting. At this layer
    we might know, but only maybe, about the physical separation of devices presented
    to the operating system. But we have no visibility into filesystems or deeper.
    So all of the concerns that we have with system-level backups and consistency
    are potentially magnified many times over. Not only do we have no way to know
    if an individual application workload has quiesced, but we cannot even tell inform
    the system-managed filesystem, file locks, or logical volume manager that we are
    attempting to read the block devices. So if we take a backup at this level alone,
    we are totally blind and simply reading blocks off of a virtual disk with no reason
    to believe that it is in any sort of a consistent state and nothing tells the
    operating system that anything is happening at all. If we do this alone, the operating
    system literally has no way to know that it is happening.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 随着虚拟化的到来，这种方法迅速流行起来。新的备份厂商推出了新技术，旨在使操作系统外的备份更简单、更快速。此层级的备份当然无法访问文件系统或应用程序API，无法与这些组件进行通信或了解数据布局。因此，进行此层级的备份必须直接与块设备或虚拟化层的存储抽象层进行交互，而这些抽象层本质上是块设备本身，这让我们通常无法知晓正在备份的数据到底是什么。在这个层级，我们可能知道，或者说可能知道，操作系统呈现给我们的物理设备分离。但我们无法看见文件系统或更深层次的内容。因此，我们在进行系统级备份时所关心的一切一致性问题，可能会在此层级被放大多倍。我们不仅无法知道一个特定的应用工作负载是否已经静默，而且我们甚至无法告诉系统管理的文件系统、文件锁或逻辑卷管理器，我们正在尝试读取块设备。所以，如果我们仅在这个层级进行备份，我们实际上是完全盲目的，仅仅从虚拟磁盘中读取块数据，而没有理由相信这些数据处于一致状态，而且没有任何信息告诉操作系统有任何事情发生。如果我们仅仅这样做，操作系统根本无法知道事情正在发生。
- en: It does not take very much thinking about how this mechanism has to work to
    realize that platform-level backups without an agent are all but impossible. We
    could shut down a virtual machine and take a backup of its storage layer while
    the machine is powered down, of course. The shutdown process of a total operating
    system is effectively the best way to ensure full quiescence and consistency.
    How do we shut down a virtual machine from the platform level without just pulling
    the virtual plug on it and putting ourselves into a state of crash consistency?
    Surprisingly, with an agent.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要多想就能意识到，没有代理的平台级备份几乎是不可能实现的。我们当然可以关闭虚拟机，并在其关闭时对存储层进行备份。操作系统的完全关闭过程实际上是确保完整静止和一致性的最佳方式。我们如何在不直接拔掉虚拟插头并让自己进入崩溃一致性状态的情况下，从平台级别关闭虚拟机呢？出奇的是，使用了代理。
- en: 'This is the big secret of platform-level (aka *agentless*) backups: they use
    an agent! They have to. In the real world taking a backup directly from any lower
    level service would be completely unreliable. But I hear you murmuring *I''ve
    done this, everyone has, and we don''t install any agents*.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是平台级（即*无代理*）备份的最大秘密：它们使用了代理！必须使用代理。在现实世界中，直接从任何低层服务进行备份是完全不可靠的。但我听到你在低声说*我做过这种事，每个人都做过，而且我们不安装任何代理*。
- en: What makes the backup agents in virtualization environments hard to identify
    is because we install them automatically and universally so that we do not think
    about it. In some cases, these agents are built right into the operating system.
    They have different names depending on the platform that you are using. The most
    famous is VMware Tools as VMware uses this and the installation process is well
    known. KVM, the primary hypervisor in the Linux world, has the guest agent built
    not just into most Linux-based operating systems, but actually baked right into
    the Linux kernel itself! So you never actually need to see the agent, even though
    it is almost always there. Many Linux distributions do the same with Hyper-V's
    equivalent agent called Linux Integration Services, which are not built into the
    kernel but are often included in the operating system automatically.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟化环境中，使备份代理难以识别的原因是因为我们自动和普遍地安装它们，以至于我们不会去思考它。在某些情况下，这些代理程序直接构建到操作系统中。根据您使用的平台不同，它们有不同的名称。最著名的是VMware
    Tools，因为VMware使用它，并且安装过程众所周知。KVM，Linux世界中的主要虚拟化管理程序，不仅将客户机代理内置到大多数基于Linux的操作系统中，而且实际上直接内置到Linux内核中！因此，您实际上永远不需要看到代理，尽管它几乎总是存在的。许多Linux发行版也采用了Hyper-V的等效代理称为Linux集成服务，虽然它们没有内置到内核中，但通常会自动包含在操作系统中。
- en: In these cases, the agents from the hypervisor vendors that I have used as examples
    are not strictly backup agents, they are general purpose agents used to coordinate
    activity between the hypervisor and the operating system, but in reality, that
    is simply a more advanced agent function and nothing more. They are agents in
    every possible sense of the word, they are software that has to be installed into
    the operating system to work, and just like more traditional backup agents they
    are sometimes included with the operating system and are sometimes third-party
    add-on packages.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，我用作示例的虚拟化管理程序供应商的代理程序并不严格是备份代理程序，它们是用于协调虚拟化管理程序和操作系统之间活动的通用代理程序，但实际上，这只是一个更高级的代理功能，没有其他更多内容。从各种可能意义上来看，它们都是代理软件，必须安装到操作系统中才能工作，就像更传统的备份代理程序一样，有时它们包含在操作系统中，有时是第三方附加包。
- en: These agents are generally part of a set of high-performance drivers needed
    to make full virtual machines work efficiently and so are rarely left missing.
    They provide a critical channel that allows the underlying platform layer to communicate
    up to the operating system layer or even higher. This communications channel is
    what is used to issue graceful shutdown commands to a virtual machine as well
    as to inform it that it needs to quiesce a filesystem or take a snapshot of a
    volume. In theory this agent could even hook into a specific application, although
    this is mostly only theoretical in the Linux world.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这些代理通常是一组高性能驱动程序的一部分，用于使完整虚拟机高效运行，因此很少被忽略。它们提供了一个关键通道，允许底层平台层与操作系统层甚至更高层通信。这种通信通道用于向虚拟机发出优雅关闭命令，以及通知其需要使文件系统静默或对卷进行快照。理论上，这种代理甚至可以钩入特定应用程序，尽管在Linux世界中这主要是理论性的。
- en: There are important advantages to taking platform level backups. If we ponder
    the workings of these backup systems, we easily see that the expectation is going
    to be a block-level image taken of an entire file system container or block device.
    The real advantage to this is in its completeness. If we take an image level backup,
    rather than a file backup, we have an opportunity to have the entire device, not
    just portions of it, that will presumably allow us to restore a system completely
    rather than having to rebuild and then restore partially.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 进行平台级备份有重要的优势。如果我们考虑这些备份系统的工作原理，我们很容易看到预期将是对整个文件系统容器或块设备进行块级镜像拍摄。这样做的真正优势在于其完整性。如果我们进行镜像级备份，而不是文件备份，我们有机会获得整个设备，而不仅仅是其部分内容，这将使我们能够完全恢复系统，而不必部分重建然后再恢复。
- en: Disk images
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 磁盘镜像
- en: When we talk about file level backups the essential mechanism, we are discussing
    is ultimately a file copy of some sort. File X exists on the filesystem that we
    want to protect and in order to protect the data that is in that file we copy
    that file to another location so that the data can exist in more than one place
    at the same time. Easy.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论文件级备份的基本机制时，最终讨论的是某种形式的文件复制。文件 X 存在于我们想要保护的文件系统中，为了保护该文件中的数据，我们将该文件复制到另一个位置，以便数据可以同时存在于多个地方。简单明了。
- en: With full block device copies at the platform level, we refer to the resulting
    copy as an image or a disk image. In theory we could be copying from one physical
    block device to another or, at the very least, from a virtual block device to
    a physical one. In nearly all real-world cases, especially those involving backups,
    what we actually do is copy the block device to a file. That file is called a
    disk image and is sometimes referred to oddly as an ISO file.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在平台级别进行完整块设备复制时，我们称结果复制为镜像或磁盘镜像。理论上，我们可以从一个物理块设备复制到另一个物理块设备，或者至少从一个虚拟块设备复制到物理块设备。在几乎所有实际情况下，特别是涉及备份的情况，我们实际上是将块设备复制到一个文件中。该文件称为磁盘镜像，有时奇怪地被称为ISO文件。
- en: We call this an image because it is essentially a picture of the entire disk
    as it was in any given moment. We also use the term snapshot to refer to this
    same operation. In regular English a snapshot is an image. The words are nearly
    interchangeable. The same is true in computing. Sometimes one is used to imply
    something different from the other, but there is no accepted definition that makes
    them not completely overlap.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之所以称之为镜像，是因为它本质上是任何给定时刻整个磁盘的图像。我们还使用“快照”一词来指代同一操作。在常规英语中，快照就是镜像。这些术语几乎可以互换使用。在计算中也是如此。有时一个术语被用来暗示与另一个不同的含义，但没有被接受的定义使它们不完全重叠。
- en: In every day usage, images are used to refer to images stored as regular files,
    such as ISO files and contain a complete copy of the original filesystem. Snapshots
    are used to refer to a nearly identical scenario but where a logical volume manager
    creates a partial image file that is in some way linked to the original file and
    may contain only the differences between the two. But that file is often used
    to make a standalone image file, which is indistinguishable from an image file
    otherwise, but is still called a snapshot. Which leads to the inappropriate situation
    where two identical files can have different designations based solely on untraceable
    and unknowable histories. Obviously, there are common misconceptions in what these
    files are that lead to these different uses of names for the same thing. Nevertheless,
    images and snapshots are overlapping concepts.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在日常使用中，“镜像”通常指存储为常规文件的镜像，例如ISO文件，并包含原始文件系统的完整副本。而“快照”通常指几乎相同的情景，但逻辑卷管理器创建的部分镜像文件与原始文件以某种方式连接，并且可能仅包含两者之间的差异。但该文件通常用于创建一个独立的镜像文件，否则与镜像文件无异，但仍被称为快照。这导致了一个不恰当的情况，即两个相同的文件可能基于不可追踪和不可知的历史有不同的命名。显然，关于这些文件的常见误解导致了对相同事物不同名称的使用。尽管如此，镜像和快照是重叠的概念。
- en: Because a disk image contains the entire contents of a block device it can be
    used to directly restore the entire block device, even onto hardware that has
    no knowledge of what that block device should contain. If you backup a Linux server
    and restore it, the entire system is restored, even if it was encrypted. An image
    will not bypass the encryption, but the encryption will do nothing to alter the
    imaging process.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因为磁盘镜像包含块设备的全部内容，所以可以直接用于恢复整个块设备，甚至在没有任何了解该块设备应包含什么的硬件上也可以。如果备份了Linux服务器并进行了恢复，整个系统都将恢复，即使它被加密。镜像不会绕过加密，但加密也不会改变镜像过程。
- en: Most virtualization platforms, even when using external storage devices like
    a SAN device, will storage the disk(s) belonging to a virtual machine as one or
    more disk image files (often in an advanced format rather than a raw ISO file.)
    This demonstrates that the image file is a full block device (virtually) and so
    can be used anywhere that any other block device is used. This is very important
    when we want to talk about restoring our data. If we have a complete image file,
    no restoration is needed if it exists in a place where we can access it. We can
    mount it directly under the right circumstances.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数虚拟化平台，即使使用外部存储设备如SAN设备，也会将属于虚拟机的磁盘存储为一个或多个磁盘镜像文件（通常不是原始ISO文件而是一种高级格式）。这表明镜像文件是一个完整的块设备（虚拟），因此可以在任何其他块设备使用的地方使用。这在我们想要谈论恢复数据时非常重要。如果我们有一个完整的镜像文件，在我们能够访问的地方就不需要恢复。我们可以根据需要直接挂载它。
- en: Image backups have some big advantages because they can be taken *closer to
    the hardware* when it comes to performance. There are also big disadvantages,
    so it is not all roses.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像备份在性能方面可以更接近硬件，因此具有一些重要优势。但也存在一些显著的劣势，所以并非一切都很完美。
- en: Advanced snapshot technologies that allow the system to essentially freeze a
    moment in time and work with it while the system is still under active use is
    a big deal for allowing major backups of active systems to have effectively. Taking
    full system images is by far the easiest process for handling backups because
    we do not have to think about what we are backing up, we just grab everything.
    Not only can we grab an entire operating system, but we can grab all of every
    operating system that exists on a single hypervisor. We can even take backups
    of virtual machines that are powered down as well as those that are actively running.
    System level backups have to happen per system, can only be done when the system
    is running, and only in very limited situations can they effectively take a complete
    backup and even more rarely can they find a way to do it that provides for a complete
    block level recreation of the system that can be restored in the same way.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 允许系统在仍然处于活动使用状态时冻结某一时刻并与之一起工作的先进快照技术对于允许主要备份活动系统具有重大意义。获取完整系统镜像是处理备份的最简单过程，因为我们不必考虑备份的内容，只需获取所有内容。我们不仅可以获取整个操作系统，还可以获取单个虚拟化层上存在的每个操作系统的所有内容。我们甚至可以对关闭电源的虚拟机以及正在运行的虚拟机进行备份。系统级别的备份必须针对每个系统进行，只能在系统运行时完成，并且只有在非常有限的情况下才能有效地进行完整备份，甚至更少的情况下才能找到一种方法以提供可以在相同方式中恢复的完整块级重新创建系统。
- en: Platform level backups have been all the rage for over a decade now for good
    reasons. They are efficient, they protect against failing to select the right
    data to be backed up, they can easily be handled by a different team than the
    standard system administrators if necessary, and they can be done at large scale
    with essentially no deployments needing to be done to work (other than the deployments
    of agents that are needed otherwise, and the deployment of the backup software
    to the hypervisor layer.) Platform level backups fit perfectly into how most organizations
    want to be able to work, and they are exceptionally easy for support vendors to
    provide blindly as a service without needed to do any due diligence.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 平台级别的备份现在已经流行了十多年，原因充分。它们高效，可以防止选择正确要备份的数据失败，如果必要，可以由不同的团队处理，而不是标准的系统管理员，而且可以在大规模上实施，基本上不需要进行其他工作（除了需要的代理部署和备份软件部署到虚拟化层）。平台级别的备份完全符合大多数组织希望工作的方式，并且对支持供应商来说，作为服务提供是非常容易的，无需进行任何尽职调查。
- en: Platform level backups come with plenty of caveats too, however, and we need
    to be aware of why we might not want to be focused on them most of the time. Being
    blind they generally require the most storage capacity to hold the backups as
    they tend to contain a lot of data that is unnecessary such as system files. This
    bloat also means that moving the resulting images around whether for archival
    purposes or to get the file(s) where they need to be for a restore will potentially
    take longer than would otherwise be required. Agents still need to be deployed.
    Mistakes are easily made because the system is almost universally misunderstood
    and, like so many things that are too complicated for the average user to grasp,
    they are seen as a panacea rather than just another tool to consider.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 平台级别的备份也有很多注意事项，因此我们需要意识到为什么大部分时间我们可能不希望专注于它们。由于其盲目性，通常需要最大的存储容量来存储备份，因为它们往往包含许多不必要的数据，比如系统文件。这种膨胀还意味着，不论是出于存档目的还是为了将文件移到恢复所需的位置，移动生成的镜像都可能比通常所需的时间长。仍然需要部署代理。系统几乎普遍被误解，因此很容易犯错，就像许多对于普通用户来说过于复杂而被视为万灵药而不是考虑的另一种工具。
- en: Quiescence is a real struggle for platform level backup. Even when all agents
    are properly in place, the nature of those agents is that they expose fewer options
    and have fewer hooks into the application layer meaning that there is a higher
    risk that backups taken from this layer will only be crash consistent. Operating
    system files will be protected because there is nearly always proper communications
    made to the operating system itself via the agent, but almost no application workload
    will be protected by that.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 平台级别备份对于平静状态确实是一个真正的挑战。即使所有代理都正确放置，这些代理的性质是它们暴露的选项较少，并且在应用层面的钩子较少，这意味着从该层面获取的备份有较高的风险，可能只是崩溃一致的。操作系统文件将受到保护，因为几乎总是通过代理与操作系统本身进行适当的通信，但几乎没有应用工作负载会受到保护。
- en: Platform level backup is flashy and cool. It is an easy way for vendors to capitalize
    on backup fears while doing minimal work; it is an easy path to big margins with
    any actual risks being pushed off to the customers who rarely do their homework.
    It makes customers feel safe because the risks are too complex for even more IT
    practitioners to grok, and it lets them tell themselves that they are protected.
    Ignorance makes people sleep well at night.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 平台级备份很引人注目且酷炫。它是供应商通过做最少的工作来利用备份恐惧的简单方式；它是一条容易获得大幅利润的捷径，而任何实际的风险都被推给了那些很少做功课的客户。它让客户感觉安全，因为这些风险太复杂，甚至更多的IT从业人员都无法理解，它让他们可以告诉自己，他们得到了保护。无知让人晚上睡得安稳。
- en: Platform level backup is a power tool and a modern marvel, but it is still just
    one mechanism, just one approach and certainly not one that fits the bill every
    time.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 平台级备份是一项强大的工具，是现代的奇迹，但它仍然只是一个机制，一种方法，当然也不是每次都适用的。
- en: That was a lot of information about two very simple backup mechanisms. We needed
    that solid understanding so that we can move on to talking about many concepts
    that exist in and around the backup and recovery world.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是关于两种非常简单的备份机制的许多信息。我们需要有这个扎实的理解，以便能够继续讨论备份和恢复领域中许多存在的概念。
- en: Snapshots, archives, backups, and disaster recovery
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快照、归档、备份和灾难恢复
- en: There are many technologies that are either confused with backups, or may be
    a component of a backup. In this section I want to break down these basics and
    make sure that we understand what they are, why they matter, how they are used,
    and when we should leverage them ourselves.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多技术要么被误解为备份，要么可能是备份的组成部分。在这一部分中，我想拆解这些基础知识，确保我们理解它们是什么、为什么重要、如何使用它们，以及何时我们自己应该利用它们。
- en: Snapshots
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快照
- en: In our last section we talked about taking block device images, how images and
    snapshots are truly the same thing, and what people tend to mean when using the
    term snapshot instead of the term images. Now we are going to really delve into
    snapshots.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一部分中，我们讨论了如何拍摄块设备镜像，镜像和快照实际上是一样的，使用快照这个术语时人们通常意味着什么，而不是使用镜像这个术语。现在，我们将真正深入探讨快照。
- en: Snapshots, as people tend to use the term, are amazing tools for doing some
    extraordinary things with storage. Snapshots are typically used to grab a momentary
    image of the state of a block storage device. The term snapshot is very descriptive
    in this case.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 快照，正如人们通常使用的术语，是在存储中做一些非凡事情的惊人工具。快照通常用于抓取块存储设备状态的瞬时镜像。在这种情况下，术语“快照”非常形象。
- en: 'For most snapshot systems, and as it is intended by most people using the term,
    the snapshot that is taken is kept on local storage along with the original data
    and the two are intrinsically linked. The assumption is that the snapshot contains
    only changes, or the differential, between it and the original data. There are
    multiple ways to achieve this, but essentially the end results are the same: a
    file much smaller than the original data that is quick to create but is able to
    perfectly recreate the state, or *snapshot*, of the block device at the time that
    the snapshot was taken.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数快照系统来说，正如大多数使用该术语的人所理解的那样，拍摄的快照会与原始数据一起保存在本地存储中，并且两者是内在联系的。假设是快照只包含与原始数据之间的变化或差异。实现这一点的方法有多种，但本质上，最终结果是相同的：一个比原始数据小得多、创建速度快、但能够完美地重现拍摄快照时块设备状态的文件，或者说是*快照*。
- en: The obvious risk to this process is that the snapshot, presumably, contains
    *only* the differences between the time that it was taken and the original data.
    So, there is no protection here against system failure. If the original file becomes
    damaged or lost, the snapshot is useless. A snapshot might be an effective protection
    mechanism against accidentally deleting a file, malware, or ransomware at the
    system level because it allows a system to revert to its pre-compromised state
    easily and quickly. This is an important value and early snapshot mechanisms were
    often used expressly as a means of protecting against file deletion and overwrite
    mistakes. But since they are tightly coupled to the original data, the most important
    protections afforded us by true backups are completely missing here.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这种过程的显而易见风险是，快照假定*仅仅*包含了拍摄时与原始数据之间的差异。因此，这里并没有对系统故障提供保护。如果原始文件损坏或丢失，快照将无效。快照可能是一个有效的保护机制，可以防止误删文件、恶意软件或勒索软件，因为它允许系统轻松、快速地恢复到未受损害的状态。这是一个重要的价值，早期的快照机制通常专门用于防止文件删除和覆盖错误。但由于它们与原始数据紧密耦合，真正的备份所能提供的最重要的保护在这里完全缺失。
- en: This risk has led to the mantra of *Snapshots are not backups!* You hear this
    everywhere. And it is true, they are not, on their own. Snapshots are a really
    critical component of backups, though. Overstating the mantra has caused many
    people to incorrectly believe that backups created using a snapshot as a source
    are not real backups.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这种风险导致了“*快照不是备份！*”的口号。你到处都会听到这个。确实，它们单独并不是备份。不过，快照是备份的重要组成部分。过度强调这一口号导致许多人错误地认为，使用快照作为来源创建的备份不是真正的备份。
- en: Types of Snapshots
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 快照类型
- en: A snapshot is a generic idea that can be executed in many ways. Two mechanisms
    popular for snapshots are copy on write and redirect on write. Nearly any production
    system that you encounter will utilize one of these two mechanisms. Understanding
    these two give a good insight into the thinking and design of snapshots and explain
    why they can be so powerful.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 快照是一个通用的概念，可以通过多种方式实现。写时复制和重定向写入是两种常见的快照机制。几乎你遇到的任何生产系统都会利用这两种机制之一。理解这两者有助于深入了解快照的思维方式和设计，并解释它们为何如此强大。
- en: First, copy on write (sometimes called COW Snapshots.) When a copy on write
    snapshot is initiated, a block device is essentially frozen in time. Mostly this
    is theoretical because nothing actually happens, and until there is an attempt
    to make a change to the storage, nothing will happen.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，写时复制（有时称为 COW 快照）。当启动写时复制快照时，一个块设备本质上被冻结在某个时间点。通常这是理论上的，因为实际上什么也不会发生，直到尝试对存储进行更改时，才会有任何操作发生。
- en: When someone attempts to write new data to the block device, at that time the
    storage system takes any block that is about to be written and copies it to a
    new location and then overwrites the original block with the new data. There is
    a performance hit while all this copying is going on, of course, and as changes
    start to add up the size of the copied data will grow. So while the snapshot is
    literally of zero size when we first initiate it, it keeps growing as long as
    we keep writing to the block device.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当有人尝试向块设备写入新数据时，存储系统会将即将写入的任何块复制到新位置，然后用新数据覆盖原始块。当然，在所有这些复制操作进行时会有性能损耗，并且随着更改的积累，复制数据的大小将不断增加。因此，虽然我们第一次启动快照时它的大小为零，但只要我们继续写入块设备，它将不断增长。
- en: Copy on write snapshots are popular because they have so little penalty to being
    destroyed. To delete the snapshot all that has to be done is the extra data be
    deleted. The working block storage is untouched in all of this. Even a process
    monitoring the original block device would never know that there was a snapshot
    somewhere because everything related to the snapshot is external to the original
    block device. So there is basically no penalty to cleaning up the snapshot when
    it is no longer needed.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 写时复制快照很受欢迎，因为它们被销毁时几乎没有任何代价。删除快照所需做的只是删除额外的数据。在这个过程中，工作块存储不受影响。即使有一个进程在监控原始块设备，它也永远不会知道在某个地方存在快照，因为与快照相关的所有内容都与原始块设备外部有关。所以，当快照不再需要时，清理它基本上没有任何代价。
- en: The alternative approach, redirect on write, works a bit differently by manipulating
    points. These points point to all of the block locations of a storage device.
    When a block is changed by writing new data to it, the system does not modify
    the original block at all, but rather writes the new data in a new location and
    simply points that blocks pointer at the new location instead. In this way there
    is essentially no impact to any given write operation. The impact is not zero,
    but it is extremely low, especially compared to copy on write which requires moving
    existing data around and rewriting it during normal operations.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种替代方法——重定向写入——通过操作指针来实现，稍微有些不同。这些指针指向存储设备的所有数据块位置。当数据块通过写入新数据进行修改时，系统不会修改原始数据块，而是将新数据写入新位置，并仅仅将该数据块的指针指向新位置。这样，写操作对数据块的任何影响基本上可以忽略不计。影响不是零，但极低，尤其是相比于写时复制，后者在正常操作中需要移动和重写现有数据。
- en: With redirect on write we get some great features like the ability to maintain
    essentially indefinite versions of our storage device. In fact there are storage
    devices that simply use redirect on write for all operations and do not think
    of changes as snapshots but treat the entire storage system as an eternal snapshotting
    mechanism so that any portion of the storage can be rolled back to literally any
    point in time.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用重定向写入，我们可以获得一些非常有用的功能，比如能够维护存储设备几乎无限的版本。事实上，有些存储设备会将所有操作都视作重定向写入，并不将变化视为快照，而是将整个存储系统看作一个永恒的快照机制，以便存储的任何部分都可以回滚到任意时间点。
- en: The caveat of redirect on write, because it sounds pretty perfect at first glance,
    is that you still have a growing amount of data over time and if you keep interim
    versions of data, rather than just a single point in time, the degree of growth
    can end up rather staggering. If you then need to clean that up the process of
    cleaning up the system of pointers can get somewhat complex and has a performance
    penalty.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 重定向写入（Redirect on write）看起来一开始非常完美，但它的警告是，你会随着时间的推移积累越来越多的数据，如果你保存数据的中间版本，而不是仅仅保存一个时间点的版本，数据的增长可能会变得非常惊人。如果你需要清理这些数据，清理指针系统的过程可能会变得相当复杂，并且会带来性能损失。
- en: Copy on write tends to be the best choice when we are talking about short term
    snapshots that are being taken, for example, just before a major system update
    is performed and the need to roll back to the time just before the update is critical,
    or a snapshot is taken in order to send data externally in a backup operation.
    At the end of either of these tasks, the snapshot would be destroyed and forgotten
    about. Copy on write is all about creating and destroying the entire snapshot
    quickly, not keeping it around, because the penalties of copy on write will exist
    only for a short time and the destruction process is painless.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 写时复制（Copy on write）通常是处理短期快照时的最佳选择，例如在执行重大系统更新之前创建快照，并且需要在更新之前的时刻进行回滚，或者在备份操作中为了将数据发送到外部而创建快照。在这些任务完成时，快照将被销毁并忘记。写时复制的核心在于快速创建和销毁整个快照，而不是保留它，因为写时复制的代价只会存在很短时间，而且销毁过程没有痛苦。
- en: Redirect on write is really powerful when we intend to keep the snapshot around
    for a long time and when we want multiple snapshots that build off of one another.
    Because there is almost no penalty during use and only a real penalty during the
    destruction of the snapshot(s) it plays the opposite role of copy on write.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们打算长时间保留快照并希望多个快照相互叠加时，重定向写入非常强大。因为在使用过程中几乎没有代价，只有在销毁快照时才会产生真正的代价，它的作用恰好与写时复制相反。
- en: 'So: redirect on write is probably the best choice for using snapshot as ongoing
    data protection and copy on write is typically what is used under the hood for
    things like backup software to originate a dataset.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 所以：重定向写入可能是将快照用作持续数据保护的最佳选择，而写时复制通常用于像备份软件这样的系统中，用来生成数据集。
- en: Even if we do not have any special backup software, we can use a snapshot taken
    by our storage system and use it as the building block of a meaningful, manual
    backup. This is far simpler than it sounds. In the simplest of examples, assuming
    that we have something like a mounted tape drive on the same system to write to,
    we simply use the storage systems ability to mount the snapshot as an immutable
    version of the block device and copy that to the tape.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们没有任何特殊的备份软件，我们也可以使用存储系统拍摄的快照，并将其作为有意义的手动备份的构建块。这比听起来要简单得多。在最简单的示例中，假设我们有类似于挂载的磁带驱动器可以在同一系统上写入数据，我们只需利用存储系统将快照挂载为不可变版本的块设备，然后将其复制到磁带上。
- en: When we do this, the source snapshot file might be absolutely tiny, or theoretically
    even zero bytes, but what is sent to the tape (or any other storage media) is
    a complete copy of the entire block storage device in the state that it was at
    the time that the snapshot was taken. This is the miracle of snapshot technology.
    The automatic and generally completely transparent recreation or rehydration of
    the original block device state while using minimal, often trivial, additional
    storage space.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们这么做时，源快照文件可能非常小，理论上甚至为零字节，但发送到磁带（或任何其他存储介质）的却是整个块存储设备的完整副本，且其状态与拍摄快照时的状态一致。这就是快照技术的奇迹。在使用极少的、通常是微不足道的额外存储空间的情况下，自动且通常完全透明地重新创建或恢复原始块设备的状态。
- en: When we do this, we have the semantic challenge of what do we call the copy
    that is no longer on the original media. It is an image, of course, but typically
    we still refer to it as a snapshot as it is identical to the snapshot in every
    way and represents a snapshot of the block device at a point in time. So, when
    we do this, the statement that snapshots are not backups becomes false because
    we can have a true backup that is also a snapshot. The correct statement would
    be that a snapshot is not typically a backup. Snapshots do often get used as backups,
    however, and even more often as the basis of backups.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们这么做时，我们面临着一个语义上的挑战：我们该如何称呼那个不再位于原始媒体上的副本？当然，它是一个镜像，但通常我们仍然称之为快照，因为它在各方面都与快照相同，并且代表着在某个时间点的块设备快照。所以，当我们这么做时，“快照不是备份”这一说法就变得不成立了，因为我们可以拥有一个既是真正的备份又是快照的副本。正确的说法应该是快照通常不是备份。然而，快照确实经常作为备份使用，甚至更常作为备份的基础。
- en: Because snapshots provide the ability to freeze the block device in a moment
    (or more than one moment) in time and then provide a way to utilize that frozen
    moment without having to interrupt the block device for future options it is perfect
    as a means of creating a source from which to take a backup while allowing the
    running system to continue on its merry way. It must be noted, though, that traditional
    snapshots all happen on top of the same underlying physical block device. So,
    while we do not need to halt the storage device in order to perform snapshot operations,
    we do use IOPS (input/output operations per second) from the original device.
    Our operations are not zero overhead, magically, but they are much lower overhead
    than other backup mechanisms will tend to be.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于快照提供了在某个时刻（或多个时刻）冻结块设备的能力，并且提供了一种利用该冻结时刻的方法，而无需中断块设备进行未来操作，因此它非常适合作为创建备份源的手段，同时允许正在运行的系统继续运行。然而，必须注意的是，传统的快照操作都是基于同一个底层物理块设备进行的。因此，虽然我们不需要停止存储设备来执行快照操作，但我们确实会使用原始设备的
    IOPS（每秒输入/输出操作次数）。我们的操作并不是零开销的神奇过程，但它们的开销远低于其他备份机制。
- en: Because of all of this, snapshots are a popular tool to use under the hood and
    behind the scenes to make many modern backups possible. Essentially every hypervisor
    or storage device level backup (platform backup) is powered by snapshots. In many
    cases, even system level (so called agent based backups inside of the operating
    system) use snapshots today, across all operating systems, not only Linux-based
    ones.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这一切，快照成为了一个流行的工具，被广泛用于幕后和底层，使得许多现代备份成为可能。实际上，每个虚拟机监控器或存储设备级别的备份（平台备份）都是由快照提供支持的。在许多情况下，即使是系统级备份（即操作系统内的代理式备份）今天也使用快照，无论是
    Linux 系统还是其他操作系统。
- en: Archives
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存档
- en: Closely related to, but importantly different from, backups are archives. These
    two concepts are very often confused for each other, even in very enterprise circles.
    In theory, just by saying the names and asking someone, anyone, to describe what
    they think of a backup and an archive is enough to get someone to self-describe
    why they are not the same thing. But taking *I can define it* and moving that
    to *I can clearly articulate and internalize that the two are different* is not
    always automatic.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 与备份密切相关，但又有重要区别的是档案。这两个概念经常被混淆，甚至在企业圈子中也不例外。理论上，只要提到这两个名称，问别人，任何人，描述他们对备份和档案的看法，就足以让他们自己认识到这两者并不相同。但将*我能定义它*转化为*我能清晰地表达并内化这两者的不同*并不是自动的。
- en: A backup, which we will define more in a moment, is a copy at a minimum. That
    much should be clear. Our English use of the term denotes this. We refer to things
    as our *backup copy*. If you articulate it well, everyone always agrees that if
    it is not a copy, then it is not a backup.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 备份，稍后我们将进一步定义，至少是一个副本。这一点应该很清楚。我们在英语中使用这个术语就是指这一点。我们称之为我们的*备份副本*。如果你表达得清楚，大家都会同意，如果它不是副本，那么它就不是备份。
- en: An archive is different. Archiving something does not suggest that there is
    not a copy, we sometimes even say things like *archival copy*, but nothing in
    the definition of archive is it suggested that a copy is required. An archive
    refers to long term storage, often assumed to be either lower cost, harder to
    access, or otherwise *archival*. Long term storage, but not necessarily close
    at hand.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 档案是不同的。归档某个东西并不意味着没有副本，我们有时甚至会说*档案副本*，但在档案的定义中并未暗示需要有副本。档案指的是长期存储，通常假定其成本较低，访问更困难，或其他方式*归档*。长期存储，但不一定是随时可以获取的。
- en: Archival storage could simply be a second hard drive where data does not change.
    Maybe it is offline tape. Maybe it is cold cloud storage. Archival storage does
    not mean, necessarily, that the performance or accessibility of the storage is
    less than regular storage would be, but it is very common for it to be.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 档案存储可以简单地理解为一个第二硬盘，数据不会发生变化。也许它是离线磁带，也许是冷存储云。档案存储并不一定意味着存储的性能或可访问性比常规存储差，但通常情况下，它们的性能确实会更低。
- en: Most organizations use archival storage as a lower cost means of maintaining
    emergency or occasional access to data that is no longer needed on a regular basis.
    It is easy to talk about potential scenarios for this. Old data could be last
    year's financial records, copies of old receipts, video footage from material
    already processed, old invoices, old meeting minutes, blueprints from completed
    projects, old project artefacts, you get the picture. Businesses produce enormous
    amounts of data that they never anticipate needing to use again, but cannot necessarily
    delete entirely.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数组织使用档案存储作为一种低成本手段，以维持对那些不再需要经常访问的数据的紧急或偶尔访问。这种情况很容易举例说明。旧数据可能是去年的财务记录、旧收据的副本、已经处理过的材料的视频片段、旧发票、旧会议记录、已完成项目的蓝图、旧项目文物，你可以想象到。这些企业会产生大量的数据，虽然他们从未预料到需要再次使用这些数据，但也不能完全删除。
- en: The assumption is that an archive, if it contains data of any importance, also
    needs to be backed up just like any other storage. The rule of thumb is that anything
    worth storing is worth backing up, if you feel that the cost or effort of taking
    a backup is too much then you should carefully reevaluate the desire to continue
    to store the data at all. Why continue to pay for its storage?
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 假设是，如果档案中包含任何重要数据，它也需要像任何其他存储一样进行备份。经验法则是，任何值得存储的东西都值得备份。如果你觉得备份的成本或努力太大，那么你应该仔细重新评估是否继续存储这些数据。为什么还要为它的存储付费呢？
- en: In a properly planned storage infrastructure this is exactly what happens and
    archives are a powerful mechanism for data retention and protection when properly
    combined with a backup. As the term archive means that the data is not changing
    it means that there should never be a lock on the data and backups are as simple
    as can be. None of the complexities that face the backup process exist when dealing
    with an archive. The need to take backups often also does not exist; a single
    backup might be all that is needed if the archive is static. Or if the archive
    is only rarely changed, maybe a monthly or annual backup might be adequate.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在正确规划的存储基础设施中，这正是发生的事情，而存档与备份结合起来时，存档是数据保留和保护的强大机制。由于存档一词意味着数据不会更改，这意味着数据不应该被锁定，并且备份可以尽可能简单。处理存档时不存在备份过程面临的复杂性。通常也不需要定期进行备份；如果存档是静态的，可能只需要一个备份就足够了。或者如果存档很少更改，也许每月或每年进行一次备份可能就足够了。
- en: Converting backups to archives
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将备份转换为存档
- en: A not uncommon thing to have happen is for a backup to become an archive. This
    happens far more frequently than you might imagine and happens for reasons that
    most of us can identify with. I have seen it happen in the largest of organizations
    with no policy to avoid it.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的情况是备份变成存档。这种情况比你想象的要频繁得多，发生的原因大多数人都能理解。我曾经看到最大的组织中发生过这种情况，而且没有政策来避免这种情况。
- en: Under normal circumstances, all data that you want to store is live and in its
    proper location for use and available normally. A backup is taken of this data
    and, in case of disaster, the system can be restored. until there is a disaster
    all of the data exists both in the original location as well as in one (or more)
    backup location(s). This redundancy of locations is what makes the copies into
    backups. Technically, if the original storage location fails, the primary backup
    (which might be the only backup) stops being a backup and turns into the temporarily
    primary source location of the data. We never speak of it in this way as we all
    know what we mean by *restoring from backup*, but for that period of time when
    the original storage is gone, the first backup is now the master of that data
    and not a backup any more. It may have backups of itself, and generally we would,
    but you can only have a backup when there is data that is not a backup for the
    backup to be a backup of! Hard to explain, but a critical concept.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常情况下，所有想要存储的数据都是实时的，并位于其适当位置以供使用和正常使用。对这些数据进行备份，以防发生灾难，系统可以恢复。在发生灾难之前，所有数据都存在于原始位置以及一个（或多个）备份位置中。这种位置的冗余性是使副本成为备份的原因。从技术上讲，如果原始存储位置失败，主要备份（可能是唯一的备份）将停止成为备份，并且暂时成为数据的主要来源位置。我们从不这样说，因为我们都知道“从备份中恢复”的含义，但是在原始存储消失的那段时间内，第一个备份现在是该数据的主数据，而不再是备份。它可能有自己的备份，通常我们会这样做，但是只有当有非备份数据时，备份才能成为备份的备份！很难解释，但这是一个关键的概念。
- en: The reason that this matters is because once you take a backup of data, it can
    be very easy to feel that our backup protects us and that we can then delete the
    original source data. It feels like we can, because there is a backup already.
    The problem here is that if we delete the original data, the backup (or at least
    the first backup) stops being a backup and instead turns into an archive! And
    in most cases, if the assumed master source location is no longer there, there
    may be no mechanism to take any further backups of this archived data. There may
    not even be any means of locating it.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这很重要的原因是一旦对数据进行了备份，就很容易感觉我们的备份可以保护我们，因此我们可以删除原始数据。因为已经有了备份，我们觉得我们可以这样做。这里的问题是，如果我们删除了原始数据，备份（或至少是第一个备份）就不再是备份，而是存档！在大多数情况下，如果假定的主源位置不再存在，可能没有机制来进一步备份这些存档数据。甚至可能没有任何手段来定位它。
- en: I have seen this myself in the real world. A daily backup task would run and
    end users just assumed that they did not need to store any data that they needed,
    even though it was a legal requirement to keep it and to keep it backed up, on
    the primary systems and so would delete the data immediately upon creation assuming
    that their data was protected by the backup system. There were some critical flaws
    in this plan, however.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我亲眼见过这种情况发生在现实世界中。每天的备份任务都会运行，而终端用户却默认认为他们不需要存储任何他们需要的数据，即使法律要求保留并备份数据在主系统上，因此他们会在创建后立即删除数据，假设他们的数据受到备份系统的保护。然而，这种计划存在一些关键缺陷。
- en: First, by deleting the original, any backups that existed became the source
    location rather than a backup and were simply a tape-based archive. Given that
    there was a legal requirement for the data to be retained and backed up, this
    violated the legal retention requirements.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过删除原始数据，任何现有的备份都会成为源位置而不是备份，并且仅仅是基于磁带的归档。考虑到数据有法律要求需要保留和备份，这违反了法律的保留要求。
- en: Second, the backup mechanism was staggered where some backups are kept for years,
    some for months, and some for weeks. So if the data happen to exist during a run
    that was kept for years there was a good chance that the one, singular tape that
    contained the files in question might be readable to able to retrieve the data,
    but if the data existed only during a backup run for a weekly job, even the archival
    version would be deleted in just a few weeks when that tape was overwritten.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，备份机制是分阶段的，有些备份保留数年，有些保留数月，有些保留数周。因此，如果数据碰巧存在于保留数年的运行中，那么包含相关文件的那一盘磁带很可能可以读取以检索数据，但如果数据仅存在于每周作业的备份运行中，即使是归档版本也会在几周后磁带被覆盖时被删除。
- en: Third, and unrelated to the archival situation, often the data was deleted before
    the daily backup job ran at all meaning that the data was deleted with no backup
    or archive ever existing and so was lost instantly. The result was that no backups
    ever existed, and once in a while a file would get lucky and be retained for a
    few years without backup, but most files were either never archived at all or
    were archived only briefly and deleted in a few weeks when tapes were reused.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 第三点，与档案情况无关，经常是数据在每日备份作业运行之前就已删除，这意味着数据在没有任何备份或档案的情况下立即丢失了。结果是从未存在过备份，偶尔某些文件可能会幸运地保留几年，但大多数文件要么根本没有被归档，要么只是短暂地被归档，并在几周后的磁带重用时被删除。
- en: Given that the requirement was seven years of retention, plus a backup of that
    retention, it is easy to see how far off the mark the process was simply because
    the end users thought that they could intentionally delete the original files
    because they thought a magic backup process was somehow protecting them. The backup
    team thought that all data was being kept live for seven years and that if any
    file was lost or corrupt that the end users would alert the backup team to restore
    it almost immediately. That the end users would themselves intentionally destroy
    the data and never alert the backup team that the data had been destroyed was
    never considered in the workflow, because why would it be?
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到需要保留七年的要求，再加上对该保留的备份，很容易看出流程有多大偏差，因为最终用户认为他们可以有意删除原始文件，因为他们认为魔术备份过程某种方式在保护他们。备份团队认为所有数据都会保持七年，并且如果有任何文件丢失或损坏，最终用户会立即通知备份团队进行恢复。他们从未考虑到最终用户会自行销毁数据并且从未通知备份团队数据已被销毁，因为为什么会这样呢？
- en: It is easy to see how we can, through actions of the end users in many cases,
    accidentally convert our backup location into an archival location and potentially
    lose data because we do not understand the complexities of the backup processes.
    If data is not going to be retained permanently in a primary location, then very
    complex processes are often needed to ensure a safe workflow for deletion.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易看出我们可以通过许多情况下最终用户的行为，无意中将我们的备份位置转换为档案位置，并且由于我们不理解备份过程的复杂性，可能会丢失数据。如果数据不会在主要位置永久保留，那么通常需要非常复杂的过程来确保删除的安全工作流程。
- en: Archives are a powerful mechanism to lower cost and keep our mainline storage
    lean. Maybe we use archives only to reduce cost. In many cases, by keeping excess
    data away from our top tier of storage, it will allow us to invest in faster,
    but smaller systems for the data that we use every day.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 档案是降低成本并保持我们主线存储瘦身的强大机制。也许我们仅使用档案来降低成本。在许多情况下，通过将多余的数据远离我们顶级存储层，可以让我们投资于更快速但更小型的系统，用于我们日常使用的数据。
- en: Archives can apply to portions of a file as well, of course. Sometimes even
    databases use a mix of storage locations to allow them to be able to store tables
    or portions of tables that are accessed regularly on the fastest storage, while
    rarely touched tables or parts of tables can be kept on slower storage that costs
    less. This could be automatic inside of a database engine, or an application might
    use multiple database systems and move data between them at the application layer,
    for example.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 档案也可以应用于文件的部分。当然，有时甚至数据库也使用混合存储位置，以便能够将经常访问的表或表的部分存储在最快的存储上，而很少接触的表或表的部分可以存储在成本更低的较慢存储上。这可能在数据库引擎内部自动进行，或者应用程序可能使用多个数据库系统，并在应用程序层面在它们之间移动数据，例如。
- en: Archives are a useful tool, but in no way a substitute for backups.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 档案是一个有用的工具，但绝不能替代备份。
- en: Backups
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 备份
- en: It is hard to believe that we have gone this far without actually digging into
    exactly what we mean when we say *backup*. As with many things, it is hard to
    sometimes jump directly into a definition as there is just so much that we have
    to consider.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 很难相信在没有实际深入探讨我们说“备份”时确切含义的情况下，我们已经走了这么远。与许多事物一样，有时候直接进入定义是很困难的，因为我们需要考虑的事情实在是太多了。
- en: At the most basic, a backup is a copy of an original set of data. We talked
    about this above. If the data does not become redundant, then it cannot be a backup.
    This is the most obvious piece of the puzzle.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在最基本的层面上，备份是原始数据集的副本。我们在上面已经讨论过这一点。如果数据没有变得冗余，那么它就不能算是备份。这是难题中最明显的部分。
- en: Next, the data must be stored twice. Meaning the hardware must exist more than
    once.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，数据必须存储两次。这意味着硬件必须存在不止一次。
- en: In many cases we can do a comparison with paper or some other physical form
    of data storage. If we have a piece of paper with an important code on it, we
    feel a sense of urgency to copy that data somewhere - to make a backup. We know
    how easy it is to smudge, burn, lose, or send a piece of paper through the wash.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，我们可以将其与纸张或其他物理形式的数据存储进行比较。如果我们有一张重要代码的纸张，我们会感到有必要将这些数据复制到其他地方 - 进行备份。我们知道纸张容易被弄脏、烧毁、丢失或者洗涤机洗过。
- en: Probably the most confusing piece of a backup requirement is that it be strongly
    decoupled from the original material. Being strongly decoupled is a term that
    involves some amount of opinion that makes determining appropriate levels of decoupling
    a little bit hard. What is decoupled enough for one organization may also not
    be enough for another.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 或许备份要求中最令人困惑的部分是它必须与原始材料强烈解耦。强烈解耦是一个涉及一些观点的术语，这使得确定适当的解耦水平有些困难。对于一个组织来说足够解耦的程度，对另一个组织来说可能还不够。
- en: When we use the term tightly coupled, we are referring to situations where the
    original data, and the copy of the data, have a connection between them. At the
    most tightly coupled is something like the snapshot concept where anything that
    happens to the original file will ruin the snapshot a well, in all cases. That
    is fully coupled. Slightly less coupled would be something like storing the copy
    on the same physical device. The farther separated the copy becomes from the original
    data, the less coupled it is.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用术语紧密耦合时，我们指的是原始数据和数据副本之间存在连接的情况。在最紧密耦合的情况下，类似快照的概念，任何发生在原始文件上的事情也会影响到快照。这是完全耦合的情况。稍微松散耦合的情况可能是将副本存储在同一物理设备上。副本与原始数据之间的距离越远，它们的耦合性就越低。
- en: 'Coupling can involve more than physical connections. It can also include concepts
    such as being stored on systems that share credentials like usernames and passwords.
    Coupling can be complex and there is no single, clear-cut way to describe it.
    When we talk about keeping backups heavily decoupled, though, we generally means
    a few things such as: completely disparate hardware and media, physically separate
    location, and disconnected authentication.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 耦合可以涉及到更多的内容。它还可以包括诸如存储在共享凭据（如用户名和密码）系统上的概念。耦合可以很复杂，并且没有单一、明确的描述方法。但是，当我们谈论保持备份高度解耦时，通常意味着一些事情，例如：完全不同的硬件和媒体、物理上分离的位置以及断开的身份验证。
- en: The idea behind every additional step of decoupling is to keep any event that
    might happen to the original data to have little to no chance of also happening
    to the backup data. This could be an accidental file deletion, a failing hardware
    storage device, a ransomware attack, flood, or fire. There are so many ways to
    lose our original data, or to lose access to it. We have to consider these possibilities
    as broadly as possible and assess how much decoupling, and what type, make sense.
    No two systems are ever truly decoupled completely, but we can decouple to a practical
    level quite easily.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 每增加一步解耦的背后想法，是让任何可能发生在原始数据上的事件，几乎没有可能同时发生在备份数据上。这可能是文件意外删除、存储设备故障、勒索病毒攻击、洪水或火灾。丢失原始数据或无法访问它的方式有很多种。我们必须尽可能广泛地考虑这些可能性，并评估多少解耦，以及什么类型的解耦是合理的。没有任何两个系统能做到完全解耦，但我们可以很容易地将解耦做到一个实际的水平。
- en: The first step is easy and very few organizations make the mistake of attempting
    to put a backup file onto the same media as the original data. It does happen,
    however. Using the same drive happens very rarely, but attempting to use a second
    drive inside of the same device is sadly somewhat common. Of course, as you can
    imagine, many events that would cause data to be lost on one drive in a computer
    can cause data on another drive to be lost. A fire inside the chassis, extreme
    shock, flooding, loss of power, theft, data corruption caused by many types of
    events, or malicious attack are all likely to destroy a backup simultaneously
    with the original data. This defeats the purpose of the backup almost entirely.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步很简单，很少有组织犯错误尝试将备份文件放在与原始数据相同的媒体上。然而，这种情况确实发生过。使用同一硬盘的情况非常罕见，但尝试在同一设备内使用第二个硬盘却悲哀地相对常见。当然，正如你所想象的那样，许多会导致计算机中一块硬盘丢失数据的事件，可能也会导致另一块硬盘上的数据丢失。机箱内的火灾、极端震动、洪水、断电、盗窃、由于各种事件导致的数据损坏或恶意攻击，都很可能同时摧毁备份数据与原始数据。这几乎完全否定了备份的意义。
- en: To compare to the physical world, we can compare to paper. You have a piece
    of paper on which you are storing critical data. You keep that piece of paper
    in a filing cabinet. You are worried about protecting that paper from something
    bad happening. You can use a single piece of paper and write the information on
    it twice. You can have a second piece of paper in the same folder in the same
    filing cabinet with the data duplicated. You can put a copy on a separate piece
    of paper in a second filing cabinet sitting next to the first one. Or you can
    put a copy of the paper in a separate filing cabinet in a different building.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用物理世界来做类比，我们可以比作纸张。你有一张存储关键数据的纸。你把这张纸放在文件柜里。你担心保护这张纸免受不好的事情的发生。你可以使用一张纸，将信息写两遍。你可以在同一个文件夹内同一个文件柜里放第二张包含数据的纸。你也可以把副本放在第二个文件柜里的独立纸张上，文件柜与第一个文件柜相邻。或者，你可以把纸张的副本放在另一个建筑物的独立文件柜里。
- en: In these examples, it is easy to see the progression from tightly coupled to
    highly decoupled. When sharing a single piece of paper, or two papers in the same
    filing cabinet, the risk is obvious. Almost anything that would hurt the first
    copy would damage the second. Having paper in a second filing cabinet at least
    gives a modicum of protection that there might be two different keys for the two
    cabinets, a cabinet falling into water *might* not affect the other, file damage
    to one *might* not affect the other, and so forth, but it does not take much to
    see that their risks are still coupled, just not as closely.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些例子中，很容易看出从紧密耦合到高度解耦的演变。当共享一张纸或两张放在同一个文件柜里的纸时，风险是显而易见的。几乎任何损坏第一份副本的情况都会同时影响第二份副本。将纸放在第二个文件柜中，至少提供了一定的保护，因为两个柜子可能有不同的钥匙，一个柜子掉入水中*可能*不会影响另一个柜子，一个文件损坏*可能*不会影响另一个文件，等等，但很容易看出它们的风险仍然是耦合的，只是没有那么紧密。
- en: By putting a filing cabinet into a completely different building, possibly on
    a different floor or even in a different town, then having a flood, fire, or theft
    that is able to destroy both the original and the backup at the same time is extremely
    unlikely. There is also the chance of a volcanic event, nuclear war, or meteor
    strike that could still destroy both copies even if located miles apart. This
    is why we say strong decoupled, but never totally decoupled.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将文件柜放置在完全不同的建筑物中，可能是在不同的楼层，甚至是不同的城市，那么发生洪水、火灾或盗窃，能够同时摧毁原始数据和备份的可能性极低。也有可能发生火山事件、核战争或陨石撞击，即便备份和原数据分别存放在几英里之外，它们仍然可能被摧毁。这就是为什么我们说强解耦，但绝不完全解耦。
- en: With our backups we have to consider just how decoupled our data is, and how
    much it costs to decouple it further. We also have to consider the efficacy of
    decoupling and how that impacts our business. It is a complex question. For most
    businesses, though, we will want our backups to have physical distance, a variety
    of media, a separation of authentication, and multiple copies. What our backups
    contain and how they will be used play into this heavily.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在备份中，我们必须考虑我们的数据解耦的程度，以及进一步解耦所需的成本。我们还必须考虑解耦的有效性以及它对我们业务的影响。这是一个复杂的问题。然而，对于大多数企业来说，我们希望备份具有物理距离、各种介质、身份验证的分离和多个副本。备份包含的内容以及它们如何使用在这一过程中起着重要作用。
- en: 'There is no simple best practice here, even common rules of thumb rarely apply
    outside of the extreme basics. Best practices dictate:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有简单的最佳实践，甚至常见的经验法则在基本的极限之外也很少适用。最佳实践要求：
- en: 'Best Practice: If data is worth storing, it is worth backing up.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践：如果数据值得存储，它就值得备份。
- en: 'Best Practice: A backup needs to be highly decoupled from the original data.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践：备份需要与原始数据高度解耦。
- en: The range of possibilities with backups are just so broad that we really must
    evaluate the needs, across the board, for every business and, in many cases, individual
    workloads. In some cases, such as backups of entire operating systems, our primary
    concern may be around rapid recovery in case of hardware failure and the actual
    contents of the backup may be trivial. In another case our backup may contain
    large amounts of highly proprietary data and keeping that backup safe and secure,
    ensuring that it cannot fall into the wrong hands, takes precedence.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 备份的可能性范围如此广泛，以至于我们必须全面评估每个企业的需求，在许多情况下，还需要考虑个人工作负载。在某些情况下，像整个操作系统的备份，我们的主要关注点可能是硬件故障时的快速恢复，而备份的实际内容可能并不重要。在另一些情况下，备份可能包含大量高度专有的数据，确保这些备份的安全性，确保它们不会落入错误的手中，成为优先考虑的事项。
- en: Why tape still matters
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么磁带仍然重要
- en: 'Inevitably when talking about backups, the discussion of tape media surfaces.
    Generally, you get one of two responses: tape is amazing and I always use it or
    tape is dead. Wildly disparate opinions.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在谈到备份时，磁带介质的问题不可避免地浮现出来。通常你会听到两种回应：磁带太棒了，我总是使用它；或者磁带已经死了。意见极为分歧。
- en: Once upon a time, tape was essentially the only backup media option. Solid state
    drives did not exist yet and hard drives were outrageously expensive per megabyte
    and had a terrible shelf life and shock capabilities. Tape was the only affordable
    and durable media option, and even it was not very good at the time.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 曾几何时，磁带几乎是唯一的备份介质选择。固态硬盘还不存在，而硬盘的每兆字节价格极为昂贵，且其使用寿命和抗震能力都非常差。磁带是唯一既实惠又耐用的介质选择，尽管当时它也并不好。
- en: In the decades since, everything has changed, as it often does. Hard drives,
    solid state drives, and services that host these for you have all become very
    standard. The biggest factors driving us to tape are gone, we have many options
    that are all viable. This has led many people to focus on these newer options
    and not keep up with the advancements in tape, but just like all of the other
    technologies, tape has advanced too and quite significantly so.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几十年里，一切都发生了变化，正如它经常发生的那样。硬盘、固态硬盘以及为你托管这些服务的公司都已经变得非常标准化。驱使我们使用磁带的主要因素已经消失，我们有很多可行的选择。这使得许多人专注于这些新选择，而没有跟上磁带技术的进步，但和其他所有技术一样，磁带技术也已经取得了相当显著的进展。
- en: Tape is a media almost purpose built for backups. It can move linear data at
    an extremely high rate, is very low cost per megabyte stored, and has incredible
    shelf durability and shock handling. Tape naturally, unless you leave the tape
    in the drive, becomes decoupled from the original system as simply as by just
    ejecting the tape from the drive. You can even have a remote tape system with
    automated tape ejection to make both technical and physical decoupling a completely
    automated process!
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Tape carries the benefit of allowing each tape to be at least partially decoupled
    from each other. Tapes can be stored in different locations and multiple tapes
    can be used for multiple copies of data. In some cases, groups of tapes might
    be stored together in a single box, effectively *re-coupling* the tapes to some
    degree. If tapes are stored apart from each other, though, dramatic decoupling
    is possible not just between the source data and the backup, but within the backup(s)
    itself!
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Tape is not perfect. It requires physically mounting the tape before being able
    to restore and it is terrible at locating single files buried deep within a backup.
    Tape shines at backing up or restoring large quantities of continuous data, but
    once you start to search for specific data the performance declines quickly. Some
    companies address the human component of tape management by employing robots and
    tape libraries, but this effectively puts the tapes back *online* and potentially
    re-couples them to the original data, at least partially, taking away one of their
    layers of protection. Straight tape, without a robot or library, has the benefit
    of needing to hack a human, on top of hacking computers, to be able to destroy
    the original data and the backup at the same time.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Tape is useful enough that even some online cloud backup providers use tape
    as a component of their storage solutions. Tape has an important place not just
    in the modern world, but in the foreseeable one.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Of course, backups may not be a single solution for a workload. A single workload
    or system might need multiple backups taken of it. One backup that is kept locally
    and moderately coupled that can be used for rapid restores in the event of an
    accident or hard drive failure. Remote backup to tape or immutable cloud storage
    for long term, highly decoupled data retention in the event of ransomware or total
    site loss.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Decoupling is so critical to a backup being functional or useful that we must
    include it in our definition of backups, even if we cannot absolutely clearly
    define what constitutes a significant enough level of decoupling. This is because
    what is adequate for one organization or situation may not be for another. For
    me, this means that our definition of decoupling has to be subjective. Stakeholders
    need to define what a backup is to protect against and define the necessary decoupling
    from there.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: It should not be glossed over that modern ransomware has become a driving force
    in organizations beginning to analyze their traditional levels of backup coupling
    because suddenly the reach and threat of backups having any real level of coupling
    is dramatic. Ransomware techniques, at the time of writing, aggressively include
    strategies to ransom backups themselves whenever possible and techniques to hide
    their activities to thwart the ability of backups to protect against system encryptions.
    Backups remain the best defense against such threats, but ensuring extreme levels
    of decoupling, often requiring techniques like immutable storage and physically
    taking backups offline so that no computer can reach them without human intervention.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 不能忽视的是，现代勒索软件已经成为推动组织开始分析传统备份耦合水平的一个驱动力，因为突然之间，备份具有任何实际耦合级别的影响和威胁变得非常剧烈。到目前为止，勒索软件技术积极采用策略，尽可能勒索备份本身，并使用隐藏其活动的技术，阻止备份在系统加密时提供保护。备份仍然是防御此类威胁的最佳手段，但确保极高的解耦级别通常需要像不可变存储和将备份物理断开连接等技术，以便没有计算机能够在没有人工干预的情况下访问它们。
- en: If you cannot recover, it was not a backup
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如果你无法恢复，那就不是备份。
- en: I have heard this said so many times and I still love it. Simply, if your backup
    does not work when there is a disaster, was it really a backup at all? To a small
    degree this is overstating the case. A backup can fail and that failure can coincide
    with the moment when an original workload has failed. But this should be statistically
    so unlikely and if it were to happen there should be a coincidence that is outrageously
    obvious.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我听过很多次这句话，我仍然很喜欢。简单来说，如果在灾难发生时你的备份无法恢复，那它真的算是备份吗？在某种程度上，这种说法有些夸张。备份可以失败，这种失败可能与原始工作负载的失败时刻重合。但这种情况应该在统计上非常不可能，如果发生了这种情况，应该有一个极为明显的巧合。
- en: What many want to express is a need for testing backups. Backups are complex
    and knowing the speed, process, and effectiveness of using the available mechanisms
    is a very critical component to any backup process. If you have never tested your
    systems, you have to assume that they will not work. And even if you have tested
    them, it is best to have tested them recently. Some backup systems even do automatic
    restoration tests to demonstrate the efficacy of the backup every, single time.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人想表达的是备份测试的必要性。备份非常复杂，了解使用可用机制的速度、过程和效果是任何备份过程中的一个非常关键的环节。如果你从未测试过你的系统，你必须假设它们不会起作用。即使你已经测试过它们，最好还是最近进行过测试。有些备份系统甚至会每次自动进行恢复测试，以展示备份的有效性。
- en: Backup tests can be misleading. Like many other data protection mechanisms like
    RAID, redundancy power supplies, or failover SAN controllers the way that we tend
    to test backups in a predictable, pristine environment rarely reflects how a restore
    would be required under emergency conditions. It is common for backup tests to
    be performed when systems are idle or slower than usual and to reflect best case
    scenarios resulting in nearly always passing tests even on systems that would
    almost always fail in a real-world scenario. Consider adverse conditions such
    as actively failing, rather than having completely failed, systems, heavy load
    during operations, or an inconsistent data state (crash consistency) that will
    not be reflective during a test scenario.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 备份测试可能会产生误导。像许多其他数据保护机制一样，如RAID、冗余电源供应或故障切换SAN控制器，我们通常在一个可预测、完美的环境中测试备份，但这种测试通常并不能反映在紧急情况下恢复所需的真实情境。备份测试通常是在系统空闲或比平时慢的情况下进行的，且通常会反映出最佳的情况，从而导致几乎总是通过测试，即使是在现实世界中几乎总会失败的系统上。考虑一下不利的条件，比如正在故障的系统（而不是完全失败的系统）、高负荷操作或不一致的数据状态（崩溃一致性），这些情况在测试场景中是无法反映的。
- en: Backups may seem like a simple thing and every backup vendor is going to present
    their product as eliminating the need for you to understand your data. Vendors
    hope for your blind trust that they will do the impossible and offer you a chance
    to open your wallet and simply hope for the best. As system administrators it
    is our task to understand our data, know how our backup mechanisms work, determine
    the consistency and coupling needs of our organization and workloads, and to assemble
    a backup solution that meets or beats those needs.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Disaster recovery
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ultimately the purpose of any backup mechanism is to enable disaster recovery.
    Disaster recovery is something that we all hope that we will never have to do,
    and yet is the most important moment in most of our careers. Disaster scenarios
    are when we earn our keep more than at any other time. Your ability to perform
    calmly and coolly when a disaster is striking, to be ready with the knowledge
    of how to get your workloads back online, and being able to adjust to whatever
    twist or surprise is thrown at you is key. Performance during a disaster can mean
    salary differences of hundreds of percents.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: As we have dug through the many types and approaches to backups, it should be
    natural that there are now many ways to recover as well. When planning for disaster
    recovery we really must take all of this into consideration as our planning process
    will very so greatly.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'If we use image-based backup methods, then the assumption is that we will approach
    restore processes by restoring an entire block device image (or images) all at
    once. This has some significant advantages during disaster recovery because we
    only have a single step: restore the entire system. In some cases, our restore
    mechanisms will automatically restore all systems at once, not just a single one!
    This is a very alluring prospect. The caveats to this method are that restores
    are typically slower and generally only crash consistent. Doing high speed restores
    with the utmost of reliability is the most challenging for this method.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Using file-based backups we need to, in almost all cases, first restore a blank
    operating system, either a template or a vanilla build, and then restores individual
    files back to it in the place where they originally went. This method is theoretically
    faster than the image-base complete restore, but in practice rarely is because
    the time to build the base operating system from traditional methods. While theoretically
    you could build the base system from modern methods, this generally does not happen
    because if you were to do so you would naturally move on to DevOps style backups.
    However, these start to overlap conceptually here and you can use a file-based
    backup mechanism in conjunction with traditional file restores. The change would,
    of course, be that the file backups would be isolated to the meaningful system
    data rather than a blind backup of anything and everything.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: And lastly, a full DevOps style restore. This is more complex as there is no
    clear single definition. The assumption here is that rebuilds of the base operating
    system will be nearly instant because of any number of automated build mechanisms.
    And then that the data restore will be heavily minimized so that it, too, can
    happen at great speed.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Of course, all of this will be going on in conjunction with triage operations
    that we will discuss shortly. Planning and timing these operations so that they
    are well known, that processes are tested, and restore times are predictable under
    different scenarios provides invaluable information that will be needed during
    a disaster scenario.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Disaster recovery planning should be more than just individual workloads being
    tested in isolation, and it should be more than testing only data loss. Different
    organizations have different risks and testing multiple types of scenarios is
    important. We think of data restores when we think of disaster recovery, but that
    might not be what we are facing. If we have workloads running in multiple locations,
    we might be looking at how to work from a slower connection to a less than ideal
    data center location. A disaster recovery test might involve testing the ability
    to spin up workloads on backup systems, to failover clusters, or to run from a
    secondary data center.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: The best practice in disaster recovery is to always test your scenarios and
    to test them regularly. Never blindly trust that our backups, our planning, our
    networking or data centers will work. We need to test not only the technology
    behind our plans, but the procedures of those plans as well.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have discussed mechanisms and terms in and around backups, it is
    time to really look at how the modern world of DevOps can redefine how our backups
    can work.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Backups in a DevOps world
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In earlier sections of this book, we have talked about modern concepts impacting
    the world of system administration such as DevOps and infrastructure as code.
    You may be wondering if these modern concepts have a potential impact on the worlds
    of backups and disaster recovery. Good question! And if the section title has
    not given away the answer, I will clue you in now: yes, yes they do!'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally we think of restoring data as either the very old fashioned way
    of just restoring individual files, or the more modern (think last two decades)
    way of restoring entire systems including the operating system and all of the
    files that go with it. We are so accustomed to thinking of restoring systems in
    this way that it is often very hard to think about the problem in any other context.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: In the ultra-modern DevOps style world where systems are built via automation
    and defined in code or configuration files we have to start to think about nearly
    everything in new contexts. When systems can be automatically built easily and
    rapidly through standard, non-disaster processes, the need to restore those systems
    rather than starting fresh completely vanishes. Imagine if instead of fixing a
    car after an accident if for less money, and less time, and more reliably you
    could have a brand new, but identical, copy delivered to your door - you would
    never waste time trying to restore something broken when a pristine, perfect copy
    can be had.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Version control systems
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When talking about backups, especially as they relate to DevOps, we should also
    talk about version (or revision) control systems. Version control systems, like
    GIT, Mercurial, or Subversion, are not themselves backup systems, but act as mechanisms
    to sync some of the most important data on a system to another location, where
    backups will often occur.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: When talking about version control in the context of backups, it can be a bit
    confusion as in some cases we might be looking at our operating system as being
    a master location and a version control system can be used to replicate configuration
    files to another location and from there, they can be simply backed up using any
    number of normal mechanisms.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Because version control systems do not only store current data but also historical
    versions and changes to files, they become essentially immutable and therefore
    useful in a backup style situation since the backup mechanism does not need to
    deal with versions over time. The version control system holds all versions and
    changes to the files over their history. So a backup of the entire version control
    system automatically includes all of the changes to the files. Because of this,
    end users accidentally deleting files, bad changes to files, ransomware attacks
    on data all become moot as the ability to roll back to just before a bad change
    was made is built in.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Version control systems typically can be used to replicate files (and their
    version histories) not only between one end point and a version control server,
    but also to many additional end points. For example, a system administration workstation
    or jump box (which we will describe in the following chapter) might contain a
    full copy of the configuration files for every Linux system in a company separate
    from any server or backup system. Even if every official copy of the data was
    lost due to enormous catastrophe, a single workstation may be able to recreate
    the entire set of documentation.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: These types of systems are already in wide use for non-backup related reasons
    and are considered absolute *must have* tools in the DevOps world. We may already
    be using them in places for system administration tasks. Even in systems that
    do not have a DevOps process, these tools can potential be used as if they were
    as far as data protection is concerned.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Even the most traditional (meaning as far from DevOps as you can get) Linux
    system can benefit from the user of version control for its configuration files.
    Organizations do not even need to stand up their own infrastructures for version
    control if it does not make sense for them to do so. Vendors such as Gitlab and
    Microsoft via GitHub provide enterprise hosted version control systems for free
    with extensive features and access control systems.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: A small company with legacy style systems that wanted to embrace version control
    protection could, in a contrived example, simply got under the `/etc` file system
    and add it to a remote GIT repository and do a push. Voila, all of the data is
    protected, that quickly and easily. Set a `cron` job to run hours to push any
    additional changes and you have automated a robust backup system with essentially
    zero effort and definitely zero cost.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Version control systems are one of those poorly kept secrets of the development
    world that have leaked into and become embraced by many other professions. Any
    system that works heavily with text files should be jumping onto the version control
    bandwagon as quickly as possible. Version control is one of the simplest ways
    to take data protection to the next level. This approach carries far more advantages
    than that simple example might imply, however, restoring a system carries a non-trivial
    amount of risk that there is corruption or worse, an infection or root kit, that
    gets restored. A clean start removes those risks giving you the peace of mind
    of starting fresh. Likely the fastest path to a working system, performed in the
    most repeatable and predictable way, with the lowest risk. This approach is also
    the easiest to test. You naturally test at least part of this approach every time
    you build a new server whether for production, testing, staging, and so on.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: When we build our base operating systems, install applications, and deploy configurations
    via DevOps-style automation we leave ourselves with only our system specific data
    that needs to be restored from backup systems, and even that only part of the
    time. If you consider a typical multi-tiered application, data that is unique
    and cannot be pulled from the initial build process is generally limited to database
    files or limited file storage. In an application running on multiple operating
    system instances, we often expect this data to only exist on one layer of those
    nodes, generally the database. If that node is replicated, we generally only need
    to take a backup of the data from a single node in the cluster (because we often
    have all of the data replicated between all nodes.) Through this process we eliminate
    many points of backup, many types of backups, and identify only the actual data
    that may or may not be at risk.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Every environment varies and in one we may find that data that requires specific
    protection to account for only one percent of all data, in another it might be
    ninety nine. We cannot say with any certainty what you will be expected to find
    in the real world as every organization and workload is so different. Universally
    the ability to limit the scale of backups, and therefore restores, brings advantages.
    The smaller the backup means the faster and less impactful the backup will be.
    The smaller the backup size the lower the cost to store it. Smaller means less
    to verify against corruption. The same smaller size that reduces backup time also
    reduces restore time in the same way.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: In our multi-tiered example, we may need to rebuild three nodes to get our application
    back up and running. The top-level load balancing and proxy layer will be assumed
    to have no unique data and can be *restored* via the already tested build process
    that built it initially. The application layer should likewise have no unique
    data and be able to be automatically restored using the already tested build process.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Our last standard layer, the database, should again, be built with all configuration
    and applications being deployed completely using the build process. At this point,
    all of the layers of our application, all of the configuration for it, have all
    been restored and our backup and restore mechanisms have not even come into play.
    The only piece missing at this stage is the restoration of the latest data in
    the database. The database is in place, but not the data that goes inside of it.
    It is now that our restore process kicks off and puts that data back where it
    belongs. This might be a simple file copy from a remote location to the database
    location with a restart of the database after the files are in place. Or maybe
    a database-specific restore operation has to happen on the data to ingest it again.
    In any case, the restore is of a minimal amount of data, of very limited types.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: This approach changes everything that we traditionally think about backups.
    It changes how quickly and how impactful backup operations are, it changes the
    tools that we need to use and potentially eliminates them altogether, it makes
    restores fast and even, potentially, fully automated!
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: If we go back to our example case and assume we are using the popular MySQL
    application as our database platform, and that all of our necessary data is stored
    in this one spot which is a reasonable assumption for many common workload designs,
    our need to use special backup tools likely does not exist. Nor do we need to
    rely on complicated or risky mechanisms like snapshots. We can use built-in tools
    to the database platform to reliably get a complete dataset from the workload
    layer (we hesitate to say application layer as that is a software engineering
    term that would be different here from the systems term) where we know that the
    workload, with all of the necessary intelligence to do so, was able to stabilize
    and lock the data during the backup operation so that our backup is safely *application*
    *consistent*.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: When we step back and start ignoring convention, and we stop focusing on simply
    *buying a solution* but instead put on our IT hats and determine how best to protect
    our environment we can often find ways to both protect our organizations and to
    save money all at the same time.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: IT provides solutions, vendors sell components
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Broader than backups, and even broader than systems administration, the concept
    of where solutions come from is fundamentally something that we need to understand
    to do our jobs well at any level in IT. At its core, it is ITs job, and no one
    else's, to produce solutions for our business. In many cases we will need to turn
    to vendors to supply one or more components of any solution. IT is hardly going
    to fabricate their own CPUs and assemble parts to make servers or write their
    own operating systems and so vendors (which could, in this context, include those
    who do not get paid but provide things like open-source software including your
    Linux based operating system itself) are a necessary part of the solution process.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Vendors are not solution providers (although a great many will call themselves
    that as a marketing name, of course) but rather sales organizations. Their role
    is to provide access to tools that will hopefully benefit us in the pursuit of
    a solution. It is IT that determines which tools are right to use, selects them,
    and uses them to assemble the final solution to meet the needs of the business.
    IT, which is a department that provides solutions, is something we do, not something
    we buy. We cannot simply depend on a vendor to sell us a product that will protect
    us; it is not that simple. We have to understand the business need, the workload,
    the backup products, the approach and put all of this information together to
    make a cohesive solution that works for us. Every business is unique, every solution
    should be as well.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: No vendor-supplied tool can take into account all of our unique backup needs
    today, let alone be adaptable for any changes in the future. If you can imagine
    it, many companies are so addicted to the vendor buying process that they attempt
    to adapt their workloads and internal processes (and needs) to fit the needs of
    a product that the vendor wants to sell! This would be like relocating to an undesirable
    house so that your boat salesman can excuse having pushed to sell you a boat when
    a car would have gotten you to work easily from your existing house.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: DevOps and similar infrastructure have really exposed the extent to which traditional
    *just buy what a salesman wants you to buy* processes have required businesses
    to adapt to the purchase, rather than choosing to buy what makes sense for the
    business. In previous technology generations the options were so much less broad,
    and the differences so much smaller that it was easy to hide or dismiss the inefficiencies.
    Today that is not possible.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Enhanced backup and recovery processes turn out to be one of the best reasons
    to consider investing in DevOps and infrastructure as code engineering efforts.
    Typically, we can find many reasons to make DevOps attractive, but better backups
    is easily the best benefit.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we understand how backups can be taken with a truly modern infrastructure,
    we are on to our last topic here: triage. Time to move on from taking backups,
    to using them!'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Triage concepts
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Planning is important and prepares you for many eventualities. When disaster
    finally strikes, though, most planning is going to go straight out the window.
    All of your assurances that your backups are good are not going to make you relax,
    end users are going to be panicking, management is going to forget that you have
    to fix things and pull you into meetings, stress is high, and nothing is quite
    as expected from the planning process.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Triage is hard because every workload, time of day, current situation has so
    many dynamic elements. We have to be ready to adjust to anything, and we have
    to get our systems back online as quickly as possible.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: At the moment of a disaster is when things matter most and this is where system
    administrators really prove their mettle. Being prepared for a disaster is relatively
    easy, but staying cool and logical, evaluating the situation in real time, and
    managing the people around you all become unpredictable and very emotional challenges.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: There is no simple guide to triage and not everyone is going to be good at it.
    The more we are prepared ahead of time, the more we understand the entire environment,
    and the better we know the business environment that we are working in the more
    adaptable we are going to be.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Triage is a skill best handled by a perceiver, in the Myers-Briggs chart. As
    such this is where administration, over engineering, really shines to its most
    extreme.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: When analyzing an outage our first step is to evaluate the situation and determine
    the extent of the disaster. Are we only missing services? Is it all services?
    Is there data loss? What is the current, ongoing, and future expected impact from
    the outage. If we do not have the data at hand, keep people busy gathering that
    data for you.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Triage is especially needed to assist the business in understanding what it
    can do during the time of an outage. Many businesses panic or have no plan (or
    if they have a plan fail to action it properly.) But business behavior needs to
    be coordinated with technology recovery efforts. As we begin to approach our recovery
    we need to be working to also keep the business working as best as possible. Of
    course, we hope that corporate management will step in and guide operations, based
    on ITs assessments of what impact is and what recovery is likely to look like,
    to make them as efficient as possible. Often IT needs to be ready to provide guidance
    as well.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: In any triage operation with have to determine the criticality to our workloads
    as well as the potential for restoration. The most critical workload will still
    take a backseat if it will take weeks to restore when many minimal services can
    be up and running in short order. We need to consider loss of productivity, loss
    of customer confidence, failure to meet contracts, and similar concerns when deciding
    how to approach our disaster recovery.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Recovery planning, even in the moment, needs to be coordinated with the business.
    What can the business do to assist in recovery, what can technology do to enable
    that? With good cooperation different businesses may find many different paths
    at their disposal to make the damage of an outage minimized.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Businesses can take actions as simple as sending staff home to relax to get
    people out of the way and allow IT more freedom to undertake restoration. A staff
    with a surprise vacation day or two might be refreshed and excited to return to
    the office and attempt to at least partially make up for lost time. Instead of
    making the team frustrated that they cannot be productive, why not reward them
    for their hard work?
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Shifting communications to systems that are not down is important as well. Can
    staff move to phones if email is down? Email if phones are down? Instant messaging?
    Voice chat through some other platform? Maybe this is a good time to visit customers
    in person!
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: There is no way to list the countless ways that businesses can leverage an outage.
    What we need is creativity and the freedom to work with the business to help them
    see how they can keep working as best as they can, and allow them to direct us
    in how we can recover in the best way for them.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Thinking about triage operations makes it evidence the importance of concepts
    that we have already discussed such as self-recovering systems, minimized restore
    sizes, and careful planning. It also highlights how important it is to have operations
    and other departments engaged, involved, informed of available plans, and ready
    to assist and coordinate when things fall apart. Good planning makes triaging
    better, but you cannot plan your triage operations. There are too many variables
    to think that we can truly plan for every contingency.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: I wish that triage and disaster recovery oversight was something we could teach
    concretely. It is a scary situation and all we can do it make sure that the right
    people with triage and perception mindsets are empowered and at the ready when
    the time comes, have good backups, good restore processes, and as much planning
    as makes sense while having an organization ready to work together to minimize
    impact as a coherent team.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nothing matters like backups. I feel like that is at least the fifth time that
    I have written that in this book, and it is certainly not enough. Today backups
    are more important than they have ever been. We face more disaster scenarios and
    more advanced data loss situations than ever before in our industry. Backups have
    always been and will likely always be our strongest defense against complete failure.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Backups have been changing, quite a lot, in the last several years. The assumptions
    as to how we would approach backups even ten years ago do not readily apply today,
    and yet many organizations still use legacy applications, legacy designs, and
    need to still use legacy backups. So, our job is a complex one and our desire
    for modern backups may be needed to drive towards more modern application designs
    so that we can protect them in a better way.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: But now we understand the mechanisms underlying different approaches to backups,
    why we want to consider backing up in different ways, and how we can advance our
    backup practices into the future. Backups are probably the best place for you
    to set yourself apart; nothing matters more and rarely is anything as forgotten
    as much as backups.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: In our next chapter we are going to look at how users exist and interact in
    Linux systems and how we can approach authentication, remote access, and security.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
