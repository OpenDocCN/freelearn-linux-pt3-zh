- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interpreting Commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To fulfill its job as the interface between the user and the operating system
    kernel, a shell has to perform five different functions. These functions include
    interpreting commands, setting variables, enabling input/output redirection, enabling
    pipelines, and allowing customization of a user’s working environment. In this
    chapter, we’ll look at how `bash` and `zsh` interpret commands. As an added bonus,
    much of what we’ll cover in the next few chapters will also help you prepare for
    certain Linux certification exams, such as the Linux Professional Institute or
    CompTIA Linux+ exams.
  prefs: []
  type: TYPE_NORMAL
- en: 'Topics in this chapter include:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the structure of a command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing multiple commands at once
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running commands recursively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the command history
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Escaping and quoting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To follow along, you can use pretty much any Linux distro that you desire, as
    long as it’s running with either `bash` or `zsh`. Your best bet is to use a virtual
    machine instead of your production workstation, in case you accidentally delete
    or change something that you shouldn’t.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Structure of a Command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A handy thing to know for both real-life and any certification exams that you
    may take, is the structure of a command. Commands can consist of up to three parts,
    and there’s a certain order for the parts. Here are the parts and the order in
    which you’ll normally place them:'
  prefs: []
  type: TYPE_NORMAL
- en: The command itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you plan to take a Linux certification exam, you’ll definitely want to remember
    this ordering rule. Later on though, we’ll see that some commands don’t always
    follow this rule.
  prefs: []
  type: TYPE_NORMAL
- en: Using Command Options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two general types of **option switches**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single-letter options**: For most commands, a single-letter option is preceded
    by a single dash. Most of the time, two or more single-letter options can be combined
    with a single dash.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Whole-word options**: For *most* commands, a whole word option is preceded
    by two dashes. Two or more whole-word options must be listed separately, because
    they can’t be combined with a single pair of dashes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To show you what we mean, check out this hands-on lab.
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on Lab – Practice With Command Options
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this lab, we’ll be working with the humble `ls` utility. Options and arguments
    are optional for this utility, so we’ll get to see the different configurations
    for the command in this hands-on practice.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s issue the naked `ls` command in order to see the files and directories
    that are in our current directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, let’s add a single-letter option. We’ll use the `-l` option to show the
    files and directories with some of their characteristics.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Use the `ls` command with the `-a` option to see any hidden files or directories.
    (Hidden files or directories have names that begin with a period.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let’s combine the two options, so that we can see the characteristics
    of both the hidden and unhidden files and directories:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the preceding examples, the `donnie donnie` part indicates that the files
    and directories belong to user `donnie` and are associated with the `donnie` group.
    In this example, we’re using a whole-word option, `--author`, preceded by two
    dashes, to view some extra information. Let’s use this `--author` switch and the
    `-l` switch together to see who authored these files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: So, it appears that that Donnie character also created the files in the first
    place. (Oh, that’s me, isn’t it?)
  prefs: []
  type: TYPE_NORMAL
- en: Using Command Arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An argument is an object upon which a command will operate. For the `ls` command,
    an argument would be the name of a file or directory. For example, let’s say that
    we want to see the details of just a certain file. We can do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the `*` **wildcard** to see details of all files of a certain type,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If you’re not familiar with the concept of wildcards, think of them as a way
    to perform pattern-matching. In the above example, the `*` wildcard is used to
    match one or more characters. For this reason, the `ls -l *.sh` command allows
    us to see all files with the .sh filename extension. You can also use this wildcard
    in other ways. For example, to see all filenames and directory names that begin
    with the letter w, just do this
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`F`or more information about wildcards, check out the reference in the *Further
    Reading* section.'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we’re looking at all files whose names end in `.sh`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’re not always limited to specifying just one argument. In this example,
    we’re looking at three different files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `-ld` option to view the characteristics of a directory without viewing
    the contents of the directory, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Although you can actually change the order in which options and arguments appear
    in many commands, it’s bad practice to do so. To avoid confusion and to prepare
    yourself for any Linux certifications exams that you might take, just follow the
    ordering rule that I’ve presented here. That is, the command itself, command options,
    and lastly, the command arguments.
  prefs: []
  type: TYPE_NORMAL
- en: That about does it for the command structure part. Let’s move on to see how
    to execute multiple commands at once.
  prefs: []
  type: TYPE_NORMAL
- en: Executing Multiple Commands at Once
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From either the command-line or from within shell scripts, it’s handy to know
    how to combine multiple commands into one single command. In this section, I’ll
    demonstrate three ways to do that which are:'
  prefs: []
  type: TYPE_NORMAL
- en: Running commands interactively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using command sequences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `find` utility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running Commands Interactively
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a form of shell-script programming, except that you’re just executing
    all commands from the command-line, instead of actually writing, saving, and executing
    a script. Here, you are creating a **for loop** – with each command of the loop
    on its own separate line – to perform a directory listing three times.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end of each line, you’ll hit the *Enter* key. But, nothing will happen
    until you type the `done` command on the final line. The `for` loop will then
    run three times, once for each of the three listed arguments. Each time that it
    runs, the value of an argument gets assigned to the `var` variable, and the `echo`
    command prints the currently-assigned value. The output will look something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, hit the up arrow key on your keyboard, and you’ll see the `for` loop
    that you just executed If you try this with `bash`, you’ll see that the individual
    commands are separated by semi-colons, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'On `zsh`, pressing the up arrow key will cause the command components to appear
    on their own separate lines, as you see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Either way, the `for` loop will run again when you hit the *Enter* key.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re still a bit unclear about how `for` loops work, have no fear. We’ll
    look at them in greater detail once we start actually creating shell scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Using Command Sequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Command sequences are another type of programming structure that you’ll find
    very useful. Here, I’m demonstrating how to use them from the command-line so
    that you can grasp the basic concepts. In the upcoming chapters, I’ll show you
    examples of how to use them in shell scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Chaining Commands with a Semi-Colon
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can also use the semi-colon to separate stand-alone commands that you want
    to execute from the same command entry. If you wanted to `cd` to a certain directory
    and then look at its contents, you could enter each command on its own line. Or,
    you could enter them both on the same line. This process is called **command chaining**,
    which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The first command failed because I tried to `cd` into a non-existent directory.
    But, the second command still executed, which listed the files in my home directory.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional Command Execution with Double Ampersands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can also instruct `bash` or `zsh` to only execute the second command if
    the first command successfully completes. Just separate the commands with `&&`
    instead of with a semi-colon, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'What if the first command doesn’t run successfully? Note here that the second
    command doesn’t execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Conditional Command Execution with Double Pipes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want `bash` or `zsh` to execute the second command only if the first
    command *doesn’t* run successfully, just separate the commands with `||`. (This
    is a pair of pipe characters, which you’ll find on the same key as the backslash.)
    To illustrate, let’s again make a slight typo while trying to change directories.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: For a more practical example, try changing to a directory, creating it if it
    doesn’t exist, and then changing to it after it’s been successfully created.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You’ll still get an error message saying that the directory you tried to access
    doesn’t exist. But, look at the command prompt, and you’ll see that the directory
    has been created, and that you’re now in it.
  prefs: []
  type: TYPE_NORMAL
- en: Using the find Utility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll now take a short intermission from our discussion of running multiple
    commands in order to introduce the `find` utility, which is truly the Cool-Mac
    Daddy of all search utilities. After this introduction, I’ll use `find` to show
    you more ways to run multiple commands at once.
  prefs: []
  type: TYPE_NORMAL
- en: Also, it would behoove us to mention that `find` isn’t just good for command-line
    searches. It’s also excellent for use within shell scripts, as you’ll see much
    later.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re as old as I am, you might remember the Windows XP search pooch, which
    pranced around on your screen every time you did a file search from the Windows
    XP graphical search utility. It was cute, but it didn’t add to your search power.
    With the Linux `find` utility, you can perform powerful searches on just about
    any criterion you can think of, and then--from the same command-line entry--invoke
    another utility to do whatever you need to do with the search results. I won’t
    try to discuss every option there is for `find`, since there are so many. Rather,
    I’ll give you an overview of what you can do with `find`, and let you read its
    man page for the rest. (Just enter `man find` at the command-line to read about
    all of its options.)
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to perform the most basic of searches, you’ll need to specify two
    things:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The search path**: You can perform a search in either a specific path, or
    the entire filesystem. Since `find` is inherently recursive, the search will automatically
    extend to all of the subdirectories that are beneath of the directory that you
    specify. (Of course, you can also add command switches that limit the depth of
    the search.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**What you’re searching for**: There are a lot of ways that you can specify
    this. You can search for files of a specific name, and decide whether to make
    the search case-sensitive. You can also use wildcards, or search for files with
    certain characteristics or that are of a certain age. Or, you can combine multiple
    criteria for even more specific searches. The main thing that limits you is your
    own imagination.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So now, let’s say that you want to search the entire filesystem for all files
    whose names end in `.conf`. You’ll want to use either the `-name` or the `-iname`
    switch in front of the file description that you want to search for. Otherwise,
    you’ll get a jumbled up mess of every directory listing that you’ve searched,
    with the information you’re looking for mixed in. For case-sensitive searches,
    use `-name`, and for case-insensitive searches, use `-iname`. In this case, we’ll
    use `-iname`, since we want to make the search case-insensitive.
  prefs: []
  type: TYPE_NORMAL
- en: I know, I’ve told you previously that most whole-word option switches are preceded
    by a pair of dashes. The `find` utility is an exception to the rule, because its
    whole-word option switches are preceded by only a single dash.
  prefs: []
  type: TYPE_NORMAL
- en: Also, be aware that searching through an entire filesystem on a production server
    with very large drives can take a long time. It’s sometimes necessary to do that,
    but it’s best to confine your searches to specific directories whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you include a wildcard character with a search criterion, you’ll need to
    enclose that search criterion in quotes. That will keep the shell from interpreting
    the wildcard character as an ambiguous file reference. For example, to perform
    a case-insensitive search through the current working directory and all of its
    subdirectories for all files with names ending with a `.conf` filename extension,
    I would do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: By using the `-iname` option, I was able to find files with names that ended
    in either `.conf` or `.CONF`. If I had used the `-name` option instead, I would
    only have found files with names that end in `.conf`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, you would specify the search path as the first component of the `find`
    command. In the GNU implementation of `find` that’s included on Linux-based operating
    systems, omitting the search path will cause `find` to search through the current
    working directory, as we’ve just seen. Unfortunately, that trick doesn’t work
    for Unix/Unix-like operating systems, such as FreeBSD, macOS, or OpenIndiana.
    For those operating systems, you’ll always need to specify a search path. To make
    `find` search through the current working directory, just use a dot to specify
    the search path. So, on my FreeBSD virtual machine, the command looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Okay, I know. You’re wondering why I’m mentioning FreeBSD, macOS, and OpenIndiana
    in what’s supposed to be a Linux book. Well, it’s because sometimes, we’ll want
    to create shell scripts that work on multiple operating systems, rather than just
    on Linux. If you include the dot in this command, it will still work on your Linux
    machines, and will also work on your Unix/Unix-like machines.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also specify search paths that aren’t your current working directory.
    For example, you can remain within your own home directory and search through
    the entire filesystem like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, this will take much longer than it does to just search through one
    directory. Also, you’ll encounter errors because your normal user account won’t
    have permission to go into every directory. To search through all directories
    on the filesystem, just preface the command with `sudo`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You can perform searches with more than one search criterion. If you separate
    the criteria with a space, it will be the same as placing an `and` operator between
    them. Here, we’ll use the `-mtime -7` switch to find all of the `.conf` files
    that were modified within the last seven days, and the `-ls` switch at the end
    to show detailed information about the files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To search for `.conf` files that were modified more than seven days ago, replace
    the `-7` with `+7`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: It’s also possible to create more advanced searches by creating compound expressions.
    It works like Algebra, in that expressions are evaluated from left to right unless
    you group some of the terms with parentheses. But, with that, there are a couple
    of minor catches.
  prefs: []
  type: TYPE_NORMAL
- en: Since the parenthesis symbols have a special meaning in `bash` and `zsh`, you’ll
    want to precede them with a backslash so that `bash` and `zsh` won’t interpret
    them the wrong way. You’ll also need to leave a space between the parenthesis
    symbols and the terms that they’re enclosing.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say that we now want to look for all of the `.conf` files in the `/etc/`
    directory that were either modified within the last seven days, or that were accessed
    more than 30 days ago. We’ll use the `-atime` switch to set the access time criterion.
    The `or` operator is represented by `-o`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: There are several subdirectories in `/etc/` that require root privileges to
    enter, so I used `sudo` again, as I did before. Adding the `-ls` option at the
    end of the command would show the timestamps on the files, which would tell me
    which of the two search criteria applies to each specific file.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to find files that belong to only a certain user, you can do that
    with the `-user` switch. Add a second criterion to find only files of a certain
    type that belong to a certain user. Here, I’m searching through the whole filesystem
    for all `.png` graphics files that belong to me:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Even with full `sudo` privileges, there are still a couple of directories where
    I’m not allowed to access. But, that’s okay.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the `-group` switch to find files that belong to a certain group.
    Here, I’m looking through my own home directory for either files or directories
    that are associated with the `nobody` group.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note that I’m still using `sudo` here, because even in my own home directory
    there are some directories that `find` won’t access without it. (These are the
    directories that contain information about Docker containers.)
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, you can use the `-nogroup` switch to find files that don’t belong
    to any group that’s listed in the `/etc/group` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the Linux/Unix world, everything on the system is represented by a file.
    Normal users of a system will usually just encounter regular files and directories,
    but there are many other types of files that will be of interest to a system administrator.
    The various file types include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Regular files:** These are the types of files that a normal user would routinely
    access. Graphics files, video files, database files, spreadsheet files, text files,
    and executable files are all examples of regular files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Directories**: It seems strange that a directory is a type of file, but that’s
    just how it is in the Linux and Unix worlds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Character devices**: A character device either accepts or supplies a serial
    stream of data. A sound card or a terminal would be represented by a character
    device file. You’ll find these files in the `/dev/` directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Block devices**: A block device file represents devices that can be accessed
    in a random manner. Examples include hard drives, solid-state drives, and drive
    partitions. You’ll also find these files in the `/dev/` directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Named pipes**: These devices take the output from one system process and
    supply it as the input to another system process, thus enabling inter-process
    communication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sockets**: These are the same as named pipes, except that they can send and
    receive file descriptors as part of the communications stream. Also, unlike named
    pipes, sockets can allow two-way data exchange between two processes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Symbolic links**: This type of file simply points to either a regular file
    or directory. This allows users to either access files and directories from multiple
    places in the filesystem, or to access them by different names.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can tell what type a file is by doing an `ls -l` command. The first character
    in the output for each file is known as the **file mode string**. This file mode
    string designates the file type. For example, let’s look at what’s in my home
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Lines that begin with a `-` represent a regular file, and lines that begin
    with a `d` represent a directory. The various file types are represented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **File mode string** | **File type** |'
  prefs: []
  type: TYPE_TB
- en: '| `-` | Regular file |'
  prefs: []
  type: TYPE_TB
- en: '| `d` | Directory |'
  prefs: []
  type: TYPE_TB
- en: '| `c` | Character device |'
  prefs: []
  type: TYPE_TB
- en: '| `b` | Block device |'
  prefs: []
  type: TYPE_TB
- en: '| `p` | Named pipe |'
  prefs: []
  type: TYPE_TB
- en: '| `s` | Socket |'
  prefs: []
  type: TYPE_TB
- en: '| `l` | Symbolic link |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2.1: File type designators'
  prefs: []
  type: TYPE_NORMAL
- en: 'There may be times when you’ll need to locate all files of a certain type.
    You can do that with the `-type` option, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As you see, I’m using the `-type p` option to search for all named pipe files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s consider the previous example in which we searched for all files
    that end with a `.conf` filename extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This command only found regular files because they’re the only types of files
    on the system that have the `.conf` filename extension. But, let’s now say that
    we want to search through the `/etc/` directory to find all subdirectories with
    the `conf` text string in their names. If we don’t specify a file type, we’ll
    see regular files, symbolic links, and directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use the `-type d` option to narrow things down:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Cool. We now only see the directories, which is exactly what we want.
  prefs: []
  type: TYPE_NORMAL
- en: As I said before, there are a lot of options that you can use with the `find`
    utility. (Enter `man find` to see them all.)
  prefs: []
  type: TYPE_NORMAL
- en: Now, with the introduction to `find` out of the way, let’s look at how to use
    `find` to perform multiple actions with one command.
  prefs: []
  type: TYPE_NORMAL
- en: Performing Multiple Actions with find
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our next trick contains a bit of a twist. We’ll use `find`'s `-exec` and `-ok`
    option switches to make `find` perform some sort of action on each file that it
    finds. First, `find` finds the files. Then, it causes another command to run that
    will take some sort of action on the files. Here’s how it works.
  prefs: []
  type: TYPE_NORMAL
- en: The `-exec` and `-ok` switches tell the shell to perform a second command only
    if the first command produces valid output. It then uses the output of the first
    command (`find`) as arguments for the second. The difference between the two switches
    is that `-exec` causes the desired action to automatically execute on each file
    without prompting the user. The `-ok` switch will cause the action to stop after
    each file that `find` finds, asking the user whether or not to proceed with the
    action for that file. Here, we’re searching the entire filesystem for all `.zip`
    files that are more than 30 days old, and copying them to the `/home/donnie/`
    directory. (Note that I’m still using `sudo` so that I can access all directories.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `{}` after the `cp` command tells `bash` or `zsh`, “Take the results from
    the `find` command, and put them here as the arguments”. Note that this command
    sequence has to end with a semi-colon. But, since the semi-colon has special meaning
    for `bash` and `zsh`, you must precede it with a backslash so that `bash` and
    `zsh` will interpret it correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that you must have a blank space after the first parenthesis, and
    another blank space before the backslash that precedes the last parenthesis.
  prefs: []
  type: TYPE_NORMAL
- en: Now, suppose that you only want to copy over some of the files that you find.
    Just replace the `-exec` switch with the `-ok` switch. It works the same as `-exec`,
    but it will ask permission before performing an operation on a file. You’ll have
    to enter either *y* or *n* before continuing to the next file.
  prefs: []
  type: TYPE_NORMAL
- en: The same principle also works for removing files.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s now suppose that Vicky, Cleopatra, Frank, and Goldie are all creating
    graphics for some sort of project. They’re supposed to place the graphics files
    into the `graphics` subdirectory that each of them have in their own home directory.
    Sometimes they forget though, and place the files into their top-level home directories,
    as we see in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21693_02_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: Some of these graphics files are in the wrong place.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s get a bit of hands-on practice with this.
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on Lab – Using find to Perform Other Commands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For this lab, use a Fedora, Debian, or Ubuntu virtual machine. (I’ll provide
    instructions for all of them.)
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say that we want to copy everyone’s graphics files into a common backup
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create the `/backup` directory, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For our present purposes, just leave ownership and permissions settings as they
    are.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create user accounts for Vicky, Cleopatra, Frank, and Goldie, and assign
    a password to each account. On Fedora, the commands would look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'On either Debian or Ubuntu, use the interactive `adduser` command, which both
    creates the user account and sets the password. It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Log into each user’s account, create a `graphics` directory in each user’s
    home directory, and then create some fake graphics files. Here are the commands
    to do that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `touch` command is actually meant to be used by programmers for purposes
    that I won’t go into here. But, it’s also handy for situations like this, when
    you just need to create some fake files for testing purposes. By enclosing a comma-separated
    list of filenames within a pair of curly braces, you can create multiple files
    with just one single command. To verify that, let’s peek into the `graphics` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'For this step, you’ll need to log back into your own user account. You want
    to be sure to get all of the graphics files, even if they’re in the users’ top-level
    home directories, and copy them into the `/backup/` directory. Your command and
    results would look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What I’ve shown you here just barely scratches the surface of what you can do
    with `find`. To see the complete list of search criteria that you can specify,
    open the `find` man page and scroll down to the **TESTS** section.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll look at some more `find` examples a bit later. For now though, let’s look
    at how to create recursive commands.
  prefs: []
  type: TYPE_NORMAL
- en: Running Commands Recursively
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve already shown you that the `find` utility is inherently recursive. That
    is, it will automatically search through the subdirectories of your specified
    search path without you having to tell it to. Most Linux commands aren’t that
    way, however. If you want them to work recursively, you’ll have to tell them to.
    For the most part, this is done with either the `-R` switch or the `-r` switch.
    (Some commands use `–R`, and some use `–r`. Something that you’ll eventually see
    for yourself is that there’s not a lot of consistency in how the different commands
    work with option switches.) Let’s see how it all works with a hands-on lab.
  prefs: []
  type: TYPE_NORMAL
- en: The examples in this section involve using the numeric method to set file and
    directory permissions. For anyone who’s not familiar with how to do that, I’ve
    provided a reference in the *Further Reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on Lab – Using Commands with Recursion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this lab, you’ll be using the recursive option for the `ls` and `chmod` utilities.
    Let’s dig in.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s create a new directory with a set of nested subdirectories, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we want to look at the permissions settings for the entire nest of directories.
    So, let’s do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Well now, that doesn’t help, does it? All we can see is just the first level
    subdirectory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try adding the `-R` option to see if that helps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This is much better, because we now see the permissions settings for all four
    of the nested subdirectories. But, we see that the permissions settings aren’t
    what we want. With the `755` permission setting that we currently have, we’re
    allowing the user to have read/write/execute access, while the group and others
    have read/execute access. What we really want is for the user and the group to
    both have read/write/execute access, and for others to have no access at all.
    We’ll do that by using `chmod` to change the permissions settings to `770`. The
    `-R` switch will allow us to change the settings for the top-level directory,
    as well as all four of the nested subdirectories.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recursively set the correnct permissions setting with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you’ve removed access for others, you’ll need to use `sudo` to view
    the permissions settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: You see that the permissions setting is now `770` for the entire nest, which
    means that we have achieved extreme coolness.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip**'
  prefs: []
  type: TYPE_NORMAL
- en: You might, at some point, be called upon to create a shell script that will
    automatically compile and install a program. The ability to create nested directories
    and recursively change permissions settings on them will come in quite handy when
    writing those kinds of scripts.
  prefs: []
  type: TYPE_NORMAL
- en: There are several other utilities that also have the recursive feature. (You’ll
    encounter some of them as you go through this book.) The slight catch is that
    for some of them the recursive option switch is `-r`, and for other it’s `-R`.
    But, that’s okay. When in doubt, just consult the man page for the utility that
    you need to use.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve covered recursion, let’s have a `history` lesson.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Command History
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever you work with the command-line, there will be times when you’ll have
    to enter some commands more than once. If you’ve just entered a command that’s
    long and complex, you may not exactly be thrilled at the prospect of having to
    type it in all over again. Not to worry, though. For this, `bash` and `zsh` give
    you the ability to recall and/or edit commands that you’ve previously entered.
    There are a few ways to do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever you enter a command, it gets stored in memory until you exit the shell
    session. The command will then get added to a file that’s specified by the `HISTFILE`
    variable. Usually, this is the `.bash_history` file on `bash`, and the `.histfile`
    file on `zsh`. You’ll find these stored in each user’s home directory. To verify
    that, you can use the `echo` command, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'On `zsh`, you’ll see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The number of commands that get saved to either the `.bash_history` file or
    the `.histfile` is set by the `HISTSIZE` variable in the `/etc/profile` file.
    (Both `bash` and `zsh` reference the same file.) You can use `grep` to search
    for that line without having to open the file, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use `echo` to see the setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Either way, we see that the system is set up to store the last 1,000 user commands
    in the `.bash_history` file.
  prefs: []
  type: TYPE_NORMAL
- en: More often than not, you’ll probably use the up and down arrow keys on your
    keyboard to call up previously entered commands. If you keep pressing the up arrow
    key, you’ll scroll through the list of previous commands, starting with the last
    one entered. If you go past the command that you want, you can use the down arrow
    key to get back to it. When you finally do get to the command that you want to
    repeat, you can either press the *Enter* key to enter it as is, or edit it and
    then press *Enter*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use the `!` in various ways to recall past commands. For example,
    entering `!!` will execute the last command that you entered, as you see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `!` followed by a text string to execute the last executed command
    that begins with that string. Let’s say that I want to repeat the last `grep`
    command that I did, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `!?` followed by a string to execute the last executed command that contains
    that string, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, for the coolest part of all. First, let’s view the history list, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'To execute a command from this list, enter `!` followed by the command number.
    For example, to perform the `echo` command again, enter `!478`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Of all of the `history` tricks that I’ve shown you, this last one is the most
    useful one for me. But wait, here’s yet one more trick that you might find useful.
    That is, you can display the command history along with timestamps that show when
    each command has been executed. On `bash`, just do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: What’s happening here is that we’re configuring the `HISTTIMEFORMAT` environmental
    variable to display the timestamp in our desired format, and then running the
    `history` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is somewhat easier on `zsh`, because `zsh` allows us to use `history`
    with the `-f` option switch, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that running `history -f` on `bash` will give you an error message, like
    this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: All right, let’s move on to the next topic.
  prefs: []
  type: TYPE_NORMAL
- en: Escaping and Quoting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever you type anything on the command-line or into a shell script, you’ll
    be using a mix of normal alphanumeric text and non-alphanumeric characters. Some
    of these characters have special meanings within the shell, and will cause the
    shell to perform in some special way. Sometimes, you’ll want the shell to interpret
    these special characters as normal text, instead of as something with a magical
    power. To do that, you can either **escape** or **quote** the special characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two general classes of characters that can be interpreted by the
    shell from within a shell command. These are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Normal characters**: `bash` and `zsh` interpret these characters literally.
    In other words, they have no special meaning to the shell.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Metacharacters**: These characters have special meanings for `bash` and `zsh`.
    You could say that a metacharacter provides some sort of special instruction to
    these shells.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s a space-separated list of metacharacters that can be used in either
    shell scripts or shell commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: I’d rather not try to explain what each one does right now, because many of
    them can perform multiple functions, depending upon the context of the command.
    But, we’ve already seen some of them in action, and we’ll see the rest of them
    in action as we progress through this book.
  prefs: []
  type: TYPE_NORMAL
- en: Escaping Metacharacters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ve already seen some of these metacharacters in action in the previous examples.
    To further demonstrate, let’s look at the humble `*` metacharacter, which can
    be used as a wildcard. Let’s first do a directory listing of all of the `.conf`
    files in the `/etc/` directory, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'You see that I’ve just listed all files with filenames that end with a `.conf`
    filename extension. Now, let’s place a `\` in front of the `*`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Placing the `\` in front of the `*` caused the shell to interpret the `*` literally,
    instead of as a metacharacter. Instead of looking for all files with `.conf` at
    the end of their filenames, we’re now looking for just one specific file with
    the filename, `*.conf`. No such file exists, so `ls` returned an error message.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `find` example where we performed a compound search, we had to place
    a `\` in front of each parenthesis character so that the shell would interpret
    them correctly. Here’s what that looked like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s try it without the \ characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This time, I get an error message, because `bash` doesn’t understand what I’m
    trying to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, just for fun, try this pair of commands on your own machine and note the
    difference in output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: I guess that I should mention that when you place a `\` in front of a metacharacter
    so that the shell will interpret the metacharacter literally, it’s called **escaping**
    the metacharacter. This is something that you’ll use extensively for either normal
    shell commands or shell scripting.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, let’s look at another way to make the shell interpret metacharacters literally.
  prefs: []
  type: TYPE_NORMAL
- en: Quoting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You sometimes might have to quote a text string when performing a shell command
    or writing a shell script. This simply involves surrounding the text string with
    either a pair of double quotes (`"`) or a pair of single quotes (`''`). If you
    surround a text string with a pair of single quotes, the shell will interpret
    any metacharacters that are within the quotes as normal, literal characters. If
    you surround a text string with a pair of double quotes, the shell will interpret
    most, but not all, metacharacters as normal, literal characters. To show how that
    works, let’s create a programming variable that we’ll call `name`, and assign
    to it the value `charlie`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we’ll try to echo back the value of `name`, using a pair of single quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'You see that the single quotes cause the shell to interpret the `$` as a literal
    character. Now, let’s see what happen if we use a pair of double quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: This time, we see the variable’s actual value, because the `$` is one of the
    metacharacters that the double quotes won’t treat as a literal character.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll cover the topic of programming variables more in depth later. So for now,
    don’t stress out if you don’t fully understand the concept.
  prefs: []
  type: TYPE_NORMAL
- en: 'For reference, here’s the complete list of metacharacters that won’t get interpreted
    as literal characters by surrounding them with double quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`` ` ``'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To clarify, the list consists of the double quote character, the backslash,
    the back-tick, and the dollar sign. (For now, don’t worry about what all of these
    metacharacters do. We’ll cover them all in due time.)
  prefs: []
  type: TYPE_NORMAL
- en: 'For all other metacharacters, it doesn’t matter whether you use double quotes
    or single quotes. Let’s look at this example that uses a wildcard character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Either way, the result is the same. Both times, the `*` gets treated as a literal
    character. To use the `*` as an actual metacharacter, just omit the quotes, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Okay, that pretty much does it for escaping and quoting, as well as for the
    whole chapter. Let’s summarize and move on.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve covered some important basics in this chapter. We started by describing
    the structure and the components of a shell command, and how to perform multiple
    actions with just one single command. Then, we looked at the `find` utility, and
    the cool things that you can do with it. We then looked at how to run commands
    recursively, and wrapped up with a discussion about escaping and quoting.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll talk about variables and pipelines. I’ll see you
    there.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which of the following sets of metacharacters would cause the second command
    to run only if the first command runs successfully?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`||`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`&&`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`|`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`&`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: You want to run a command that contains the `$` metacharacter, but you want
    the shell to interpret the metacharacter literally. How would you do that? (Choose
    two.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Precede the metacharacter with a `/`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Surround the text string that contains the metacharacter with a pair of single
    quotes.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Precede the metacharacter with a `\`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Surround the text string that contains the metacharacter with a pair of double
    quotes.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It’s not possible.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: You’re using `find` to search for files on a FreeBSD system. To search through
    the current working directory, what must you do on FreeBSD that you don’t have
    to do on Linux?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a dot to designate the search path.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Nothing. The commands are performed the same way on both systems.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: This isn’t possible on a FreeBSD system.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `sudo`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: You want to create a nested directory structure with one single `mkdir` command.
    How would you do that?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `-r` option to make `mkdir` run recursively.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `-R` option to make `mkdir` run recursively.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `-P` option.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `-p` option.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: You want to automatically perform an action on every file that `find` finds,
    without being prompted. Which `find` option would you use to do that?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`-ok`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`-exec`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`--exec`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`--ok`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Linux File Permissions Explained: [https://www.redhat.com/sysadmin/linux-file-permissions-explained](https://www.redhat.com/sysadmin/linux-file-permissions-explained)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How to Use Bash Wildcards for Globbing?: [https://www.shell-tips.com/bash/wildcards-globbing/#gsc.tab=0](https://www.shell-tips.com/bash/wildcards-globbing/#gsc.tab=0)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How to Recursively Search Directory Names in Linux: [https://www.howtogeek.com/devops/how-to-recursively-search-directory-names-in-linux/](https://www.howtogeek.com/devops/how-to-recursively-search-directory-names-in-linux/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Find Command in Linux: [https://linuxize.com/post/how-to-find-files-in-linux-using-the-command-line/](https://linuxize.com/post/how-to-find-files-in-linux-using-the-command-line/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '10 Ways to Use the Linux find Command: [https://www.redhat.com/sysadmin/linux-find-command](https://www.redhat.com/sysadmin/linux-find-command)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What are Linux Metacharacters? Everything You Need to Know: [https://www.makeuseof.com/what-are-linux-metacharacters/](https://www.makeuseof.com/what-are-linux-metacharacters/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '6 Linux metacharacters I love to use on the command line: [https://opensource.com/article/22/2/metacharacters-linux](https://opensource.com/article/22/2/metacharacters-linux)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How to Use Your Bash Historyin the Linux or MacOS Terminal: [https://www.howtogeek.com/44997/how-to-use-bash-history-to-improve-your-command-line-productivity/](https://www.howtogeek.com/44997/how-to-use-bash-history-to-improve-your-command-line-productivity/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Navigating Bash History Ctrl+r: [https://lornajane.net/posts/2011/navigating-bash-history-with-ctrlr](https://lornajane.net/posts/2011/navigating-bash-history-with-ctrlr)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How to Find When a Command is Executed in Linux: [https://ostechnix.com/find-when-a-command-is-executed-in-linux/](https://ostechnix.com/find-when-a-command-is-executed-in-linux/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Escape Quotes in Bash: [https://linuxsimply.com/bash-scripting-tutorial/quotes/escape-quotes/](https://linuxsimply.com/bash-scripting-tutorial/quotes/escape-quotes/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: b
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: b and c
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: d
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: b
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Join our community on Discord!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Read this book alongside other users, Linux experts, and the author himself.
  prefs: []
  type: TYPE_NORMAL
- en: Ask questions, provide solutions to other readers, chat with the author via
    Ask Me Anything sessions, and much more. Scan the QR code or visit the link to
    join the community.
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/SecNet](https://packt.link/SecNet)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code10596186092701843.png)'
  prefs: []
  type: TYPE_IMG
