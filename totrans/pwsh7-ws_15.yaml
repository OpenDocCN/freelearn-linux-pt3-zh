- en: '15'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PowerShell 7 and the Raspberry Pi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is one of the chapters I’ve looked forward to writing the most. I’ve got
    a house full of Raspberry Pis (and Arduinos, micro:bits, and ESP32s…). I use them
    to teach coding to school kids (and adults), as well as to run adblockers, media
    centers, wildlife cameras, and horticultural systems. I’ve got one with buttons
    that randomly selects episodes of my favorite radio shows and plays them (called
    the Shendomizer). Mostly, I program them with Python, but PowerShell is also an
    option. We can even install a stripped-down version of Windows 10 on them, but
    we won’t cover that in this book. Instead, we’ll look at how to install PowerShell
    7 and **Visual Studio** (**VS**) Code, how to connect remotely to a headless Pi
    over Wi-Fi using SSH with both PowerShell and VS Code, the default module for
    working with PowerShell on the Raspberry Pi, and finish up by creating a script
    to accomplish the first steps in physical computing: getting an LED to blink on
    and off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The main topics we’ll cover in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to the Raspberry Pi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing PowerShell and VS Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting remotely to the Pi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running PowerShell on Raspberry Pi OS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple physical computing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, we will need a Raspberry Pi with a power supply, screen, keyboard
    and mouse, and the requisite cables. Some of this chapter has been written on
    the Pi 400, which is a handy version of the Pi that’s installed on a keyboard
    with everything we need except a monitor. Other parts have been written using
    a Raspberry Pi 3 single-board computer.
  prefs: []
  type: TYPE_NORMAL
- en: Note that a Pi Zero or Pi Pico will not work. They use a different ARM chip
    version, so the architecture won’t work with .NET.
  prefs: []
  type: TYPE_NORMAL
- en: 'For simple automation, we’ll need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An LED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 300-400 Ohm resistor (but 250-500 will work)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two male-to-female jumper cables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to the Raspberry Pi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Raspberry Pi is a small, affordable, and versatile single-board computer
    developed by the Raspberry Pi Foundation in the UK. Its primary goal was to promote
    the teaching of basic computer science in schools and developing countries. However,
    its accessibility, low cost, and ease of use have made it incredibly popular among
    hobbyists, educators, and professionals for various applications, from learning
    programming to building complex projects.
  prefs: []
  type: TYPE_NORMAL
- en: It’s designed to be a blank slate, allowing users to understand the basics of
    hardware and software interactions. This computer is essentially a tiny, self-contained
    PC that can be used for many of the same tasks we might use a desktop or laptop
    PC for, such as browsing the internet, word processing, and playing games. Moreover,
    its **general-purpose input/output** (**GPIO**) pins enable it to interact with
    external hardware, making it ideal for electronics projects and **Internet of
    Things** (**IoT**) applications.
  prefs: []
  type: TYPE_NORMAL
- en: Over the years, several models of the Raspberry Pi have been released, each
    improving on its predecessor. The latest model is the Raspberry Pi 4 Model B.
    This model has a 64-bit quad-core ARM Cortex-A72 CPU, offering processing speeds
    of up to 1.5 GHz. It comes in variants that have 2 GB, 4 GB, or 8 GB of LPDDR4-3200
    SDRAM. For connectivity, it includes Gigabit Ethernet, Bluetooth 5.0, and dual-band
    Wi-Fi (2.4G Hz and 5.0 GHz). It also has two USB 3.0 ports, two USB 2.0 ports,
    two micro HDMI ports supporting up to 4K resolution, and a USB-C port for power.
  prefs: []
  type: TYPE_NORMAL
- en: The Raspberry Pi can run various **operating systems** (**OSs**), with Raspberry
    Pi OS (formerly Raspbian) being the most popular. This Debian-based OS is optimized
    for the Raspberry Pi hardware and comes pre-loaded with essential tools, programming
    languages, and applications. Users can also install different flavors of Linux
    and even a version of Windows 10 IoT Core. The OS can be installed by flashing
    an image to a MicroSD card.
  prefs: []
  type: TYPE_NORMAL
- en: For programming, Python is the most commonly used language due to its simplicity
    and power. However, the Raspberry Pi supports numerous other languages, such as
    JavaScript, PHP, C++, Java, and, most importantly for us, PowerShell 7\. Its versatility
    makes it a valuable tool for software development, especially in IoT and embedded
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: The Raspberry Pi’s range of use cases is vast. In education, it’s used to teach
    programming, computer science fundamentals, and even hardware design. Hobbyists
    use it for projects such as retro gaming consoles, media centers, and home automation
    systems. In professional settings, it serves as a cost-effective tool for prototyping,
    data collection, and automation. We can also use it for parallel computing; an
    example of this is the OctaPi project run by GCHQ in the UK. Some institutions
    even use it as a supercomputer; the Los Alamos National Laboratory built a 750-node
    high-performance computer out of Pis.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Raspberry Pi ecosystem has expanded over the years since its release in
    2012\. There are three separate series: the Pi, the Pi Zero, developed as a lightweight
    and even cheaper alternative that can be dedicated to a single project and left
    to run (I have several Pi Zero wildlife cameras running on rechargeable batteries),
    and the Pi Pico, an alternative to the popular Arduino single chipboard. PowerShell
    7 will only run on the full-fat Pi, not the Pi Zero or Pico. These smaller alternatives
    run on ARMv6 chip designs; .NET, and therefore PowerShell 7, requires an ARMv7
    or ARMv8 chip, as found in the Pi 2, 3, and 4\. This is partly because the ARMv6
    is lower-powered, but also because nobody wants to be designing for old hardware,
    do they?'
  prefs: []
  type: TYPE_NORMAL
- en: Right. Shall we get on and install PowerShell on a Pi?
  prefs: []
  type: TYPE_NORMAL
- en: Installing PowerShell 7 and VS Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Raspberry Pi OS is a Linux distro based on Debian, the same as Ubuntu, so the
    Ubuntu instructions we followed in [*Chapter 14*](B17600_14.xhtml#_idTextAnchor280),
    *PowerShell 7 for Linux and macOS*, will work, but there’s an even easier way
    to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Installing PowerShell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we go to the *Community support for PowerShell on Linux* page at [https://learn.microsoft.com/en-us/powershell/scripting/install/community-support](https://learn.microsoft.com/en-us/powershell/scripting/install/community-support),
    we’ll find a very handy script that will install PowerShell for us, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.1 – The Raspberry Pi OS install script](img/B17600_15_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.1 – The Raspberry Pi OS install script
  prefs: []
  type: TYPE_NORMAL
- en: 'If we click the **Copy** button in the top-right corner of the script box,
    then we can simply open a terminal window on the Raspberry Pi and right-click
    to paste it into the terminal, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.2 – Installing PowerShell by pasting the script into the terminal](img/B17600_15_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.2 – Installing PowerShell by pasting the script into the terminal
  prefs: []
  type: TYPE_NORMAL
- en: Once we’ve pasted it, all we have to do is press *Enter* on the line highlighted
    in the preceding screenshot, at which point the script will work through, install,
    and then start PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, that may be prone to errors, so we might want to actually create
    a script, check that it’s right, and then execute it. To do this, from the terminal
    prompt, type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This will open the nano text editor. Paste the script into nano, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.3 – Creating a PowerShell install script in nano](img/B17600_15_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.3 – Creating a PowerShell install script in nano
  prefs: []
  type: TYPE_NORMAL
- en: 'Check that you’ve pasted it correctly, and then save it by pressing *Ctrl*
    + *X*, typing *Y* when asked to save it, and then typing a suitable filename –
    I’ve called mine `installPosh.sh`. Once we’ve returned to the terminal prompt,
    we can run the script by typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Again, we’ll be taken straight to PowerShell. Now, let’s look at installing
    VS Code.
  prefs: []
  type: TYPE_NORMAL
- en: Installing VS Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Getting VS Code onto our Pi is even easier. VS Code is included in the official
    repositories for Raspberry Pi OS, so we don’t need to manually download files
    or set up alternative repositories – we can just open the terminal and type the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we’ve done this, after a few minutes, VS Code will appear on our machine
    alongside a lot of chatter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.4 – Installing and starting VS Code on the Raspberry Pi](img/B17600_15_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.4 – Installing and starting VS Code on the Raspberry Pi
  prefs: []
  type: TYPE_NORMAL
- en: We can either type `code` in the terminal, or we can find it in the **Programming**
    subsection of the applications menu by clicking on the raspberry icon in the top-left
    corner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s look at the most common way I use the Raspberry Pi: remotely.'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting remotely to the Pi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While it’s quite common to see the Raspberry Pi used as a PC in educational
    settings, it’s more likely that we’ll want to use it as a server of some sort,
    and therefore connect to it remotely, rather than set it up with its own monitor,
    mouse and keyboard. This is called **headless** mode, and it’s what we’re going
    to look at next.
  prefs: []
  type: TYPE_NORMAL
- en: Working with a headless Pi
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To use a headless Pi, we’ll need to set it up so that we have a way of connecting
    it to the network and accessing it remotely. We’re going to configure a new Pi
    (or just rebuild the old one) to access a wireless network, and we’re going to
    use SSH for access, which we saw in [*Chapter 14*](B17600_14.xhtml#_idTextAnchor280),
    *PowerShell 7 for Linux and macOS*. We can set up both of these things with the
    Raspberry Pi Imager tool on the Pi website at [https://www.raspberrypi.com/software/](https://www.raspberrypi.com/software/).
    Note that a lot of documentation on the internet suggests that we might want to
    create and edit a file called `wpa_supplicant.conf`. This is true for older versions
    of Raspberry Pi OS and Raspbian, but recent versions won’t use it.
  prefs: []
  type: TYPE_NORMAL
- en: Download the appropriate version of the installer for the OS we are going to
    run it from – in my case, Windows – and install it.
  prefs: []
  type: TYPE_NORMAL
- en: When we run it, we may experience an OpenGL error if we haven’t kept our graphics
    drivers up to date, so make sure that the latest drivers are installed.
  prefs: []
  type: TYPE_NORMAL
- en: We will also need a microSD card ready to be imaged.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we open the imager tool, we’ll be asked what device we want to install
    on, what OS we want, and what storage we are going to use, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.5 – The Raspberry Pi Imager tool](img/B17600_15_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.5 – The Raspberry Pi Imager tool
  prefs: []
  type: TYPE_NORMAL
- en: 'In my case, I’m installing on a Raspberry Pi 4, I want the latest 64-bit OS,
    and I would like the image to be written to the SDHC card in my laptop. When we
    click **NEXT**, we’ll be asked if we’d like to apply OS customization settings.
    Yes. Yes, we would. Click **Edit Settings**; we’ll see the **OS Customisation**
    dialog box open on the **GENERAL** tab, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.6 – Customizing our Raspberry Pi OS](img/B17600_15_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.6 – Customizing our Raspberry Pi OS
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding screenshot, I have set my hostname, the username and password
    I want to use on the Pi, and, most importantly, I’ve configured the wireless LAN
    settings to automatically connect to the Wi-Fi network I want to use, `ShedWifi`,
    which is the Wi-Fi network in my shed. Now, we need to switch to the **SERVICES**
    tab to enable SSH. By default, when we click on **Enable SSH**, it will select
    **Use password authentication**. I’m sticking with that, but we could configure
    it to **Allow public-key authentication only**. If we click **Save**, we will
    be warned that all the data on our destination SDHC card will be overwritten and
    asked to confirm this. Once we do, after a few minutes, we’ll get a **Write Successful**
    popup telling us that we can remove the SDHC card. Let’s do just that – put it
    in the Pi and power it up. The **SERVICES** tab is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.7 – The Raspberry Pi Imager SERVICES tab](img/B17600_15_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.7 – The Raspberry Pi Imager SERVICES tab
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the Pi has booted up, we should be able to see it on the network if our
    client is on the same subnet. To test this, in a PowerShell session on our client,
    type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We should see the IPv6 and IPv4 addresses, as well as a lot of other information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.8 – Confirming the presence of my Pi](img/B17600_15_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.8 – Confirming the presence of my Pi
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, my Pi has got its IP addresses, as expected, and I can now connect
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try it out.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to the Pi with PowerShell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the PowerShell session on the client, type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can type the following if your usernames are different on
    the client and the host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows what the process looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.9 – Using SSH to connect to the Pi](img/B17600_15_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.9 – Using SSH to connect to the Pi
  prefs: []
  type: TYPE_NORMAL
- en: On line 1, we started an SSH session to the Pi with the `ssh` `poshpi` command.
  prefs: []
  type: TYPE_NORMAL
- en: On line 2, we were prompted to agree to connect since the authenticity of the
    Pi can’t be determined. We’re probably OK to type `yes` here; note that typing
    `Y` on its own won’t work.
  prefs: []
  type: TYPE_NORMAL
- en: On line 3, we’re asked to input the password for the user – in my case, this
    is `nickp`.
  prefs: []
  type: TYPE_NORMAL
- en: On line 4, we’re presented with the bash prompt from the Pi – that is, `nickp@poshpi.local:~
    $`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to install PowerShell. We can do that in the same way we did it
    earlier – that is, by copying the contents of the Microsoft script into the command
    line or creating a bash script with it in nano. Once it’s finished, we can start
    PowerShell with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can create a **symbolic link** (**symlink**), like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, all we need to type in the future is `pwsh`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.10 – Setting up a symlink to run PowerShell](img/B17600_15_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.10 – Setting up a symlink to run PowerShell
  prefs: []
  type: TYPE_NORMAL
- en: On line 1, we created a symlink, while on line 2, we started PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: On line 3, we’re running PowerShell on Linux via the `PS /home/nickp>` prompt;
    we can call the `$PSVersionTable` variable to see what version of PowerShell we’re
    running.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, on line 4, we used *Ctrl* + *Break* to drop out of the SSH session
    and go back to the PowerShell session running on the Windows client – `PS C:\users\nickp>`
    – on line 5\. We can also use *Ctrl* + *D* to log out of the session.
  prefs: []
  type: TYPE_NORMAL
- en: 'Great! Let’s look at another way to connect to our headless Pi: with VS Code.'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to the Pi with VS Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This method will work with any machine we want to connect to with SSH, including
    Linux. We’re going to use a VS Code extension called `Remote-SSH` in the search
    bar, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.11 – Installing the Remote – SSH extension](img/B17600_15_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.11 – Installing the Remote – SSH extension
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve found the extension, click on it, then click **Install** in the
    center pane, as shown in the preceding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we’ve done this, we’ve have a desktop icon in the left-hand sidebar. We
    can click on that to open the **Remote Explorer** window and set up an SSH connection
    to the Pi. We’ll be asked to choose what sort of remote we want – a remote machine
    or a WSL target. We want a remote machine, so select that, and then click on **SSH**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.12 – Selecting SSH](img/B17600_15_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.12 – Selecting SSH
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the `ssh <username>@<hostname>`. In my case, I typed the following
    and pressed *Enter*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we’ll be asked to choose an SSH config file to update. I’m updating my
    personal file, `C:\Users\nickp\.ssh\config`. Then, we’ll see a message box telling
    us **Host added!**. In the **REMOTE EXPLORER** area, click the refresh icon next
    to **REMOTES (TUNNELS/SSH)**, as highlighted in green in *Figure 15**.13*; we
    should see our new host appear in the **SSH** subsection with two icons next to
    it – one to open the host in the existing window, which is depicted with an arrow,
    and another to open in a new window, as highlighted in red. Click the *Connect
    in a New* *Window* icon:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.13 – Opening a connection to the Pi](img/B17600_15_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.13 – Opening a connection to the Pi
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll be asked to select the platform of the remote host; it’s Linux.
    We’ll also need to enter the password. Once we’ve done that, we’ll need to wait
    a minute or two while everything gets set up and dismiss a message window or two.
    Finally, we’ll have a new window connected to our Pi; we know this because in
    the bottom-left corner is a box saying **SSH: <hostname>**. Everything we do in
    this window is happening on the Pi. Cool, eh? This means that instead of writing
    our scripts on our client and transferring them to the Pi, we can write them directly
    to the Pi from VS Code.'
  prefs: []
  type: TYPE_NORMAL
- en: So, that’s us ready to go. We can use PowerShell in the same way we’ve been
    doing throughout this book on the Pi, but that’s not really what I use the Raspberry
    Pi for. Next, we’ll look at how we can use PowerShell on the Pi.
  prefs: []
  type: TYPE_NORMAL
- en: Running PowerShell on Raspberry Pi OS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The beauty of the Raspberry Pi is just how many ways you can connect it to
    the outside world, from joystick controllers to cameras to sensors to motors to…
    ooh… *everything*. In this chapter, we’re going to look at using GPIO pins to
    make an LED blink, but first, we need to learn how we can interact with the GPIO.
    There are two options, neither of them particularly well supported. The better
    option is to install a new OS: Windows 10 IoT Core. That would take a chapter
    or two in itself, and it doesn’t really address the topic of running PowerShell
    on Raspberry Pi OS. The other way is to use the PowerShell IoT module. This hasn’t
    been updated since about 2020 and doesn’t appear to work with later versions of
    the Pi 4B, but it works reasonably well on older ones, and we can live in hope
    that it will be updated at some point. I’m going to take advantage of a Pi 3B
    I’ve got in my drawer.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing the IoT module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’re working with hardware here, so we need to start PowerShell with root
    privileges by typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we’re in PowerShell, we can install the module as we usually do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we’ll probably want to clone the repository from GitHub so that we
    have access to the examples. We can do this with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This will install all the code in the GitHub repository into a new folder below
    our chosen folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.14 – Installing the PowerShell IoT module and cloning the GitHub
    repository](img/B17600_15_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.14 – Installing the PowerShell IoT module and cloning the GitHub repository
  prefs: []
  type: TYPE_NORMAL
- en: This gives us access to all the example modules in the `Examples` folder. This
    includes some interesting tools that we can use with various sensors, such as
    the BME280 environmental sensor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to import the module and check that it’s working:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'And with a bit of luck, we’ll see something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.15 – Importing the module and checking the voltage on a given GPIO
    pin](img/B17600_15_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.15 – Importing the module and checking the voltage on a given GPIO
    pin
  prefs: []
  type: TYPE_NORMAL
- en: Shall we explore the cmdlets we get in this module?
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the IoT module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inside the IoT module, there are six cmdlets for working with the three I/O
    interfaces on the Pi: simple GPIO, I2C, and **Synchronous Peripheral Interface**
    (**SPI**). Confusingly, all three interfaces use the GPIO pins. This can sometimes
    make it difficult to choose which pins we wish to use for what purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: Simple GPIO reads or sets the voltage on a specific GPIO pin with a pair of
    cmdlets called `Get-GpioPin` and `Set-GpioPin`. We’ll be using this shortly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I2C uses the `Get-I2CRegister` and `Set-I2CRegister`, there is also a `Get-I2CDevice`
    cmdlet.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, there is the SPI. This is quite complex, and we’re not going to cover
    it in this book. There is only one cmdlet: `Send-SPIData`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s take a closer look at the five cmdlets we’re going to use the most. The
    helpfiles for these cmdlets can be found in the `/home/<username>/PowerShell-IoT/docs/help/`
    folder, but let’s cover their basic uses here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Get-GpioPin`: This cmdlet gets the voltage from a specified GPIO pin. There
    are three parameters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Id`, which takes an Int32 value and specifies which GPIO pin we want to look
    at.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-PullMode`, which may be set to `Off`, `PullDown`, or `PullUp`, and may be
    needed with some chipsets, but not the Pi. The default value is `Null`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A `-Raw` switch, which returns a value of `High` or `Low`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Set-GpioPin`: This cmdlet sets the voltage on a specified pin to `High` or
    `Low`. It has three parameters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Id`, which takes an `Int32` value and specifies the pin.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Value`, which takes either `High` or `Low`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-PassThru`, which, by default, results in the cmdlet returning nothing. If
    we want it to return a PowerShell object confirming that the value was set, then
    we can use this parameter.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Get-I2CDevice`: This cmdlet creates an I2C device object with a friendly name
    that we can then use with the `*-I2Cregister` cmdlets. It has two parameters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Id`, which takes an `Int32` value and specifies the address of the device'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-FriendlyName`, which we use to assign a string to the device'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Get-I2Cregister`: This cmdlet gets the value held in a register on a particular
    device. There are four parameters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Device`, which takes an I2C device object'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Register`, which takes a `Uint16` value that specifies the register on the
    device we want to read'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Raw`, which returns the value stored in the register, rather than an `I2CdeviceRegisterData`
    object'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Bytecount`, which takes a byte value and specifies the number of bytes expected
    in the data'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Set-I2Cregister`: This cmdlet sets the register value on a device. There are
    four parameters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Device`, which takes an I2C device object.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Register`, which takes a `Uint16` value that specifies the register on the
    device we want to set.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Data`, a value in bytes to be written to the register.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-PassThru`, which, by default, results in the cmdlet returning nothing. If
    we want it to return a PowerShell object confirming that the value was set, then
    we can use this parameter.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: And that’s it. The best way to see how they work is to get on and play with
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Simple physical computing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Physical computing on the Raspberry Pi uses the GPIO pins on the right of the
    board, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.16 – The GPIO pins of the Raspberry Pi](img/B17600_15_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.16 – The GPIO pins of the Raspberry Pi
  prefs: []
  type: TYPE_NORMAL
- en: The important things to remember are that the ground pins are negative and the
    voltage pins, 3V3 and 5V, are positive and always on. While the GPIO pins may
    have secondary specialist purposes, they are the ones we can turn on and off –
    they will deliver a positive current.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we’re learning a new programming language, we start with the simplest
    possible program – *Hello World*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In Python, we can write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Physical computing is slightly different – we write a program to make an LED
    blink on and off. It doesn’t seem to matter what the platform is; this is where
    we start. For instance, the program to get an Arduino to blink an LED is written
    in C and looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`v``oid setup()` initializes the onboard LED as an output and runs once each
    time the Arduino is reset. The `void loop()` command sets up a loop that runs
    continuously while the Arduino is switched on (`void` just tells the Arduino not
    to produce an output). The `digitalwrite()` commands set the voltage to the output
    as `HIGH` (on) or `LOW` (off). This looks pretty similar on the Raspberry Pi in
    Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s try it in PowerShell. First, we’ll need to set up our hardware according
    to the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.17 – How to set up the components](img/B17600_15_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.17 – How to set up the components
  prefs: []
  type: TYPE_NORMAL
- en: The LED will have two legs on it, one longer than the other. The longer leg
    needs to be connected to the positive side of the circuit, and the shorter leg
    needs to be on the negative or ground side. The current the Pi sends is too high
    for the LED, so we need to use a resistor of around 300-400 Ohms to drop it slightly.
    More than 1K Ohms will possibly stop the LED from lighting, and less than 200
    risks burning it out, if it’s cheap. The breadboard sockets are connected in columns
    of five, so the resistor spans two columns here.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to write some PowerShell code to turn the LED on and off. Let’s
    connect to the Pi using VS Code SSH remoting and open a new document. Call it
    `blink.ps1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by importing the IoT module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we’re going to need a loop that always runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this loop, we’re going to need to turn the LED on and off using `Set-GpioPin`.
    If you followed the preceding diagram, you should be using pin 17.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll also need to use `Start-Sleep` to wait between each command; otherwise,
    we’ll blow the LED up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'I’ve added a couple of output lines here so that I can reasonably demonstrate
    this without using a YouTube link. Running it looks like this in VS Code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.18 – Blinkin’ LEDs](img/B17600_15_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.18 – Blinkin’ LEDs
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the LED’s state changes once a second; this will continue until
    the script is stopped manually. We can see how it compares to the programs we
    saw for the Arduino, in C, and the Python program.
  prefs: []
  type: TYPE_NORMAL
- en: There’s also an example LED module in the `Examples` folder – it’s well worth
    taking a look to see how they’ve done it in there.
  prefs: []
  type: TYPE_NORMAL
- en: That about wraps it up for this chapter. Let’s summarize what we’ve learned.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started this chapter by taking a quick look at the Raspberry Pi, including
    what it does, what it was designed to do, and how people use it. We looked at
    the different series; the main B series single board computers, the Zero mini
    version, and the Pico single chip board. We learned that we can only install PowerShell
    on the B series since the architecture of the chip is wrong on the Zero and Pico
    series.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we looked at different ways of installing PowerShell on the Pi using a
    script provided by Microsoft. Then, we saw how easy it is to install VS Code on
    the Pi since it is included in the official Raspberry Pi repositories.
  prefs: []
  type: TYPE_NORMAL
- en: While there are Raspberry Pi models that are suitable as desktop PC replacements,
    most people will use the Raspberry Pi without a screen or mouse – that is, in
    headless mode. We looked at how to set up a Raspberry Pi in headless mode, and
    then how to connect to it from PowerShell with SSH, before going on to look at
    a convenient way to work directly on the Pi with VS Code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we discussed one of the most popular use cases for the Pi: physical computing.
    This is where we interact with sensors and objects in the physical world. We looked
    at the Microsoft module for interacting with the GPIO on the Raspberry Pi and
    finished up with a script that can be used to make an LED blink on and off.'
  prefs: []
  type: TYPE_NORMAL
- en: That’s it for the environments we’re going to look at. In the next and final
    chapter, we’re going to look at how we can access the .NET system that PowerShell
    is built on and look at what our next steps could be.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why can’t we install PowerShell on the Raspberry Pi Zero or Pico?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Where is the SSH configuration stored for VS Code on a Windows machine?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the PowerShell cmdlet for testing network connectivity to another device
    from the Raspberry Pi?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you create an SSH connection to a headless Pi from PowerShell?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ve saved our install script as `Install.sh`. How do we run it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why might we want to create a symlink to the `pwsh` executable?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How might we create a symlink to `pwsh`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would we get a value of `High` or `Low` from a GPIO pin?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What sort of OS is Raspberry Pi OS?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OctaPi cluster computer: [https://projects.Raspberrypi.org/en/projects/build-an-octapi](https://projects.Raspberrypi.org/en/projects/build-an-octapi)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Oracle’s 1050-node Pi supercomputer: [https://blogs.oracle.com/developers/post/building-the-worlds-largest-Raspberry-pi-cluster](https://blogs.oracle.com/developers/post/building-the-worlds-largest-Raspberry-pi-cluster)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Community support for PowerShell on Linux: [https://learn.microsoft.com/en-us/powershell/scripting/install/community-support](https://learn.microsoft.com/en-us/powershell/scripting/install/community-support)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PowerShell on ARM processors: [https://learn.microsoft.com/en-us/powershell/scripting/install/powershell-on-arm](https://learn.microsoft.com/en-us/powershell/scripting/install/powershell-on-arm)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'VS Code on the Pi: [https://code.visualstudio.com/docs/setup/raspberry-pi](https://code.visualstudio.com/docs/setup/raspberry-pi)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'VS Code remote SSH: [https://code.visualstudio.com/docs/remote/ssh-tutorial](https://code.visualstudio.com/docs/remote/ssh-tutorial)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PowerShell IoT module on GitHub: [https://github.com/PowerShell/PowerShell-IoT](https://github.com/PowerShell/PowerShell-IoT)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An overview of Windows for IoT: [https://learn.microsoft.com/en-us/windows/iot/product-family/windows-iot](https://learn.microsoft.com/en-us/windows/iot/product-family/windows-iot)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Windows 10 IoT Core on Raspberry Pi:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://cdn-learn.adafruit.com/downloads/pdf/getting-started-with-windows-iot-on-raspberry-pi.pdf](https://cdn-learn.adafruit.com/downloads/pdf/getting-started-with-windows-iot-on-raspberry-pi.pdf)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://devblogs.microsoft.com/premier-developer/getting-started-with-windows-10-iot-core-raspberry-pi-3b/](https://devblogs.microsoft.com/premier-developer/getting-started-with-windows-10-iot-core-raspberry-pi-3b/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Raspberry Pi Configuration documentation: [https://www.raspberrypi.com/documentation/computers/configuration.html](https://www.raspberrypi.com/documentation/computers/configuration.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I2C overview:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/I%C2%B2C](https://en.wikipedia.org/wiki/I%C2%B2C)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://learn.sparkfun.com/tutorials/i2c/all](https://learn.sparkfun.com/tutorials/i2c/all)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SPI overview: [https://learn.sparkfun.com/tutorials/serial-peripheral-interface-spi/all](https://learn.sparkfun.com/tutorials/serial-peripheral-interface-spi/all)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
