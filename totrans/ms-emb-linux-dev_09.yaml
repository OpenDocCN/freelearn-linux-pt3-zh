- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developing with Yocto
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bringing up Linux on unsupported hardware can be a painstaking process. Luckily,
    Yocto provides **Board Support Packages** (**BSPs**) to bootstrap embedded Linux
    development on popular single-board computers like BeaglePlay and Raspberry Pi
    4\. Building on top of an existing BSP layer lets us quickly take advantage of
    complex built-in peripherals such as Bluetooth and Wi-Fi. In this chapter, we
    will create a custom application layer to do just that.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at the development workflow enabled by Yocto’s extensible
    SDK. Modifying software running on a target device usually means swapping out
    the microSD card. Since rebuilding and redeploying full images is too time-consuming,
    I will show you how to use `devtool` to quickly automate and iterate over your
    work. While doing so, you will also learn how to save your work in your own layers
    so that it does not get lost.
  prefs: []
  type: TYPE_NORMAL
- en: Yocto not only builds Linux images but entire Linux distributions. We will discuss
    the reasons for doing so before going through the motions of assembling our own
    Linux distribution. The many choices made include whether or not to add runtime
    package management for rapid application development on the target device. This
    comes at the cost of having to maintain a package database and remote package
    server, which I will touch on last.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Building on top of an existing BSP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capturing changes with `devtool`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building your own distro
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provisioning a remote package server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow along with the examples, make sure you have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An Ubuntu 24.04 or later LTS host system with at least 90 GB of free disk space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Yocto 5.0 (scarthgap) LTS release
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A microSD card reader and card
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: balenaEtcher for Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Ethernet cable and router with an available port for network connectivity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Wi-Fi router
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A smartphone with Bluetooth
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raspberry Pi 4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 5 V USB-C power supply capable of delivering 3A
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should have already built the 5.0 (scarthgap) LTS release of Yocto in [*Chapter
    6*](Chapter_04.xhtml#_idTextAnchor110). If you have not, then please refer to
    the *Compatible Linux Distribution* and *Build Host Packages* sections of the
    *Yocto Project Quick Build* guide ([https://docs.yoctoproject.org/brief-yoctoprojectqs/)](https://docs.yoctoproject.org/brief-yoctoprojectqs/)
    before building Yocto on your Linux host according to the instructions in [*Chapter
    6*](Chapter_04.xhtml#_idTextAnchor110).
  prefs: []
  type: TYPE_NORMAL
- en: 'The code used in this chapter can be found in the chapter folder in this book’s
    GitHub repository: [https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development](https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development).'
  prefs: []
  type: TYPE_NORMAL
- en: Building on top of an existing BSP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **BSP** layer adds support for a particular hardware device or family of devices
    to Yocto. This support usually includes the bootloader, device tree blobs, and
    additional kernel drivers needed to boot Linux on that specific hardware. A BSP
    may also include any additional user-space software and peripheral firmware needed
    to fully enable and utilize all the features of the hardware. By convention, BSP
    layer names start with the `meta-` prefix followed by the machine’s name. Locating
    the best BSP for your target device is the first step toward building a bootable
    image for it using Yocto.
  prefs: []
  type: TYPE_NORMAL
- en: The OpenEmbedded layer index ([https://layers.openembedded.org/layerindex)](https://layers.openembedded.org/layerindex))
    is the best place to start looking for quality BSPs. Your board’s manufacturer
    or silicon vendor may also offer BSP layers. The Yocto Project provides a BSP
    for all variants of Raspberry Pi. You can find the Git repository for that BSP
    layer and all the other layers endorsed by The Yocto Project in the project’s
    source repositories ([https://git.yoctoproject.org](https://git.yoctoproject.org)).
  prefs: []
  type: TYPE_NORMAL
- en: Building an existing BSP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following exercises assume you have already cloned or extracted the scarthgap
    release of Yocto to a directory named `poky` within your host environment. Before
    proceeding, we also need to clone the following dependency layers one level up
    from that `poky` directory so that the layer and `poky` directories sit next to
    each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the branch name of the dependency layers matches the Yocto release
    for compatibility. Keep all three clones up to date and in sync with their remotes
    using periodic `git pull` commands. The `meta-raspberrypi` layer is the BSP for
    all Raspberry Pis. Once these dependencies are in place, you can build an image
    that’s been customized for Raspberry Pi 4\. But before we do that, let’s explore
    the recipes for Yocto’s generic images:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, navigate to the directory where you cloned Yocto:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, move down into the directory where the recipes for the standard images
    are:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'List the core image recipes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Display the `core-image-base` recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that this recipe inherits from `core-image` so it’s importing the contents
    of `core-image.bbclass`, which we will look at later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Display the `core-image-minimal` recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Like `core-image-base`, this recipe also inherits from the `core-image` class
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Display the `core-image-minimal-dev` recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Navigate up to the classes directory under poky/meta:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, display the `core-image` class file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice the long list of available `IMAGE_FEATURES` at the top of this class
    file, including the aforementioned `dev-pkgs` feature.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Standard images such as `core-image-minimal` and `core-image-minimal-dev` are
    machine-agnostic. In [*Chapter 6*](Chapter_04.xhtml#_idTextAnchor110), we built
    `core-image-minimal` for both the QEMU Arm emulator and BeaglePlay. We could have
    just as easily built a `core-image-minimal` image for Raspberry Pi 4\. In contrast,
    a BSP layer includes image recipes intended for a specific board or series of
    boards.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s take a look at the `rpi-test-image` recipe inside the `meta-rasberrypi`
    BSP layer to see how support for both Wi-Fi and Bluetooth is added to `core-image-base`
    for Raspberry Pi 4:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, navigate one level above the directory where you cloned Yocto:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, move down into the directory inside the `meta-raspberrypi` BSP layer
    where the image recipes for Raspberry Pis are:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'List the Raspberry Pi image recipes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Display the `rpi-test-image` recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that the `IMAGE_INSTALL` variable has been overridden so that it can
    append `packagegroup-rpi-test` and include those packages on the image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Navigate to the neighboring `packagegroups` directory under `metaraspberrypi/recipes-core`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, display the `packagegroup-rpi-test` recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that the `connman`, `connman-client`, and `bluez5` packages are included
    in the list of runtime dependencies so that Wi-Fi and Bluetooth are fully enabled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, let’s build `rpi-test-image` for Raspberry Pi 4:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, navigate one level above the directory where you cloned Yocto:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, set up your BitBake work environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This sets up a bunch of environment variables and puts you in a newly created
    `build-rpi` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, add the following layers to your image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**IMPORTANT NOTE**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The order in which you add these layers matters because the `meta-networking`
    and `meta-multimedia` layers both depend on the `meta-python` layer. If `bitbake-layers
    add-layer` or `bitbake-layers show-layers` starts failing due to parse errors,
    then delete the `build-rpi` directory and restart this exercise from *step 1*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Verify that all the necessary layers have been added to the image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output of the command should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Observe the changes that the preceding `bitbake-layers add-layer` commands
    made to `bblayers.conf`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The same eight layers from the previous step should be assigned to the `BBLAYERS`
    variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'List the machines supported by the `meta-raspberrypi` BSP layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that there are `raspberrypi4` and `raspberrypi4-64` machine configurations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following line to your `conf/local.conf` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This overrides the following default in your `conf/local.conf` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Setting the `MACHINE` variable to `raspberrypi4-64` ensures that the image we’re
    about to build works for Raspberry Pi 4.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following line to your `conf/local.conf` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This suppresses the following build error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, append `ssh-server-openssh` to the list of `EXTRA_IMAGE_FEATURES` in your
    `conf/local.conf` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This adds an SSH server to our image for local network access.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Lastly, build the image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first build could take anywhere from minutes to hours to complete depending
    on how many CPU cores your host environment has available.
  prefs: []
  type: TYPE_NORMAL
- en: '`TARGET_SYS` should be `aarch64-poky-linux` and `MACHINE` should be `raspberrypi4-64`
    since this image is targeting 64-bit for the Arm Cortex-A72 cores in Raspberry
    Pi 4.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the image has finished building, there should be a file named `rpi-test-image-raspberrypi4-64.rootfs.wic.bz2`
    in the `tmp/deploy/images/raspberrypi4-64` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Notice that `rpi-test-image-raspberrypi4-64.rootfs.wic.bz2` is a symbolic link
    pointing to the actual image file in the same directory. An integer denoting the
    date and time of the build is appended to the image filename before the `wic.bz2`
    extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now write that image to a microSD card using Etcher and boot it on your Raspberry
    Pi 4:'
  prefs: []
  type: TYPE_NORMAL
- en: Insert a microSD card into your host machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Launch Etcher.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Flash from file** from Etcher.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate the `wic.bz2` image that you built for Raspberry Pi 4 and open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Select target** from Etcher.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the microSD card that you inserted in *step 1*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Flash** from Etcher to write the image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Eject the microSD card when Etcher is done flashing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert the microSD card into your Raspberry Pi 4.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply power to Raspberry Pi 4 by way of its USB-C port.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Confirm that your Raspberry Pi 4 booted successfully by plugging it into your
    Ethernet and observing that the network activity lights blink.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling Wi-Fi
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous exercise, we built a bootable image for Raspberry Pi 4 that
    includes working Ethernet, Wi-Fi, and Bluetooth. Now that the device has booted
    and connected to your local network via Ethernet, let’s connect to a nearby Wi-Fi
    network. We will use `connman` for this exercise since that is what the `meta-raspberrypi`
    layer ships with out of the box. Other BSP layers rely on different network interface
    configuration daemons, such as `systemd-networkd` and `NetworkManager`. Follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The image we built has a hostname of `raspberrypi4-64` so you should be able
    to SSH into the device as root:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Enter `yes` when asked if you want to continue connecting. You will not be prompted
    for a password. If no host is found at `raspberrypi4-64.local`, use a tool such
    as `arp-scan` to locate the IP address of your Raspberry Pi 4 and SSH into that
    instead of doing so by hostname.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you are in, verify that the Wi-Fi driver is on board:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start `connman-client`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Turn on Wi-Fi:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Disregard `"``Error wifi: Already enabled"` if the Wi-Fi is already on.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Register `connmanctl` as the connection agent:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Scan for Wi-Fi networks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'List all the available Wi-Fi networks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`RT-AC66U_B1_38_2G` and `RT-AC66U_B1_38_5G` are Wi-Fi network SSIDs for an
    ASUS router. Your list will look different. The `*AO` before `Wired` indicates
    that the device is currently online via Ethernet.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Connect to a Wi-Fi network:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Replace the service identifier after `connect` with your service identifier
    or target network from the previous step. Substitute your Wi-Fi passphrase for
    `somepassword`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'List the services again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This time, `*AR` appears before the SSID you just connected to, indicating that
    this network connection is ready. Ethernet takes precedence over Wi-Fi, so the
    device remains online over `Wired`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Exit `connman-client`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Unplug your Raspberry Pi 4 from the Ethernet, thereby closing your SSH session:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Reconnect to your Raspberry Pi 4:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start `connman-client` again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'List the services again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Observe that the `Wired` connection is now gone and that the Wi-Fi SSID you
    connected to that was previously ready has now been promoted to online.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `connman` daemon saves your Wi-Fi credentials to a network profile directory
    under `/var/lib/connman`, which persists on the microSD card. This means that
    `connman` will automatically reconnect to your Wi-Fi network when your Raspberry
    Pi 4 boots up. There is no need to go through these steps again after power cycling.
    You can leave your Ethernet unplugged if you like.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling Bluetooth
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to the `connman` and `connman-client` packages, the `meta-raspberrypi`
    layer includes `bluez5` for its Bluetooth stack. All of these packages as well
    as the requisite Bluetooth drivers are included in `rpi-test-image`, which we
    built for Raspberry Pi 4\. Let’s get Bluetooth up and running and attempt to pair
    it with another device:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Power up your Raspberry Pi 4 and SSH in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Verify that the Bluetooth drivers are on board:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize the HCI UART driver for Bluetooth connectivity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start `connman-client`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Turn on Bluetooth:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Disregard `"Error bluetooth: Already enabled"` if Bluetooth is already on.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Exit `connman-client`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start the Bluetooth CLI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Request the default agent:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Power on the controller:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Show information about the controller:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start scanning for Bluetooth devices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If your smartphone is nearby and has Bluetooth enabled, it should appear in
    the list as a `[NEW]` device. The `DC:08:0F:03:52:CD` part next to `Frank's` `iPhone`
    is the Bluetooth MAC address of my smartphone.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Stop scanning for Bluetooth devices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you have an iPhone open, go to **Bluetooth** under **Settings** so that you
    can accept the pairing request from your Raspberry Pi 4.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Attempt to pair with your smartphone:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Substitute your smartphone’s Bluetooth MAC address for `DC:08:0F:03:52:CD`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before entering `yes`, accept the pairing request from your smartphone:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Bluetooth pairing request](img/B18466_07_01.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – Bluetooth pairing request
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter `yes` to confirm the passkey:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Connect to your smartphone:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Again, substitute your smartphone’s Bluetooth MAC address for `DC:08:0F:03:52:CD`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When prompted to authorize the service, enter `yes`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Your Raspberry Pi 4 is now paired and connected to your smartphone over Bluetooth.
    It should appear on your smartphone’s list of Bluetooth devices as **BlueZ 5.72**.
    The `bluetoothctl` program has numerous commands and submenus. We’ve only just
    scratched the surface. I recommend entering `help` and perusing the self-documentation
    to get an idea of what you can do from the command line. Like `connman`, the BlueZ
    Bluetooth stack is a D-Bus service, so you can communicate with it programmatically
    over D-Bus from Python or other high-level programming languages using D-Bus bindings.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a custom layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are using Raspberry Pi 4 to prototype a new product, then you can quickly
    generate your own custom images by adding packages to the list that’s been assigned
    to the `IMAGE_INSTALL:append` variable in `conf/local.conf`. While this simple
    technique works, at some point you are going to want to start developing your
    own embedded application.
  prefs: []
  type: TYPE_NORMAL
- en: How do you build this additional software so that you can include it in your
    custom images? The answer is to create a custom layer with a new recipe to build
    your software.
  prefs: []
  type: TYPE_NORMAL
- en: First, navigate one level above the directory where you cloned Yocto.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, set up your BitBake work environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This sets a bunch of environment variables and puts you back in the `build-rpi`
    directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new layer for your application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This layer is named `meta-gattd` for the GATT daemon. Name your layer whatever
    you like, but please adhere to the `meta-` prefix convention.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Navigate up to the new layer directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Examine the layer’s file structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Rename the `recipes-examples` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Rename the `example` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Rename the example recipe file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Display the renamed recipe file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You want to populate this recipe with the metadata that’s needed to build your
    software, including `SRC_URI` and `md5` checksums.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For now, just replace gattd_0.1.bb with the finished recipe I have provided
    for you in `MELD/Chapter07/meta-gattd/recipes-gattd/gattd/gattd_0.1.bb`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Git repository for your new layer and push it to GitHub.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `scarthgap` branch in your Git repository and push it to GitHub.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have a custom layer for our application, let’s add it to your working
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, navigate one level above the directory where you cloned Yocto:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Clone your layer or my `meta-gattd` layer from GitHub:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Replace `fvasquez` with your GitHub username and `meta-gattd` with your layer’s
    repo name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, set up your BitBake work environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This sets a bunch of environment variables and puts you back in the `build-rpi`
    directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, add the newly cloned layer to the image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Replace `meta-gattd` with the name of your layer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Verify that all the necessary layers have been added to the image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There should be a total of nine layers in the list, including your new layer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, add the extra package to your `conf/local.conf` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`CORE_IMAGE_EXTRA_INSTALL` is a convenience variable that’s used to add extra
    packages to an image that inherits from the `core-image` class like `rpi-test-image`
    does. `IMAGE_INSTALL` is the variable that controls what packages are included
    in any image. We cannot use `IMAGE_INSTALL += "gattd"` in `conf/local.conf` because
    it replaces the default lazy assignment that’s done in `core-image.bbclass`. Use
    `IMAGE_INSTALL:append = " gattd"` or `CORE_IMAGE_EXTRA_INSTALL += " gattd"` instead.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Lastly, rebuild the image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If your software successfully builds and installs, it should be included on
    the finished `rpi-test-image-raspberrypi4-64.rootfs.wic.bz2` image. Write that
    image to a microSD card and boot it on your Raspberry Pi 4 to find out. There
    should be a Python script at `/usr/bin/gatt_server.py`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding packages to `conf/local.conf` makes sense during the earliest stages
    of development. When you are ready to share the fruits of your labor with the
    rest of your team, you should create an image recipe and put your packages there.
    At the end of the previous chapter, we went all the way and wrote a `nova-image`
    recipe to add a `helloworld` package to `core-image-minimal`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve spent a good amount of time testing newly built images on actual
    hardware, it’s time to turn our attention back to software. In the next section,
    we’ll look at a tool that was designed to streamline the tedious compile, test,
    and debug cycle we’ve grown accustomed to while developing embedded software.
  prefs: []
  type: TYPE_NORMAL
- en: Capturing changes with devtool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned how to create a recipe for a `helloworld`
    program from scratch. A copy-paste approach to packaging recipes may work initially,
    but it soon becomes very frustrating as your project grows and the number of recipes
    you need to maintain multiplies. I’m here to show you a better way of working
    with package recipes – both yours and those that are contributed to upstream by
    some third party. It is called `devtool` and it is the cornerstone of Yocto’s
    extensible SDK.
  prefs: []
  type: TYPE_NORMAL
- en: Development workflows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before you get started with `devtool`, you want to make sure that you’re doing
    your work in a new layer instead of modifying recipes in-tree. Otherwise, you
    could easily overwrite and lose hours and hours of work:'
  prefs: []
  type: TYPE_NORMAL
- en: First, navigate one level above the directory where you cloned Yocto.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, set up your BitBake work environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This sets a bunch of environment variables and puts you in a new `build-mine`
    directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set `MACHINE` in `conf/local.conf` for 64-bit Arm:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create your new layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add your new layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check that your new layer was created where you want it to be:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output of `bitbake-layers show-layers` should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'To get some first-hand experience with development workflows, you are going
    to need a target to deploy to. That means building an image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Building a full image takes a few hours the first time. When it’s complete,
    go ahead and boot it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: By specifying the `nographic` option, we can run QEMU directly in a separate
    shell. This makes typing easier than having to cope with the emulated graphics
    output. Log in as `root`. There is no password. Leave QEMU running for now because
    we need it for the subsequent exercises. You can SSH into this VM with `ssh root@192.168.7.2`.
  prefs: []
  type: TYPE_NORMAL
- en: '`devtool` supports three common development workflows:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Patch the source built by an existing recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upgrade a recipe to fetch a newer version of the upstream source.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you initiate any of these workflows, `devtool` creates a temporary workspace
    for you to make your changes. This sandbox contains the recipe files and fetched
    source. When you are done with your work, `devtool` integrates your changes back
    into your layer so that the workspace can be destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new recipe
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s say there is some open source software you want that no one has submitted
    a BitBake recipe for yet. And let’s say that the software in question is the `validator`
    file-signing, verification, and installation tool. In this instance, you could
    download a source tarball release of `validator` from GitHub and create a recipe
    for it. That’s exactly what `devtool add` does.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, `devtool add` creates a workspace with its own local Git repository.
    Inside this new workspace directory, it creates a `recipes/validator` directory
    and extracts the tarball contents into a `sources/validator` directory. `devtool`
    knows about popular build systems such as Autotools and CMake and will do its
    best to figure out what kind of project this is (Autotools in the case of `validator`).
    It then uses parsed metadata and built package data cached from previous BitBake
    builds to figure out the values of `DEPENDS` and `RDEPENDS` as well as what files
    to inherit and require:'
  prefs: []
  type: TYPE_NORMAL
- en: First, open another shell and navigate one level above the directory where you
    cloned Yocto.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, set up your BitBake environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This sets a bunch of environment variables and puts you back in your `build-mine`
    working directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, run `devtool add` with the URL of the source tarball release:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`devtool add` will generate a recipe that you can then build.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before you build your new recipe, let’s take a look at it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`devtool` will open `recipes/validator/validator_0.2.2.bb` in an editor. Notice
    that `devtool` has already filled in the MD5 checksums for you.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add this line to the end of `validator_0.2.2.bb`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Correct any obvious mistakes, save any changes, and exit your editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To build your new recipe, use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, deploy the compiled `validator` executable to the target emulator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This installs the necessary build artifacts onto the target emulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From your QEMU shell, run the `validator` executable that you just built and
    deployed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you see a bunch of `validator`-related self-documentation, then the build
    and deployment were successful. If you do not, then use `devtool` to repeat the
    edit, build, and deploy steps until you are convinced that `validator` works.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you are satisfied, clean up your target emulator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Merge all your work back into your layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Delete the leftover sources from the workspace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you think others might benefit from your new recipe, then submit a patch
    to Yocto.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the source built by a recipe
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s say you find a bug in `jq`, a command-line JSON preprocessor. You search
    the Git repository at [https://github.com/stedolan/jq](https://github.com/stedolan/jq)
    and find that no one has reported the issue. Then, you look at the source code.
    It turns out that the fix requires just a few small code changes, so you decide
    to patch `jq` yourself. That’s where `devtool` modify comes in.
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, when `devtool` looks at Yocto’s cached metadata, it sees that a
    recipe already exists for `jq`. Like `devtool add`, `devtool modify` creates a
    new temporary workspace with its own local Git repository where it copies the
    recipe files and extracts the upstream sources. `jq` is written in C and located
    in an existing OpenEmbedded layer named `meta-oe`. We need to add this layer as
    well as `jq`''s dependencies to our working image before we can modify the package
    source:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, delete a couple of layers from your `build-mine` environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, clone the `meta-openembedded` repository from GitHub if it does not exist
    already:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add the `meta-oe` and `meta-mine` layers to your image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Verify that all the necessary layers have been added to the image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output of the command should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following line to `conf/local.conf` because the `onig` package is a
    runtime dependency of `jq`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Rebuild your image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Exit QEMU with *Ctrl + A* and *x* from your other shell and restart the emulator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Like many patching tools, `devtool modify` uses your commit messages to generate
    patch filenames, so keep your commit messages brief and meaningful. It also automatically
    generates the patch files themselves based on your GitHub history and creates
    a `.bbappend` file with the new patch filenames. Remember to prune and squash
    your Git commits so that `devtool` divides your work up into sensible patch files:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run `devtool modify` with the name of the package you wish to modify:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make your code changes using your preferred editor. Use the standard Git add
    and commit workflow to keep track of what you’ve done.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Build the modified sources using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, deploy the compiled `jq` executable to the target emulator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This installs the necessary build artifacts onto the target emulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If connecting fails, then delete the stale emulator’s key as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Replace `frank` with your username in the path.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From your QEMU shell, run the `jq` executable that you just built and deployed.
    If you can no longer reproduce the bug, then your changes worked. Otherwise, repeat
    the edit, build, and deploy steps until you are satisfied.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you are satisfied, clean up your target emulator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Merge all your work back into your layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the merge fails because the Git source tree is dirty, then remove or unstage
    any leftover `jq` build artifacts and try `devtool finish` again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Delete the leftover sources from the workspace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you think others might benefit from your patch or patches, then submit them
    to the upstream project maintainers.
  prefs: []
  type: TYPE_NORMAL
- en: Upgrading a recipe to a newer version
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s say you’re using the mypy Python static typechecker to develop on your
    target device and a new version of mypy has just been released. This latest version
    of mypy has a new feature that you just can’t wait to get your hands on. Instead
    of waiting for the mypy recipe maintainers to upgrade to the new release version,
    you decide to upgrade the recipe yourself. You would think that would be as easy
    as bumping a version number in a recipe file, but there are also source archive
    checksums involved. Wouldn’t it be great if the tedious process could be fully
    automated? Guess what devtool upgrade is for? mypy is a Python 3 module, so your
    image needs to include Python 3, mypy, and mypy’s dependencies before you can
    upgrade it. To obtain all of them, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, delete a couple of layers from your build-mine environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add the meta-python and meta-mine layers to your image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '3\. Verify that all the necessary layers have been added to the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output of the command should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, there should be lots of Python modules available for you to use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: One of those modules is `python3-mypy`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make sure `python3` and `python3-mypy` are being built and installed on your
    image by searching for both of them inside `conf/local.conf`. If they are not
    there, then you can include them both by adding the following line to your `conf/local.conf`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Rebuild your image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Exit QEMU with Ctrl + A and x from your other shell and restart the emulator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**IMPORTANT NOTE**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: At the time of writing, the version of mypy included with meta-python is 1.9.0
    and the latest version of mypy available on PyPI is 1.12.1.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that all the pieces are in place, let’s do the upgrade:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, run devtool upgrade with the name of the package and the target version
    to upgrade to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before you build your upgraded recipe, let’s take a look at it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: devtool will open `recipes/python3-mypy/python3-mypy_1.12.1.bb` in an editor.
    There is nothing version-specific to change in this recipe, so save the new file
    and exit your editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To build your new recipe, use this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, deploy your new mypy module to the target emulator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This installs the necessary build artifacts onto the target emulator.
  prefs: []
  type: TYPE_NORMAL
- en: 'If connecting fails, then delete the stale emulator’s key as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Replace frank with your username in the path.
  prefs: []
  type: TYPE_NORMAL
- en: 'From your QEMU shell, check what version of mypy was deployed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If entering `mypy --version` returns ‘`1.12.1`', then the upgrade worked. If
    it does not, then use devtool to repeat the edit, build, and deploy steps until
    you’ve figured out what went wrong.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you are satisfied, clean up your target emulator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Clean up your workspace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Commit a change to SOURCES.txt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Merge all your work back into your layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: devtool finish moves the sources to a folder called attic.
  prefs: []
  type: TYPE_NORMAL
- en: If the merge fails because the GitHub source tree is dirty, then remove or unstage
    any leftover `python3-mypy` build artifacts and try devtool finish again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Delete the leftover sources from the workspace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you think others might also be anxious to upgrade their distros to the latest
    version of a package, then submit a patch to Yocto.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we’ve arrived at the topic of how to build our own distro. This feature
    is unique to Yocto and notably missing from Buildroot. A **distro layer** is a
    powerful abstraction that can be shared across multiple projects targeting different
    hardware.
  prefs: []
  type: TYPE_NORMAL
- en: Building your own distro
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the start of the previous chapter, I told you about distro layers such as
    `meta-poky` and the distribution metadata contained in their `conf/distro` subdirectories.
    As we have seen, you don’t need your own distro layer to build your own custom
    images. You can go a long way without ever having to modify any of Poky’s distribution
    metadata. But if you want to alter distro policies (e.g., features, C library
    implementations, choice of package manager, and so on), then you can choose to
    build your own distro.
  prefs: []
  type: TYPE_NORMAL
- en: 'Building your own distro is a three-step process:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new distro layer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a distro configuration file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add more recipes to your distro.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: But before we get into the technical details of how to do that, let’s consider
    when it’s the right time to roll your own distro.
  prefs: []
  type: TYPE_NORMAL
- en: When and when not to
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Distro settings define the package format (`rpm`, `deb`, or `ipk`), package
    feed, `init` system (`systemd` or `sysvinit`), and specific package versions.
    You could create your own distro in a new layer by inheriting from Poky and overriding
    what needs to change for your distro. However, if you find yourself adding a lot
    of values to your build directory’s `local.conf` file aside from the obvious local
    settings (such as relative paths), then it is probably time to create your own
    distro from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new distro layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You know how to create a layer. Creating a distro layer is no different.
  prefs: []
  type: TYPE_NORMAL
- en: First, navigate one level above the directory where you cloned Yocto.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, set up your BitBake work environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This sets a bunch of environment variables and puts you back in the `build-rpi`
    directory from earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Delete the `meta-gattd` layer from your `build-rpi` environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Comment out or delete `CORE_IMAGE_EXTRA_INSTALL` from `conf/local.conf`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new layer for our distro:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add our new layer to the `build-rpi` configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The name of our distro is `mackerel`. Creating our own distro layer enables
    us to keep distro policies separate from package recipes (the implementation).
  prefs: []
  type: TYPE_NORMAL
- en: Configuring your distro
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create the distro configuration file in the `conf/distro` directory of your
    `meta-mackerel` distro layer. Give it the same name as your distro (e.g., `mackerel.conf`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the required `DISTRO_NAME` and `DISTRO_VERSSION` variables in `conf/distro/mackerel.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'The following optional variables can also be set in `mackerel.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: Once you are done with those variables, you can define just about any variable
    in `conf/local.conf` that you want for your distro. Look at other distros’ `conf/distro`
    directories, such as Poky’s, to see how they organize things, or copy and use
    `poky/meta/conf/distro/defaultsetup.conf` as a template. If you decide to break
    your distro configuration file up into multiple include files, make sure to place
    them in the `conf/distro/include` directory of your layer.
  prefs: []
  type: TYPE_NORMAL
- en: Adding more recipes to your distro
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Add more distro-related metadata to your distro layer. You will want to add
    recipes for additional configuration files. These are configuration files that
    have yet to be installed by an existing recipe. More importantly, you will also
    want to add append files to customize existing recipes and add their configuration
    files to your distro.
  prefs: []
  type: TYPE_NORMAL
- en: Runtime package management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Including a package manager for your distro images is great for enabling secure
    over-the-air updates and rapid application development. When your team works on
    software that revs multiple times a day, frequent package updates are one way
    to keep everybody in sync and moving forward. Full image updates are unnecessary
    (only one package changes) and disruptive (reboot required). Being able to fetch
    packages from a remote server and install them on a target device is known as
    **runtime package management**.
  prefs: []
  type: TYPE_NORMAL
- en: Yocto has support for different package formats (`rpm`, `ipk`, and `deb`) and
    different package managers (`dnf` and `opkg`). The package format you select for
    your distro determines which package manager you can include on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To select a package format for our distro, you can set the `PACKAGE_CLASSES`
    variable in your distro’s `conf` file. Add this line to `meta-mackerel/conf/distro/mackerel.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s return to the `build-rpi` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'We are targeting Raspberry Pi 4, so make sure `MACHINE` is still set accordingly
    in `conf/local.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'Comment out `PACKAGE_CLASSES` in your build directory’s `conf/local.conf` since
    our distro already selects `package_ipk`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'To enable runtime package management, append `package-management` to the list
    of `EXTRA_IMAGE_FEATURES` in your build directory’s `conf/local.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: This will install a package database containing all the packages from your current
    build onto your distro image. A prepopulated package database is optional because
    you can always initialize a package database on the target after your distro image
    has been deployed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, set the `DISTRO` variable in your build directory’s `conf/local.conf`
    file to the name of our distro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: This points your build directory’s `conf/local.conf` file at our distro configuration
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we are ready to build our distro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'We are rebuilding `rpi-test-image` with a different package format, so this
    will take a little while. The finished images are placed in a different directory
    this time around:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the image to a microSD card using Etcher and boot it on your Raspberry
    Pi 4\. Plug it into your Ethernet and SSH in like you did previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'If connecting fails, then delete Raspberry Pi’s stale key, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: Replace `frank` with your username in the path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have logged in, verify that the `opkg` package manager has been installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: A package manager isn’t of much use without a remote package server to pull
    it from.
  prefs: []
  type: TYPE_NORMAL
- en: Provisioning a remote package server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Setting up an HTTP remote package server and pointing your target clients at
    it is easier than you might think. The client-side server address configuration
    varies between package managers. We will configure `opkg` manually on Raspberry
    Pi 4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with the package server:'
  prefs: []
  type: TYPE_NORMAL
- en: First, navigate one level above the directory where you cloned Yocto.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, set up your BitBake work environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This sets a bunch of environment variables and puts you back in the `build-rpi`
    directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Build the `curl` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Populate the package index:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Locate the package installer files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There should be three directories, named cortexa72, all, and raspberrypi4_64,
    in ipk. The architecture directory is cortexa72 while the machine directory is
    raspberrypi4_64\. The names of these two directories will vary depending on how
    your image has been configured for building.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Navigate to the `ipk` directory, which is where the package installer files
    are:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Get the IP address of your Linux host machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start the HTTP package server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Replace `192.168.1.69` with your Linux host machine’s IP address.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let’s configure the target client:'
  prefs: []
  type: TYPE_NORMAL
- en: 'SSH back into your Raspberry Pi 4:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit `/etc/opkg/opkg.conf` so that it looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Replace `192.168.1.69` with your Linux host machine’s IP address.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run `opkg update`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Try to run `curl`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The command should fail because `curl` is not installed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Install `curl`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Verify that `curl` was installed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you continue to work in the `build-rpi` directory from a Linux host machine,
    you can check for updates from your Raspberry Pi 4:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can apply them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: This is faster than rewriting an image, swapping out the microSD card, and rebooting.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I know that was a lot to absorb. And trust me – this is just the beginning.
    Yocto certainly has a steep learning curve. Luckily, there is lots of documentation
    and a friendly community to guide you. There is also `devtool` to automate much
    of the tedium and mistakes of copy-paste development. If you use the tools provided
    for you and continually save your work to your own layers, Yocto doesn’t have
    to be painful. Before you know it, you’ll be rolling your own distro layer and
    running your own remote package server.
  prefs: []
  type: TYPE_NORMAL
- en: A remote package server is just one way to deploy packages and applications.
    We will learn about a few others later in [*Chapter 15*](Chapter_15.xhtml#_idTextAnchor483).
    Despite the title, some of the techniques we’ll look at in that chapter (e.g.,
    conda) apply to any programming language. While package managers are great for
    development, runtime package management is not commonly used on embedded systems
    running in production. We will look closely at full image and containerized over-the-air
    update mechanisms in [*Chapter 10*](Chapter_10.xhtml#_idTextAnchor341).
  prefs: []
  type: TYPE_NORMAL
- en: Further study
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Transitioning to a custom environment for systems development*, Yocto Project
    – [https://docs.yoctoproject.org/transitioning-to-a-custom-environment.html](https://docs.yoctoproject.org/transitioning-to-a-custom-environment.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Yocto Project Development Tasks Manual*, Yocto Project – [https://docs.yoctoproject.org/dev-manual/](https://docs.yoctoproject.org/dev-manual/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using Devtool to Streamline Your Yocto Project Workflow*, by Tim Orling –
    [https://www.youtube.com/watch?v=CiD7rB35CRE](https://www.youtube.com/watch?v=CiD7rB35CRE)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
