<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer018">
			<h1 id="_idParaDest-13"><em class="italic"><a id="_idTextAnchor012"/>Chapter 1</em>: Basics of Shell and Text Terminal</h1>
			<p>An ancient Chinese proverb states that <em class="italic">A journey of a thousand miles begins with a single step</em>. This chapter is going to be that single, first step on our journey to mastering the Linux <strong class="bold">command-line interface</strong> (<strong class="bold">CLI</strong>) and <strong class="bold">shell scripting</strong>. Specifically, we're going to learn how to use Terminal, the shell, some basic commands, and one very handy utility to work on many things at once, called <strong class="bold">screen</strong>. </p>
			<p>As you progress further through the book, you'll notice that we will be using these concepts a lot, as they're the basis for what we're going to do in the later chapters. When dealing with systems administration, we can usually do a lot more in some kind of CLI than in any kind of <strong class="bold">graphical user interface</strong> (<strong class="bold">GUI</strong>). This stems from the idea of the programmability of a <em class="italic">CLI</em> versus the <em class="italic">static</em> nature of most GUIs in IT. Furthermore, a utility such as screen will make our life in the CLI a lot easier, as we're going to be able to deal with multiple virtual screens at the same time, thus enhancing our productivity.</p>
			<p>So, in short, we're going to deal with the following recipes:</p>
			<ul>
				<li>Accessing the shell</li>
				<li>Setting up the user shell</li>
				<li>Setting up the Bash shell</li>
				<li>Using the most common shell commands</li>
				<li>Using <strong class="source-inline">screen</strong></li>
			</ul>
			<h1 id="_idParaDest-14"><a id="_idTextAnchor013"/>Technical requirements </h1>
			<p>For these recipes, we're going to use two Linux machines – in our case, it's going to be two VMware virtual machines with <em class="italic">Ubuntu</em> (<em class="italic">20.04 Focal Fossa</em>). Let's call them <strong class="source-inline">cli1</strong> and <strong class="source-inline">gui1</strong>, and as the book progresses, we're going to add some more, as our topics grow in complexity. So, all in all, we need the following:</p>
			<ul>
				<li>VMware Player, Workstation, Fusion, or ESXi</li>
				<li>Ubuntu 20.04 Focal Fossa installation ISO file</li>
				<li>A bit of time to install these two virtual machines without the GUI (the <strong class="source-inline">cli1</strong> machine) and with the GUI (<strong class="source-inline">gui1</strong>)</li>
			</ul>
			<p>After the installation process is finished, we're going to start with shell basics – our very next topic.</p>
			<h1 id="_idParaDest-15"><a id="_idTextAnchor014"/>Accessing the shell</h1>
			<p>First, let's briefly discuss various <strong class="bold">shell</strong> access methods. It can be as simple as just installing a virtual machine <a id="_idIndexMarker000"/>with Linux that's running text mode only, but it could also be a virtual machine with the GUI. That would require us doing something to have access to text mode; so, let's learn about these different ways of getting access to the shell.</p>
			<p>It's also important to understand <em class="italic">why</em> accessing the shell is so important. The reasoning behind this is simple, which is that we can do a lot more in the shell than in the GUI. In the second part of this book, we're going to dig deeper into the concept of shell scripting, and then it's going to become obvious how that applies to our statement about being able to do a lot more in the shell.</p>
			<h2 id="_idParaDest-16"><a id="_idTextAnchor015"/>Getting ready</h2>
			<p>For starters, we need to deploy our two virtual machines. We can actually install both of these machines as text-mode machines with the OpenSSH server (the installation process asks about OpenSSH at one point). Then, we could add the GUI to the <strong class="source-inline">gui1</strong> machine so that we can work with that, too. We do that by typing a couple of commands into the <strong class="source-inline">gui1</strong> machine after logging in as <strong class="source-inline">student</strong> (which is the username we came up with for this example):</p>
			<p class="source-code">sudo apt-get -y install tasksel</p>
			<p class="source-code">tasksel</p>
			<p><strong class="source-inline">sudo</strong> is going to ask us for the <strong class="source-inline">student</strong> user password (it can be any user that you created during the installation process; <strong class="source-inline">student</strong> is just something that we used in our example). When the <strong class="bold">tasksel TUI</strong> interface starts, we will select the <strong class="bold">Ubuntu desktop</strong> package set, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer005" class="IMG---Figure">
					<img src="Images/Figure_1.1_B16269.jpg" alt="Figure 1.1 – Ubuntu desktop package&#13;&#10;" width="1254" height="925"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.1 – Ubuntu desktop package</p>
			<p>As you can see<a id="_idIndexMarker001"/> from <em class="italic">Figure 1.1</em>, you need to select <strong class="bold">Ubuntu desktop</strong> by using the arrow keys and spacebar to select from the menu, then use <em class="italic">Tab</em> or the arrow keys to select <strong class="bold">Ok</strong> and press <em class="italic">Enter</em>.</p>
			<p>Let's now discuss how to access the shell.</p>
			<h2 id="_idParaDest-17"><a id="_idTextAnchor016"/>How to do it…</h2>
			<p>If we deployed our Ubuntu machine with default options, we're going to be faced with text mode by default. To access the shell and have the capability to do something with our Linux virtual machine, we need to type in our <em class="italic">username</em> and <em class="italic">password</em>. It needs to be the username or password that we typed in during the installation process. In our virtual machine, the user named <strong class="source-inline">student</strong> was created, with the preassigned <strong class="source-inline">student</strong> password. When we successfully log in, we're faced with the regular text mode and associated shell, as in the<a id="_idIndexMarker002"/> following screenshot:</p>
			<div>
				<div id="_idContainer006" class="IMG---Figure">
					<img src="Images/Figure_1.2_B16269.jpg" alt="Figure 1.2 – Accessing the CLI from text mode after logging in&#13;&#10;" width="1647" height="924"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.2 – Accessing the CLI from text mode after logging in</p>
			<p>If, however, we did a GUI installation, there are three different ways of accessing the shell:</p>
			<ol>
				<li>We could start a <a id="_idIndexMarker003"/>text Terminal in <strong class="bold">GNOME</strong> (<strong class="bold">GNOME Terminal</strong>) and use <a id="_idIndexMarker004"/>the shell from there. On the plus side, it gives us a GUI-like look and feel that might be a bit more user-friendly to a lot of people. On the downside, we're rarely going to find a GUI on Linux servers in production environments, so it might be a case of <em class="italic">learning bad habits</em>. To start GNOME Terminal, we can either use the built-in GNOME search function (by pressing the <em class="italic">WIN</em> key) or just right-click on the desktop and open <strong class="bold">Terminal</strong>. The result will look like this:</li>
			</ol>
			<div>
				<div id="_idContainer007" class="IMG---Figure">
					<img src="Images/Figure_1.3_B16269.jpg" alt="Figure 1.3 – Finding Terminal in the GNOME GUI by using &#13;&#10;the WIN key to search for the Terminal keyword&#13;&#10;" width="1510" height="937"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.3 – Finding Terminal in the GNOME GUI by using the WIN key to search for the Terminal keyword</p>
			<ol>
				<li value="2">We could just switch to a text-based text console, as Linux doesn't stop us from using text consoles when we deploy the GUI. For that, we need to press a dedicated key combination that is going to get us to one of those text consoles. For example, we can press the <em class="italic">Ctrl</em> + <em class="italic">Alt</em> + <em class="italic">F3</em> key combination. That is going to take us to text mode, specifically, to the text console number.</li>
			</ol>
			<p>There, we can log in and<a id="_idIndexMarker005"/> start typing our commands. The result will look like this:</p>
			<div>
				<div id="_idContainer008" class="IMG---Figure">
					<img src="Images/Figure_1.4_B16269.jpg" alt="Figure 1.4 – Switching to the text Terminal from the GUI&#13;&#10;" width="994" height="619"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.4 – Switching to the text Terminal from the GUI</p>
			<p>We're in the shell again. We can now start using any commands we want to.</p>
			<ol>
				<li value="3">We could use the <strong class="source-inline">systemctl</strong> command to<a id="_idIndexMarker006"/> switch to text mode as a default mode for the current session (until the next reboot). We could even use it to make the text mode permanent, regardless of the fact that we have full GUI installation. To achieve that, in our GUI, we need to log in and then type the following sequence of commands into GNOME Terminal:</li>
			</ol>
			<p class="source-code">systemctl set-default multi-user.target</p>
			<p class="source-code">systemctl isolate multi-user.target</p>
			<p>We can use the first command if we want to set our Linux virtual machine to boot to text mode <em class="italic">by default</em>. We can use the second command to re-configure our Linux machine to switch to text mode <em class="italic">immediately</em>.  </p>
			<h2 id="_idParaDest-18"><a id="_idTextAnchor017"/>How it works…</h2>
			<p>There are a couple of sets of <a id="_idIndexMarker007"/>commands that we used in the previous recipe, so let's explain what these commands do so that we can have a clear picture of what we were doing.</p>
			<p>The first set of commands is as follows:</p>
			<p class="source-code">sudo -i</p>
			<p class="source-code">apt-get -y install tasksel</p>
			<p class="source-code">tasksel</p>
			<p>These three commands are going to do the following:</p>
			<ul>
				<li><strong class="source-inline">sudo -i</strong> is going to ask us for the current user's password. If that user has been added to the <strong class="source-inline">sudoers</strong> system (<strong class="source-inline">/etc/sudoers</strong>), that means that we can use the current user's password to log in as root and use administrative privileges.</li>
				<li><strong class="source-inline">apt-get -y install tasksel</strong> will install the <strong class="source-inline">tasksel</strong> application. The main purpose of this application is to simplify package deployment. Specifically, we are going to use it in the next step to deploy an <em class="italic">Ubuntu desktop</em> set of packages (multiple hundreds of packages). Imagine typing all the <strong class="source-inline">apt-get</strong> commands for that deployment procedure manually!</li>
				<li>The <strong class="source-inline">tasksel</strong> command<a id="_idIndexMarker008"/> is going to start the tasksel application, which will be used to deploy the necessary packages.</li>
			</ul>
			<p>The second set of <a id="_idIndexMarker009"/>commands do the following things:</p>
			<ul>
				<li><strong class="source-inline">systemctl set-default multi-user.target</strong> will set text mode as the default boot target. The translation of this is that our Linux machine will boot in text mode by default only when it becomes valid after the next reboot.</li>
				<li><strong class="source-inline">systemctl isolate multi-user.target</strong> will switch us to text mode immediately. It's completely different from the <strong class="source-inline">set-default</strong> procedure, as it has nothing to do with the state of our Linux machine post-reboot.</li>
			</ul>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor018"/>See also</h2>
			<p>If you <a id="_idIndexMarker010"/>need more information about <strong class="source-inline">apt-get</strong>, <strong class="source-inline">tasksel</strong>, or <strong class="source-inline">systemctl</strong>, we <a id="_idIndexMarker011"/>suggest<a id="_idIndexMarker012"/> that you visit these links:</p>
			<ul>
				<li><strong class="source-inline">apt-get</strong>: <a href="https://help.ubuntu.com/community/AptGet/Howto">https://help.ubuntu.com/community/AptGet/Howto</a></li>
				<li><strong class="source-inline">tasksel</strong>: <a href="https://help.ubuntu.com/community/Tasksel">https://help.ubuntu.com/community/Tasksel</a></li>
				<li><strong class="source-inline">systemctl</strong>: <a href="https://www.liquidweb.com/kb/what-is-systemctl-an-in-depth-overview/">https://www.liquidweb.com/kb/what-is-systemctl-an-in-depth-overview/</a></li>
			</ul>
			<h1 id="_idParaDest-20"><a id="_idTextAnchor019"/>Setting up the user shell</h1>
			<p>Now that we have learned about <a id="_idIndexMarker013"/>how to access the shell, let's configure it for our comfortable use. We're going to see a couple of examples so that we can understand how customizable the Linux shell is. Specifically, we're going to customize the look and feel of our prompt.</p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor020"/>Getting ready</h2>
			<p>We just need to keep our virtual machines up and running.</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>How to do it…</h2>
			<p>We're going to edit a file called <strong class="source-inline">/home/student/.bashrc</strong>. Before we do that, let's create a backup copy of the <strong class="source-inline">.bashrc</strong> file, just in case we make some mistakes:</p>
			<p class="source-code">cp /home/student/.bashrc /home/student/.bashrc.tmp</p>
			<p>Before we edit this file, make sure that you take note of how the prompt looks at this point. If you're logged in as <strong class="source-inline">student</strong> to the <strong class="source-inline">cli1</strong> machine, your prompt should look like this:</p>
			<p class="source-code">student@cli1:~$</p>
			<p>Let's edit the <strong class="source-inline">.bashrc</strong> file by using <strong class="source-inline">nano</strong>. Type in the following command:</p>
			<p class="source-code">nano /home/student/.bashrc</p>
			<p>When we type in this <a id="_idIndexMarker014"/>command, we're going to open <strong class="source-inline">.bashrc</strong> in the nano editor. Let's scroll all the way to the end of this file, which should look like this:</p>
			<div>
				<div id="_idContainer009" class="IMG---Figure">
					<img src="Images/Figure_1.5_B16269.jpg" alt="Figure 1.5 – .bashrc default content &#13;&#10;" width="1064" height="724"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.5 – .bashrc default content </p>
			<p>Let's go all the way below the last <strong class="source-inline">fi</strong> and add the following statement:</p>
			<p class="source-code">PS1="MyCustomPrompt&gt; "</p>
			<p>Next, use <em class="italic">Ctrl</em> + <em class="italic">X</em> to save the file. Then, when we're back in the shell, let's type in the following command:</p>
			<p class="source-code">source .bashrc</p>
			<p>If we did everything <a id="_idIndexMarker015"/>correctly, our prompt should look like this now:</p>
			<p class="source-code">MyCustomPrompt&gt; </p>
			<p>This can be further customized by using PS1 parameters. Let's locate the following:</p>
			<p class="source-code">PS1="MyCustomPrompt&gt; "</p>
			<p>We'll change it to the following:</p>
			<p class="source-code">PS1="\u@\H&gt; \A "</p>
			<p>The <strong class="source-inline">\u@\H</strong> part represents the <strong class="source-inline">username@host</strong> part of the prompt. The <strong class="source-inline">\A</strong> part is for 24-hour time. So, when we do the following:</p>
			<p class="source-code">source .bashrc</p>
			<p>Again, we should get the following state of our prompt:</p>
			<p class="source-code">[student@cli1&gt; 19:30]</p>
			<p><strong class="source-inline">19:30</strong> represents time. We could also customize things such as the type of font (underlined, normal, dim, bold) and color (black, red, green, and so on). Let's do that now. For example, let's edit <strong class="source-inline">.bashrc</strong> again and set <strong class="source-inline">PS1</strong> like this:</p>
			<p class="source-code">PS1="\e[0;31m[\u@\H \A] \e[0m"</p>
			<p>Our prompt should now look like this:</p>
			<p class="source-code">[student@cli1 19:39]</p>
			<p>In this particular example, <strong class="source-inline">\e[</strong> tells the <strong class="source-inline">PS1</strong> variable that we want to change the color of our prompt. <strong class="source-inline">0;31m</strong> means red (<strong class="source-inline">30</strong> is black, <strong class="source-inline">34</strong> is blue, and so on). The <strong class="source-inline">[]</strong> enclosed part is our regular prompt, as previously discussed. The last bit, <strong class="source-inline">\e[0m</strong>, tells the <strong class="source-inline">PS1</strong> variable that we're done with color modification for our <strong class="source-inline">PS1</strong> output. </p>
			<p>As we can see, touching <a id="_idIndexMarker016"/>just one shell variable (<strong class="source-inline">PS1</strong>) can drastically change the way we consume text mode in our Linux virtual machine.</p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>How it works…</h2>
			<p>As a shell variable, <strong class="source-inline">PS1</strong> can be used to customize the look and feel of our shell. Think of it in the way that most users customize their GUI using different wallpapers, text sizes, colors, and so on, and it's a natural thing that we do because we like what we like. <strong class="source-inline">PS1</strong> is often called a <strong class="bold">primary prompt display variable</strong>, as described<a id="_idIndexMarker017"/> in the previous section. </p>
			<p>The <strong class="source-inline">source</strong> command that we used <em class="italic">executes</em> <strong class="source-inline">.bashrc</strong>, in the sense that it will apply the settings from <strong class="source-inline">.bashrc</strong>. That's why we didn't need to log off and log in again, as it would be a waste of time, and the <strong class="source-inline">source</strong> command can help us with that.</p>
			<p>Let's now add some more settings to our <strong class="source-inline">.bashrc</strong> file, as there are many more things that we can customize.</p>
			<h1 id="_idParaDest-24"><a id="_idTextAnchor023"/>Setting up the Bash shell </h1>
			<p>We played with the <strong class="source-inline">PS1</strong> variable and configured it so that it's more to our liking. Let's now use more <strong class="source-inline">.bashrc</strong> settings to configure our Bash shell even further.</p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor024"/>Getting ready</h2>
			<p>We need to leave our virtual<a id="_idIndexMarker018"/> machines running. If they are not powered on, we need to power them back on. </p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor025"/>How to do it…</h2>
			<p>Let's discuss how to change the following shell parameters:</p>
			<ol>
				<li value="1">Add some custom aliases.</li>
			</ol>
			<p>If we open the <strong class="source-inline">.bashrc</strong> file again, we can do some additional magic with it. First, let's add a couple of aliases. Close to the end of the <strong class="source-inline">.bashrc</strong> file, there's a section with a couple of aliases (<strong class="source-inline">ll</strong>, <strong class="source-inline">la</strong>, and <strong class="source-inline">l</strong>). Let's add the following lines to that part of the <strong class="source-inline">.bashrc</strong> file:</p>
			<p class="source-code">alias proc="ps auwwx"</p>
			<p class="source-code">alias pfilter="ps auwwx | grep "</p>
			<p class="source-code">alias start="systemctl start "</p>
			<p class="source-code">alias stop="systemctl stop "</p>
			<p class="source-code">alias ena="systemctl enable "</p>
			<p>This code will introduce five new aliases:</p>
			<ul>
				<li>To see a list of processes</li>
				<li>To filter processes according to the keyword to be typed in after <strong class="source-inline">pfilter</strong></li>
				<li>To start the service; service name to be typed after <strong class="source-inline">start</strong></li>
				<li>To stop the service; service name to be typed after <strong class="source-inline">stop</strong></li>
				<li>To enable the service; service name to be typed after <strong class="source-inline">ena</strong></li>
			</ul>
			<p>As we can see, using aliases can make our typing shorter and the administration process simpler.</p>
			<ol>
				<li value="2">Adjust the size of the Bash history.</li>
			</ol>
			<p>At the top of the <strong class="source-inline">.bashrc</strong> file, there's a section similar to this:</p>
			<p class="source-code">HISTSIZE = 1000</p>
			<p class="source-code">HISTFILESIZE = 1000</p>
			<p>If we want the Bash shell to remember more than the last 1,000 typed commands in the current session (<strong class="source-inline">HISTSIZE</strong>), and to save more than 1,000 commands in the history file (called <strong class="source-inline">.bash_history</strong>), we can change the values of these variables, let's say to <strong class="source-inline">2000</strong> and <strong class="source-inline">2000</strong>.</p>
			<ol>
				<li value="3">Adjust the <strong class="source-inline">PATH</strong> variable.</li>
			</ol>
			<p>Let's say that we <a id="_idIndexMarker019"/>want to add a custom path to our existing <strong class="source-inline">PATH</strong> variable. For example, we installed our custom application in the <strong class="source-inline">/opt/bin</strong> directory, and we don't want to call that application by using the full path every single time. </p>
			<p>We need to edit the <strong class="source-inline">.profile</strong> file for this, as the <strong class="source-inline">PATH</strong> variable for our current user is set there. So, open the <strong class="source-inline">.profile</strong> file in the editor and add the following line to the end of this file:</p>
			<p class="source-code">PATH=$PATH:/opt/bin</p>
			<ol>
				<li value="4">Set our default editor.</li>
			</ol>
			<p>Let's add the following two lines to the <strong class="source-inline">.bashrc</strong> file, at the end of the file:</p>
			<p class="source-code">export VISUAL=nano</p>
			<p class="source-code">export EDITOR=nano</p>
			<p>This would set nano as our preferred default editor.</p>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor026"/>How it works…</h2>
			<p>The Bash shell has a set of reserved variables that we can use solely for Bash purposes. Some of these reserved variables include the following:</p>
			<ul>
				<li><strong class="source-inline">PS1</strong>, <strong class="source-inline">PS2</strong>, <strong class="source-inline">PS3</strong>, and <strong class="source-inline">PS4</strong></li>
				<li><strong class="source-inline">HISTFILESIZE</strong> and <strong class="source-inline">HISTSIZE</strong></li>
				<li><strong class="source-inline">VISUAL</strong> and <strong class="source-inline">EDITOR</strong></li>
				<li><strong class="source-inline">OLDPWD</strong></li>
				<li><strong class="source-inline">PWD</strong></li>
			</ul>
			<p>These are reserved for<a id="_idIndexMarker020"/> specific Bash functions, so we shouldn't create custom variables with these names. You can learn more about these reserved variables from the link provided in the <em class="italic">There's more…</em> section.</p>
			<p>As far as PS variables are concerned, we can consider them to be our entry into customization of the Bash shell. That especially goes for the PS1 variable, as it's the variable that's most commonly used. We can use all of these variables to set Bash to suit our own needs as we don't have to use predefined global configuration only. As time goes by, more and more Linux system administrators create their own, customized configurations for Bash as it increases the convenience of using the Bash shell and their own productivity.</p>
			<h2 id="_idParaDest-28"><a id="_idTextAnchor027"/>There's more…</h2>
			<p>If we need to learn more about Bash reserved variables and PS variables, we can check the following links:</p>
			<ul>
				<li><strong class="source-inline">https://tldp.org/LDP/Bash-Beginners-Guide/html/sect_03_02.html</strong></li>
				<li><strong class="source-inline">https://access.redhat.com/solutions/505983</strong></li>
			</ul>
			<h1 id="_idParaDest-29"><a id="_idTextAnchor028"/>Using the most common shell commands</h1>
			<p>Let's now switch our attention to <a id="_idIndexMarker021"/>learning a basic set of <strong class="bold">Linux shell commands</strong>. We're going to discuss commands to manipulate files and folders, processes, archives, and links. We'll do that via a scenario that is going to involve many steps.</p>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor029"/>Getting ready</h2>
			<p>We still need the same virtual machines as with our previous recipes. </p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor030"/>How to do it…</h2>
			<p>In order for us to be able to use shell commands, we have to start the shell. If we're using the CLI, we just need to log in and we're going to enter the shell session. If we're using a GUI approach, we have to find a GUI Terminal in our application menu. After that, we can start typing commands:</p>
			<ol>
				<li value="1">For starters, let's use a basic set of commands to work with files and directories. </li>
			</ol>
			<p>Let's list the content of the current directory:</p>
			<p class="source-code"><strong class="bold">ls -al</strong></p>
			<p>The output will look similar to this:</p>
			<div>
				<div id="_idContainer010" class="IMG---Figure">
					<img src="Images/Figure_1.6_B16269.jpg" alt="Figure 1.6 – Standard output for the ls -al command with all the pertinent information&#13;&#10;" width="1051" height="614"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.6 – Standard output for the ls -al command with all the pertinent information</p>
			<ol>
				<li value="2">Now, let's create a directory called <strong class="source-inline">directory1</strong> and a stack of five files called <strong class="source-inline">test1</strong> to <strong class="source-inline">test5</strong>. That's what the <strong class="source-inline">touch</strong> command does – it creates empty files. Then, let's copy these files to that directory:<p class="source-code"><strong class="bold">mkdir directory1</strong></p><p class="source-code"><strong class="bold">touch test1</strong></p><p class="source-code"><strong class="bold">touch test2</strong></p><p class="source-code"><strong class="bold">touch test3</strong></p><p class="source-code"><strong class="bold">touch test4</strong></p><p class="source-code"><strong class="bold">touch test5</strong></p><p class="source-code"><strong class="bold">cp test* directory1</strong></p></li>
				<li>After that, let's create a<a id="_idIndexMarker022"/> directory called <strong class="source-inline">directory2</strong> and move files 1-5 to <strong class="source-inline">directory2</strong>:<p class="source-code"><strong class="bold">mkdir directory2</strong></p><p class="source-code"><strong class="bold">mv test* directory2</strong></p></li>
				<li>Let's check the amount of used disk space in <strong class="source-inline">directory1</strong> and <strong class="source-inline">directory2</strong>:<p class="source-code"><strong class="bold">[student@cli1 21:47] du directory1</strong></p><p class="source-code"><strong class="bold">4       directory1</strong></p><p class="source-code"><strong class="bold">[student@cli1 21:47] du -hs directory2</strong></p><p class="source-code"><strong class="bold">4.0K    directory2</strong></p><p class="source-code"><strong class="bold">[student@cli1 21:48]</strong></p></li>
				<li>Let's check the capacity of our current disk (the <strong class="source-inline">-h</strong> switch provides us with a nice, human-readable output):<p class="source-code"><strong class="bold">df -h .</strong></p><p class="source-code"><strong class="bold">Filesystem                         Size  Used Avail Use% Mounted on</strong></p><p class="source-code"><strong class="bold">/dev/mapper/ubuntu--vg-ubuntu--lv   19G  4.5G   14G  26% /</strong></p></li>
			</ol>
			<p>The next stack of <a id="_idIndexMarker023"/>commands is related to<a id="_idIndexMarker024"/> links known as <strong class="bold">hard links</strong> and <strong class="bold">soft links</strong>. </p>
			<ol>
				<li value="6">For creating <a id="_idIndexMarker025"/>hard and<a id="_idIndexMarker026"/> soft links, let's log in to our <strong class="source-inline">cli1</strong> virtual machine and log in as <strong class="source-inline">root</strong>. The overall concept of hard and soft links will be explained a bit later in this chapter. So, create a temporary directory and use some files. We'll just use an existing file as it's<a id="_idIndexMarker027"/> more than enough for this scenario (the <strong class="source-inline">.bashrc</strong> file):<p class="source-code"><strong class="bold">mkdir links</strong></p><p class="source-code"><strong class="bold">cd links</strong></p><p class="source-code"><strong class="bold">cp /root/.bashrc content.cfg</strong></p><p class="source-code"><strong class="bold">ln content.cfg hardlink.cfg</strong></p><p class="source-code"><strong class="bold">ln -s content.cfg softlink.cfg</strong></p><p class="source-code"><strong class="bold">ls -al</strong></p><p class="source-code"><strong class="bold">cd /root</strong></p><p class="source-code"><strong class="bold">ln -s links links2</strong></p><p class="source-code"><strong class="bold">ln links links3</strong></p><p class="source-code"><strong class="bold">ln: links: hard link not allowed for directory</strong></p><p class="source-code"><strong class="bold">cp .bashrc /tmp</strong></p><p class="source-code"><strong class="bold">cd /tmp</strong></p><p class="source-code"><strong class="bold">ln .bashrc /root/notworking</strong></p><p class="source-code"><strong class="bold">ln: failed to create hard link '/root/notworking' =&gt; '.bashrc': invalid cross-device link</strong></p><p class="source-code"><strong class="bold">ln -s .bashrc /root/working.cfg</strong></p><p class="source-code"><strong class="bold">ls /root/working.cfg</strong></p><p class="source-code"><strong class="bold">/root/working.cfg</strong></p></li>
				<li>Let's now check the <a id="_idIndexMarker028"/>beginning and end of one of these files. For example, let's use <strong class="source-inline">/tmp/.bashrc</strong>:<p class="source-code"><strong class="bold">head /tmp/.bashrc</strong></p><p class="source-code"><strong class="bold">[student@cli1 22:28] head /tmp/.bashrc</strong></p><p class="source-code"><strong class="bold"># ~/.bashrc: executed by bash(1) for non-login shells.</strong></p><p class="source-code"><strong class="bold"># see /usr/share/doc/bash/examples/startup-files (in the package bash-doc)</strong></p><p class="source-code"><strong class="bold"># for examples</strong></p><p class="source-code"><strong class="bold"># If not running interactively, don't do anything</strong></p><p class="source-code"><strong class="bold">case $- in</strong></p><p class="source-code"><strong class="bold">    *i*) ;;</strong></p><p class="source-code"><strong class="bold">      *) return;;</strong></p><p class="source-code"><strong class="bold">esac</strong></p></li>
			</ol>
			<p>Let's now check the tail end of the same file:</p>
			<p class="source-code"><strong class="bold">[student@cli1 22:29] tail /tmp/.bashrc</strong></p>
			<p class="source-code"><strong class="bold">  if [ -f /usr/share/bash-completion/bash_completion ]; then</strong></p>
			<p class="source-code"><strong class="bold">    . /usr/share/bash-completion/bash_completion</strong></p>
			<p class="source-code"><strong class="bold">  elif [ -f /etc/bash_completion ]; then</strong></p>
			<p class="source-code"><strong class="bold">    . /etc/bash_completion</strong></p>
			<p class="source-code"><strong class="bold">  fi</strong></p>
			<p class="source-code"><strong class="bold">fi</strong></p>
			<p class="source-code"><strong class="bold">PS1="\e[0;31m[\u@\H \A] \e[0m"</strong></p>
			<p class="source-code"><strong class="bold">export VISUAL=nano</strong></p>
			<p class="source-code"><strong class="bold">export EDITOR=nano</strong></p>
			<ol>
				<li value="8">The next step is going to involve checking running processes and the system state. </li>
			</ol>
			<p>Let's now use commands to check the load our system currently has, find some processes, and kill some of them for fun.</p>
			<p>First, let's check the <a id="_idIndexMarker029"/>load (uptime command) and find the top 20 most time-consuming processes (the <strong class="source-inline">ps</strong> command):</p>
			<p class="source-code"><strong class="bold">uptime</strong></p>
			<p class="source-code"><strong class="bold">22:35:48 up  3:16,  2 users,  load average: 0.00, 0.00, 0.00</strong></p>
			<p class="source-code"><strong class="bold">ps  auwwx | head -20</strong></p>
			<p class="source-code"><strong class="bold">[student@cli1 22:35] ps auwwx | head -20</strong></p>
			<p class="source-code"><strong class="bold">USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</strong></p>
			<p class="source-code"><strong class="bold">root           1  0.0  0.5 103252 11844 ?        Ss   19:18   0:02 /sbin/init</strong></p>
			<p class="source-code"><strong class="bold">root           2  0.0  0.0      0     0 ?        S    19:18   0:00 [kthreadd]</strong></p>
			<p class="source-code"><strong class="bold">root           3  0.0  0.0      0     0 ?        I&lt;   19:18   0:00 [rcu_gp]</strong></p>
			<p class="source-code"><strong class="bold">root           4  0.0  0.0      0     0 ?        I&lt;   19:18   0:00 [rcu_par_gp]</strong></p>
			<p class="source-code"><strong class="bold">root           6  0.0  0.0      0     0 ?        I&lt;   19:18   0:00 [kworker/0:0H-kblockd]</strong></p>
			<p class="source-code"><strong class="bold">root           9  0.0  0.0      0     0 ?        I&lt;   19:18   0:00 [mm_percpu_wq]</strong></p>
			<p class="source-code"><strong class="bold">root          10  0.0  0.0      0     0 ?        S    19:18   0:00 [ksoftirqd/0]</strong></p>
			<p class="source-code"><strong class="bold">root          11  0.0  0.0      0     0 ?        I    19:18   0:04 [rcu_sched]</strong></p>
			<p class="source-code"><strong class="bold">root          12  0.0  0.0      0     0 ?        S    19:18   0:00 [migration/0]</strong></p>
			<p>Next, let's<a id="_idIndexMarker030"/> find a specific process by name and kill it:</p>
			<p class="source-code"><strong class="bold">student@gui1:~$ ps auwwx | grep -i firefox</strong></p>
			<p class="source-code"><strong class="bold">student    47198 22.1 21.3 2825436 426736 ?      Rl   22:38   0:12 /usr/lib/firefox/firefox -new-window</strong></p>
			<p class="source-code"><strong class="bold">student    47253  1.5  6.8 2427560 137988 ?      Sl   22:38   0:00 /usr/lib/firefox/firefox -contentproc -childID 1 -isForBrowser -prefsLen 1 -prefMapSize 223938 -parentBuildID 20210222142601 -appdir /usr/lib/firefox/browser 47198 true tab</strong></p>
			<p class="source-code"><strong class="bold">student    47266  1.0  5.5 2402216 110116 ?      Sl   22:38   0:00 /usr/lib/firefox/firefox -contentproc -childID 2 -isForBrowser -prefsLen 85 -prefMapSize 223938 -parentBuildID 20210222142601 -appdir /usr/lib/firefox/browser 47198 true tab</strong></p>
			<p class="source-code"><strong class="bold">student    47304  1.3  6.6 2468136 133340 ?      Sl   22:38   0:00 /usr/lib/firefox/firefox -contentproc -childID 3 -isForBrowser -prefsLen 1246 -prefMapSize 223938 -parentBuildID 20210222142601 -appdir /usr/lib/firefox/browser 47198 true tab</strong></p>
			<p class="source-code"><strong class="bold">student    47363  0.6  4.1 2386184 83588 ?       Sl   22:38   0:00 /usr/lib/firefox/firefox -contentproc -childID 4 -isForBrowser -prefsLen 10270 -prefMapSize 223938 -parentBuildID 20210222142601 -appdir /usr/lib/firefox/browser 47198 true tab</strong></p>
			<p class="source-code"><strong class="bold">student    48047  0.0  0.0   5168   880 pts/1    S+   22:39   0:00 grep --color=auto -i firefox</strong></p>
			<p class="source-code"><strong class="bold">student@gui1:~$ killall firefox</strong></p>
			<p class="source-code"><strong class="bold">student@gui1:~$ ps auwwx | grep -i firefox</strong></p>
			<p class="source-code"><strong class="bold">student    48323  0.0  0.0   5168   884 pts/1    S+   22:40   0:00 grep --color=auto -i firefox</strong></p>
			<p>We're done with this part of the recipe. Let's now discuss the next part of this recipe, which is about administering users and groups.</p>
			<ol>
				<li value="9">Using shell <a id="_idIndexMarker031"/>commands for user and group administration, let's first go through the list of commands that we're going to use in this recipe:<ul><li><strong class="source-inline">useradd</strong>: Command<a id="_idIndexMarker032"/> that's used to <em class="italic">create</em> a local user account</li><li><strong class="source-inline">usermod</strong>: Command <a id="_idIndexMarker033"/>that's used to <em class="italic">modify</em> a local user account</li><li><strong class="source-inline">userdel</strong>: Command<a id="_idIndexMarker034"/> that's used to <em class="italic">delete</em> a local user account</li><li><strong class="source-inline">groupadd</strong>: Command<a id="_idIndexMarker035"/> that's used to <em class="italic">create</em> a local group</li><li><strong class="source-inline">groupmod</strong>: Command<a id="_idIndexMarker036"/> that's used to <em class="italic">modify</em> a local group</li><li><strong class="source-inline">groupdel</strong>: Command <a id="_idIndexMarker037"/>that's used to <em class="italic">delete</em> a local group</li><li><strong class="source-inline">passwd</strong>: Command<a id="_idIndexMarker038"/> that's most often used to assign passwords to user accounts, but it can be used for some other scenarios (for example, locking user accounts)</li><li><strong class="source-inline">chage</strong>: Command <a id="_idIndexMarker039"/>that's used to manage user password expiry.</li></ul></li>
			</ol>
			<p>So, let's create our first users and groups by using the <strong class="source-inline">useradd</strong> and <strong class="source-inline">groupadd</strong> commands with a scenario. Let's say that our task is as follows:</p>
			<ul>
				<li>Create four users called <strong class="source-inline">jack</strong>, <strong class="source-inline">joe</strong>, <strong class="source-inline">jill</strong>, and <strong class="source-inline">sarah</strong>.</li>
				<li>Create two user groups called <strong class="source-inline">profs</strong> and <strong class="source-inline">pupils</strong>.</li>
				<li>Re-configure the <strong class="source-inline">jack</strong> and <strong class="source-inline">jill</strong> user accounts to be members of the <strong class="source-inline">profs</strong> group.</li>
				<li>Re-configure the <strong class="source-inline">joe</strong> and <strong class="source-inline">sarah</strong> user accounts to be members of the <strong class="source-inline">pupils</strong> group.</li>
				<li>Assign a standard password to all the accounts (we're going to use <strong class="source-inline">P@ckT2021</strong> for this purpose).</li>
				<li>Configure user accounts so that they have to change their password on the next login.</li>
				<li>Set a specific expiry data for the <strong class="source-inline">profs</strong> users group – the minimum number of days before password change set to <strong class="source-inline">15</strong>, the maximum number of days before forced password change set to <strong class="source-inline">30</strong>, the warning for password change needs to start a week before it expires, and set the expiry date for accounts to 2022/01/01 (January 1st, 2022).</li>
				<li>Set a specific expiry data for the <strong class="source-inline">pupils</strong> users group – the minimum number of days before password change set to <strong class="source-inline">7</strong>, the maximum number of days before forced password change set to <strong class="source-inline">30</strong>, the warning for password change needs to start 10 days before it expires, and set the expiry date for accounts to 2021/09/01 (September 1st, 2021).</li>
				<li>Modify the <strong class="source-inline">profs</strong> group to be called <strong class="source-inline">professors</strong> and the <strong class="source-inline">pupils</strong> group to be called <strong class="source-inline">students</strong>.</li>
			</ul>
			<ol>
				<li value="10">The first task is to create the<a id="_idIndexMarker040"/> user accounts:<p class="source-code"><strong class="bold">useradd jack</strong></p><p class="source-code"><strong class="bold">useradd joe</strong></p><p class="source-code"><strong class="bold">useradd jill</strong></p><p class="source-code"><strong class="bold">useradd sarah</strong></p></li>
			</ol>
			<p>This will create entries for these four users in the <strong class="source-inline">/etc/passwd</strong> file (where most of the users' information is stored – username, user ID, group ID, default home directory, and default shell) and the <strong class="source-inline">/etc/shadow</strong> file (where users' passwords and aging information are stored). </p>
			<ol>
				<li value="11">Then, we need to create the groups:<p class="source-code"><strong class="bold">groupadd profs</strong></p><p class="source-code"><strong class="bold">groupadd pupils</strong></p></li>
			</ol>
			<p>This will create entries for these groups in the <strong class="source-inline">/etc/group</strong> file, where the system keeps all the system groups.</p>
			<ol>
				<li value="12">The next step is to manage users' group membership, for both the <strong class="source-inline">professors</strong> and <strong class="source-inline">students</strong> user groups. </li>
			</ol>
			<p>Before we do that, we need to be aware of one fact. There are two distinctive local group types, a <strong class="bold">primary group</strong> and a <strong class="bold">supplementary group</strong>. A primary group is important in <a id="_idIndexMarker041"/>terms of being the key parameter used when creating new files and directories, as the users primary group will be used by default for that (there are exceptions, as we'll mention in <em class="italic">the Setting up the Bash shell recipe</em> in this chapter, about umask, permissions, and ACLs). A supplementary group is important when dealing<a id="_idIndexMarker042"/> with sharing files and folders and related scenarios and exceptions. This is what's usually used for some additional settings for more advanced scenarios. These scenarios are going to be explained partially in the aforementioned <em class="italic">Setting up the Bash shell recipe</em> in this chapter, as well as in recipes about NFS and Samba in <a href="B16269_09_Final_PD_ePub.xhtml#_idTextAnchor206"><em class="italic">Chapter 9</em></a><em class="italic">, An Introduction to Shell Scripting.</em> </p>
			<p>Primary and supplementary groups are stored in the <strong class="source-inline">/etc/group</strong> file.</p>
			<ol>
				<li value="13">Now that we've<a id="_idIndexMarker043"/> gotten that out of the way, let's modify our users' settings so that they belong to <em class="italic">supplementary</em> groups as assigned by the scenario:<p class="source-code"><strong class="bold">usermod -G profs jack</strong></p><p class="source-code"><strong class="bold">usermod -G profs jill</strong></p><p class="source-code"><strong class="bold">usermod -G pupils joe</strong></p><p class="source-code"><strong class="bold">usermod -G pupils sarah</strong></p></li>
			</ol>
			<p>Let's now check how that changes the <strong class="source-inline">/etc/group</strong> file:</p>
			<div>
				<div id="_idContainer011" class="IMG---Figure">
					<img src="Images/Figure_1.7_B16269.jpg" alt="Figure 1.7 – Entries in the /etc/group file&#13;&#10;" width="601" height="191"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.7 – Entries in the /etc/group file</p>
			<p>The first four entries in the <strong class="source-inline">/etc/group</strong> file were actually created when we used the <strong class="source-inline">useradd</strong> command to create these user accounts. The next two entries (except for the last part, after the <strong class="source-inline">:</strong> sign) were created by the <strong class="source-inline">groupadd</strong> commands. Entries after the <strong class="source-inline">:</strong> sign were created after the <strong class="source-inline">usermod</strong> commands.</p>
			<ol>
				<li value="14">Let's now set their <a id="_idIndexMarker044"/>initial password and set a forced password change on the next login. We can do this in a couple of different ways, but let's learn the more <em class="italic">programmatic</em> approach to doing this, by echoing a string and using it as the plain-text password for a user account:<p class="source-code"><strong class="bold">echo "jack:P@ckT2021" | chpasswd</strong></p><p class="source-code"><strong class="bold">echo "joe:P@ckT2021" | chpasswd</strong></p><p class="source-code"><strong class="bold">echo "jill:P@ckT2021" | chpasswd</strong></p><p class="source-code"><strong class="bold">echo "sarah:P@ckT2021" | chpasswd</strong></p></li>
			</ol>
			<p>The echo part, without the rest of the command, would just mean typing <strong class="source-inline">P@ckT2021</strong> in to a Terminal, like this:</p>
			<p class="source-code"><strong class="bold">echo "P@ckT2021"</strong></p>
			<p class="source-code"><strong class="bold">P@ckT2021</strong></p>
			<p>In CentOS and similar distributions, we could use the <strong class="source-inline">passwd</strong> command with the <strong class="source-inline">--stdin</strong> parameter, which would mean that we want to add a password for the user account via standard input (keyboard, variables, and so on). In Ubuntu, this is not available. So, we can echo the <strong class="source-inline">username:P@ckT2021</strong> string to the shell and pipe that to the <strong class="source-inline">chpasswd</strong> command, which achieves just that purpose; instead of outputting the string to our Terminal, the <strong class="source-inline">chpasswd</strong> command uses it as standard input into itself.</p>
			<ol>
				<li value="15">Let's set the expiry date for professors and students. For this purpose, we need to learn how to use the <strong class="source-inline">chage</strong> command and some of its parameters (<strong class="source-inline">-m</strong>, <strong class="source-inline">-M</strong>, <strong class="source-inline">-W</strong>, and <strong class="source-inline">-E</strong>). In short, they mean the following:<ul><li>If we use the <strong class="source-inline">-m</strong> parameter, that <a id="_idIndexMarker045"/>means that we want to assign the minimum number of days before the password change is <em class="italic">allowed</em>.</li><li>If we use the <strong class="source-inline">-M</strong> parameter, that means that we want to assign the maximum number of days before the password change is <em class="italic">forced</em>. </li><li>If we use the <strong class="source-inline">-W</strong> parameter, that means that we want to set the number of warning days before password expiration, which in turn means that the shell is going to start throwing us messages about needing to change our password before it expires.</li><li>If we use the <strong class="source-inline">-E</strong> parameter, that means that we want to set account expiration to a certain date (YYYY-MM-DD format).</li></ul></li>
			</ol>
			<p>Let's now translate that into commands:</p>
			<p class="source-code"><strong class="bold">chage -m 15 -M 30 -W 7 -E 2022-01-01 jack</strong></p>
			<p class="source-code"><strong class="bold">chage -m 15 -M 30 -W 7 -E 2022-01-01 jill</strong></p>
			<p class="source-code"><strong class="bold">chage -m 7 -M 30 -W 10 -E 2021-09-01 joe</strong></p>
			<p class="source-code"><strong class="bold">chage -m 7 -M 30 -W 10 -E 2021-09-01 sarah</strong></p>
			<ol>
				<li value="16">Finally, let's modify the groups to their final settings:<p class="source-code"><strong class="bold">groupmod -n professors profs</strong></p><p class="source-code"><strong class="bold">groupmod -n students pupils</strong></p></li>
			</ol>
			<p>These commands will only change group names, not their other data (such as group ID), which is going to be reflected in our users' information, as well:</p>
			<div>
				<div id="_idContainer012" class="IMG---Figure">
					<img src="Images/Figure_1.8_B16269.jpg" alt="Figure 1.8 – Checking created users' settings&#13;&#10;" width="602" height="166"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.8 – Checking created users' settings</p>
			<p>As we can see, <strong class="source-inline">jack</strong> and <strong class="source-inline">jill</strong> are members of a group that's now called <strong class="source-inline">professors</strong>, while <strong class="source-inline">joe</strong> and <strong class="source-inline">sarah</strong> are now members of a group called <strong class="source-inline">students</strong>.</p>
			<p>We deliberately left <a id="_idIndexMarker046"/>the <strong class="source-inline">userdel</strong> and <strong class="source-inline">groupdel</strong> commands for last, as these come with some caveats and shouldn't be used lightly. Let's create a user called <strong class="source-inline">temp</strong> and a group called <strong class="source-inline">temporary</strong>, and then let's delete them:</p>
			<p class="source-code"><strong class="bold">useradd temp</strong></p>
			<p class="source-code"><strong class="bold">groupadd temporary</strong></p>
			<p class="source-code"><strong class="bold">userdel temp</strong></p>
			<p class="source-code"><strong class="bold">groupdel temporary</strong></p>
			<p>This will work just fine. The thing is, because we used the <strong class="source-inline">userdel</strong> command without any parameters, it will leave the user's home directory intact. Since users' home directories are usually stored in the <strong class="source-inline">/home</strong> directory, by default that means that the <strong class="source-inline">/home/temp</strong> directory is still going to be there. When deleting users, we sometimes want to delete a user but not their files. If you specifically want to delete a user account and all the data from that user account, then use the <strong class="source-inline">userdel -r username</strong> command. But think twice before doing it!</p>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor031"/>How it works...</h2>
			<p>Let's now <a id="_idIndexMarker047"/>discuss the more <a id="_idIndexMarker048"/>complex part of the previous recipe, which is <strong class="bold">symbolic links</strong> and <strong class="bold">hard links</strong>. </p>
			<p>Using the <strong class="source-inline">ln</strong> command without extra parameters tries to create a hard link. Using <strong class="source-inline">ln</strong> with the <strong class="source-inline">-s</strong> parameter tries to create a soft link. We can clearly see <a id="_idIndexMarker049"/>that there are some errors in that part of our recipe. Let's discuss them now by going back from the top.</p>
			<p>When we've finished typing in the first six commands from the recipe (ending with <strong class="source-inline">ls -al</strong>), which we're using to list the folder contents, the end result should look similar to this:</p>
			<div>
				<div id="_idContainer013" class="IMG---Figure">
					<img src="Images/Figure_1.9_B16269.jpg" alt="Figure 1.9 – Original file, hard link and soft link&#13;&#10;" width="601" height="143"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.9 – Original file, hard link and soft link</p>
			<p>There are some conclusions that can be reached just by interpreting this previous screenshot:</p>
			<ul>
				<li>The <strong class="source-inline">content</strong> file and the <strong class="source-inline">hardlink</strong> file have the same size (1,349 bytes, in our case).</li>
				<li>The <strong class="source-inline">content</strong> file and the <strong class="source-inline">softlink</strong> file don't have the same file size (1,349 bytes versus 11 bytes here).</li>
				<li>Soft links<a id="_idIndexMarker050"/> are marked differently by default (usually, a different color in the Terminal).</li>
			</ul>
			<p>Now, for the purposes of building up this explanation, let's delete the original <strong class="source-inline">content</strong> file:</p>
			<p class="source-code">r m content.cfg</p>
			<p>The end result will look like this:</p>
			<div>
				<div id="_idContainer014" class="IMG---Figure">
					<img src="Images/Figure_1.10_B16269.jpg" alt="Figure 1.10 – Removing the original file leaves interesting consequences&#13;&#10;" width="601" height="141"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.10 – Removing the original file leaves interesting consequences</p>
			<p>We can see that the original file is gone, while the <a id="_idIndexMarker051"/>hard link is still here and has the same size. On the other hand, the soft link changed color (from green to red), indicating that there's some kind of problem. Interesting, isn't it?</p>
			<p>If we open the <strong class="source-inline">hardlink.cfg</strong> file<a id="_idIndexMarker052"/> in the <strong class="bold">vi editor</strong>, the content is definitely there:</p>
			<div>
				<div id="_idContainer015" class="IMG---Figure">
					<img src="Images/Figure_1.11_B16269.jpg" alt="Figure 1.11 – The hardlink.cfg file still has the original content&#13;&#10;" width="1335" height="946"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.11 – The hardlink.cfg file still has the original content</p>
			<p>The reason why this<a id="_idIndexMarker053"/> happens comes from the way in which filesystems work. When we delete a file, we don't delete the content of the file, we just delete an entry in the filesystem table (filename) that points to the content of the file. The reason for this is simple in that it's about speed and convenience. If the operating system actually removed the file content, it would need to free its blocks and write zeros to them. That would take a lot of time. Furthermore, it would complicate file recovery.</p>
			<p>This is where hard links<a id="_idIndexMarker054"/> and soft links<a id="_idIndexMarker055"/> come into play. The main difference between them is something that we can easily deduce from the scenario. It's the fact that hard links point to the actual file content, while soft links point to the original filename. That also explains the size difference. Hard links must be the same size as the original file (as the original file and hard link point to the content of the same content, therefore the same size). The reason why <strong class="source-inline">softlink.cfg</strong> only consumes 11 bytes on the filesystem is simple; it's that the <strong class="source-inline">content.cfg</strong> string needs 11 bytes to be saved to the filesystem table. </p>
			<p>This is also the reason why there are two other major differences between hard links and soft links:</p>
			<ul>
				<li>Hard links <a id="_idIndexMarker056"/>cannot point to a directory and they have to point to a file.</li>
				<li>Hard links cannot go across partitions. We can't reference/see data from the first mounted partition if we look from the perspective of the second partition. The second partition has its own filesystem table (which contains entries pointing to the actual content on that partition) that's completely independent of the filesystem table of the first partition.</li>
			</ul>
			<p>The cool thing, going back to our recipe, is that we can easily recover the original file. If we go back to the <strong class="source-inline">/root/links</strong> directory, we can just copy the <strong class="source-inline">hardlink.cfg</strong> file to <strong class="source-inline">content.cfg</strong> and our original file and the corresponding symbolic link are back:</p>
			<p class="source-code">cd /root/links</p>
			<p class="source-code">cp hardlink.cfg content.cfg</p>
			<p>The end result will be just like earlier, when we created the <strong class="source-inline">content.cfg</strong> file and the hard link and soft link pointing to it:</p>
			<div>
				<div id="_idContainer016" class="IMG---Figure">
					<img src="Images/Figure_1.12_B16269.jpg" alt="Figure 1.12 – Our original file and soft link are back&#13;&#10;" width="601" height="159"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.12 – Our original file and soft link are back</p>
			<p>We will use these commands throughout this book, so we need to make sure that we master using them before we move on to the next chapters. But for the time being, we'll add just one more command to the stack. It's the subject of our next recipe, known as <strong class="bold">screen</strong>.</p>
			<h1 id="_idParaDest-33"><a id="_idTextAnchor032"/>Using screen </h1>
			<p><strong class="bold">screen</strong> is one of <a id="_idIndexMarker057"/>those text utilities that was incredibly popular in the 1990s and 2000s, with its popularity shrinking after that. System administrators often have to open multiple consoles on the same machine or use any of those multiple consoles to connect to external machines. Let's see how screen fits into this scenario.</p>
			<h2 id="_idParaDest-34"><a id="_idTextAnchor033"/>Getting ready</h2>
			<p>Before starting with this recipe, we need to make sure that we have screen on our Linux machine. So, we need to use the following command:</p>
			<p class="source-code">apt-get -y install screen</p>
			<p>After that, we're ready to follow our recipe.</p>
			<h2 id="_idParaDest-35"><a id="_idTextAnchor034"/>How to do it…</h2>
			<p>We need to start a regular text Terminal (this can be done in the GUI as well, but it can be considered as a bit of a less-effective way to use screen real estate). Then, we just need to type in the following command:</p>
			<p class="source-code">screen</p>
			<p>When we start screen, it is going to throw us a long piece of text about licensing and other less-than-interesting subjects, with a couple of important pieces of information at the bottom of the screen. It will look similar to this:</p>
			<div>
				<div id="_idContainer017" class="IMG---Figure">
					<img src="Images/Figure_1.13_B16269.jpg" alt="Figure 1.13 – Basic screen information&#13;&#10;" width="1290" height="706"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.13 – Basic screen information</p>
			<p>The only part of<a id="_idIndexMarker058"/> this output that's really interesting to us is <strong class="bold">Capabilities</strong>. It tells us that with screen, we can do some cool stuff, such as copy, detach, and work with fonts. But even without most of these advanced features, screen enables us to open multiple virtual text Terminals, within the limits of one text Terminal. Then, it enables us to detach (something like putting the screen process in the background), log off, come back later, log in, and re-attach our session to screen. That enables some cool things, such as leaving a permanent set of virtual text consoles open for the most common, mostly used use cases.</p>
			<p>After we press the <em class="italic">Enter</em> key on the screen shown in the previous screenshot, we're going to be thrown into the text mode again. This is screen's first virtual text console. If we want to use additional virtual text consoles, we can create them by using the <em class="italic">Ctrl</em> + <em class="italic">A</em> + <em class="italic">C</em> key combination. Every one of these virtual text consoles is numbered from 0 onward. If we create five virtual text consoles in screen (numbered 0-4) and we're in screen 4 and want to jump to screen 0, we can easily do that in two ways. The first one involves <em class="italic">absolute</em> addressing, in other words, we can tell screen that we want to go specifically to screen 0 (by using <em class="italic">Ctrl</em> + <em class="italic">A</em> + <em class="italic">0</em>). The second way to go from screen 4 to 0 is to use a <em class="italic">circular</em> approach. When we use the <em class="italic">Ctrl</em> + <em class="italic">A</em> + spacebar key combination, we're circling through screens in a subsequent fashion – 0, then 1, then 2, and so on. If we're on screen 4 and we want to go to 0, because we don't have a screen 5, we can just circle from 4 to 0 by using <em class="italic">Ctrl</em> + <em class="italic">A</em> + spacebar. </p>
			<p>If we need to log off, we can detach our screen. The key combination for that is <em class="italic">Ctrl</em> + <em class="italic">A</em> + <em class="italic">D</em> (detach screen). If sometime later we want to go back to our screens, we need to type in the following command:</p>
			<p class="source-code">screen -R</p>
			<p>We can also copy-paste in screen by using the <em class="italic">Ctrl</em> + <em class="italic">A</em> + <em class="italic">]</em> key combination, then scroll and find the bit of text that we want to start copying, use the spacebar to start copying and to end the copying process, and then the <em class="italic">Ctrl</em> + <em class="italic">A</em> + <em class="italic">]</em> combination if we want to paste text somewhere. It takes a bit of practice, but it's also very usable. <em class="italic">Just imagine doing stuff like that in 1996!</em> </p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">When working with screen, we suggest that you first press <em class="italic">Ctrl</em> + <em class="italic">A</em>, let those keys go, and then press whichever key you need to go wherever you want to go on the screen.</p>
			<h2 id="_idParaDest-36"><a id="_idTextAnchor035"/>How it works…</h2>
			<p>screen works by<a id="_idIndexMarker059"/> creating multiple detachable virtual text consoles. These consoles remain active until there's a process that kills screen, or until the system reboots. Keeping in mind that most production environments based on Linux servers don't have a GUI, having the capability to connect to a server once and then open multiple screens comes in handy. </p>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor036"/>There's more…</h2>
			<p>screen requires a bit of trial and error and getting used to. We recommend that you check the following link to learn more:</p>
			<p><strong class="source-inline">https://www.howtogeek.com/662422/how-to-use-linuxs-screen-command/</strong></p>
		</div>
	</div></body></html>