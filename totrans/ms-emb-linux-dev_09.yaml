- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Developing with Yocto
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Yocto 开发
- en: Bringing up Linux on unsupported hardware can be a painstaking process. Luckily,
    Yocto provides **Board Support Packages** (**BSPs**) to bootstrap embedded Linux
    development on popular single-board computers like BeaglePlay and Raspberry Pi
    4\. Building on top of an existing BSP layer lets us quickly take advantage of
    complex built-in peripherals such as Bluetooth and Wi-Fi. In this chapter, we
    will create a custom application layer to do just that.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在不支持的硬件上启动 Linux 可能是一个繁琐的过程。幸运的是，Yocto 提供了**板级支持包**（**BSPs**），可以帮助我们在 BeaglePlay
    和 Raspberry Pi 4 等流行单板计算机上快速启动嵌入式 Linux 开发。基于现有的 BSP 层进行构建，让我们能够迅速利用复杂的内建外设，如蓝牙和
    Wi-Fi。在本章中，我们将创建一个自定义应用层来实现这一目标。
- en: Next, we will look at the development workflow enabled by Yocto’s extensible
    SDK. Modifying software running on a target device usually means swapping out
    the microSD card. Since rebuilding and redeploying full images is too time-consuming,
    I will show you how to use `devtool` to quickly automate and iterate over your
    work. While doing so, you will also learn how to save your work in your own layers
    so that it does not get lost.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看 Yocto 可扩展 SDK 启用的开发工作流。在目标设备上修改软件通常意味着需要更换 microSD 卡。由于重新构建和重新部署完整的镜像太过耗时，我将向你展示如何使用
    `devtool` 快速自动化并反复测试你的工作。在此过程中，你还将学习如何将你的工作保存到自己的层中，避免工作丢失。
- en: Yocto not only builds Linux images but entire Linux distributions. We will discuss
    the reasons for doing so before going through the motions of assembling our own
    Linux distribution. The many choices made include whether or not to add runtime
    package management for rapid application development on the target device. This
    comes at the cost of having to maintain a package database and remote package
    server, which I will touch on last.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Yocto 不仅构建 Linux 镜像，还能构建整个 Linux 发行版。在我们动手构建自己的 Linux 发行版之前，我们将先讨论这样做的原因。我们所做的许多选择包括是否添加运行时软件包管理，以便在目标设备上进行快速应用开发。这需要维护软件包数据库和远程软件包服务器，我将在最后提到这一点。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Building on top of an existing BSP
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在现有 BSP 上构建
- en: Capturing changes with `devtool`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `devtool` 捕获变更
- en: Building your own distro
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建你自己的发行版
- en: Provisioning a remote package server
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置远程软件包服务器
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with the examples, make sure you have the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随示例进行操作，请确保你具备以下设备：
- en: An Ubuntu 24.04 or later LTS host system with at least 90 GB of free disk space
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台运行 Ubuntu 24.04 或更高版本 LTS 的主机系统，并且至少有 90 GB 的可用磁盘空间
- en: The Yocto 5.0 (scarthgap) LTS release
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Yocto 5.0 (scarthgap) LTS 版本
- en: A microSD card reader and card
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台 microSD 卡读卡器和卡
- en: balenaEtcher for Linux
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用于 Linux 的 balenaEtcher
- en: An Ethernet cable and router with an available port for network connectivity
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一根以太网线和一台带有可用端口的路由器，用于网络连接
- en: A Wi-Fi router
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台 Wi-Fi 路由器
- en: A smartphone with Bluetooth
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一部支持蓝牙的智能手机
- en: Raspberry Pi 4
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Raspberry Pi 4
- en: A 5 V USB-C power supply capable of delivering 3A
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台能够提供 3A 电流的 5V USB-C 电源
- en: You should have already built the 5.0 (scarthgap) LTS release of Yocto in [*Chapter
    6*](Chapter_04.xhtml#_idTextAnchor110). If you have not, then please refer to
    the *Compatible Linux Distribution* and *Build Host Packages* sections of the
    *Yocto Project Quick Build* guide ([https://docs.yoctoproject.org/brief-yoctoprojectqs/)](https://docs.yoctoproject.org/brief-yoctoprojectqs/)
    before building Yocto on your Linux host according to the instructions in [*Chapter
    6*](Chapter_04.xhtml#_idTextAnchor110).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经在 [*第 6 章*](Chapter_04.xhtml#_idTextAnchor110) 中构建了 Yocto 的 5.0 (scarthgap)
    LTS 版本。如果还没有，请先参考 *兼容的 Linux 发行版* 和 *构建主机软件包* 部分，查阅 *Yocto 项目快速构建* 指南 ([https://docs.yoctoproject.org/brief-yoctoprojectqs/)](https://docs.yoctoproject.org/brief-yoctoprojectqs/)，然后按照
    [*第 6 章*](Chapter_04.xhtml#_idTextAnchor110) 中的说明在你的 Linux 主机上构建 Yocto。
- en: 'The code used in this chapter can be found in the chapter folder in this book’s
    GitHub repository: [https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development](https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码可以在本书的 GitHub 仓库的章节文件夹中找到：[https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development](https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development)。
- en: Building on top of an existing BSP
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在现有 BSP 上构建
- en: A **BSP** layer adds support for a particular hardware device or family of devices
    to Yocto. This support usually includes the bootloader, device tree blobs, and
    additional kernel drivers needed to boot Linux on that specific hardware. A BSP
    may also include any additional user-space software and peripheral firmware needed
    to fully enable and utilize all the features of the hardware. By convention, BSP
    layer names start with the `meta-` prefix followed by the machine’s name. Locating
    the best BSP for your target device is the first step toward building a bootable
    image for it using Yocto.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 **BSP** 层为 Yocto 添加对特定硬件设备或设备系列的支持。这个支持通常包括引导加载程序、设备树二进制文件以及启动 Linux 所需的额外内核驱动程序。BSP
    还可能包含任何附加的用户空间软件和外设固件，以充分启用和利用硬件的所有功能。按照惯例，BSP 层的名称以 `meta-` 前缀开始，后跟机器名称。找到适合你目标设备的最佳
    BSP 是使用 Yocto 构建可启动镜像的第一步。
- en: The OpenEmbedded layer index ([https://layers.openembedded.org/layerindex)](https://layers.openembedded.org/layerindex))
    is the best place to start looking for quality BSPs. Your board’s manufacturer
    or silicon vendor may also offer BSP layers. The Yocto Project provides a BSP
    for all variants of Raspberry Pi. You can find the Git repository for that BSP
    layer and all the other layers endorsed by The Yocto Project in the project’s
    source repositories ([https://git.yoctoproject.org](https://git.yoctoproject.org)).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: OpenEmbedded 层索引 ([https://layers.openembedded.org/layerindex)](https://layers.openembedded.org/layerindex))
    是开始查找优质 BSP 的最佳地方。你的板卡制造商或硅片供应商也可能提供 BSP 层。Yocto 项目为所有 Raspberry Pi 变种提供了一个 BSP。你可以在项目的源代码库中找到该
    BSP 层及 Yocto 项目认可的所有其他层的 Git 仓库 ([https://git.yoctoproject.org](https://git.yoctoproject.org))。
- en: Building an existing BSP
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建现有的 BSP
- en: 'The following exercises assume you have already cloned or extracted the scarthgap
    release of Yocto to a directory named `poky` within your host environment. Before
    proceeding, we also need to clone the following dependency layers one level up
    from that `poky` directory so that the layer and `poky` directories sit next to
    each other:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下练习假设你已经将 Yocto 的 scarthgap 版本克隆或解压到主机环境中名为 `poky` 的目录。在继续之前，我们还需要从 `poky`
    目录向上克隆以下依赖层，这样 `layer` 和 `poky` 目录就能并排放置：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Notice that the branch name of the dependency layers matches the Yocto release
    for compatibility. Keep all three clones up to date and in sync with their remotes
    using periodic `git pull` commands. The `meta-raspberrypi` layer is the BSP for
    all Raspberry Pis. Once these dependencies are in place, you can build an image
    that’s been customized for Raspberry Pi 4\. But before we do that, let’s explore
    the recipes for Yocto’s generic images:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，依赖层的分支名称与 Yocto 版本匹配以确保兼容性。使用定期的 `git pull` 命令保持所有三个克隆与远程仓库同步并保持最新。`meta-raspberrypi`
    层是所有 Raspberry Pi 的 BSP。一旦这些依赖关系就位，你可以构建一个为 Raspberry Pi 4 定制的镜像。但在此之前，让我们先看看
    Yocto 的通用镜像配方：
- en: 'First, navigate to the directory where you cloned Yocto:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，导航到你克隆 Yocto 的目录：
- en: '[PRE1]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, move down into the directory where the recipes for the standard images
    are:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，进入包含标准镜像配方的目录：
- en: '[PRE2]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'List the core image recipes:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出核心镜像配方：
- en: '[PRE3]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Display the `core-image-base` recipe:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示 `core-image-base` 配方：
- en: '[PRE4]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice that this recipe inherits from `core-image` so it’s importing the contents
    of `core-image.bbclass`, which we will look at later.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，这个配方继承自 `core-image`，因此它导入了 `core-image.bbclass` 的内容，我们稍后将查看它。
- en: 'Display the `core-image-minimal` recipe:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示 `core-image-minimal` 配方：
- en: '[PRE5]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Like `core-image-base`, this recipe also inherits from the `core-image` class
    file.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与 `core-image-base` 一样，这个配方也继承自 `core-image` 类文件。
- en: 'Display the `core-image-minimal-dev` recipe:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示 `core-image-minimal-dev` 配方：
- en: '[PRE6]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Navigate up to the classes directory under poky/meta:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 poky/meta 下的 classes 目录：
- en: '[PRE7]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Lastly, display the `core-image` class file:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，显示 `core-image` 类文件：
- en: '[PRE8]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice the long list of available `IMAGE_FEATURES` at the top of this class
    file, including the aforementioned `dev-pkgs` feature.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，在这个类文件的顶部列出了大量可用的 `IMAGE_FEATURES`，包括前面提到的 `dev-pkgs` 特性。
- en: Standard images such as `core-image-minimal` and `core-image-minimal-dev` are
    machine-agnostic. In [*Chapter 6*](Chapter_04.xhtml#_idTextAnchor110), we built
    `core-image-minimal` for both the QEMU Arm emulator and BeaglePlay. We could have
    just as easily built a `core-image-minimal` image for Raspberry Pi 4\. In contrast,
    a BSP layer includes image recipes intended for a specific board or series of
    boards.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 标准镜像，如 `core-image-minimal` 和 `core-image-minimal-dev`，是机器无关的。在 [*第6章*](Chapter_04.xhtml#_idTextAnchor110)
    中，我们为 QEMU Arm 模拟器和 BeaglePlay 构建了 `core-image-minimal`。我们本可以同样为树莓派 4 构建一个 `core-image-minimal`
    镜像。相比之下，BSP 层包括为特定板或一系列板设计的镜像配方。
- en: 'Now let’s take a look at the `rpi-test-image` recipe inside the `meta-rasberrypi`
    BSP layer to see how support for both Wi-Fi and Bluetooth is added to `core-image-base`
    for Raspberry Pi 4:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 `meta-rasberrypi` BSP 层中的 `rpi-test-image` 配方，了解如何将 Wi-Fi 和蓝牙的支持添加到树莓派
    4 的 `core-image-base` 中：
- en: 'First, navigate one level above the directory where you cloned Yocto:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，导航到克隆 Yocto 的目录上一级：
- en: '[PRE9]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, move down into the directory inside the `meta-raspberrypi` BSP layer
    where the image recipes for Raspberry Pis are:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，进入 `meta-raspberrypi` BSP 层中存放树莓派镜像配方的目录：
- en: '[PRE10]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'List the Raspberry Pi image recipes:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出树莓派镜像配方：
- en: '[PRE11]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Display the `rpi-test-image` recipe:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示 `rpi-test-image` 配方：
- en: '[PRE12]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice that the `IMAGE_INSTALL` variable has been overridden so that it can
    append `packagegroup-rpi-test` and include those packages on the image.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，`IMAGE_INSTALL` 变量已被覆盖，以便它可以附加 `packagegroup-rpi-test` 并将这些包包含在镜像中。
- en: 'Navigate to the neighboring `packagegroups` directory under `metaraspberrypi/recipes-core`:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 `metaraspberrypi/recipes-core` 下相邻的 `packagegroups` 目录：
- en: '[PRE13]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Lastly, display the `packagegroup-rpi-test` recipe:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，显示 `packagegroup-rpi-test` 配方：
- en: '[PRE14]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice that the `connman`, `connman-client`, and `bluez5` packages are included
    in the list of runtime dependencies so that Wi-Fi and Bluetooth are fully enabled.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，`connman`、`connman-client` 和 `bluez5` 包已包含在运行时依赖项列表中，以便完全启用 Wi-Fi 和蓝牙功能。
- en: 'Finally, let’s build `rpi-test-image` for Raspberry Pi 4:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为树莓派 4 构建 `rpi-test-image`：
- en: 'First, navigate one level above the directory where you cloned Yocto:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，导航到克隆 Yocto 的目录上一级：
- en: '[PRE15]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, set up your BitBake work environment:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，设置你的 BitBake 工作环境：
- en: '[PRE16]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This sets up a bunch of environment variables and puts you in a newly created
    `build-rpi` directory.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这会设置一堆环境变量并将你带入新创建的 `build-rpi` 目录。
- en: 'Then, add the following layers to your image:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，向你的镜像中添加以下层：
- en: '[PRE17]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**IMPORTANT NOTE**'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: The order in which you add these layers matters because the `meta-networking`
    and `meta-multimedia` layers both depend on the `meta-python` layer. If `bitbake-layers
    add-layer` or `bitbake-layers show-layers` starts failing due to parse errors,
    then delete the `build-rpi` directory and restart this exercise from *step 1*.
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 添加这些层的顺序很重要，因为 `meta-networking` 和 `meta-multimedia` 层都依赖于 `meta-python` 层。如果
    `bitbake-layers add-layer` 或 `bitbake-layers show-layers` 因解析错误而失败，请删除 `build-rpi`
    目录，并从 *步骤 1* 重新开始此练习。
- en: 'Verify that all the necessary layers have been added to the image:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证所有必要的层是否已添加到镜像中：
- en: '[PRE18]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output of the command should look like this:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命令的输出应如下所示：
- en: '[PRE19]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Observe the changes that the preceding `bitbake-layers add-layer` commands
    made to `bblayers.conf`:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察前面 `bitbake-layers add-layer` 命令对 `bblayers.conf` 所做的更改：
- en: '[PRE20]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The same eight layers from the previous step should be assigned to the `BBLAYERS`
    variable.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上一步中的相同八个层应分配给 `BBLAYERS` 变量。
- en: 'List the machines supported by the `meta-raspberrypi` BSP layer:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出 `meta-raspberrypi` BSP 层支持的机器：
- en: '[PRE21]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Notice that there are `raspberrypi4` and `raspberrypi4-64` machine configurations.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，存在 `raspberrypi4` 和 `raspberrypi4-64` 机器配置。
- en: 'Add the following line to your `conf/local.conf` file:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下行添加到你的 `conf/local.conf` 文件中：
- en: '[PRE22]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This overrides the following default in your `conf/local.conf` file:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将覆盖你 `conf/local.conf` 文件中的以下默认设置：
- en: '[PRE23]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Setting the `MACHINE` variable to `raspberrypi4-64` ensures that the image we’re
    about to build works for Raspberry Pi 4.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置 `MACHINE` 变量为 `raspberrypi4-64` 确保我们即将构建的镜像适用于树莓派 4。
- en: 'Add the following line to your `conf/local.conf` file:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下行添加到你的 `conf/local.conf` 文件中：
- en: '[PRE24]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This suppresses the following build error:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将抑制以下构建错误：
- en: '[PRE25]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, append `ssh-server-openssh` to the list of `EXTRA_IMAGE_FEATURES` in your
    `conf/local.conf` file:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将 `ssh-server-openssh` 添加到你 `conf/local.conf` 文件中 `EXTRA_IMAGE_FEATURES`
    列表中：
- en: '[PRE26]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This adds an SSH server to our image for local network access.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这会在我们的镜像中添加一个 SSH 服务器，用于本地网络访问。
- en: 'Lastly, build the image:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，构建镜像：
- en: '[PRE27]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The first build could take anywhere from minutes to hours to complete depending
    on how many CPU cores your host environment has available.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次构建可能需要几分钟到几小时，具体取决于主机环境可用的CPU核心数量。
- en: '`TARGET_SYS` should be `aarch64-poky-linux` and `MACHINE` should be `raspberrypi4-64`
    since this image is targeting 64-bit for the Arm Cortex-A72 cores in Raspberry
    Pi 4.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`TARGET_SYS`应该为`aarch64-poky-linux`，而`MACHINE`应该为`raspberrypi4-64`，因为该映像是为Raspberry
    Pi 4中的Arm Cortex-A72核心的64位目标架构构建的。'
- en: 'Once the image has finished building, there should be a file named `rpi-test-image-raspberrypi4-64.rootfs.wic.bz2`
    in the `tmp/deploy/images/raspberrypi4-64` directory:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦映像构建完成，在`tmp/deploy/images/raspberrypi4-64`目录下应该会有一个名为`rpi-test-image-raspberrypi4-64.rootfs.wic.bz2`的文件：
- en: '[PRE28]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Notice that `rpi-test-image-raspberrypi4-64.rootfs.wic.bz2` is a symbolic link
    pointing to the actual image file in the same directory. An integer denoting the
    date and time of the build is appended to the image filename before the `wic.bz2`
    extension.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`rpi-test-image-raspberrypi4-64.rootfs.wic.bz2`是一个符号链接，指向同一目录下的实际映像文件。在`wic.bz2`扩展名之前，附加了表示构建日期和时间的整数。
- en: 'Now write that image to a microSD card using Etcher and boot it on your Raspberry
    Pi 4:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用Etcher将该映像写入microSD卡并在你的Raspberry Pi 4上启动它：
- en: Insert a microSD card into your host machine.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将microSD卡插入主机计算机。
- en: Launch Etcher.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Etcher。
- en: Click **Flash from file** from Etcher.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Etcher中点击**Flash from file**。
- en: Locate the `wic.bz2` image that you built for Raspberry Pi 4 and open it.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到你为Raspberry Pi 4构建的`wic.bz2`映像并打开它。
- en: Click **Select target** from Etcher.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Etcher中点击**Select target**。
- en: Select the microSD card that you inserted in *step 1*.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你在*步骤1*中插入的microSD卡。
- en: Click **Flash** from Etcher to write the image.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Etcher中点击**Flash**，将映像写入microSD卡。
- en: Eject the microSD card when Etcher is done flashing.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等Etcher完成烧录后，弹出microSD卡。
- en: Insert the microSD card into your Raspberry Pi 4.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将microSD卡插入你的Raspberry Pi 4。
- en: Apply power to Raspberry Pi 4 by way of its USB-C port.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过Raspberry Pi 4的USB-C端口为其供电。
- en: Confirm that your Raspberry Pi 4 booted successfully by plugging it into your
    Ethernet and observing that the network activity lights blink.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将Raspberry Pi 4连接到以太网，并观察网络活动指示灯是否闪烁，确认你的Raspberry Pi 4是否成功启动。
- en: Controlling Wi-Fi
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制Wi-Fi
- en: 'In the previous exercise, we built a bootable image for Raspberry Pi 4 that
    includes working Ethernet, Wi-Fi, and Bluetooth. Now that the device has booted
    and connected to your local network via Ethernet, let’s connect to a nearby Wi-Fi
    network. We will use `connman` for this exercise since that is what the `meta-raspberrypi`
    layer ships with out of the box. Other BSP layers rely on different network interface
    configuration daemons, such as `systemd-networkd` and `NetworkManager`. Follow
    these steps:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，我们为Raspberry Pi 4构建了一个可启动映像，其中包含了工作中的以太网、Wi-Fi和蓝牙。现在设备已经启动并通过以太网连接到本地网络，我们来连接附近的Wi-Fi网络。我们将在本练习中使用`connman`，因为这是`meta-raspberrypi`层默认提供的工具。其他BSP层则依赖于不同的网络接口配置守护进程，例如`systemd-networkd`和`NetworkManager`。请按照以下步骤操作：
- en: 'The image we built has a hostname of `raspberrypi4-64` so you should be able
    to SSH into the device as root:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们构建的映像主机名为`raspberrypi4-64`，因此你应该能够以root用户通过SSH连接到设备：
- en: '[PRE29]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Enter `yes` when asked if you want to continue connecting. You will not be prompted
    for a password. If no host is found at `raspberrypi4-64.local`, use a tool such
    as `arp-scan` to locate the IP address of your Raspberry Pi 4 and SSH into that
    instead of doing so by hostname.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当询问是否继续连接时，输入`yes`。你不会被提示输入密码。如果没有在`raspberrypi4-64.local`找到主机，可以使用`arp-scan`等工具定位你的Raspberry
    Pi 4的IP地址，然后通过该IP地址SSH连接，而不是通过主机名连接。
- en: 'Once you are in, verify that the Wi-Fi driver is on board:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦进入，验证Wi-Fi驱动是否已加载：
- en: '[PRE30]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Start `connman-client`:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动`connman-client`：
- en: '[PRE31]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Turn on Wi-Fi:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Wi-Fi：
- en: '[PRE32]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Disregard `"``Error wifi: Already enabled"` if the Wi-Fi is already on.'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '如果Wi-Fi已经开启，忽略`"``Error wifi: Already enabled"`。'
- en: 'Register `connmanctl` as the connection agent:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册`connmanctl`作为连接代理：
- en: '[PRE33]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Scan for Wi-Fi networks:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扫描Wi-Fi网络：
- en: '[PRE34]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'List all the available Wi-Fi networks:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出所有可用的Wi-Fi网络：
- en: '[PRE35]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`RT-AC66U_B1_38_2G` and `RT-AC66U_B1_38_5G` are Wi-Fi network SSIDs for an
    ASUS router. Your list will look different. The `*AO` before `Wired` indicates
    that the device is currently online via Ethernet.'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RT-AC66U_B1_38_2G`和`RT-AC66U_B1_38_5G`是ASUS路由器的Wi-Fi网络SSID。你的列表可能会有所不同。`*AO`标记在`Wired`前面表示设备当前通过以太网在线。'
- en: 'Connect to a Wi-Fi network:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接到Wi-Fi网络：
- en: '[PRE36]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Replace the service identifier after `connect` with your service identifier
    or target network from the previous step. Substitute your Wi-Fi passphrase for
    `somepassword`.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `connect` 后替换服务标识符为您在前一步中获得的服务标识符或目标网络。将您的 Wi-Fi 密码替换为 `somepassword`。
- en: 'List the services again:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次列出服务：
- en: '[PRE37]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This time, `*AR` appears before the SSID you just connected to, indicating that
    this network connection is ready. Ethernet takes precedence over Wi-Fi, so the
    device remains online over `Wired`.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这次，`*AR` 出现在您刚刚连接的 SSID 前面，表示该网络连接已经准备好。以太网优先于 Wi-Fi，因此设备会通过 `Wired` 保持在线。
- en: 'Exit `connman-client`:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出 `connman-client`：
- en: '[PRE38]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Unplug your Raspberry Pi 4 from the Ethernet, thereby closing your SSH session:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的 Raspberry Pi 4 从以太网中拔出，从而关闭 SSH 会话：
- en: '[PRE39]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Reconnect to your Raspberry Pi 4:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新连接到您的 Raspberry Pi 4：
- en: '[PRE40]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Start `connman-client` again:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次启动 `connman-client`：
- en: '[PRE41]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'List the services again:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次列出服务：
- en: '[PRE42]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Observe that the `Wired` connection is now gone and that the Wi-Fi SSID you
    connected to that was previously ready has now been promoted to online.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意到 `Wired` 连接现在消失，而您之前连接的 Wi-Fi SSID 已被提升为在线状态。
- en: The `connman` daemon saves your Wi-Fi credentials to a network profile directory
    under `/var/lib/connman`, which persists on the microSD card. This means that
    `connman` will automatically reconnect to your Wi-Fi network when your Raspberry
    Pi 4 boots up. There is no need to go through these steps again after power cycling.
    You can leave your Ethernet unplugged if you like.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`connman` 守护进程将您的 Wi-Fi 凭据保存在 `/var/lib/connman` 下的网络配置文件目录中，并且这些数据会在 microSD
    卡上持久保存。这意味着 `connman` 会在您的 Raspberry Pi 4 启动时自动重新连接到您的 Wi-Fi 网络。电源重启后，您无需再次执行这些步骤。如果您愿意，可以保持以太网未插入。'
- en: Controlling Bluetooth
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制蓝牙
- en: 'In addition to the `connman` and `connman-client` packages, the `meta-raspberrypi`
    layer includes `bluez5` for its Bluetooth stack. All of these packages as well
    as the requisite Bluetooth drivers are included in `rpi-test-image`, which we
    built for Raspberry Pi 4\. Let’s get Bluetooth up and running and attempt to pair
    it with another device:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `connman` 和 `connman-client` 包之外，`meta-raspberrypi` 层还包括 `bluez5` 作为蓝牙栈。所有这些包以及所需的蓝牙驱动程序都包含在我们为
    Raspberry Pi 4 构建的 `rpi-test-image` 中。让我们开始启用蓝牙并尝试与其他设备配对：
- en: 'Power up your Raspberry Pi 4 and SSH in:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动您的 Raspberry Pi 4 并通过 SSH 连接：
- en: '[PRE43]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Verify that the Bluetooth drivers are on board:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证蓝牙驱动程序是否已加载：
- en: '[PRE44]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Initialize the HCI UART driver for Bluetooth connectivity:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化 HCI UART 驱动以实现蓝牙连接：
- en: '[PRE45]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Start `connman-client`:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 `connman-client`：
- en: '[PRE46]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Turn on Bluetooth:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开蓝牙：
- en: '[PRE47]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Disregard `"Error bluetooth: Already enabled"` if Bluetooth is already on.'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '如果蓝牙已开启，忽略 `"Error bluetooth: Already enabled"` 错误信息。'
- en: 'Exit `connman-client`:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出 `connman-client`：
- en: '[PRE48]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Start the Bluetooth CLI:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动蓝牙 CLI：
- en: '[PRE49]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Request the default agent:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求默认代理：
- en: '[PRE50]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Power on the controller:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开启控制器：
- en: '[PRE51]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Show information about the controller:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示控制器信息：
- en: '[PRE52]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Start scanning for Bluetooth devices:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始扫描蓝牙设备：
- en: '[PRE53]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: If your smartphone is nearby and has Bluetooth enabled, it should appear in
    the list as a `[NEW]` device. The `DC:08:0F:03:52:CD` part next to `Frank's` `iPhone`
    is the Bluetooth MAC address of my smartphone.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您的智能手机在附近并且已启用蓝牙，它应当作为 `[NEW]` 设备出现在列表中。`Frank's` `iPhone` 后面的 `DC:08:0F:03:52:CD`
    是我的智能手机的蓝牙 MAC 地址。
- en: 'Stop scanning for Bluetooth devices:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止扫描蓝牙设备：
- en: '[PRE54]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: If you have an iPhone open, go to **Bluetooth** under **Settings** so that you
    can accept the pairing request from your Raspberry Pi 4.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您有 iPhone 打开，请进入 **设置** 中的 **蓝牙** 以便接受来自您的 Raspberry Pi 4 的配对请求。
- en: 'Attempt to pair with your smartphone:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试与您的智能手机配对：
- en: '[PRE55]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Substitute your smartphone’s Bluetooth MAC address for `DC:08:0F:03:52:CD`.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的智能手机蓝牙 MAC 地址替换为 `DC:08:0F:03:52:CD`。
- en: 'Before entering `yes`, accept the pairing request from your smartphone:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在输入 `yes` 之前，接受来自智能手机的配对请求：
- en: '![Figure 7.1 – Bluetooth pairing request](img/B18466_07_01.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.1 – 蓝牙配对请求](img/B18466_07_01.png)'
- en: Figure 7.1 – Bluetooth pairing request
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – 蓝牙配对请求
- en: 'Enter `yes` to confirm the passkey:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 `yes` 以确认密码：
- en: '[PRE56]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Connect to your smartphone:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接到您的智能手机：
- en: '[PRE57]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Again, substitute your smartphone’s Bluetooth MAC address for `DC:08:0F:03:52:CD`.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次将您的智能手机蓝牙 MAC 地址替换为 `DC:08:0F:03:52:CD`。
- en: 'When prompted to authorize the service, enter `yes`:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提示授权服务时，输入 `yes`：
- en: '[PRE58]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Your Raspberry Pi 4 is now paired and connected to your smartphone over Bluetooth.
    It should appear on your smartphone’s list of Bluetooth devices as **BlueZ 5.72**.
    The `bluetoothctl` program has numerous commands and submenus. We’ve only just
    scratched the surface. I recommend entering `help` and perusing the self-documentation
    to get an idea of what you can do from the command line. Like `connman`, the BlueZ
    Bluetooth stack is a D-Bus service, so you can communicate with it programmatically
    over D-Bus from Python or other high-level programming languages using D-Bus bindings.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你的Raspberry Pi 4现在已经通过蓝牙与智能手机配对并连接。它应该出现在你智能手机的蓝牙设备列表中，显示为**BlueZ 5.72**。`bluetoothctl`程序有许多命令和子菜单，我们只是略微触及了表面。我建议输入`help`并浏览自文档，以了解你可以通过命令行做些什么。像`connman`一样，BlueZ蓝牙栈是一个D-Bus服务，因此你可以通过Python或其他高级编程语言使用D-Bus绑定在D-Bus上与其进行编程通信。
- en: Adding a custom layer
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加自定义层
- en: If you are using Raspberry Pi 4 to prototype a new product, then you can quickly
    generate your own custom images by adding packages to the list that’s been assigned
    to the `IMAGE_INSTALL:append` variable in `conf/local.conf`. While this simple
    technique works, at some point you are going to want to start developing your
    own embedded application.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是Raspberry Pi 4来原型化新产品，那么你可以通过向`conf/local.conf`中的`IMAGE_INSTALL:append`变量分配的列表中添加包来快速生成自己的自定义镜像。虽然这种简单技巧有效，但在某个时候，你可能会想要开始开发自己的嵌入式应用。
- en: How do you build this additional software so that you can include it in your
    custom images? The answer is to create a custom layer with a new recipe to build
    your software.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如何构建这个额外的软件，以便将其包含在自定义镜像中？答案是创建一个自定义层，配合新配方来构建你的软件。
- en: First, navigate one level above the directory where you cloned Yocto.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，导航到你克隆Yocto的目录上一级。
- en: 'Next, set up your BitBake work environment:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，设置你的BitBake工作环境：
- en: '[PRE59]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This sets a bunch of environment variables and puts you back in the `build-rpi`
    directory.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这会设置一堆环境变量，并将你带回`build-rpi`目录。
- en: 'Create a new layer for your application:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为你的应用创建一个新层：
- en: '[PRE60]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This layer is named `meta-gattd` for the GATT daemon. Name your layer whatever
    you like, but please adhere to the `meta-` prefix convention.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个层的名称是`meta-gattd`，用于GATT守护进程。你可以随意命名你的层，但请遵循`meta-`前缀约定。
- en: 'Navigate up to the new layer directory:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到新的层目录：
- en: '[PRE61]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Examine the layer’s file structure:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查层的文件结构：
- en: '[PRE62]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Rename the `recipes-examples` directory:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重命名`recipes-examples`目录：
- en: '[PRE63]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Rename the `example` directory:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重命名`example`目录：
- en: '[PRE64]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Rename the example recipe file:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重命名示例配方文件：
- en: '[PRE65]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Display the renamed recipe file:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示重命名后的配方文件：
- en: '[PRE66]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: You want to populate this recipe with the metadata that’s needed to build your
    software, including `SRC_URI` and `md5` checksums.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要为这个配方填充构建软件所需的元数据，包括`SRC_URI`和`md5`校验和。
- en: For now, just replace gattd_0.1.bb with the finished recipe I have provided
    for you in `MELD/Chapter07/meta-gattd/recipes-gattd/gattd/gattd_0.1.bb`.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，暂时将gattd_0.1.bb替换为我在`MELD/Chapter07/meta-gattd/recipes-gattd/gattd/gattd_0.1.bb`中提供的完成配方。
- en: Create a Git repository for your new layer and push it to GitHub.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为你的新层创建一个Git仓库，并将其推送到GitHub。
- en: Create a `scarthgap` branch in your Git repository and push it to GitHub.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的Git仓库中创建一个`scarthgap`分支，并将其推送到GitHub。
- en: 'Now that we have a custom layer for our application, let’s add it to your working
    image:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个用于应用的自定义层，让我们将其添加到你的工作镜像中：
- en: 'First, navigate one level above the directory where you cloned Yocto:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，导航到你克隆Yocto的目录上一级：
- en: '[PRE67]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Clone your layer or my `meta-gattd` layer from GitHub:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从GitHub克隆你的层或我的`meta-gattd`层：
- en: '[PRE68]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Replace `fvasquez` with your GitHub username and `meta-gattd` with your layer’s
    repo name.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`fvasquez`替换为你的GitHub用户名，将`meta-gattd`替换为你层的仓库名称。
- en: 'Next, set up your BitBake work environment:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，设置你的BitBake工作环境：
- en: '[PRE69]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: This sets a bunch of environment variables and puts you back in the `build-rpi`
    directory.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这会设置一堆环境变量，并将你带回`build-rpi`目录。
- en: 'Then, add the newly cloned layer to the image:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将新克隆的层添加到镜像中：
- en: '[PRE70]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Replace `meta-gattd` with the name of your layer.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`meta-gattd`替换为你层的名称。
- en: 'Verify that all the necessary layers have been added to the image:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证所有必要的层是否已经添加到镜像中：
- en: '[PRE71]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: There should be a total of nine layers in the list, including your new layer.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列表中应该有总共九个层，包括你新的层。
- en: 'Now, add the extra package to your `conf/local.conf` file:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将额外的软件包添加到你的`conf/local.conf`文件中：
- en: '[PRE72]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '`CORE_IMAGE_EXTRA_INSTALL` is a convenience variable that’s used to add extra
    packages to an image that inherits from the `core-image` class like `rpi-test-image`
    does. `IMAGE_INSTALL` is the variable that controls what packages are included
    in any image. We cannot use `IMAGE_INSTALL += "gattd"` in `conf/local.conf` because
    it replaces the default lazy assignment that’s done in `core-image.bbclass`. Use
    `IMAGE_INSTALL:append = " gattd"` or `CORE_IMAGE_EXTRA_INSTALL += " gattd"` instead.'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CORE_IMAGE_EXTRA_INSTALL`是一个便利变量，用于向从`core-image`类继承的镜像中添加额外的软件包，像`rpi-test-image`那样。`IMAGE_INSTALL`是控制镜像中包含哪些软件包的变量。我们不能在`conf/local.conf`中使用`IMAGE_INSTALL
    += "gattd"`，因为它会替代`core-image.bbclass`中默认的惰性赋值。请改用`IMAGE_INSTALL:append = " gattd"`或`CORE_IMAGE_EXTRA_INSTALL
    += " gattd"`。'
- en: 'Lastly, rebuild the image:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，重新构建镜像：
- en: '[PRE73]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: If your software successfully builds and installs, it should be included on
    the finished `rpi-test-image-raspberrypi4-64.rootfs.wic.bz2` image. Write that
    image to a microSD card and boot it on your Raspberry Pi 4 to find out. There
    should be a Python script at `/usr/bin/gatt_server.py`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的软件成功构建并安装，它应该包含在完成的`rpi-test-image-raspberrypi4-64.rootfs.wic.bz2`镜像中。将该镜像写入microSD卡，并在你的Raspberry
    Pi 4上启动它查看。应该可以在`/usr/bin/gatt_server.py`找到一个Python脚本。
- en: Adding packages to `conf/local.conf` makes sense during the earliest stages
    of development. When you are ready to share the fruits of your labor with the
    rest of your team, you should create an image recipe and put your packages there.
    At the end of the previous chapter, we went all the way and wrote a `nova-image`
    recipe to add a `helloworld` package to `core-image-minimal`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 将软件包添加到`conf/local.conf`中，在开发的最初阶段是有意义的。当你准备好与团队分享你的成果时，你应该创建一个镜像配方，并将你的软件包放在那里。在上一章的结尾，我们完成了并编写了一个`nova-image`配方，将`helloworld`包添加到`core-image-minimal`中。
- en: Now that we’ve spent a good amount of time testing newly built images on actual
    hardware, it’s time to turn our attention back to software. In the next section,
    we’ll look at a tool that was designed to streamline the tedious compile, test,
    and debug cycle we’ve grown accustomed to while developing embedded software.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经花了不少时间在实际硬件上测试新构建的镜像，是时候将注意力转回软件了。在接下来的部分，我们将介绍一个工具，它旨在简化我们在开发嵌入式软件时习惯的冗长编译、测试和调试周期。
- en: Capturing changes with devtool
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用devtool捕获更改
- en: In the previous chapter, you learned how to create a recipe for a `helloworld`
    program from scratch. A copy-paste approach to packaging recipes may work initially,
    but it soon becomes very frustrating as your project grows and the number of recipes
    you need to maintain multiplies. I’m here to show you a better way of working
    with package recipes – both yours and those that are contributed to upstream by
    some third party. It is called `devtool` and it is the cornerstone of Yocto’s
    extensible SDK.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了如何从头开始为`helloworld`程序创建一个配方。最初，复制粘贴的方式可以工作，但随着项目的增长和你需要维护的配方数量的增加，这种方式很快就会变得令人沮丧。我将在这里展示一种更好的方法来处理软件包配方——无论是你自己的，还是第三方贡献给上游的。它叫做`devtool`，是Yocto可扩展SDK的基石。
- en: Development workflows
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发工作流程
- en: 'Before you get started with `devtool`, you want to make sure that you’re doing
    your work in a new layer instead of modifying recipes in-tree. Otherwise, you
    could easily overwrite and lose hours and hours of work:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始使用`devtool`之前，确保你在一个新的层中进行工作，而不是修改树中的配方。否则，你可能会轻易地覆盖并丢失数小时的工作：
- en: First, navigate one level above the directory where you cloned Yocto.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，导航到克隆Yocto目录的上一级。
- en: 'Next, set up your BitBake work environment:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，设置你的BitBake工作环境：
- en: '[PRE74]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This sets a bunch of environment variables and puts you in a new `build-mine`
    directory.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将设置一堆环境变量，并将你置于一个新的`build-mine`目录中。
- en: 'Set `MACHINE` in `conf/local.conf` for 64-bit Arm:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`conf/local.conf`中为64位Arm设置`MACHINE`：
- en: '[PRE75]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Create your new layer:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建你的新层：
- en: '[PRE76]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Now, add your new layer:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加你的新层：
- en: '[PRE77]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Check that your new layer was created where you want it to be:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查你创建的新层是否位于你希望的位置：
- en: '[PRE78]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The output of `bitbake-layers show-layers` should look like this:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`bitbake-layers show-layers`的输出应该如下所示：'
- en: '[PRE79]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'To get some first-hand experience with development workflows, you are going
    to need a target to deploy to. That means building an image:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得一些开发工作流程的第一手经验，你需要一个目标设备来进行部署。这意味着要构建一个镜像：
- en: '[PRE80]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Building a full image takes a few hours the first time. When it’s complete,
    go ahead and boot it:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次构建完整镜像通常需要几个小时。当完成时，继续启动它：
- en: '[PRE81]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: By specifying the `nographic` option, we can run QEMU directly in a separate
    shell. This makes typing easier than having to cope with the emulated graphics
    output. Log in as `root`. There is no password. Leave QEMU running for now because
    we need it for the subsequent exercises. You can SSH into this VM with `ssh root@192.168.7.2`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 通过指定`nographic`选项，我们可以直接在一个独立的 shell 中运行 QEMU。这比应对模拟的图形输出更容易输入。以`root`身份登录，密码为空。现在保持
    QEMU 运行，因为我们接下来的练习需要它。你可以通过`ssh root@192.168.7.2`登录到这个虚拟机。
- en: '`devtool` supports three common development workflows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`devtool`支持三种常见的开发工作流：'
- en: Add a new recipe.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个新配方。
- en: Patch the source built by an existing recipe.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修补现有配方构建的源代码。
- en: Upgrade a recipe to fetch a newer version of the upstream source.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 升级配方以获取上游源的更新版本。
- en: When you initiate any of these workflows, `devtool` creates a temporary workspace
    for you to make your changes. This sandbox contains the recipe files and fetched
    source. When you are done with your work, `devtool` integrates your changes back
    into your layer so that the workspace can be destroyed.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 当你启动任何这些工作流时，`devtool`会为你创建一个临时工作区，以便你进行修改。这个沙盒包含配方文件和已获取的源代码。当你完成工作后，`devtool`会将你的更改集成回你的层，以便销毁工作区。
- en: Creating a new recipe
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个新配方。
- en: Let’s say there is some open source software you want that no one has submitted
    a BitBake recipe for yet. And let’s say that the software in question is the `validator`
    file-signing, verification, and installation tool. In this instance, you could
    download a source tarball release of `validator` from GitHub and create a recipe
    for it. That’s exactly what `devtool add` does.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个开源软件你想要，但没有人提交过 BitBake 配方。而且假设这个软件是`validator`文件签名、验证和安装工具。在这种情况下，你可以从
    GitHub 下载`validator`的源 tarball 发布包，并为其创建一个配方。这正是`devtool add`所做的。
- en: 'First, `devtool add` creates a workspace with its own local Git repository.
    Inside this new workspace directory, it creates a `recipes/validator` directory
    and extracts the tarball contents into a `sources/validator` directory. `devtool`
    knows about popular build systems such as Autotools and CMake and will do its
    best to figure out what kind of project this is (Autotools in the case of `validator`).
    It then uses parsed metadata and built package data cached from previous BitBake
    builds to figure out the values of `DEPENDS` and `RDEPENDS` as well as what files
    to inherit and require:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`devtool add`会创建一个带有本地 Git 仓库的工作区。在这个新的工作区目录中，它会创建一个`recipes/validator`目录，并将
    tarball 内容提取到`sources/validator`目录。`devtool`了解常见的构建系统，如 Autotools 和 CMake，并会尽力弄清楚这是什么类型的项目（在`validator`的情况下是
    Autotools）。然后，它使用解析后的元数据和从以前的 BitBake 构建中缓存的已构建包数据来确定`DEPENDS`和`RDEPENDS`的值，以及要继承和要求的文件：
- en: First, open another shell and navigate one level above the directory where you
    cloned Yocto.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开另一个 shell 并进入你克隆 Yocto 的目录上一级。
- en: 'Next, set up your BitBake environment:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，设置你的 BitBake 环境：
- en: '[PRE82]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: This sets a bunch of environment variables and puts you back in your `build-mine`
    working directory.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这会设置一组环境变量，并将你带回`build-mine`工作目录。
- en: 'Then, run `devtool add` with the URL of the source tarball release:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用源 tarball 发布包的 URL 运行`devtool add`：
- en: '[PRE83]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '`devtool add` will generate a recipe that you can then build.'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`devtool add`将生成一个配方，你可以用它来构建。'
- en: 'Before you build your new recipe, let’s take a look at it:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你构建新的配方之前，让我们先看看它：
- en: '[PRE84]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '`devtool` will open `recipes/validator/validator_0.2.2.bb` in an editor. Notice
    that `devtool` has already filled in the MD5 checksums for you.'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`devtool`会在编辑器中打开`recipes/validator/validator_0.2.2.bb`。注意，`devtool`已经为你填写了
    MD5 校验和。'
- en: 'Add this line to the end of `validator_0.2.2.bb`:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下行添加到`validator_0.2.2.bb`的末尾：
- en: '[PRE85]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Correct any obvious mistakes, save any changes, and exit your editor.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修正任何明显的错误，保存任何更改，然后退出编辑器。
- en: 'To build your new recipe, use the following command:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要构建你的新配方，请使用以下命令：
- en: '[PRE86]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Next, deploy the compiled `validator` executable to the target emulator:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将编译好的`validator`可执行文件部署到目标模拟器：
- en: '[PRE87]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: This installs the necessary build artifacts onto the target emulator.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这会将必要的构建工件安装到目标模拟器上。
- en: 'From your QEMU shell, run the `validator` executable that you just built and
    deployed:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从你的 QEMU shell 中，运行你刚刚构建和部署的`validator`可执行文件：
- en: '[PRE88]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: If you see a bunch of `validator`-related self-documentation, then the build
    and deployment were successful. If you do not, then use `devtool` to repeat the
    edit, build, and deploy steps until you are convinced that `validator` works.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你看到大量与`validator`相关的自文档，那么说明构建和部署成功。如果没有看到，使用`devtool`重复编辑、构建和部署步骤，直到你确信`validator`能够正常工作。
- en: 'Once you are satisfied, clean up your target emulator:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你满意了，清理你的目标仿真器：
- en: '[PRE89]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Merge all your work back into your layer:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有工作合并回你的层：
- en: '[PRE90]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Delete the leftover sources from the workspace:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除工作区中剩余的源代码：
- en: '[PRE91]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: If you think others might benefit from your new recipe, then submit a patch
    to Yocto.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为其他人可能从你的新配方中受益，那么可以将补丁提交到Yocto。
- en: Modifying the source built by a recipe
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改由配方构建的源代码
- en: Let’s say you find a bug in `jq`, a command-line JSON preprocessor. You search
    the Git repository at [https://github.com/stedolan/jq](https://github.com/stedolan/jq)
    and find that no one has reported the issue. Then, you look at the source code.
    It turns out that the fix requires just a few small code changes, so you decide
    to patch `jq` yourself. That’s where `devtool` modify comes in.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你在`jq`（一个命令行JSON预处理器）中发现了一个bug。你在[https://github.com/stedolan/jq](https://github.com/stedolan/jq)上搜索Git仓库，发现没有人报告这个问题。然后，你查看源代码。原来修复只需要几个小的代码修改，于是你决定自己给`jq`打补丁。这时，`devtool
    modify`就派上用场了。
- en: 'This time, when `devtool` looks at Yocto’s cached metadata, it sees that a
    recipe already exists for `jq`. Like `devtool add`, `devtool modify` creates a
    new temporary workspace with its own local Git repository where it copies the
    recipe files and extracts the upstream sources. `jq` is written in C and located
    in an existing OpenEmbedded layer named `meta-oe`. We need to add this layer as
    well as `jq`''s dependencies to our working image before we can modify the package
    source:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，当`devtool`查看Yocto的缓存元数据时，它会发现`jq`已经有一个配方。如同`devtool add`，`devtool modify`会创建一个新的临时工作区，并在其中复制配方文件并提取上游源代码。`jq`是用C语言编写的，并位于名为`meta-oe`的现有OpenEmbedded层中。在我们能够修改软件包源代码之前，需要将此层以及`jq`的依赖项添加到我们的工作镜像中：
- en: 'First, delete a couple of layers from your `build-mine` environment:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，删除`build-mine`环境中的几个层：
- en: '[PRE92]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Next, clone the `meta-openembedded` repository from GitHub if it does not exist
    already:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，从GitHub克隆`meta-openembedded`仓库（如果尚未存在）：
- en: '[PRE93]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Then, add the `meta-oe` and `meta-mine` layers to your image:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将`meta-oe`和`meta-mine`层添加到你的镜像中：
- en: '[PRE94]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Verify that all the necessary layers have been added to the image:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证所有必要的层是否已被添加到镜像中：
- en: '[PRE95]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The output of the command should look like this:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命令的输出应该如下所示：
- en: '[PRE96]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Add the following line to `conf/local.conf` because the `onig` package is a
    runtime dependency of `jq`:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`conf/local.conf`中添加以下行，因为`onig`包是`jq`的运行时依赖：
- en: '[PRE97]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Rebuild your image:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新构建你的镜像：
- en: '[PRE98]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Exit QEMU with *Ctrl + A* and *x* from your other shell and restart the emulator:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*Ctrl + A*和*x*从另一个终端退出QEMU并重启仿真器：
- en: '[PRE99]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Like many patching tools, `devtool modify` uses your commit messages to generate
    patch filenames, so keep your commit messages brief and meaningful. It also automatically
    generates the patch files themselves based on your GitHub history and creates
    a `.bbappend` file with the new patch filenames. Remember to prune and squash
    your Git commits so that `devtool` divides your work up into sensible patch files:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 像许多补丁工具一样，`devtool modify`使用你的提交信息来生成补丁文件名，因此请保持提交信息简洁且有意义。它还会根据你的GitHub历史自动生成补丁文件，并创建一个包含新补丁文件名的`.bbappend`文件。记得修剪和压缩你的Git提交，以便`devtool`能够将你的工作合理地划分为补丁文件：
- en: 'Run `devtool modify` with the name of the package you wish to modify:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`devtool modify`命令并指定你希望修改的软件包名称：
- en: '[PRE100]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Make your code changes using your preferred editor. Use the standard Git add
    and commit workflow to keep track of what you’ve done.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你喜欢的编辑器进行代码更改。使用标准的Git添加和提交工作流来跟踪你所做的更改。
- en: 'Build the modified sources using the following command:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令构建修改过的源代码：
- en: '[PRE101]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Next, deploy the compiled `jq` executable to the target emulator:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将编译后的`jq`可执行文件部署到目标仿真器：
- en: '[PRE102]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: This installs the necessary build artifacts onto the target emulator.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将必要的构建工件安装到目标仿真器中。
- en: 'If connecting fails, then delete the stale emulator’s key as shown here:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果连接失败，请删除过期仿真器的密钥，具体操作如下：
- en: '[PRE103]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Replace `frank` with your username in the path.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在路径中将`frank`替换为你的用户名。
- en: From your QEMU shell, run the `jq` executable that you just built and deployed.
    If you can no longer reproduce the bug, then your changes worked. Otherwise, repeat
    the edit, build, and deploy steps until you are satisfied.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从你的 QEMU shell 中运行你刚刚构建并部署的 `jq` 可执行文件。如果你无法再复现该 bug，那么你的更改是有效的。否则，重复编辑、构建和部署步骤，直到你满意为止。
- en: 'Once you are satisfied, clean up your target emulator:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你满意了，清理你的目标仿真器：
- en: '[PRE104]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Merge all your work back into your layer:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有工作合并回你的层：
- en: '[PRE105]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: If the merge fails because the Git source tree is dirty, then remove or unstage
    any leftover `jq` build artifacts and try `devtool finish` again.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果合并失败是因为 Git 源树有更改未提交，请删除或撤销任何剩余的 `jq` 构建工件，并再次尝试运行 `devtool finish`。
- en: 'Delete the leftover sources from the workspace:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除工作区中剩余的源文件：
- en: '[PRE106]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: If you think others might benefit from your patch or patches, then submit them
    to the upstream project maintainers.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为其他人也能受益于你的补丁，可以将其提交给上游项目的维护者。
- en: Upgrading a recipe to a newer version
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 升级配方到新版本
- en: 'Let’s say you’re using the mypy Python static typechecker to develop on your
    target device and a new version of mypy has just been released. This latest version
    of mypy has a new feature that you just can’t wait to get your hands on. Instead
    of waiting for the mypy recipe maintainers to upgrade to the new release version,
    you decide to upgrade the recipe yourself. You would think that would be as easy
    as bumping a version number in a recipe file, but there are also source archive
    checksums involved. Wouldn’t it be great if the tedious process could be fully
    automated? Guess what devtool upgrade is for? mypy is a Python 3 module, so your
    image needs to include Python 3, mypy, and mypy’s dependencies before you can
    upgrade it. To obtain all of them, follow these steps:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在使用 mypy Python 静态类型检查器在目标设备上进行开发，并且 mypy 的新版本刚刚发布。这个最新版本的 mypy 有一个新特性，你迫不及待地想要使用它。在等待
    mypy 配方维护者升级到新版本之前，你决定自己升级配方。你可能会认为，这就像在配方文件中修改版本号一样简单，但其实还涉及到源代码归档的校验和。如果这个繁琐的过程可以完全自动化，那该多好？猜猜
    `devtool upgrade` 是用来做什么的？mypy 是一个 Python 3 模块，因此在你升级它之前，你的镜像需要包含 Python 3、mypy
    以及 mypy 的依赖项。要获取它们，按照以下步骤操作：
- en: 'First, delete a couple of layers from your build-mine environment:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，从你的构建环境中删除几层：
- en: '[PRE107]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Next, add the meta-python and meta-mine layers to your image:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将 meta-python 和 meta-mine 层添加到你的镜像中：
- en: '[PRE108]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '3\. Verify that all the necessary layers have been added to the project:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3\. 验证所有必要的层是否已添加到项目中：
- en: '[PRE109]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'The output of the command should look like this:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命令的输出应如下所示：
- en: '[PRE110]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Now, there should be lots of Python modules available for you to use:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，应该有很多 Python 模块可以供你使用：
- en: '[PRE111]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: One of those modules is `python3-mypy`.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其中一个模块是 `python3-mypy`。
- en: 'Make sure `python3` and `python3-mypy` are being built and installed on your
    image by searching for both of them inside `conf/local.conf`. If they are not
    there, then you can include them both by adding the following line to your `conf/local.conf`:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在 `conf/local.conf` 中搜索 `python3` 和 `python3-mypy`，确保它们都正在构建并安装到你的镜像中。如果它们不在那里，你可以通过向
    `conf/local.conf` 添加以下行来包括它们：
- en: '[PRE112]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Rebuild your image:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新构建你的镜像：
- en: '[PRE113]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Exit QEMU with Ctrl + A and x from your other shell and restart the emulator:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从另一个 shell 使用 Ctrl + A 和 x 退出 QEMU，并重启仿真器：
- en: '[PRE114]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '**IMPORTANT NOTE**'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**重要说明**'
- en: At the time of writing, the version of mypy included with meta-python is 1.9.0
    and the latest version of mypy available on PyPI is 1.12.1.
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在写作时，meta-python 中包含的 mypy 版本是 1.9.0，而 PyPI 上可用的最新版本是 1.12.1。
- en: 'Now that all the pieces are in place, let’s do the upgrade:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有步骤都已到位，让我们进行升级：
- en: 'First, run devtool upgrade with the name of the package and the target version
    to upgrade to:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用包的名称和目标版本运行 devtool upgrade 进行升级：
- en: '[PRE115]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Before you build your upgraded recipe, let’s take a look at it:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构建你升级后的配方之前，我们先看一下它：
- en: '[PRE116]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: devtool will open `recipes/python3-mypy/python3-mypy_1.12.1.bb` in an editor.
    There is nothing version-specific to change in this recipe, so save the new file
    and exit your editor.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: devtool 会在编辑器中打开 `recipes/python3-mypy/python3-mypy_1.12.1.bb` 文件。这个配方中没有任何版本特定的修改内容，所以保存新文件并退出编辑器。
- en: 'To build your new recipe, use this command:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要构建你的新配方，请使用以下命令：
- en: '[PRE117]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Next, deploy your new mypy module to the target emulator:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将新的 mypy 模块部署到目标仿真器：
- en: '[PRE118]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: This installs the necessary build artifacts onto the target emulator.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将必要的构建工件安装到目标仿真器上。
- en: 'If connecting fails, then delete the stale emulator’s key as shown here:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果连接失败，请按照这里所示删除过期的仿真器密钥：
- en: '[PRE119]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Replace frank with your username in the path.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在路径中将 frank 替换为你的用户名。
- en: 'From your QEMU shell, check what version of mypy was deployed:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从你的 QEMU shell 中，检查部署了哪个版本的 mypy：
- en: '[PRE120]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: If entering `mypy --version` returns ‘`1.12.1`', then the upgrade worked. If
    it does not, then use devtool to repeat the edit, build, and deploy steps until
    you’ve figured out what went wrong.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果输入 `mypy --version` 返回‘`1.12.1`’，那么升级成功。如果没有返回该版本，则使用 `devtool` 重复编辑、构建和部署步骤，直到找出问题所在。
- en: 'Once you are satisfied, clean up your target emulator:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你满意，清理你的目标模拟器：
- en: '[PRE121]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Clean up your workspace:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清理你的工作空间：
- en: '[PRE122]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Commit a change to SOURCES.txt:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交对 `SOURCES.txt` 的更改：
- en: '[PRE123]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Merge all your work back into your layer:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你所有的工作合并回到你的层中：
- en: '[PRE124]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: devtool finish moves the sources to a folder called attic.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '`devtool finish` 将源代码移动到一个名为 attic 的文件夹中。'
- en: If the merge fails because the GitHub source tree is dirty, then remove or unstage
    any leftover `python3-mypy` build artifacts and try devtool finish again.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果合并失败，因为 GitHub 源代码树脏了，那么移除或撤销任何剩余的 `python3-mypy` 构建工件，然后再次尝试 `devtool finish`。
- en: 'Delete the leftover sources from the workspace:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除工作空间中剩余的源代码：
- en: '[PRE125]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: If you think others might also be anxious to upgrade their distros to the latest
    version of a package, then submit a patch to Yocto.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为其他人也可能急于将他们的发行版升级到某个包的最新版本，那么提交一个补丁到 Yocto。
- en: Finally, we’ve arrived at the topic of how to build our own distro. This feature
    is unique to Yocto and notably missing from Buildroot. A **distro layer** is a
    powerful abstraction that can be shared across multiple projects targeting different
    hardware.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来到了如何构建自己发行版的话题。这个功能是 Yocto 特有的，而在 Buildroot 中明显缺失。**发行版层**是一个强大的抽象，可以跨多个项目共享，针对不同硬件。
- en: Building your own distro
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建你自己的发行版
- en: At the start of the previous chapter, I told you about distro layers such as
    `meta-poky` and the distribution metadata contained in their `conf/distro` subdirectories.
    As we have seen, you don’t need your own distro layer to build your own custom
    images. You can go a long way without ever having to modify any of Poky’s distribution
    metadata. But if you want to alter distro policies (e.g., features, C library
    implementations, choice of package manager, and so on), then you can choose to
    build your own distro.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章开始时，我告诉你关于发行版层，例如 `meta-poky` 和它们的 `conf/distro` 子目录中包含的发行版元数据。正如我们所见，你不需要自己的发行版层就能构建定制的镜像。你可以在不修改任何
    Poky 发行版元数据的情况下，完成很多工作。但如果你想修改发行版政策（例如功能、C 库实现、包管理器选择等），那么你可以选择构建自己的发行版。
- en: 'Building your own distro is a three-step process:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 构建你自己的发行版是一个三步过程：
- en: Create a new distro layer.
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的发行版层。
- en: Create a distro configuration file.
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个发行版配置文件。
- en: Add more recipes to your distro.
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为你的发行版添加更多配方。
- en: But before we get into the technical details of how to do that, let’s consider
    when it’s the right time to roll your own distro.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 但在进入如何执行这些操作的技术细节之前，让我们先考虑一下，什么时候是自己制作发行版的合适时机。
- en: When and when not to
  id: totrans-403
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么时候该做，什么时候不该做
- en: Distro settings define the package format (`rpm`, `deb`, or `ipk`), package
    feed, `init` system (`systemd` or `sysvinit`), and specific package versions.
    You could create your own distro in a new layer by inheriting from Poky and overriding
    what needs to change for your distro. However, if you find yourself adding a lot
    of values to your build directory’s `local.conf` file aside from the obvious local
    settings (such as relative paths), then it is probably time to create your own
    distro from scratch.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 发行版设置定义了包格式（`rpm`、`deb` 或 `ipk`）、包源、`init` 系统（`systemd` 或 `sysvinit`）以及特定包版本。你可以通过从
    Poky 继承并覆盖需要为你的发行版改变的部分，来在一个新层中创建自己的发行版。然而，如果你发现自己除了明显的本地设置（例如相对路径）之外，向构建目录的 `local.conf`
    文件中添加了很多值，那么可能是时候从头开始创建你自己的发行版了。
- en: Creating a new distro layer
  id: totrans-405
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个新的发行版层
- en: You know how to create a layer. Creating a distro layer is no different.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道如何创建一个层。创建发行版层没有什么不同。
- en: First, navigate one level above the directory where you cloned Yocto.
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，导航到你克隆 Yocto 的目录的上一层。
- en: 'Next, set up your BitBake work environment:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，设置你的 BitBake 工作环境：
- en: '[PRE126]'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: This sets a bunch of environment variables and puts you back in the `build-rpi`
    directory from earlier.
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这会设置一堆环境变量，并将你带回到之前的 `build-rpi` 目录。
- en: 'Delete the `meta-gattd` layer from your `build-rpi` environment:'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从你的 `build-rpi` 环境中删除 `meta-gattd` 层：
- en: '[PRE127]'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Comment out or delete `CORE_IMAGE_EXTRA_INSTALL` from `conf/local.conf`:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注释掉或删除 `conf/local.conf` 中的 `CORE_IMAGE_EXTRA_INSTALL`：
- en: '[PRE128]'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Create a new layer for our distro:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的发行版创建一个新层：
- en: '[PRE129]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Now, add our new layer to the `build-rpi` configuration:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将我们的新层添加到 `build-rpi` 配置中：
- en: '[PRE130]'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: The name of our distro is `mackerel`. Creating our own distro layer enables
    us to keep distro policies separate from package recipes (the implementation).
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的发行版名称是 `mackerel`。创建我们自己的发行版层使我们能够将发行版策略与包配方（实现）分开。
- en: Configuring your distro
  id: totrans-420
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置你的发行版
- en: Create the distro configuration file in the `conf/distro` directory of your
    `meta-mackerel` distro layer. Give it the same name as your distro (e.g., `mackerel.conf`).
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `meta-mackerel` 发行版层的 `conf/distro` 目录中创建发行版配置文件。给它取与发行版相同的名字（例如：`mackerel.conf`）。
- en: 'Set the required `DISTRO_NAME` and `DISTRO_VERSSION` variables in `conf/distro/mackerel.conf`:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `conf/distro/mackerel.conf` 中设置所需的 `DISTRO_NAME` 和 `DISTRO_VERSSION` 变量：
- en: '[PRE131]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'The following optional variables can also be set in `mackerel.conf`:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 以下可选变量也可以在`mackerel.conf`中设置：
- en: '[PRE132]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: Once you are done with those variables, you can define just about any variable
    in `conf/local.conf` that you want for your distro. Look at other distros’ `conf/distro`
    directories, such as Poky’s, to see how they organize things, or copy and use
    `poky/meta/conf/distro/defaultsetup.conf` as a template. If you decide to break
    your distro configuration file up into multiple include files, make sure to place
    them in the `conf/distro/include` directory of your layer.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些变量设置后，你可以在 `conf/local.conf` 中定义你想要的几乎任何变量。查看其他发行版的 `conf/distro` 目录，例如
    Poky 的目录，看看它们是如何组织的，或者复制并使用 `poky/meta/conf/distro/defaultsetup.conf` 作为模板。如果你决定将发行版配置文件拆分成多个包含文件，确保将它们放在你层的
    `conf/distro/include` 目录中。
- en: Adding more recipes to your distro
  id: totrans-427
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向你的发行版添加更多的配方
- en: Add more distro-related metadata to your distro layer. You will want to add
    recipes for additional configuration files. These are configuration files that
    have yet to be installed by an existing recipe. More importantly, you will also
    want to add append files to customize existing recipes and add their configuration
    files to your distro.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 向你的发行版层添加更多的发行版相关元数据。你将需要为额外的配置文件添加配方。这些是尚未通过现有配方安装的配置文件。更重要的是，你还需要添加附加文件来定制现有的配方，并将它们的配置文件添加到你的发行版中。
- en: Runtime package management
  id: totrans-429
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行时包管理
- en: Including a package manager for your distro images is great for enabling secure
    over-the-air updates and rapid application development. When your team works on
    software that revs multiple times a day, frequent package updates are one way
    to keep everybody in sync and moving forward. Full image updates are unnecessary
    (only one package changes) and disruptive (reboot required). Being able to fetch
    packages from a remote server and install them on a target device is known as
    **runtime package management**.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在发行版镜像中包含一个包管理器非常适合启用安全的空中更新和快速的应用开发。当你的团队在软件上频繁更新（每天多次迭代）时，频繁的包更新是一种保持每个人同步并向前推进的方式。完整的镜像更新是不必要的（只有一个包发生变化）且具有干扰性（需要重启）。能够从远程服务器获取包并将其安装到目标设备上，被称为**运行时包管理**。
- en: Yocto has support for different package formats (`rpm`, `ipk`, and `deb`) and
    different package managers (`dnf` and `opkg`). The package format you select for
    your distro determines which package manager you can include on it.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: Yocto 支持不同的包格式（`rpm`、`ipk` 和 `deb`）以及不同的包管理器（`dnf` 和 `opkg`）。你为发行版选择的包格式决定了可以在其上使用的包管理器。
- en: 'To select a package format for our distro, you can set the `PACKAGE_CLASSES`
    variable in your distro’s `conf` file. Add this line to `meta-mackerel/conf/distro/mackerel.conf`:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 要为你的发行版选择包格式，可以在发行版的 `conf` 文件中设置 `PACKAGE_CLASSES` 变量。将以下行添加到 `meta-mackerel/conf/distro/mackerel.conf`
    中：
- en: '[PRE133]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Now, let’s return to the `build-rpi` directory:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到 `build-rpi` 目录：
- en: '[PRE134]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'We are targeting Raspberry Pi 4, so make sure `MACHINE` is still set accordingly
    in `conf/local.conf`:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是 Raspberry Pi 4，因此请确保 `MACHINE` 在 `conf/local.conf` 中仍然正确设置：
- en: '[PRE135]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Comment out `PACKAGE_CLASSES` in your build directory’s `conf/local.conf` since
    our distro already selects `package_ipk`:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的构建目录的 `conf/local.conf` 中注释掉 `PACKAGE_CLASSES`，因为我们的发行版已经选择了 `package_ipk`：
- en: '[PRE136]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'To enable runtime package management, append `package-management` to the list
    of `EXTRA_IMAGE_FEATURES` in your build directory’s `conf/local.conf`:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启用运行时包管理，将 `package-management` 添加到构建目录 `conf/local.conf` 中 `EXTRA_IMAGE_FEATURES`
    的列表中：
- en: '[PRE137]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: This will install a package database containing all the packages from your current
    build onto your distro image. A prepopulated package database is optional because
    you can always initialize a package database on the target after your distro image
    has been deployed.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装一个包含当前构建中所有包的包数据库到你的发行版镜像中。预填充的包数据库是可选的，因为你总是可以在发行版镜像部署到目标后初始化包数据库。
- en: 'Lastly, set the `DISTRO` variable in your build directory’s `conf/local.conf`
    file to the name of our distro:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在构建目录的 `conf/local.conf` 文件中设置 `DISTRO` 变量为我们发行版的名称：
- en: '[PRE138]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: This points your build directory’s `conf/local.conf` file at our distro configuration
    file.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 这将你的构建目录的 `conf/local.conf` 文件指向我们的发行版配置文件。
- en: 'Finally, we are ready to build our distro:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们准备构建我们的发行版：
- en: '[PRE139]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'We are rebuilding `rpi-test-image` with a different package format, so this
    will take a little while. The finished images are placed in a different directory
    this time around:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在用不同的包格式重新构建 `rpi-test-image`，所以这需要一些时间。完成的镜像这次会放在一个不同的目录中：
- en: '[PRE140]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Write the image to a microSD card using Etcher and boot it on your Raspberry
    Pi 4\. Plug it into your Ethernet and SSH in like you did previously:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Etcher 将镜像写入 microSD 卡，并在你的 Raspberry Pi 4 上启动。像之前一样插入以太网并通过 SSH 连接：
- en: '[PRE141]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'If connecting fails, then delete Raspberry Pi’s stale key, as shown here:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 如果连接失败，请删除 Raspberry Pi 的过期密钥，如下所示：
- en: '[PRE142]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: Replace `frank` with your username in the path.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 在路径中将 `frank` 替换为你的用户名。
- en: 'Once you have logged in, verify that the `opkg` package manager has been installed:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 登录后，验证是否已安装 `opkg` 包管理器：
- en: '[PRE143]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: A package manager isn’t of much use without a remote package server to pull
    it from.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 没有远程包服务器，包管理器几乎没有用。
- en: Provisioning a remote package server
  id: totrans-458
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置远程包服务器
- en: Setting up an HTTP remote package server and pointing your target clients at
    it is easier than you might think. The client-side server address configuration
    varies between package managers. We will configure `opkg` manually on Raspberry
    Pi 4.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 HTTP 远程包服务器并指向目标客户端比你想象的要简单。客户端的服务器地址配置在不同的包管理器之间有所不同。我们将手动配置 Raspberry Pi
    4 上的 `opkg`。
- en: 'Let’s start with the package server:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从包服务器开始：
- en: First, navigate one level above the directory where you cloned Yocto.
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，导航到你克隆 Yocto 的目录的上一层。
- en: 'Next, set up your BitBake work environment:'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，设置你的 BitBake 工作环境：
- en: '[PRE144]'
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: This sets a bunch of environment variables and puts you back in the `build-rpi`
    directory.
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这会设置一堆环境变量，并让你回到 `build-rpi` 目录。
- en: 'Build the `curl` package:'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建 `curl` 包：
- en: '[PRE145]'
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Populate the package index:'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填充包索引：
- en: '[PRE146]'
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Locate the package installer files:'
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位包安装文件：
- en: '[PRE147]'
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: There should be three directories, named cortexa72, all, and raspberrypi4_64,
    in ipk. The architecture directory is cortexa72 while the machine directory is
    raspberrypi4_64\. The names of these two directories will vary depending on how
    your image has been configured for building.
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 ipk 中应该有三个目录，分别是 cortexa72、all 和 raspberrypi4_64。架构目录是 cortexa72，机器目录是 raspberrypi4_64。根据镜像的构建配置，这两个目录的名称可能会有所不同。
- en: 'Navigate to the `ipk` directory, which is where the package installer files
    are:'
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 `ipk` 目录，这是包安装文件所在的地方：
- en: '[PRE148]'
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: Get the IP address of your Linux host machine.
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取你 Linux 主机的 IP 地址。
- en: 'Start the HTTP package server:'
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 HTTP 包服务器：
- en: '[PRE149]'
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: Replace `192.168.1.69` with your Linux host machine’s IP address.
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `192.168.1.69` 替换为你的 Linux 主机的 IP 地址。
- en: 'Now, let’s configure the target client:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们配置目标客户端：
- en: 'SSH back into your Raspberry Pi 4:'
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过 SSH 重新连接到你的 Raspberry Pi 4：
- en: '[PRE150]'
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'Edit `/etc/opkg/opkg.conf` so that it looks like this:'
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `/etc/opkg/opkg.conf`，使其如下所示：
- en: '[PRE151]'
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: Replace `192.168.1.69` with your Linux host machine’s IP address.
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `192.168.1.69` 替换为你的 Linux 主机的 IP 地址。
- en: 'Run `opkg update`:'
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `opkg update`：
- en: '[PRE152]'
  id: totrans-485
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'Try to run `curl`:'
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试运行 `curl`：
- en: '[PRE153]'
  id: totrans-487
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE153]'
- en: The command should fail because `curl` is not installed.
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于没有安装 `curl`，命令应该会失败。
- en: 'Install `curl`:'
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 `curl`：
- en: '[PRE154]'
  id: totrans-490
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Verify that `curl` was installed:'
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证 `curl` 是否已安装：
- en: '[PRE155]'
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'As you continue to work in the `build-rpi` directory from a Linux host machine,
    you can check for updates from your Raspberry Pi 4:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 当你继续在 Linux 主机的 `build-rpi` 目录中工作时，你可以从 Raspberry Pi 4 检查更新：
- en: '[PRE156]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'Then, you can apply them:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以应用它们：
- en: '[PRE157]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: This is faster than rewriting an image, swapping out the microSD card, and rebooting.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 这样比重写镜像、交换 microSD 卡并重新启动更快。
- en: Summary
  id: totrans-498
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: I know that was a lot to absorb. And trust me – this is just the beginning.
    Yocto certainly has a steep learning curve. Luckily, there is lots of documentation
    and a friendly community to guide you. There is also `devtool` to automate much
    of the tedium and mistakes of copy-paste development. If you use the tools provided
    for you and continually save your work to your own layers, Yocto doesn’t have
    to be painful. Before you know it, you’ll be rolling your own distro layer and
    running your own remote package server.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道这可能有点多，理解起来需要些时间。相信我——这只是个开始。Yocto 确实有一个陡峭的学习曲线。幸运的是，Yocto 有大量文档和友好的社区可以指导你。还有
    `devtool` 来自动化许多复制粘贴开发中的枯燥和错误。如果你使用提供的工具，并不断将工作保存到自己的层中，Yocto 并不需要那么痛苦。不久之后，你将能够打造自己的发行版层并运行自己的远程包服务器。
- en: A remote package server is just one way to deploy packages and applications.
    We will learn about a few others later in [*Chapter 15*](Chapter_15.xhtml#_idTextAnchor483).
    Despite the title, some of the techniques we’ll look at in that chapter (e.g.,
    conda) apply to any programming language. While package managers are great for
    development, runtime package management is not commonly used on embedded systems
    running in production. We will look closely at full image and containerized over-the-air
    update mechanisms in [*Chapter 10*](Chapter_10.xhtml#_idTextAnchor341).
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 远程包服务器只是部署包和应用程序的一种方式。我们将在稍后的[*第15章*](Chapter_15.xhtml#_idTextAnchor483)中了解其他几种方法。尽管标题如此，但我们将在该章节中看到的一些技术（例如，conda）适用于任何编程语言。虽然包管理器在开发中非常有用，但在生产环境中运行的嵌入式系统上，运行时包管理并不常见。我们将在[*第10章*](Chapter_10.xhtml#_idTextAnchor341)中深入研究完整镜像和容器化空中更新机制。
- en: Further study
  id: totrans-501
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入学习
- en: '*Transitioning to a custom environment for systems development*, Yocto Project
    – [https://docs.yoctoproject.org/transitioning-to-a-custom-environment.html](https://docs.yoctoproject.org/transitioning-to-a-custom-environment.html)'
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*过渡到自定义环境进行系统开发*，Yocto 项目 – [https://docs.yoctoproject.org/transitioning-to-a-custom-environment.html](https://docs.yoctoproject.org/transitioning-to-a-custom-environment.html)'
- en: '*Yocto Project Development Tasks Manual*, Yocto Project – [https://docs.yoctoproject.org/dev-manual/](https://docs.yoctoproject.org/dev-manual/)'
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Yocto 项目开发任务手册*，Yocto 项目 – [https://docs.yoctoproject.org/dev-manual/](https://docs.yoctoproject.org/dev-manual/)'
- en: '*Using Devtool to Streamline Your Yocto Project Workflow*, by Tim Orling –
    [https://www.youtube.com/watch?v=CiD7rB35CRE](https://www.youtube.com/watch?v=CiD7rB35CRE)'
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Devtool 简化你的 Yocto 项目工作流程*，Tim Orling 撰写 – [https://www.youtube.com/watch?v=CiD7rB35CRE](https://www.youtube.com/watch?v=CiD7rB35CRE)'
