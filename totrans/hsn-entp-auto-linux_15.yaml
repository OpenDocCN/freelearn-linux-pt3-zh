- en: Performing Routine Maintenance with Ansible
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '使用 Ansible 执行常规维护  '
- en: As you have worked through this book, you will have completed many steps to
    define and build a Linux environment for your enterprise that supports automation.
    However, Ansible's assistance with your environment does not end here. Even an
    environment that has been built and is in active use requires maintenance and
    intervention from time to time. Historically, these interventions would have been
    performed manually by system administrators, using shell commands or scripts.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '在您完成本书的学习后，您将已经完成了多个步骤，为您的企业定义并构建了一个支持自动化的 Linux 环境。然而，Ansible 对您的环境的帮助并未就此结束。即便是一个已经构建并在使用中的环境，也需要定期进行维护和干预。从前，这些干预通常由系统管理员手动执行，使用
    shell 命令或脚本。  '
- en: As we have discussed many times throughout this book, tasks that are run by
    hand present a number of challenges for the enterprise—not least that they may
    not be well documented, and hence there is a steep learning curve for new members
    of staff. In addition, our old friends auditability and repeatability come into
    play—how can you be sure of who did what, and when, if everyone is logging on
    to the shell of your Linux machines and performing tasks by hand?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本书中多次提到的那样，手动执行的任务给企业带来了许多挑战——其中最重要的是，它们可能没有很好地文档化，因此新员工的学习曲线较陡。此外，我们的老朋友可审计性和可重复性也会出现——如果每个人都直接登录到
    Linux 机器的 shell 并手动执行任务，您如何确保知道谁在什么时候做了什么？
- en: In this chapter, we explore the ways in which Ansible can assist the enterprise
    with the day-to-day management of the Linux estate and, especially, in performing
    routine maintenance tasks. Ansible is extremely powerful, and your possibilities
    for routine maintenance are not limited to the examples in this chapter—rather,
    they are intended to get you started, and show by example the kinds of tasks you
    may be able to automate.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '在本章中，我们将探讨 Ansible 如何帮助企业管理 Linux 环境的日常工作，特别是在执行常规维护任务时。Ansible 功能强大，您进行常规维护的可能性不仅限于本章中的示例——这些示例旨在帮助您入门，并通过示范展示您可能能够自动化的任务种类。  '
- en: 'Specifically, we will cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '本章将具体介绍以下主题：  '
- en: Tidying up disk space
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '清理磁盘空间  '
- en: Monitoring for configuration drift
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '监控配置漂移  '
- en: Managing processes with Ansible
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '使用 Ansible 管理进程  '
- en: Rolling updates with Ansible
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '使用 Ansible 执行滚动更新  '
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '技术要求  '
- en: 'This chapter includes examples, based on the following technologies:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '本章包括以下技术的示例：  '
- en: Ubuntu Server 18.04 LTS
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Ubuntu Server 18.04 LTS  '
- en: CentOS 7.6
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'CentOS 7.6  '
- en: Ansible 2.8
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Ansible 2.8  '
- en: To run through these examples, you will need access to two servers or virtual
    machines running one each of the operating systems just listed, and also Ansible.
    Note that the examples given in this chapter may be destructive in nature (for
    example, they delete files, and make changes to server configuration), and if
    run as is, are only intended to be run in an isolated test environment.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '要运行这些示例，您需要访问两台服务器或虚拟机，每台运行一个上述操作系统，同时安装 Ansible。请注意，本章中给出的示例可能具有破坏性（例如，它们会删除文件并更改服务器配置），如果按原样运行，它们仅适用于在隔离的测试环境中运行。  '
- en: Once you are satisfied that you have a safe environment in which to operate,
    let's get started with routine system maintenance, with Ansible.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '一旦您确认已拥有一个安全的操作环境，就可以开始使用 Ansible 进行常规系统维护了。  '
- en: All example code discussed in this chapter is available from GitHub, at the
    following URL: [https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux/tree/master/chapter12](https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux/tree/master/chapter12).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '本章讨论的所有示例代码都可以在 GitHub 上找到，网址为：[https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux/tree/master/chapter12](https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux/tree/master/chapter12)。  '
- en: Tidying up disk space
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '清理磁盘空间  '
- en: One of the most routine and mundane (and yet, vitally important) tasks that
    a system administrator has to complete on a routine basis is clearing out disk
    space. Although ideally, systems should be well behaved—for example, log files
    should be rotated, and temporary files cleaned up—those with experience in the
    industry will know that this is not always the case. The author of this book has
    worked in environments where clearing out a given directory was considered a routine
    task—hence, a prime candidate for automation.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 系统管理员需要定期完成的最常规、最琐碎（但却至关重要）任务之一就是清理磁盘空间。尽管理想情况下，系统应该是良好运作的——例如，日志文件应该进行轮换，临时文件应该被清理——但是在这个行业有经验的人都会知道，情况并不总是如此。本书的作者曾在一些环境中工作，在这些环境中，清理某个特定目录被视为常规任务——因此，它是自动化的最佳候选项。
- en: 'Of course, you would not just randomly delete files from a filesystem. Any
    task like this should be performed in a precise manner. Let''s proceed with a
    practical example—as this is hypothetical, let''s create some test files to work
    with. Suppose our fictional application creates a data file every day, and never
    prunes its `data` directory. To synthesize this, we might create some data files,
    as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你不会随便从文件系统中删除文件。任何这样的任务都应该以精确的方式执行。让我们来看一个实际的例子——由于这是假设的，我们来创建一些测试文件。假设我们的虚构应用每天都会创建一个数据文件，并且从不清理其
    `data` 目录。为了模拟这个情况，我们可能会创建一些数据文件，像这样：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding commands create a directory called `/var/lib/appdata`, and then
    create one (empty) file for each day, for the last 20 days. We could, of course,
    create files with data in, but it makes no difference to this example—we don't
    actually want to fill the disk up!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的命令创建了一个名为 `/var/lib/appdata` 的目录，并且为过去 20 天的每一天创建了一个（空的）文件。当然，我们也可以创建有数据的文件，但这对这个例子没有影响——我们并不想真正填满磁盘！
- en: 'Now, let''s suppose that our disk is getting full and that we want to prune
    this directory, keeping only the last 5 days'' worth. If we were to do this by
    hand, we might use the venerable `find` command, to list the files meeting our
    criteria, and remove anything older. This might look something like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们的磁盘空间快满了，我们想清理这个目录，只保留最近 5 天的数据。如果我们手动执行此操作，可能会使用久经考验的 `find` 命令，列出符合条件的文件，并删除较旧的文件。这看起来可能是这样：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'That is an easy enough command to run, and you might be surprised to learn
    how common it is to see commands like that in enterprise run-books for Linux servers.
    Let''s improve on this, with Ansible. We know that if we implement this in Ansible,
    the following will be the case:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当简单的命令，你可能会惊讶地发现，类似的命令在企业级的 Linux 服务器运行手册中非常常见。让我们用 Ansible 来改进这个过程。我们知道，如果我们在
    Ansible 中实现它，以下情况将会发生：
- en: The Ansible engine will return an appropriate status—`ok`, `changed`, or `failed`,
    depending on the actions taken. The `find` command shown in the preceding code
    block will return the same output and exit code, whether it deletes any files
    or not.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible 引擎将根据所采取的操作返回适当的状态——`ok`、`changed` 或 `failed`。前面的代码块中展示的 `find` 命令无论是否删除任何文件，都会返回相同的输出和退出代码。
- en: The Ansible code we write will be self-documenting—for example, it will begin
    with an appropriate `name`—perhaps `Prune /var/lib/appdata`.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们编写的 Ansible 代码将具有自我文档化的特性——例如，它将以适当的 `name` 开始——可能是 `Prune /var/lib/appdata`。
- en: The Ansible code can be run from AWX or Ansible Tower, ensuring that this routine
    task can be delegated to the appropriate team, using the built-in role-based access
    controls.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible 代码可以从 AWX 或 Ansible Tower 运行，确保这个常规任务可以委派给适当的团队，使用内置的基于角色的访问控制。
- en: In addition, the task can be given a user-friendly name in AWX, meaning operators
    don't need any specialist knowledge to jump in and start being effective in assisting
    with Linux environment management.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，任务可以在 AWX 中赋予一个用户友好的名称，这意味着操作员无需任何专业知识即可开始有效地协助管理 Linux 环境。
- en: AWX and Ansible Tower will faithfully log the output from the task run, to ensure
    it is possible to audit these cleanup jobs in the future.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWX 和 Ansible Tower 会忠实地记录任务执行的输出，确保将来能够审核这些清理任务。
- en: 'Of course, none of these Ansible benefits is new to us by now—we have frequently
    referred to them throughout the book. Nonetheless, it is my wish to impress upon
    you the benefits of effective automation in the enterprise. Let''s start by defining
    a role to perform exactly this function—prune a directory of files over 5 days
    old with Ansible:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，Ansible的这些好处对我们来说并不新鲜——我们在整本书中经常提到它们。尽管如此，我还是希望强调企业中有效自动化的好处。让我们从定义一个角色开始，来执行这个具体的功能——使用Ansible修剪超过5天的文件目录：
- en: 'We start by making use of the Ansible `find` module, which enables us to build
    up a list of filesystem objects (such as files or directories), just as the `find`
    shell command does. We will `register` the output in an Ansible variable to make
    use of it later on, as follows:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先利用Ansible的`find`模块，它使我们能够构建一个文件系统对象的列表（如文件或目录），就像`find` shell命令一样。我们将`find`模块的输出`register`到一个Ansible变量中，以便稍后使用，具体如下：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The code fragment shown here should be fairly self-explanatory—note, however, 
    that we have made use of variables for the `path` and `age` parameters; this is
    with good reason. Roles are all about reuse of code, and if we define these parameters
    using variables, we can reuse this role to prune other directories (for example,
    for different applications), without needing to change the role code itself. You
    will also observe that we can use the variables in the `name` of the task—very
    useful and powerful when returning to audit Ansible runs in the future.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示的代码片段应该比较容易理解—然而请注意，我们已经为`path`和`age`参数使用了变量；这是有充分理由的。角色的核心在于代码的复用，如果我们通过变量定义这些参数，就可以复用这个角色来修剪其他目录（例如，针对不同的应用），而无需修改角色代码本身。你还会发现，我们可以在任务的`name`中使用这些变量—当我们将来回头审计Ansible运行时，这非常有用且强大。
- en: 'The `find` module will build up a list of files we need to delete—however,
    given our goal of auditing, it might be useful for us to print these filenames
    in the Ansible output, to ensure we can come back later and find out exactly what
    was deleted. Note that we could print more data than just the path—perhaps also
    capturing size and timestamp information could be useful? All of this is available
    in the `prune_list` variable we captured earlier, and it is left as an exercise
    for you to explore this. (Hint: Replace `msg: "{{ item.path }}"` with `msg: "{{
    item }}"`, to see all the information captured by the `find` task.) Run the following
    code:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`find`模块将构建一个我们需要删除的文件列表——然而，考虑到我们审计的目标，可能对我们来说有用的是在Ansible输出中打印这些文件名，以确保我们稍后可以回来并准确了解删除了哪些文件。请注意，我们不仅可以打印路径—也许捕获文件大小和时间戳信息会更有用？所有这些信息都可以在我们之前捕获的`prune_list`变量中找到，你可以自行探索这些内容。（提示：将`msg:
    "{{ item.path }}"`替换为`msg: "{{ item }}"`，查看`find`任务捕获的所有信息。）运行以下代码：'
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, we are simply using an Ansible loop to iterate over the data generated
    by the `find` module—specifically, extracting the `path` dictionary item from
    the `files` dictionary within our variable. The `loop_control` option prevents
    Ansible from printing the entire dictionary structure above each `debug` message,
    instead, just using the `path` to each file as the `label`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是使用Ansible的循环，遍历`find`模块生成的数据——具体来说，从我们的变量中的`files`字典提取`path`字典项。`loop_control`选项防止Ansible在每个`debug`消息前打印整个字典结构，而是仅使用每个文件的`path`作为`label`。
- en: 'Finally, we use the `file` module to remove the files, again looping over `prune_list`,
    just as we did previously, as follows:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用`file`模块删除文件，依旧像之前那样遍历`prune_list`，具体如下：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With the role complete, we must define the variables for our play—in this example,
    I am defining them in the `site.yml` playbook that references our new role, as
    follows:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在角色完成后，我们必须为我们的play定义变量—在本例中，我在引用我们新角色的`site.yml`剧本中定义了它们，具体如下：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Running this code with the test files generated earlier in this section will
    result in an output that looks something like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本节之前生成的测试文件运行此代码，将会得到类似于下面这样的输出：
- en: '![](img/644b6558-b091-4fb4-be4f-c2244b4faff0.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/644b6558-b091-4fb4-be4f-c2244b4faff0.png)'
- en: The test file set has been reduced for the preceding screenshot, to ensure it
    fits on the screen—however, you can clearly see the output, and which files were
    deleted.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保截图能适应屏幕，前面的测试文件集已经进行了缩减—但是你可以清楚地看到输出，以及哪些文件被删除了。
- en: While good housekeeping is an essential part of server maintenance, sometimes
    it is only desirable to take action (such as pruning a directory) if it is absolutely
    necessary. What if we decided that this role should only run when there is 10%
    or less disk space remaining on the filesystem containing `/var/lib/appdata`?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然良好的维护是服务器管理的关键部分，但有时我们只希望在绝对必要时采取行动（例如修剪目录）。假如我们决定这个角色只有在包含`/var/lib/appdata`的文件系统剩余磁盘空间少于10%时才会运行，会怎么样呢？
- en: 'The following process demonstrates how Ansible can be used to perform conditional
    housekeeping, operating only when the disk is more than 90% full:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下过程演示了如何使用Ansible执行条件性维护，只有当磁盘使用率超过90%时才会运行：
- en: 'We start by modifying our existing role—first of all, we add a new task to
    the role, to get the disk usage as a percentage from our `target` directory, as
    follows:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先修改现有的角色——首先，我们为角色添加了一个新任务，以获取`target`目录的磁盘使用率百分比，如下所示：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Although there are Ansible facts that contain disk usage information, we use
    the `df` command here because it can query our directory directly—we must somehow
    trace this back to the mount point on which it lives if we are to successfully
    use Ansible facts. We also make use of `changed_when: false`, as this shell task
    will always show a changed result otherwise, which can be confusing in the output—this
    is a read-only query, so nothing should have changed!'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '尽管Ansible有包含磁盘使用信息的事实数据，但我们在这里使用`df`命令，因为它可以直接查询我们的目录——如果我们想成功使用Ansible的事实数据，我们必须以某种方式追溯到它所在的挂载点。我们还使用`changed_when:
    false`，因为这个shell任务如果没有这个设置，会总是显示变化的结果，这可能会让输出变得令人困惑——这是一个只读查询，所以不应该有任何变化！'
- en: 'With this data gathered and registered in the `dfresult` variable, we then
    wrap our existing code in a block. A block in Ansible is simply a way of wrapping
    a set of tasks together—thus, rather than having to put a `when` condition on
    each of our three tasks from our earlier example, we simply put the conditional
    on the block instead. The block would begin something like this:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这些数据收集并注册在`dfresult`变量中后，我们将现有代码包装在一个代码块中。Ansible中的代码块只是将一组任务封装在一起的方式——因此，与其在我们之前示例中的三个任务上分别加上`when`条件，我们直接将条件放在代码块上。代码块的开始可能是这样的：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Note how the previous set of tasks is now indented by two spaces. This ensures
    that Ansible understands it is part of the block. Indent all the existing tasks,
    and conclude the block with the following code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意之前的任务集现在被缩进了两个空格。这确保Ansible理解它是该代码块的一部分。缩进所有现有任务，并用以下代码结束该代码块：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here, we are using the standard output captured in the `dfresult` variable,
    casting it to an integer, and then, checking to see if it is 90% or more. Thus,
    we only run the pruning tasks if the filesystem is more than 90% full. This is,
    of course, just one conditional—you could gather any data that you require to
    make any of your tasks run, in a variety of other cases. Running this new role
    on my test server, which has much less than 90% disk utilization, shows the pruning
    tasks being skipped altogether now, as can be seen in the following screenshot:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用标准输出捕获的`dfresult`变量，将其转换为整数，然后检查它是否为90%或更高。因此，只有当文件系统超过90%满时，我们才会运行修剪任务。当然，这只是一个条件——你可以收集任何需要的数据，以在其他多种情况下运行你的任务。在我的测试服务器上运行这个新角色，服务器的磁盘利用率远低于90%，可以看到修剪任务被完全跳过，如下截图所示：
- en: '![](img/153ab9cf-57c9-49fc-b1eb-09882d409f3a.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/153ab9cf-57c9-49fc-b1eb-09882d409f3a.png)'
- en: In this way, it is easy for us to perform routine disk housekeeping tasks across
    a large enterprise estate, and—as is ever the case with Ansible—the sky is the
    limit for what you can do. Hopefully, the examples from this section will give
    you some ideas on how to get started. In the next section, we will look at how
    Ansible can be used to effectively monitor for configuration drift, across your
    Linux estate.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们可以轻松地在大型企业环境中执行常规的磁盘维护任务，并且——就像Ansible的使用方式一样——你能做的事情没有上限。希望本节中的示例能给你一些关于如何入手的启发。在接下来的部分中，我们将探讨如何使用Ansible有效地监控Linux环境中的配置漂移。
- en: Monitoring for configuration drift
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控配置漂移
- en: In [Chapter 7](200bea26-7066-4feb-a571-481a5f047ae4.xhtml), *Configuration Management
    with Ansible*, we have explored the ways that Ansible can be used both to deploy
    configuration at an enterprise scale and to enforce it. Let us now build on this,
    with something else—monitoring for configuration drift.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](200bea26-7066-4feb-a571-481a5f047ae4.xhtml)中，*使用Ansible进行配置管理*，我们探讨了Ansible如何在企业规模上部署配置并强制执行它。现在，让我们在此基础上，增加一个新的内容——监控配置漂移。
- en: As we discussed in [Chapter 1](c7596fb8-4971-44d7-943a-7660c5eecb17.xhtml),
    *Building a Standard Operating Environment on Linux*, manual changes are the enemy
    of automation. Beyond this, they are also a security risk. Let us work with a
    specific example here, to demonstrate. As was suggested previously in this book,
    it would be advisable to manage the **Secure Shell** (**SSH**) server configuration
    with Ansible. SSH is the standard protocol for managing Linux servers and can
    be used not only for management but also for file transfer. In short, it is one
    of the key mechanisms through which people will access your servers, and hence
    it is vital that it is secure.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第1章](c7596fb8-4971-44d7-943a-7660c5eecb17.xhtml)中讨论的，*在Linux上构建标准操作环境*，手动更改是自动化的敌人。除此之外，它们也是一个安全风险。让我们通过一个具体的例子来演示。如本书前面所建议的，建议通过Ansible管理**安全外壳（SSH）**服务器配置。SSH是管理Linux服务器的标准协议，不仅可以用于管理，还可以用于文件传输。简而言之，它是人们访问你的服务器的关键机制之一，因此确保其安全至关重要。
- en: It is also common, however, for a variety of people to have root access to Linux
    servers. Whether developers are deploying code, or system administrators are performing
    routine (or break-fix) work, it is considered perfectly normal for many people
    to have root access to a server. This is fine if everyone is *well behaved*, and
    actively supports the principles of automation in your enterprise. However, what
    happens if someone makes unauthorized changes?
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，也常见多个人拥有Linux服务器的root访问权限。无论是开发人员在部署代码，还是系统管理员在执行日常（或修复）工作，很多人拥有服务器的root访问权限是完全正常的。如果每个人都*表现得很得体*，并积极支持企业中的自动化原则，那是没问题的。但是，如果有人做出未经授权的更改怎么办？
- en: Through the SSH configuration, they might enable remote root logins. They might
    turn on password-based authentication when you have disabled this in favor of
    key-based authentication. Many times, these kinds of changes are made to support
    laziness—it is easier to copy files around as a root user, for example.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通过SSH配置，可能会启用远程root登录。也可能在你禁用了密码认证并改用基于密钥的认证时，重新启用基于密码的认证。许多时候，这些更改是为了支持懒惰——例如，作为root用户复制文件更容易。
- en: Whatever the intention and root cause, someone manually making these changes
    to a Linux server you deployed previously is a problem. How do you go about detecting
    them, though? Certainly, you don't have time to log in to every server and check
    the files by hand. Ansible, however, can help.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 无论意图和根本原因如何，某人手动更改你之前部署的Linux服务器配置都是一个问题。那么，如何检测这些更改呢？当然，你没有时间登录到每台服务器手动检查文件。然而，Ansible可以提供帮助。
- en: In [Chapter 7](200bea26-7066-4feb-a571-481a5f047ae4.xhtml), *Configuration Management
    with Ansible*, we proposed a simple Ansible example that deployed the SSH server
    configuration from a template and restarted the SSH service if the configuration
    was changed using a handler.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](200bea26-7066-4feb-a571-481a5f047ae4.xhtml)中，*使用Ansible进行配置管理*，我们提出了一个简单的Ansible示例，该示例从模板中部署SSH服务器配置，并在配置发生更改时使用处理程序重启SSH服务。
- en: We can actually repurpose this code for our configuration drift checks. Without
    even making any code changes, we can run the playbook with Ansible in *check*
    mode. Check mode makes no changes to the systems on which it is working—rather,
    it tries its best to predict any changes that might occur. The reliability of
    these predictions depends very much on the modules used in the role. For example,
    the `template` module can reliably predict changes because it knows whether the
    file that would be written is different from the file that is in place. Conversely,
    the `shell` module can never know the difference between a `change` and an `ok`
    result because it is such a general-purpose module (though it can detect failures
    with a reasonable degree of accuracy). Thus, I advocate strongly the use of `changed_when` when
    this module is used.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上可以将这段代码重新用于我们的配置漂移检查。即使不做任何代码更改，我们也可以在*检查*模式下使用Ansible运行剧本。检查模式不会对正在操作的系统做出任何更改——相反，它会尽力预测可能发生的任何更改。这些预测的可靠性在很大程度上取决于角色中使用的模块。例如，`template`模块能够可靠地预测更改，因为它知道写入的文件是否与现有文件不同。相反，`shell`模块永远无法知道`change`和`ok`结果之间的区别，因为它是一个通用模块（尽管它可以在合理的准确度范围内检测失败）。因此，我强烈建议在使用该模块时使用`changed_when`。
- en: 'Let''s see what happens if we rerun the `securesshd` role from before, this
    time in check mode. The result can be seen in the following screenshot:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果重新运行之前的`securesshd`角色，这次使用检查模式会发生什么。结果可以在以下截图中看到：
- en: '![](img/1e3395f9-8bd4-4af4-aaf2-2ed627fdd564.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1e3395f9-8bd4-4af4-aaf2-2ed627fdd564.png)'
- en: 'Here, we can see that someone has indeed changed the SSH server configuration—if
    it matched the template we were providing, the output would look like this instead:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到确实有人更改了SSH服务器配置——如果它与我们提供的模板匹配，输出将会像这样：
- en: '![](img/3a0b8a58-c5b3-448a-9570-ec42ac43e597.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3a0b8a58-c5b3-448a-9570-ec42ac43e597.png)'
- en: So far, so good—you could run this against a hundred, or even a thousand, servers,
    and you would know that any `changed` results came from servers where the SSH
    server configuration no longer matches the template. You could even run the playbook
    again to rectify the situation, only this time not in check mode (that is, without
    the `-C` flag on the command line).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利——你可以将其运行在一百台，甚至一千台服务器上，你会知道任何`changed`结果都来自那些SSH服务器配置不再与模板匹配的服务器。你甚至可以再次运行剧本来纠正这种情况，只是这次不在检查模式下运行（也就是说，命令行上没有`-C`标志）。
- en: In an environment such as AWX or Ansible Tower, jobs (that is to say, running
    playbooks) are categorized into two different states—success and failure. Success
    is categorized as any playbook that runs to completion, producing only `changed`
    or `ok` results. Failure, however, comes about from one or more `failed` or `unreachable`
    states being returned from the playbook run.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在像AWX或Ansible Tower这样的环境中，作业（即运行剧本）被分类为两种不同的状态——成功和失败。成功是指任何运行到完成的剧本，只产生`changed`或`ok`结果。然而，失败则是由于剧本运行返回一个或多个`failed`或`unreachable`状态。
- en: 'Thus, we could enhance our playbook by getting it to issue a `failed` state
    if the configuration file is different from the templated version. The bulk of
    the role remains exactly the same, but, on our template task, we add the following
    clauses:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以通过让剧本在配置文件与模板版本不同的情况下发出`failed`状态来增强它。角色的主体部分保持不变，但在我们的模板任务中，我们添加了以下子句：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'These have the following effect on the operation of this task:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对任务的操作产生了以下影响：
- en: The result of the task is registered in the `template_result` variable.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务的结果会被注册到`template_result`变量中。
- en: 'We change the  failure condition of this task to the following:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将这个任务的失败条件改为如下：
- en: The template task result was changed, and we are running it in check mode.
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板任务的结果发生了变化，我们正在以检查模式运行它。
- en: Or, the template task failed for some other reason—this is a catch-all case,
    to ensure we still report other failure cases correctly (for example, access denied
    to a file).
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，模板任务因其他原因失败——这是一个通用情况，确保我们仍然正确报告其他失败情况（例如，文件访问被拒绝）。
- en: 'You will observe the use of both logical `and` and `or` operators in the `failed_when`
    clause—a powerful way to expand on the operation of Ansible. Now, when we run
    the playbook in check mode and the file has changed, we see the following result:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你将观察到`failed_when`子句中同时使用了逻辑`and`和`or`运算符——这是扩展Ansible操作的一种强大方式。现在，当我们在检查模式下运行剧本并且文件发生变化时，我们会看到以下结果：
- en: '![](img/03d63c86-98b2-418c-b46d-14cae77c2b8a.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/03d63c86-98b2-418c-b46d-14cae77c2b8a.png)'
- en: Now, we can very clearly see that there is an issue on our host, and it will
    be reported as a failure in AWX and Ansible Tower too.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以非常清楚地看到我们的主机上存在问题，并且它将在AWX和Ansible Tower中报告为失败。
- en: 'Of course, this works very well for plain text files. What about binary files,
    though? Ansible is, of course, not a complete replacement for a file integrity
    monitoring tool such as **Advanced Intrusion Detection Environment** (**AIDE**)
    or the venerable **Tripwire**—however, it can help with the use of binary files
    too. In fact, the process is very simple. Let''s suppose you want to ensure the
    integrity of `/bin/bash`—this is the shell that everyone uses by default on most
    systems, so the integrity of this file is incredibly important. If you have space
    to store a copy of the original binary on your Ansible server, then you can use
    the `copy` module to copy it across to the target hosts. The `copy` module makes
    use of checksumming to determine whether a file needs to be copied, and so, you
    can be sure that, if the `copy` module results in a `changed` result, then the
    target file differs from your original version, and integrity is compromised.
    The role code for this would look very similar to our template example here:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这对于纯文本文件非常有效。那么二进制文件呢？Ansible当然不能完全替代像**高级入侵检测环境**（**AIDE**）或久负盛名的**Tripwire**这样的文件完整性监控工具——然而，它也可以帮助处理二进制文件。事实上，过程非常简单。假设你想确保`/bin/bash`的完整性——这是大多数系统默认使用的Shell，因此该文件的完整性非常重要。如果你有空间在你的Ansible服务器上存储原始二进制文件的副本，那么你可以使用`copy`模块将其复制到目标主机。`copy`模块利用校验和来判断文件是否需要复制，因此，你可以确信，如果`copy`模块返回`changed`结果，那么目标文件与原始版本不同，完整性已被破坏。该角色的代码将与我们在此处的模板示例非常相似：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Of course, storing original binaries on your Ansible server is inefficient,
    and also, means you have to keep them up to date, in line with your server patching
    schedule, which is not desirable when you have a large number of files to check.
    Fortunately, the Ansible `stat` module can generate checksums, as well as returning
    lots of other useful data about files, and so, we could very easily write a playbook
    to check that our binary for Bash has not been tampered with, by running the following
    code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，将原始二进制文件存储在Ansible服务器上是低效的，而且还意味着你必须保持它们与服务器修补计划同步，这在需要检查大量文件时并不理想。幸运的是，Ansible的`stat`模块可以生成校验和，并返回有关文件的其他有用数据，因此，我们可以非常容易地编写一个剧本，通过运行以下代码来检查我们的Bash二进制文件是否被篡改：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is a very simple example and could be enhanced significantly by ensuring
    the file path and name, and checksum, are variables rather than static values.
    It could also be made to loop over a dictionary of files and their respective
    checksums—these tasks are left as an exercise for you, and this is entirely possible,
    using techniques we have covered throughout this book. Now, if we run this playbook
    (whether in check mode or not), we will see a failed result if the integrity of
    Bash has not been maintained, and `ok` otherwise, as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的示例，可以通过确保文件路径、名称和校验和是变量而不是静态值来显著增强。它还可以通过遍历一个包含文件及其相应校验和的字典来进行改进——这些任务留给你自己完成，这是完全可能的，使用我们在本书中介绍的技术。现在，如果我们运行这个剧本（无论是否在检查模式下），如果Bash的完整性没有得到保持，我们将看到失败的结果，否则将看到`ok`，如下所示：
- en: '![](img/5b4a99b8-fbc9-4a79-912b-bd17cbac9ba4.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5b4a99b8-fbc9-4a79-912b-bd17cbac9ba4.png)'
- en: Checksumming can be used to verify the integrity of configuration files too,
    so, this example role serves as a good basis for any file integrity checking you
    might wish to undertake.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 校验和可以用来验证配置文件的完整性，因此，这个示例角色为你可能进行的任何文件完整性检查提供了良好的基础。
- en: We have now completed our exploration of file and integrity monitoring with
    Ansible, and hence, the ability check for configuration drift. In the next section
    of this chapter, we'll take a look at how Ansible can be used to manage processes
    across an Enterprise Linux estate.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了对Ansible文件和完整性监控的探索，因此，也具备了检查配置漂移的能力。在本章的下一部分，我们将看看如何使用Ansible来管理企业Linux环境中的进程。
- en: Understanding process management with Ansible
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ansible理解进程管理
- en: Sooner or later, you will end up with the need to manage, and possibly even
    kill, processes on one or more Linux servers within your enterprise. Obviously,
    this is not an ideal scenario, and in day-to-day operations, most services should
    be managed using the Ansible `service` module, many examples of which we have
    seen in this book.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 迟早，你会需要在你的企业内部管理，甚至可能需要终止一个或多个 Linux 服务器上的进程。显然，这不是理想的场景，在日常操作中，大多数服务应该使用 Ansible
    的`service`模块进行管理，在本书中我们已经看到过许多这样的示例。
- en: 'What if, however, you need to actually kill a service that has hung? Obviously,
    a system administrator could SSH into the errant server and issue commands such
    as the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你需要真正终止一个挂起的服务呢？显然，系统管理员可以通过 SSH 进入故障服务器并发出如下命令：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If the process refuses stubbornly to terminate, then the following may become
    necessary:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果进程固执地拒绝终止，那么以下操作可能是必要的：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: While this is a fairly standard practice, in which most system administrators
    will be well versed (and indeed, may have their own favorite tools to handle,
    such as `pkill`), it suffers the same problem as most manual interventions on
    a server—how can you keep track of what happened, and which processes were affected?
    If numeric **process IDs** (**PIDs**) were used, then even with access to the
    command history, it is still impossible to tell which process historically held
    that numeric PID.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是一个相当标准的做法，大多数系统管理员都会熟悉（并且可能有自己喜欢的工具来处理，例如 `pkill`），但它与大多数服务器上的手动干预面临相同的问题——你如何追踪发生了什么，哪些进程受到了影响？如果使用了数字
    **进程 ID** (**PID**)，即使访问了命令历史记录，也仍然无法确定哪个进程曾经占用过那个数字 PID。
- en: What we propose here is an unconventional use of Ansible—yet one that, if run
    through a tool such as AWX or Ansible Tower, would enable us to track all operations
    that were performed, along with details of who ran them and, if we put the process
    name in a parameter, what the target was too. This could be useful if, in the
    future, it becomes necessary to analyze the history of a problem, whereupon it
    would be easy to check which servers were acted upon, and which processes were
    targeted, along with precise timestamps.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里提出的是一种非传统的 Ansible 用法——如果通过像 AWX 或 Ansible Tower 这样的工具运行，它将使我们能够追踪所有执行过的操作，以及谁执行了这些操作的详细信息，如果我们将进程名称作为参数传递，还可以追踪目标是什么。这个功能在将来可能会非常有用，尤其是当我们需要分析问题的历史时，这样就可以轻松检查哪些服务器被操作过，哪些进程被目标化，并且还能得到精确的时间戳。
- en: 'Let''s build up a role to perform exactly this set of tasks. This chapter was
    originally written against Ansible 2.8, which did not feature a module for process
    management, and so, the following example uses native shell commands to handle
    this case:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个角色来执行这套任务。本章最初是针对 Ansible 2.8 编写的，当时没有用于进程管理的模块，因此，以下示例使用原生的 Shell 命令来处理这种情况：
- en: 'We start by running the process listing we proposed earlier in this section,
    but this time, registering the list of PIDs into an Ansible variable, as follows:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先运行我们之前在本节中提出的进程列表，但这次我们将 PID 列表注册到一个 Ansible 变量中，如下所示：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Most people familiar with shell scripting should be able to understand this
    line—we are filtering the system process table for whole-word matches for the
    Ansible variable `procname`, and removing any extraneous process names that might
    come up and confuse the output, such as `grep` and `ansible`. Finally, we use
    `awk` to process the output into a comma-separated list, containing the PID, in
    the first column, and the process name itself in the second.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉 Shell 脚本的人应该能够理解这一行——我们在系统进程表中筛选出与 Ansible 变量 `procname` 完全匹配的项，并去除可能出现的任何多余进程名称（例如
    `grep` 和 `ansible`），以免混淆输出。最后，我们使用 `awk` 将输出处理成一个逗号分隔的列表，其中第一列包含 PID，第二列则是进程名称。
- en: 'Now, we must start to take action on this output. We now loop over the `process_ids`
    variable populated previously, issuing a `kill` command against the first column
    in the output (that is, the numeric PID), as follows:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须开始对这个输出进行操作。我们将对之前填充的 `process_ids` 变量进行循环，并对输出的第一列（即数字 PID）执行 `kill`
    命令，如下所示：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You will observe the use of Jinja2 filtering here—we can use the built-in `split`
    function to split the data we created in the previous code block, taking only
    the first column of output (the numeric PID). However, we use the `loop_control`
    label to set the task label containing both the PID and process name, which could
    be very useful in an auditing or debugging scenario.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你将观察到这里使用了Jinja2过滤器——我们可以使用内置的`split`函数来拆分我们在前一个代码块中创建的数据，仅取输出的第一列（数字PID）。不过，我们使用`loop_control`标签来设置任务标签，包含PID和进程名称，在审计或调试场景中可能非常有用。
- en: 'Any experienced system administrator will know that it is not sufficient to
    just issue a `kill` command to a process—some processes must be forcefully killed
    as they are hung. Not all processes exit immediately, so we will use the Ansible
    `wait_for` module to check for the PID in the `/proc` directory—when it becomes
    `absent`, then we know the process has exited. Run the following code:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何有经验的系统管理员都知道，仅仅发出`kill`命令来终止进程是不够的——某些进程必须强制终止，因为它们可能挂起。并非所有进程都会立即退出，因此我们将使用Ansible的`wait_for`模块来检查`/proc`目录中的PID——当它变为`absent`时，我们就知道该进程已退出。运行以下代码：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We have set the timeout here to 5 seconds—however, you should set it as appropriate
    in your environment. Once again, we register the output to a variable—we need
    to know which processes failed to exit, and hence, try killing them more forcefully.
    Note that we set `ignore_errors` here, as the `wait_for` module produces an error
    if the desired state (that is, `/proc/PID` becomes `absent`) does not occur within
    the `timeout` specified. This should not be an error in our role, simply a prompt
    for further processing.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里将超时设置为5秒——然而，你应根据你的环境适当设置它。再次，我们将输出注册到一个变量中——我们需要知道哪些进程未能退出，因此尝试更强制地终止它们。注意，我们在这里设置了`ignore_errors`，因为`wait_for`模块如果未能在指定的`timeout`内使所需状态（即`/proc/PID`变为`absent`）发生时，会产生错误。对此我们不应视为错误，而应作为进一步处理的提示。
- en: 'We now loop over the results of the `wait_for`  task —only this time, we use
    the Jinja2 `selectattr` function, to select only dictionary items that have `failed`
    asserted; we don''t want to forcefully terminate non-existent PIDs. Run the following
    code:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们遍历`wait_for`任务的结果——这次，我们使用Jinja2的`selectattr`函数，仅选择那些已经断言为`failed`的字典项；我们不想强制终止不存在的PID。运行以下代码：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, we attempt to kill the stuck processes with the `-9` flag—normally, sufficient
    to kill most hung processes. Note again the use of Jinaj2 filtering and the tidy
    labeling of the loop, to ensure we can use the output of this role for auditing
    and debugging.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们尝试使用`-9`标志终止卡住的进程——通常足以杀死大多数挂起的进程。再一次，注意Jinja2过滤器的使用和循环的整洁标签，以确保我们可以将此角色的输出用于审计和调试。
- en: 'Now, we run the playbook, specifying a value for `procname`—there is no default
    process to be killed, and I would not suggest that setting a default value for
    this variable is safe. Thus, in the following screenshot, I am setting it using
    the `-e` flag when I invoke the `ansible-playbook` command:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们运行剧本，指定`procname`的值——没有默认的进程可供终止，我不建议为此变量设置默认值是安全的。因此，在下图中，我使用`-e`标志在调用`ansible-playbook`命令时设置它：
- en: '![](img/99908df0-83de-4c8e-ad70-76dae520fc2c.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/99908df0-83de-4c8e-ad70-76dae520fc2c.png)'
- en: From the preceding screenshot, we can clearly see the playbook killing the `mysqld`
    process, and the output of the playbook is tidy and concise, yet contains enough
    information for debugging, should the need occur.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的截图中，我们可以清楚地看到剧本终止了`mysqld`进程，且剧本的输出简洁明了，但包含了足够的调试信息，以备不时之需。
- en: 'As an addendum, if you are using Ansible 2.8 or later, there is now a native
    Ansible module called `pids` that will return a nice, clean list of PIDs for a
    given process name, if it is running. Adapting our role for this new functionality,
    we can, first of all, remove the shell command and replace it with the `pids`
    module, which is much easier to read, like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 作为附加说明，如果你使用的是Ansible 2.8或更高版本，现在有一个原生的Ansible模块叫做`pids`，它将返回一个干净、整洁的PID列表，列出正在运行的指定进程名。如果我们要适应这个新功能，首先可以移除shell命令，并用`pids`模块替代，它更易于阅读，如下所示：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'From this point on, the role is almost identical to before, except that, rather
    than the comma-separated list we generated from our shell command, we have a simple
    list that just contains the PIDs for each running process that matches the procname
    variable in name. Thus, we no longer need to use the split Jinja2 filter on our
    variables when executing commands on them. Run the following code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一点开始，角色几乎与之前相同，不同之处在于，我们不再使用从 shell 命令生成的逗号分隔列表，而是拥有一个简单的列表，仅包含与名称中的 procname
    变量匹配的每个运行中进程的 PID。因此，在对变量执行命令时，我们不再需要使用 Jinja2 的 split 过滤器。运行以下代码：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This block of code performs the same functions as before, only now, it is a
    little more readable, as we've reduced the number of Jinja2 filters required,
    and we have removed one shell command, in favor of the `pids` module. These techniques,
    combined with the `service` module discussed earlier, should give you a sound
    basis to meet all of your process control needs with Ansible.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码执行的功能与之前相同，只不过现在它更具可读性，因为我们减少了所需的 Jinja2 过滤器数量，并且我们去掉了一个 shell 命令，改用了 `pids`
    模块。结合前面讨论的 `service` 模块，这些技术应能为你提供坚实的基础，满足你所有使用 Ansible 进行进程控制的需求。
- en: In the next and final section of this chapter, we'll take a look at how to use
    Ansible when you have multiple nodes in a cluster, and you don't want to take
    them all out of service at once.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的下一部分也是最后一部分中，我们将看看如何在集群中有多个节点时使用 Ansible，并且你不希望一次性将它们全部停机。
- en: Rolling updates with Ansible
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Ansible 进行滚动更新
- en: No chapter on routine maintenance would be complete without a look at rolling
    updates. So far in this book, we have kept our examples simple with one or two
    hosts, and have worked on the basis that all examples can be scaled up to manage
    hundreds, if not thousands, of servers using the same roles and playbooks.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 关于常规维护的章节，如果没有涉及滚动更新，那么将是不完整的。到目前为止，在本书中，我们的示例保持简单，通常只有一个或两个主机，并假设所有示例都可以扩展以管理成百上千的服务器，使用相同的角色和
    playbook。
- en: 'This, by and large, holds true—however, there are certain special cases where
    perhaps we need to look a little deeper at the operation of Ansible. Let''s build
    up a hypothetical example, where we have four web application servers behind a
    load balancer. A new release of the web application code needs to be deployed,
    and the deployment process requires multiple steps (thus, multiple Ansible tasks).
    In our simple example, the deployment process will be as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，这种情况是成立的——然而，确实存在某些特殊情况，我们可能需要更深入地了解 Ansible 的操作。让我们构建一个假设的例子，其中有四个 Web
    应用服务器位于负载均衡器后面。需要部署 Web 应用代码的新版本，且部署过程需要多个步骤（因此，需要多个 Ansible 任务）。在我们的简单示例中，部署过程将如下所示：
- en: Deploy the web application code to the server.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Web 应用代码部署到服务器。
- en: Restart the web server service, to pick up the new code.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重启 Web 服务器服务，以加载新代码。
- en: In a production environment, you would almost certainly want to take further
    steps to ensure the integrity of your web service—for example, if it is behind
    a load balancer, you would take it out of service during the code deployment,
    and ensure it is not returned to service until it is validated as working properly.
    It is not anticipated that everyone reading this book will have access to such
    an environment, and so, the example has been kept simple, to ensure everyone can
    try it out.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，你几乎肯定会采取进一步的步骤来确保你的 Web 服务的完整性——例如，如果它位于负载均衡器后面，在代码部署期间，你需要将其下线，并确保在经过验证正常工作之前不会重新上线。预计并非所有读者都能接触到这样的环境，因此，示例保持简单，以确保每个人都能尝试。
- en: 'We could easily write a simple Ansible role to perform this task—an example
    is shown, as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地编写一个简单的 Ansible 角色来执行这个任务——示例如下所示：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This code performs our two steps in turn, exactly as we desire. However, let''s
    have a look at what happens when we run this role in a playbook. The result is
    shown in the following screenshot:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码按顺序执行我们的两个步骤，完全符合我们的需求。不过，让我们来看一下，当我们在 playbook 中运行这个角色时会发生什么。结果如下图所示：
- en: '![](img/9d39932e-4386-4e93-846f-bbb71bd6d76f.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9d39932e-4386-4e93-846f-bbb71bd6d76f.png)'
- en: Notice how Ansible performed the tasks. First of all, the new code was deployed
    on all four servers. Only then, were they restarted. This may not be desirable,
    for a number of reasons. For example, the servers may be in an inconsistent state
    after the first task, and you would not want all four servers to be in an inconsistent
    state at once, as anyone using the web application would experience errors. Also,
    if the playbook goes wrong for some reason and produces a failed state, it will
    faithfully fail on all four servers, thus breaking the entire web application
    for everyone, and causing a service outage.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意Ansible如何执行这些任务。首先，新的代码在所有四台服务器上部署。然后，才重启它们。出于多种原因，这可能并不理想。例如，在第一个任务之后，服务器可能处于不一致的状态，而你可能不希望四台服务器同时处于不一致状态，因为任何使用Web应用程序的用户都会遇到错误。此外，如果playbook由于某种原因出错并进入失败状态，它将忠实地在所有四台服务器上失败，从而破坏整个Web应用程序并导致服务中断。
- en: 'To prevent these kinds of issues from occurring, we can use the `serial` keyword,
    to ask Ansible to only perform the update on a given number of servers at a time.
    For example, if we insert the line `serial: 2` into the `site.yml` playbook calling
    this role, suddenly the behavior becomes rather different, as the following screenshot
    shows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '为了防止这种问题的发生，我们可以使用`serial`关键字，要求Ansible每次只对一定数量的服务器进行更新。例如，如果我们在调用此角色的`site.yml`
    playbook中插入`serial: 2`这一行，行为将变得相当不同，正如下面的截图所示：'
- en: '![](img/d36cc8c5-8931-40e9-b934-d5ae7827d1f8.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d36cc8c5-8931-40e9-b934-d5ae7827d1f8.png)'
- en: The preceding output is truncated to save space but clearly shows that the playbook
    is now being run on only two servers at a time—thus, during the initial phase
    of the run, only `cluster1` and `cluster2` are inconsistent, while `cluster3`
    and `cluster4` remain consistent and untouched. Only when all tasks are completed
    on the first two servers are the next two processed.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的输出为了节省空间被截断了，但清晰地显示了playbook现在每次只在两台服务器上运行—因此，在执行的初始阶段，只有`cluster1`和`cluster2`是异常的，而`cluster3`和`cluster4`保持一致且未受影响。只有在前两台服务器上的所有任务完成后，接下来的两台才会被处理。
- en: Failure handling is also important, and a danger of automation is that you could
    break an entire environment very easily if an issue exists in the code or playbook.
    For example, if our `Deploy new code` task fails for all servers, running the
    playbook on two servers at a time will not help. Ansible will still faithfully
    do what it is asked—in this case, break all four servers.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 故障处理同样重要，自动化的一个危险是，如果代码或playbook中存在问题，可能很容易破坏整个环境。例如，如果我们的`部署新代码`任务对所有服务器都失败了，那么每次只在两台服务器上运行playbook也无济于事。Ansible仍会忠实地执行它被要求的操作——在这种情况下，就是将所有四台服务器都弄坏。
- en: 'In this instance, it is a good idea to add to the playbook the `max_fail_percentage`
    parameter too. For example, if we set this to `50`, then Ansible will stop processing
    hosts as soon as 50% of its inventory has failed, as shown in the following screenshot:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，将`max_fail_percentage`参数添加到playbook中是个好主意。例如，如果我们将其设置为`50`，那么当50%的库存主机失败时，Ansible将停止处理主机，正如下面的截图所示：
- en: '![](img/173b92e9-ce2b-459b-93c4-caeca67c9f43.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/173b92e9-ce2b-459b-93c4-caeca67c9f43.png)'
- en: As we can see here, even though our inventory has not been changed, Ansible
    has stopped after processing `cluster1` and `cluster2`—because they failed, it
    is not performing any tasks on `cluster3` and `cluster4`; thus, at least two hosts
    remain in service with good code, allowing users to continue using the web application,
    in spite of the failure.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，尽管我们的库存没有变化，Ansible在处理完`cluster1`和`cluster2`后停止了，因为它们失败了，因此没有对`cluster3`和`cluster4`执行任何任务；因此，至少有两台主机保持正常工作，允许用户继续使用Web应用程序，尽管发生了故障。
- en: It is important to make use of these Ansible features when working with large,
    load-balanced environments, to ensure that failures do not propagate to an entire
    estate of servers. That concludes our look at the use of Ansible in routine server
    maintenance—as ever, the possibilities are endless, but it is hoped that once
    again, this chapter has given you some inspiration and examples upon which to
    build.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理大型负载均衡环境时，使用这些Ansible功能非常重要，以确保故障不会传播到整个服务器群。以上就是我们对Ansible在日常服务器维护中使用的总结——如同往常一样，可能性是无穷无尽的，但希望本章能再次为你提供一些灵感和可供构建的示例。
- en: Summary
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Ansible is a very powerful tool, but not just for deployment and configuration
    management. Although these are core strengths it possesses, it is also of powerful
    assistance when it comes to day-to-day management tasks. As ever, when coupled
    with an enterprise management tool such as AWX or Ansible Tower, it becomes incredibly
    important in the management of your Linux estate, especially for auditing and
    debugging purposes.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 是一个非常强大的工具，但不仅仅用于部署和配置管理。虽然这些是它的核心优势，但在日常管理任务中，它也能提供强大的帮助。正如以往一样，当它与
    AWX 或 Ansible Tower 等企业管理工具结合使用时，它在管理你的 Linux 系统中变得非常重要，尤其是在审计和调试方面。
- en: In this chapter, you learned how to tidy up disk space using Ansible, and how
    to make this conditional. You then learned how Ansible can help monitor configuration
    drift, and even alert to possible tampering with binary files. You learned how
    to manage processes on remote servers using Ansible, and finally, how to perform
    rolling updates in a graceful and managed fashion, across a load-balanced pool
    of servers.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学会了如何使用 Ansible 清理磁盘空间，并使其具备条件执行功能。你还学会了 Ansible 如何帮助监控配置漂移，甚至警报可能的二进制文件篡改。你了解了如何使用
    Ansible 管理远程服务器上的进程，最后，你学会了如何在负载均衡的服务器池中，以优雅和受控的方式执行滚动更新。
- en: In the next chapter, we take a look at securing your Linux servers in a standardized
    fashion, with CIS Benchmarks.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何通过 CIS 基准标准以标准化的方式保护你的 Linux 服务器。
- en: Questions
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why might you make use of the output from the `df` command rather than an Ansible
    fact when examining disk space?
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么在检查磁盘空间时，你可能会使用 `df` 命令的输出，而不是 Ansible 事实？
- en: Which Ansible module is used to locate files based on given criteria, such as
    age?
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个 Ansible 模块用于根据给定的标准（例如，文件的年龄）定位文件？
- en: Why is it important to monitor for configuration drift?
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么监控配置漂移很重要？
- en: What are two ways in which you can monitor a text-based configuration file for
    changes in Ansible?
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Ansible 中，有哪两种方式可以监控基于文本的配置文件的变化？
- en: How would you manage a `systemd` service on a remote server using Ansible?
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何使用 Ansible 管理远程服务器上的 `systemd` 服务？
- en: What is the name of the built-in filtering within Ansible that can help process
    string output (for example, to split a comma-separated list)?
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Ansible 中的内置过滤功能是什么，它可以帮助处理字符串输出（例如，拆分逗号分隔的列表）？
- en: How would you split a comma-separated list in an Ansible variable?
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在 Ansible 变量中拆分一个以逗号分隔的列表？
- en: When operating in a load-balanced environment, why would you not want all tasks
    performed on all the servers in one go?
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在负载均衡环境中，为什么不希望所有任务都在所有服务器上同时执行？
- en: Which Ansible feature can prevent you from rolling out a failed task to all
    servers?
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个 Ansible 功能可以防止你将失败的任务推送到所有服务器？
- en: Further reading
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: For an in-depth understanding of Ansible, please refer to *Mastering Ansible,
    Third Edition—James Freeman* and *Jesse Keating* ([https://www.packtpub.com/gb/virtualization-and-cloud/mastering-ansible-third-edition](https://www.packtpub.com/gb/virtualization-and-cloud/mastering-ansible-third-edition))
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要深入了解 Ansible，请参考 *Mastering Ansible, 第三版——James Freeman* 和 *Jesse Keating*（[https://www.packtpub.com/gb/virtualization-and-cloud/mastering-ansible-third-edition](https://www.packtpub.com/gb/virtualization-and-cloud/mastering-ansible-third-edition)）
