- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Writing Our First Script – Turning Simple Cmdlets into Reusable Code
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写我们的第一个脚本 – 将简单的 Cmdlet 转换为可重用代码
- en: 'Starting in this chapter, we’re going to look at how we can put the basic concepts
    we’ve learned together into scripts and tools that we can reuse, adapt, and distribute
    for others. In the coming chapters, we’re going to look at creating functions
    and script blocks, error handling and debugging, creating modules that allow us
    to distribute our code as tools, and finally, securing PowerShell. In this chapter,
    though, we’re going to start with the basics: turning a handful of cmdlets into
    a script.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章开始，我们将学习如何将我们学到的基本概念结合起来，编写可以重用、调整和分发给他人的脚本和工具。在接下来的章节中，我们将讨论如何创建函数和脚本块、错误处理和调试、创建模块使我们能够将代码作为工具分发，最后，我们还会讨论如何保护
    PowerShell。但在本章中，我们将从基础开始：将一小部分 cmdlet 转换为脚本。
- en: We’ll start by discussing scripts in general and why we might want to write
    one. After that, we’ll take a quick look at where we can find PowerShell scripts
    online, and then we’ll cover how we can run scripts.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从讨论脚本的一般概念以及为什么我们可能想要编写脚本开始。之后，我们将简要了解我们可以在哪里在线找到 PowerShell 脚本，然后我们将讨论如何运行脚本。
- en: Once we understand how to use other people’s scripts, we’ll dive into writing
    our own. First, we’ll learn how to identify changing values in a working cmdlet
    pipeline, then we’ll learn how to turn those into parameters so we can pass the
    values into the cmdlets when we run the script, rather than having to edit the
    script each time. We’ll cover how to make parameters mandatory, how to take values
    from the pipeline, and how to create switch parameters, before moving on to cover
    how to help ourselves and others use our scripts.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们理解了如何使用他人的脚本，我们就会开始编写自己的脚本。首先，我们将学习如何在工作中的 cmdlet 管道中识别变化的值，接着我们会学习如何将这些值转化为参数，这样我们就能在运行脚本时将这些值传递给
    cmdlets，而不需要每次都编辑脚本。我们将涵盖如何使参数成为必填项、如何从管道中获取值以及如何创建切换参数，之后我们将学习如何帮助自己和他人使用我们的脚本。
- en: In the second part of this chapter, we’ll cover how to add comments and comment
    blocks to our script that explain what we’re trying to do in each part and help
    us and others edit and adapt the script. Next, we’ll look at how we can write
    help information that can be accessed from outside the script using the `Get-Help`
    cmdlet. After that, we’ll move on to a script construct that can help us understand
    what is going on when the script is producing unexpected output – the `Write-Verbose`
    cmdlet. Finally, we’ll cover how to add help messages for mandatory parameters,
    which will prompt users with information about how to use the parameter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的第二部分，我们将讨论如何在脚本中添加注释和注释块，解释我们在每个部分尝试做的事情，并帮助我们和他人编辑和调整脚本。接下来，我们将探讨如何编写帮助信息，使其可以通过
    `Get-Help` cmdlet 从脚本外部访问。之后，我们将讨论一个脚本构造，它可以帮助我们理解当脚本产生意外输出时发生了什么——`Write-Verbose`
    cmdlet。最后，我们将讲解如何为必填参数添加帮助信息，提示用户如何使用该参数。
- en: 'In this chapter, we are going to cover the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将覆盖以下主要内容：
- en: Introduction to scripting
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本编写简介
- en: Writing a script
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写脚本
- en: Identifying changing values
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别变化的值
- en: Working with parameters
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用参数
- en: Providing help for our script
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的脚本提供帮助
- en: Introduction to scripting
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本编写简介
- en: A script is a sequence of instructions written in a human-readable form for
    a computer to carry out. They are usually written in a scripting language such
    as PowerShell, Python, or JavaScript. We covered the differences between scripting
    languages and programming languages back in [*Chapter 1*](B17600_01.xhtml#_idTextAnchor013),
    *Introduction to PowerShell 7 – What It Is and How to Get It*; the key thing to
    remember is that scripting languages are interpreted and so need a program (such
    as PowerShell) to be running on the client to run the script, whereas programming
    languages are compiled; they will run directly in the operating system.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本是一系列指令，用人类可读的形式编写，供计算机执行。它们通常使用脚本语言编写，例如 PowerShell、Python 或 JavaScript。我们在[*第1章*](B17600_01.xhtml#_idTextAnchor013)，*PowerShell
    7 简介 – 它是什么以及如何获取*中讨论了脚本语言和编程语言之间的区别；需要记住的关键点是，脚本语言是解释型的，因此需要一个程序（如 PowerShell）在客户端运行来执行脚本，而编程语言是编译型的；它们会直接在操作系统中运行。
- en: Scripting, to me, is an art form. It’s probably the truest cybernetic art form;
    what we write in a script has to make sense to both human beings and machines.
    In [*Chapter 6*](B17600_06.xhtml#_idTextAnchor117), *PowerShell and Files – Reading,
    Writing, and Manipulating Data*, we talked about *Exercises in Programming Style*
    by Cristina Videira Lopes, where a term frequency task was solved in dozens of
    different ways. This is equally true of scripts in PowerShell. There is no one
    way to write a script, and what seems lovely to one person may be really ugly
    to another; I have a deep loathing of code golf, where a script is written with
    as few lines and characters as possible, but that is a personal preference – other
    people love it. Simplicity, and clean and functional code – these things are beautiful,
    and it requires a creative and inventive mind to write it. In this chapter, we’re
    going to cover how I approach writing scripts.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，脚本编写是一种艺术形式。这可能是最真实的控制论艺术形式；我们在脚本中编写的内容必须对人类和机器都有意义。在[*第6章*](B17600_06.xhtml#_idTextAnchor117)，*PowerShell
    和文件 – 读取、写入和操作数据*，我们谈到了Cristina Videira Lopes的*编程风格练习*，在其中以几十种不同的方式解决了术语频率任务。这同样适用于PowerShell中的脚本。没有一种编写脚本的唯一方法，对一个人来说看起来美好的东西对另一个人来说可能非常丑陋；我非常厌恶代码高尔夫，即尽可能少的行数和字符编写脚本，但这是个人偏好
    – 其他人却喜欢。简单、干净和功能性代码 – 这些东西是美丽的，编写它们需要创造性和富有创造力的头脑。在本章中，我们将讨论我如何编写脚本的方法。
- en: Why do we want to write scripts?
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么我们想要编写脚本呢？
- en: Fundamentally, because we are lazy. A script allows us to capture a series of
    steps that may be complicated or time-consuming, and repeat them easily without
    work. Secondly, because we are fallible and easily distracted. The longer and
    more complicated a task is, the more likely we are to make a mistake. Writing
    a script means the task will be completed in the same way every time. If we can
    get it right once and capture that process, then we almost never need to get it
    right again. We can go and make our mistakes somewhere else. Finally, because
    we don’t want to do the thing at all; if we write a script, we can give it to
    somebody else to do.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，因为我们懒惰。脚本允许我们捕捉一系列可能复杂或耗时的步骤，并轻松地重复执行而不需要额外工作。其次，因为我们容易出错和容易分心。任务越复杂越长，我们犯错的可能性就越大。编写脚本意味着任务每次都会以相同的方式完成。如果我们能够做对一次并捕捉该过程，那么我们几乎永远不需要再次做对。我们可以去其他地方犯错误。最后，因为我们根本不想做这件事；如果我们编写一个脚本，我们可以把它交给别人去做。
- en: Script writing is an example of toolmaking, where we create something to make
    our task easier to accomplish. Some script writing might be proper automation,
    but generally, automation includes the concept of a feedback loop, where the tool
    responds to an external stimulus without user intervention. A central heating
    boiler is a tool; it makes heating your house much easier than building a fire
    in each room. A thermostat is automation; when the temperature is too low, it
    turns the boiler on, and when it is too high, it turns the boiler off. If we’ve
    set it correctly, then we should never be too warm or too cold.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本编写是工具制造的一个例子，我们创建一些东西来使任务更容易完成。一些脚本编写可能是适当的自动化，但一般来说，自动化包括反馈循环的概念，即工具在没有用户干预的情况下响应外部刺激。中央供暖锅炉就是一个工具；它使得加热房屋比在每个房间里生火要容易得多。恒温器是自动化的一种；当温度过低时，它打开锅炉，而当温度过高时，它关闭锅炉。如果我们设置正确，那么我们就不会太热或太冷。
- en: 'There is some theory around toolmaking and automation that is worth considering,
    as it can help us decide whether we want to write a script or not. Let’s quickly
    cover the three basic principles of automation:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些围绕工具制造和自动化的理论值得考虑，因为它可以帮助我们决定是否要编写脚本。让我们快速了解自动化的三个基本原则：
- en: '**Compensatory principle**: This is based on the concept that machines are
    better at some tasks than people, and people are better at some tasks than machines.
    Automation and tools based on this principle divide work based on the strengths
    and weaknesses of people and machines.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**补偿原则**：基于这样一个概念，即机器在某些任务上比人类更擅长，而人类在某些任务上又比机器更擅长。基于这一原则的自动化和工具根据人类和机器的优势和劣势来分配工作。'
- en: '**Complementarity principle**: Constantly using tools to accomplish difficult
    tasks can de-skill the human operator; we forget how to do things. Then, when
    we really need to take over, when things are going wrong, we can’t fix the problem.
    We use this principle where the human operator must retain the skills that the
    automation is replacing. Aircraft autopilots are a good example of this; the operator
    doesn’t use them all the time or may only use part of them so that they retain
    the skills they need when the autopilot can’t land the plane because of weather
    or a mechanical failure.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**互补性原理**：不断使用工具完成困难的任务可能会削弱人类操作员的技能；我们会忘记如何做事。然后，当我们真的需要接管时，当事情出错时，我们无法修复问题。我们使用这个原理，要求人类操作员必须保持自动化替代的技能。飞机自动驾驶仪就是一个很好的例子；操作员并不是一直使用它们，或者可能只使用其中的一部分，以便在自动驾驶仪因为天气或机械故障无法着陆时，操作员能保持所需的技能。'
- en: '**Left-over principle**: This is the principle we most commonly associate with
    scripting. It’s the idea that we automate everything we can, and then manually
    do what is left over.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**剩余原理**：这是我们最常与脚本编写相关联的原理。它的想法是我们自动化所有能自动化的任务，然后手动完成剩下的部分。'
- en: Of course, it’s a little bit more complicated than that. Sometimes, tasks are
    too hard to automate, or we do them so rarely it’s not worth bothering. We’ll
    not save any time or effort by writing a script. A rule of thumb is to script
    anything that will take less time to script than you will spend doing it manually
    over three years. So, if you have a task that you do every weekday that takes
    5 minutes, and it will take you 4 hours to script, then that works out at 62 hours
    over 3 years. By spending 4 hours scripting it, you’ll save over a week of work
    for yourself, over 3 years. Let’s start by understanding where we can get scripts
    that other people have written.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这比听起来要复杂一点。有时任务太难以自动化，或者我们做得很少，以至于不值得麻烦。通过编写脚本我们并不会节省时间或精力。一个经验法则是，如果你有一个任务，每天都要做，且每次花费
    5 分钟，而写脚本需要 4 小时，那么在 3 年内，这个任务将花费 62 小时。通过花费 4 小时编写脚本，你将在 3 年内为自己节省一周的工作。让我们从了解如何获取别人编写的脚本开始。
- en: Getting scripts
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取脚本
- en: 'We discussed different places to get PowerShell modules and cmdlets in [*Chapter
    2*](B17600_02.xhtml#_idTextAnchor034), *Exploring PowerShell Cmdlets and Syntax*.
    We can use those same places to find PowerShell scripts as well. Let’s just recap
    them:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [*第 2 章*](B17600_02.xhtml#_idTextAnchor034)《探索 PowerShell Cmdlet 和语法》中讨论了获取
    PowerShell 模块和 Cmdlet 的不同途径。我们也可以利用这些途径来查找 PowerShell 脚本。让我们回顾一下这些资源：
- en: '**PowerShell repositories**: Whether it’s the official PowerShell repository
    at [https://www.powershellgallery.com/](https://www.powershellgallery.com/), the
    Microsoft Learn repository at [https://learn.microsoft.com/en-us/samples/browse/](https://learn.microsoft.com/en-us/samples/browse/),
    or an internal one, repositories are great places to find scripts. Generally speaking,
    scripts in the PowerShell Gallery have undergone some minimal validation and will
    have information about the author, the version, and the license for use.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PowerShell 仓库**：无论是官方的 PowerShell 仓库 [https://www.powershellgallery.com/](https://www.powershellgallery.com/)，还是
    Microsoft Learn 仓库 [https://learn.microsoft.com/en-us/samples/browse/](https://learn.microsoft.com/en-us/samples/browse/)，或者内部的仓库，都是寻找脚本的好地方。一般来说，PowerShell
    Gallery 中的脚本经过了一些基本验证，会提供关于作者、版本和使用许可的信息。'
- en: '**GitHub**: This is also a good source for PowerShell scripts, but they’re
    generally not validated and may not be complete or functional.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GitHub**：这是另一个很好的 PowerShell 脚本来源，但这些脚本通常没有经过验证，可能不完整或不可用。'
- en: '**Online elsewhere**: There are very good scripts elsewhere online. For example,
    the Practical 365 site ([https://practical365.com](https://practical365.com))
    has some extremely useful scripts for working with Microsoft 365\. However, the
    quality of online scripts may be variable.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**其他在线资源**：网上有很多很好的脚本。例如，Practical 365 网站（[https://practical365.com](https://practical365.com)）有一些非常有用的
    Microsoft 365 脚本。然而，在线脚本的质量可能会有所不同。'
- en: Whenever we get a script from an author we don’t know or trust, we should be
    careful to understand what the script does and how it does it before running it
    in an environment we care about. We should do this even when we do trust the author,
    of course. It is worth starting a sandbox or virtual machine to test the script
    first.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们从不认识或不信任的作者那里获取脚本时，应该小心理解脚本的作用和运行方式，再在我们关注的环境中运行它。当然，即使我们信任作者，仍然值得先在沙箱或虚拟机中测试脚本。
- en: Running scripts
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two things we need to be aware of before we can run a script. The
    first is that PowerShell scripts always have an extension of `.ps1`. Files with
    this extension are not registered as executables, so double-clicking them in Windows
    Explorer will open them in Notepad or another editor; it won’t run the script.
    Files with this extension also require a relative or absolute path to run from
    the PowerShell terminal, so with either `PS C:\myscripts> .\MySuperScript.ps1`
    (relative path) or `PS C:\> C:\myscripts\MySuperScript.ps1` (absolute path) without
    the `.\`, the script won’t run.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'Secondly, PowerShell has an execution policy for running scripts, but only
    on Windows computers. By default, on a Windows client, the execution policy is
    `Restricted`, which means that scripts cannot run. Happily, we can change this
    for the current user by running the following cmdlet:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will allow the current user to run scripts that have been written on the
    local machine, or scripts downloaded from the internet that include a code signature.
    We’ll be covering execution policy and code signing in detail in [*Chapter 12*](B17600_12.xhtml#_idTextAnchor236),
    *Securing PowerShell*, but for now, run this cmdlet so that we can get on with
    writing a script.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: If we are using a Linux or Mac client, we don’t need to do this. The policy
    is effectively `Unrestricted` for those computers because of differences in the
    way security is implemented in the Linux and macOS operating systems.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s enough introduction; let’s get on with what we’re here for: writing
    a script.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Writing a script
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'How do we go about writing a script? Pretty much every script I write from
    scratch starts with writing down the steps and cmdlets I need to complete a task.
    Once I can complete the task with only the information in the list, and all the
    cmdlets work, I know I am ready. Let’s start our script with a working command.
    As an example, consider the following cmdlet:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This cmdlet gets some weather data for my location from the API service from
    the Weather API, using a personal key, and writes it to an HTML file for display.
    Obviously, I’ve not put my real personal key in the preceding cmdlet, so it will
    fail with an API key error if we run that exact code. Let’s consider how we might
    turn this cmdlet into a script. To continue, we’ll need to get our own personal
    key.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Getting a Personal Key for the Weather API Service
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'To work through this chapter, we’ll need our own personal key for the Weather
    API service:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Go to [https://www.weatherapi.com](https://www.weatherapi.com) and click
    the **Sign** **Up** button.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Enter an email address (twice) and a new password (twice), accept the terms
    and conditions, complete the CAPTCHA, and we will be sent a verification email.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Clicking the link in the verification email will open a web page to tell
    us that we are verified, and will invite us to log in.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Do this by clicking the login link and entering our email address and the
    password we have just created. At the top of the next page is our personal API
    key. This is the key we will use to run this cmdlet.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. 通过点击登录链接并输入我们刚刚创建的电子邮件地址和密码来完成此操作。下一页的顶部是我们的个人API密钥。这就是我们将用来运行此cmdlet的密钥。
- en: 5\. Copy it and save it in a text file somewhere safe. You can always find it
    again by logging in to the service.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 5\. 复制它并保存在某个安全的文本文件中。你可以随时通过登录服务再次找到它。
- en: 'Now we’ve got a key, let’s open VS Code and create a new file. Call it `weatherdata.ps1`.
    Type the following, using the key we’ve just generated from the Weather API instead
    of `<our new` `key here>`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了密钥，让我们打开VS Code并创建一个新文件。命名为`weatherdata.ps1`。输入以下内容，使用我们刚刚从天气API生成的密钥，而不是`<our
    new key here>`：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let’s think about tidying this cmdlet up so that it is more readable. The cmdlet
    does two things; it gets information from the API, and it outputs that information
    to a file, so let’s split those up:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们思考如何整理这个cmdlet，以使其更加可读。这个cmdlet做了两件事：它从API获取信息，然后将这些信息输出到文件中，所以我们可以将这两部分拆开：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: So now, we are storing the response in a variable and then outputting it in
    the second line.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将响应存储在一个变量中，然后在第二行输出它。
- en: 'How else might we make this more readable? That first cmdlet is very long.
    We could break out the headers and the URI to make it more readable, as we can
    see in the following figure:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以如何使这个代码更具可读性？第一个cmdlet非常长。我们可以将头部和URI分开，以使其更具可读性，正如以下图所示：
- en: '![Figure 8.1 – Readable code](img/B17600_08_001.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.1 – 可读代码](img/B17600_08_001.jpg)'
- en: Figure 8.1 – Readable code
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – 可读代码
- en: 'If we save `weatherdata.ps1`, we can now run it from the PowerShell console
    by switching to the directory we save it in and running the following at the prompt:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们保存`weatherdata.ps1`，现在可以从PowerShell控制台运行它，只需切换到我们保存它的目录，并在提示符下运行以下命令：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: While the code is readable, it’s not very flexible. It does one thing, and if
    we want it to do something slightly different (for instance, produce the data
    for a different city) or if we want to share it with someone else, we need to
    make some changes. Let’s look at where we might start with that.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然代码是可读的，但它并不太灵活。它做一件事，如果我们希望它做一些稍微不同的事情（例如，获取不同城市的数据），或者如果我们想与其他人共享它，我们需要做一些更改。让我们看看从哪里开始做这些更改。
- en: Identifying changing values
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别变化的值
- en: Let’s think about things we might want to change in this code. We want it to
    get weather information from the web and write it to a HTML document. This means
    it’s unlikely that we want to change the `Invoke-RestMethod`, `Convertto-Html`,
    and `Out-File` cmdlets. Think about what values might change before we move on.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们思考一下在这段代码中可能需要更改的内容。我们希望它从网络获取天气信息并将其写入HTML文档。这意味着我们不太可能想要更改`Invoke-RestMethod`、`Convertto-Html`和`Out-File`这些cmdlet。想一想在我们继续之前可能会更改的值。
- en: Ready? Good.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好了吗？很好。
- en: 'These are some things that we might want to be able to change the values of
    when we run the script:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们可能希望在运行脚本时能够更改其值的一些内容：
- en: We might want to change the city.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可能想要更改城市。
- en: We might want to change where we save the HTML output.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可能想要更改HTML输出的保存位置。
- en: We might want to change the API key.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可能想要更改API密钥。
- en: We might not want to hardcode the API key in the script at all.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可能根本不想在脚本中硬编码API密钥。
- en: We can pass values for these things when we call the script by making them parameters
    within the script. The next section will be all about parameterizing our script.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在脚本中将它们设置为参数来传递这些值。下一节将专门讲解如何将脚本参数化。
- en: Working with parameters
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用参数
- en: Parameters are values for script variables that can be passed when we run the
    script, rather than being hardcoded into the script. As we’ve just seen in the
    previous section, we run the script in much the same way as we run any other cmdlet,
    and, as with cmdlets, we can pass parameter values to our script. Let’s look at
    how we do that.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 参数是脚本变量的值，可以在我们运行脚本时传递，而不是硬编码到脚本中。正如我们在上一节中所看到的，我们以与运行其他cmdlet相同的方式运行脚本，并且，像cmdlet一样，我们可以向脚本传递参数值。让我们看看如何做到这一点。
- en: 'The first thing we need is the `CmdletBinding` attribute. Attributes are a
    way of telling PowerShell how we want it to process the elements of our script.
    We’ve used them before in [*Chapter 4*](B17600_04.xhtml#_idTextAnchor071), *PowerShell
    Variables and Data Structures*, when we learned how to cast variables. The `CmdletBinding`
    attribute tells PowerShell that we want it to treat the script as a cmdlet. Some
    of the big advantages this has are that our script will be able to access common
    parameters such as `-Verbose`, as well as positional binding. Let’s add it. At
    the top of our script, create a new line and add this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, we need to create a `Param()` block to hold the variables we want to
    use as parameters. On a line directly under the `CmdletBinding` attribute, type
    this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `Param()` block must precede all the code that we’re going to write. We
    will add our parameters inside the brackets, so it’s best to press *Enter* a couple
    of times inside the brackets so that we have some space to add them:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, we’re ready to start creating parameters.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Creating useful parameters
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most useful parameters are values that change. Let’s start with the city
    we’re getting weather data for. The city is embedded in the `$uri` variable, which
    is a string. We can easily create a new variable to just hold the city name and
    pass it to the `$uri` variable. Try this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And change the `$uri` variable to look like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Remember we need to use double quotes here (`"`) so that the `$City` variable
    will be expanded. We can check our code against the following figure:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Adding the CmdletBinding attribute and a param() block](img/B17600_08_002.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – Adding the CmdletBinding attribute and a param() block
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: This will write the value of `$city` into the `$uri` value when we run it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Test, Test, Test
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: This is really important; if we make two changes and the script stops working,
    we will have to work out which change broke the script. Test after every change.
    Make sure it all still works before moving on to another change.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s test it. From the console, make sure we’re in the directory where we’ve
    saved the script, and type the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, check the `WeatherData.html` file. It should look like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – Welcome to beautiful Paris](img/B17600_08_003.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – Welcome to beautiful Paris
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: If this has worked for you, congratulations! You have parameterized your first
    script. Let’s look at what we’ve done.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: By putting the `$City` variable into the `Param()` block, we’ve made it accessible
    from outside the script so that we can pass values to it when we run the script.
    By assigning a value to the variable, writing `$City = "London"`, we’ve set a
    default value so that if we don’t pass a value via a parameter, the script will
    still run.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: We can put as many variables as we like in the `Param()` block, but we must
    separate each one with a comma (`,`). Let’s do another one; try the following
    activity.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Activity 1
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: How might we pass the location where we want to save the output? And how might
    we make that as easy as possible?
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint: if we pass just a filename, it will save the output in the same location
    as the script is running from. Would we want that every time?'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at what we could do with the key. Keys are a long string of random
    characters, so it’s not going to be practical to type that into a parameter. How
    might we get around this?
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: We could save the key to a file, and then use `Get-Content` to extract the string
    from the file and use it that way. In [*Chapter 7*](B17600_07.xhtml#_idTextAnchor140),
    *PowerShell and the Web – HTTP, REST, and JSON* we saw there are two ways of passing
    a key to `Invoke-RestMethod`. We can either pass it to the `-Key` parameter or
    include it in the `-Headers` parameter, as we are doing in this script. The important
    difference is that in one scenario the key must be encoded, and in the other,
    it must be plain text. Can you remember which is which? Look back to the last
    chapter to find out.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: If you remembered, well done. If you worked it out from how our script currently
    works, even better. We’re already passing an unencoded string in the header, so
    we don’t need to encode our key before saving it.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Open a new text document using your preferred text editor and save it as `key.txt`
    in the same folder as the script – in my case, `c:\temp\poshbook\ch8`. Copy and
    paste your `WeatherApi` key into it and save it.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we need to do is add a parameter that points to the file, and a line
    that gets the content from the file. Then, we can add that to the `$headers` variable.
    It might look something like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We’ve identified our changing values and created our parameters.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Activity 2
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Knowing what we know from previous chapters, how might we rewrite our script
    so that we can accept multiple values for the `-``City` parameter?
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint 1: Look at a help file for a cmdlet that accepts multiple strings in a
    parameter to see how we could write an attribute for the `-City` parameter. `Get-Random`
    accepts multiple objects for `-InputObject`.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint 2: We’re going to want a way of processing each string in turn. Remember,
    multiple strings passed into a parameter are an array.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint 3: We’re going to want to send each city to a different output.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at how we might improve them using attributes.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Specifying type
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can limit the possibility of errors by specifying the type of the parameter
    in the same way as we specify the type of a variable, by typing the attribute
    before the variable. In your script, replace the `$City = "London"` line with
    this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, whatever we pass in the `-City` parameter will be cast to a string.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Making parameters mandatory
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We might want our script to require an explicit value for the `–City` parameter
    each time we run it. We could do that by changing the `-City` parameter like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We’ve added the line `[Parameter(Mandatory = $true)]` before the `$City` parameter.
    Note that there is no comma (`,`) after the attribute. Now we’ve done that, the
    script ignores the default value for the parameter (`"London"`), and it prompts
    for a city:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – Mandatory parameters](img/B17600_08_004.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 – Mandatory parameters
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: In the figure, we can see that because we didn’t include a value for the `-City`
    parameter, we get prompted. One of the most useful things we can do with a script
    is to make it accept parameter values from the pipeline. Let’s have a look at
    how we can do that.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Taking values from the pipeline
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We covered how parameters can take values from the pipeline in [*Chapter 3*](B17600_03.xhtml#_idTextAnchor049),
    *The PowerShell Pipeline – How to String Cmdlets Together*. In this section, we’re
    going to see how easy it is to make our script accept pipeline values. Remember,
    there are two ways that a parameter can take values from the pipeline: `ByValue`
    and `ByName`. For our script, it would be best if we let the `-City` parameter
    accept pipeline input by value, so let’s do this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'All we’ve done is add the line `[Parameter(ValueFromPipeline)]` to the `Param()`
    block. We can see the difference it makes in the following figure:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – Accepting values from the pipeline](img/B17600_08_005.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 – Accepting values from the pipeline
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: In the first example, we can see that we’ve created a string, `"cwmbran"`, and
    tried to pass it through the pipeline to the script. The script doesn’t accept
    values from the pipeline, and we get an error message in red telling us just that.
    If we then alter the `-City` parameter to accept values from the pipeline, we
    can see the script completing without error in the second example.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see what happens if we try feeding two values into the script through
    the pipeline, as in this example:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We will only get an output for the last item. To make this work properly, we
    need to include the part of the script we want to repeat for each item in a `process
    {}` block, like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6 – Making pipeline input work properly](img/B17600_08_006.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
- en: Figure 8.6 – Making pipeline input work properly
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'I’m opening a `process {}` block on line `44`, and then closing it on line
    `61`. I can now feed multiple cities into the pipeline and get an HTML file for
    each of them, like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that doesn’t mean we can get rid of the `foreach` loop from *Activity 2*
    entirely, though. If we pass multiple cities explicitly using the `-City` parameter,
    we will still need to process them individually with a loop.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'There are lots of other things we can do with parameters, which are detailed
    in the article here: [https://learn.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-12](https://learn.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-12).'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'Many of them can be used to validate the parameter input: making sure that
    it is the correct type, or even selecting input from a list of accepted values.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Switch parameters
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There’s one last feature of parameters we should talk about before moving on:
    switch parameters. Many of the cmdlets we’ve been using have parameters that act
    as switches; they don’t take a value, they just have to be present to change the
    behavior of the cmdlet. For example, using the `-Full` parameter in `Get-Help`
    changes the amount of help information that is returned. We can do that in our
    script too. Try this – after the `param()` block, add the following lines:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then on the last line of the `param()` block, add the following line before
    the closing parenthesis. Remember, you will also need to add a comma after the
    previous parameter:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following figure shows how it looks in my script and shows the output when
    we use our new `-``Joke` parameter:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7 – Only joking](img/B17600_08_007.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
- en: Figure 8.7 – Only joking
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: In line `40`, I’ve added a comma after the parameter, so PowerShell knows there’s
    another parameter coming. I’ve added the new `-Joke` switch parameter in line
    `41`, and then on lines `44`-`46`, I’ve added an `If` statement to tell PowerShell
    what to do if the switch is present. Finally, I’ve used the switch in the terminal
    at the bottom when I called the script, and the script told me the best joke in
    the world. Simple, huh?
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Note that when we’re looking at other people’s scripts on the internet, we may
    well see a different construction for switch parameters. Instead of using `If
    ($Joke.IsPresent)`, we will often see `If ($Joke -eq $true)`. While this will
    work, it’s a much older way of doing things and could be confusing. Using the
    `.IsPresent` method of the parameter is the way Microsoft recommends.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: We’ll be using parameters a lot as we go through the rest of the book, but for
    now, let’s look at the other main topic of this chapter, providing help in our
    scripts.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Providing help for our script
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing scripts is great fun, and we learn new things every time we write one.
    We include the new techniques or shortcuts, finish the script, put it to work,
    and then forget about it. The next time we look at it might be months or even
    years later, by which time we might well have forgotten how it works or why we
    wrote it the way we did. The answer to this is to write comprehensive help for
    the script, explaining how our script works and how to use it. This is even more
    important for scripts that we make available for other people to use.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’re going to cover four ways of providing help. First, we’re
    going to briefly look at how we can comment our code to help ourselves and others.
    After that, we’ll look at creating comment-based help for use with the `Get-Help`
    cmdlet. Then, we’re going to look at the `Write-Verbose` cmdlet, and how we can
    use it to understand what the script is doing. Finally, we’ll look at how we can
    provide help for mandatory parameters.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with commenting our code.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Comments
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We briefly mentioned comments in [*Chapter 5*](B17600_05.xhtml#_idTextAnchor096),
    *PowerShell Control Flow – Conditionals and Loops*. We saw that a single line
    may be turned into a comment by adding a hash at the start (`#`), and we could
    create multiline comments by enclosing a body of text like this: `<# … #>`. However,
    we didn’t really talk about why comments are useful. PowerShell is a scripting
    language – a particularly friendly one, in my opinion. Most of the time, it is
    reasonably obvious to someone who knows the language what a line of code will
    do, but a line of explanation means that we don’t need to parse each line to know
    what was intended. And, of course, what we write doesn’t always do what we intend.
    A comment that records what we want the line to do makes our lives a lot easier
    when we’re digging through four or five hundred lines of code. When the script
    is being adapted by somebody else, comments are invaluable. Have a look at the
    example below:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The comment line tells us exactly what the slightly unreadable code is hopefully
    going to achieve.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Comment blocks
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Comments are intended to be read in an editor of some sort. To make them easier
    to read, we will want to split a long comment across multiple lines. We could
    use the backtick character (`` ` ``) to escape manual line breaks, but that doesn’t
    really make it easier to read, particularly for some editors and some fonts. It’s
    better to use the blockquote construct, `<#...#>`. Have a look at the following
    figure:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8 – Comment blocks](img/B17600_08_008.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
- en: Figure 8.8 – Comment blocks
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'The comment block is in green and explains the intention of the following lines.
    Let’s have a look at some dos and don’ts for writing good comments:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Comment on a separate line; adding a comment on the same line makes the line
    either too long or causes it to wrap in the editor.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comment before the line you’re explaining; prepare the reader for what’s coming
    next in the script, not what’s been.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t comment on the obvious; generally speaking, too many comments are better
    than too few but don’t waste your time explaining things that don’t need it. Better
    to comment what a block of simple lines does than each individual line.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s look at how we can provide help for our script with the `Get-Help` cmdlet.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Comment-based help
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Get-Help` cmdlet reads XML help files included with the main PowerShell
    program, and for modules and functions that have them. However, it can also read
    correctly formatted comments embedded in a script. This is called **comment-based
    help**. We can write comment-based help by adding special help comment keywords
    at the start of our script.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a number of rules to remember about writing comment-based help:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: It must be either at the start or the end of a script. For a couple of reasons,
    including the best practices for comments we covered previously, we should put
    it at the start.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comment-based help must be contiguous. We can’t split it up into different comment
    blocks.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each section of the help must start with a legitimate keyword. The keyword is
    not case-sensitive, but it must be preceded by a dot (`.`).
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There must be two blank lines after the comment-based help.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Luckily, VS Code makes writing comment-based help a breeze. Let’s see it working.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: In our script, create a new line at the start of the script, and type `comm`.
    As we can see in the following figure, VS Code will offer us the `comment-help`
    function helper if we have the PowerShell extension installed.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.9 – The comment-help function in VS Code](img/B17600_08_009.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
- en: Figure 8.9 – The comment-help function in VS Code
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and select it. VS Code will create a comment-based help template for
    us with the most commonly used keywords, correctly formatted, and even add the
    two blank lines after the block for us.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at the common sections:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '`.SYNOPSIS`: This section should be one line that summarizes what the script
    does.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.DESCRIPTION`: This is where we put the full description, including how it
    works, what it should be used for, different ways to use it, and so on.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.NOTES`: This is where we should put warnings about incompatibilities, prerequisites
    for running the script (for instance, that we need to have a `weatherapi` key
    saved to a text file), and any other useful information that doesn’t fit in the
    description.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.LINK`: This will provide a link for `Get-Help -Online` to consume. Personally,
    I never use it and delete it from the help section.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.EXAMPLE`: We can put examples of usage here to explain how to use the parameters.
    Separate each example with a new `.EXAMPLE` keyword on a new line.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I’ll admit, the first time I did this, it was a real thrill seeing my script
    help looking like the real thing. It doesn’t get old:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.10 – Retrieving comment-based help for a script](img/B17600_08_010.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
- en: Figure 8.10 – Retrieving comment-based help for a script
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: This works just like anything else with `Get-Help`. To see the notes, type `Get-Help
    .\weatherdata.ps1 -Detailed`. To get everything, use the `-``Full` parameter.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Activity 3
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Write a short comment-based help for the script. Test it by calling `Get-Help
    .\weatherdata.ps1` from the console.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s it for comment-based help. It’s incredibly useful, whether we read it
    in the editor or using the `Get-Help` cmdlet. I recommend we use it as often as
    we can. Let’s look at something else now, that isn’t strictly help, but is definitely
    helpful: the `Write-Verbose` cmdlet.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Write-Verbose
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Back in [*Chapter 3*](B17600_03.xhtml#_idTextAnchor049), *The PowerShell Pipeline
    – How to String Cmdlets Together*, we talked briefly about the standard streams:
    output streams that exist in most programming languages and classify and direct
    output. The verbose stream is one of them and is intended for messages that help
    users understand what a cmdlet is doing. It’s particularly useful for troubleshooting
    long-running cmdlets that don’t appear to be doing anything. Every PowerShell
    cmdlet has a `-Verbose` switch parameter that allows us to see what the cmdlet
    is doing and whether it’s got stuck, although not all of them produce a verbose
    stream output. We can see this in action already in our script because the `Invoke-RestMethod`
    cmdlet has a particularly useful verbose output. Try this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You should see something like the following figure:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.11 – Verbose output from inside our script](img/B17600_08_011.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
- en: Figure 8.11 – Verbose output from inside our script
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: We’re able to access this verbose output because we have used the `CmdletBinding()`
    attribute at the start of the script, which gives us access to advanced functions.
    Without it, we can call the `-Verbose` parameter without an error, but it won’t
    produce any output.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do even more than this, though; we can write our own verbose stream
    messages with the `Write-Verbose` cmdlet. Why is this useful? Because when we
    are processing many items in a loop in our script, it can tell us which item in
    the loop is failing. Let’s say we ask our script to produce the data for three
    cities as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, we’ll get an error saying that when `Invoke-RestMethod` ran, a matching
    location couldn’t be found, but the line of code that threw the error is as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: So it could be any of the cities that doesn’t exist.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'We can fix this by changing the start of the `foreach` loop:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We’ve added the line `Write-Verbose "Processing $Item"` at the start of the
    loop, which means that if we use the `-Verbose` parameter now, the script tells
    us which city it’s processing, and we can see which of our cities is fictitious,
    as in the following figure:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.12 – Using Write-Verbose to illuminate the Bible-black](img/B17600_08_012.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
- en: Figure 8.12 – Using Write-Verbose to illuminate the Bible-black
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run the script in the first line, all we see is the error, but when
    we run it with the `-Verbose` parameter, it tells us which city it was processing
    when it encountered the error. Let’s look at the final type of help we’ll cover
    in this chapter: parameter help messages.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Parameter help messages
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As well as controlling how parameters work in a script, we can also write helpful
    comments to guide people in using parameters in our scripts. These comments only
    apply to mandatory comments and are available if the mandatory parameter isn’t
    provided. Let’s try it. Edit the `$City` parameter like this:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, when we run it without supplying a value for the `$City` parameter, we
    get a message suggesting we type an interrobang (`!?`) for help:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.13 – Accessing the HelpMessage parameter](img/B17600_08_013.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
- en: Figure 8.13 – Accessing the HelpMessage parameter
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Once we type the interrobang, the message we wrote in the script is presented.
    It’s as easy as that; just remember that we can only use parameter help messages
    with mandatory parameters.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: That about wraps it up for this chapter. Let’s review what we’ve learned.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ve moved on from learning the building blocks of PowerShell
    syntax, and now we’re beginning to put things together. The techniques we’ve learned
    may not be familiar to us, but with time and practice, they will become familiar
    and easy. As we go through the rest of the book, we will have plenty of opportunities
    to use them.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: We started by talking about what scripts are and why we might want to write
    scripts at all. We looked briefly at where we can find other people’s scripts,
    and what we need to do to run them on our machines.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: We’ve done a lot of practical work in this chapter. Firstly, we looked at how
    we might make it easier for people to read what we’re doing by breaking long pipelines
    up and substituting variables for hardcoded values in cmdlets, particularly values
    that might change.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: We moved on to look at how we could pass those values into the script from outside
    using parameters, and we looked at various ways we could define and manipulate
    those parameters by making them mandatory or taking values from the pipeline.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: We then looked at how we could make our scripts more easily understood by providing
    comments, before creating full-blown comment-based help for them, so that we can
    use the `Get-Help` cmdlet.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: After that, we looked at using the `Write-Verbose` cmdlet to provide verbose
    output. This helps us understand what our script is doing when it doesn’t seem
    to be working as we hoped.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we looked at providing help messages for mandatory parameters to make
    it easier for people to run our scripts.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’re going to look at how we can make our code simpler
    and easier to write using script blocks, lambdas, and functions.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Output streams: https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_output_streams'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some automation theory: https://poshidiot.wordpress.com/2018/06/12/how-do-i-know-what-to-automate/'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Practice of Cloud System Administration*, Limoncelli, T., Hogan, C., and
    Chalup, S. (2017) Boston: Addison-Wesley, [*Chapter 12*](B17600_12.xhtml#_idTextAnchor236).'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Time Management for System Administrators*, Sebastopol: Limoncelli, T. (2008),
    O’Reilly Media, Inc., [*Chapter 13*](B17600_13.xhtml#_idTextAnchor267).'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Why the Fitts list has persisted throughout the history of function allocation*:
    de Winter, J. C. F., and Dodou, D. (2014), Journal of Cognition, Technology &
    Work'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Learn more about attributes and parameters: https://learn.microsoft.com/en-us/powershell/scripting/lang-spec/chapter-12'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On attempting to run a script we’ve written, another user on our machine gets
    an error message that says `running scripts is disabled on this system`. What
    do we have to do to allow them to run the script?
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We have a young relative who loves *Dungeons and Dragons*, but they’ve lost
    their 20-sided die. We write a short PowerShell script for them, `Get-Die.ps1`,
    as follows:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This will produce a random number between 1 and 20 every time it is run. Which
    value in this line of code is most likely to change if they lose another die with
    a different number of sides?
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the `Get-Die.ps1` script from the previous question, how would we parameterize
    the changing value?
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What type of parameter should it be, and how would we specify it?
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They like the script, and now they’ve lost their four-sided die. They’ve discovered
    that they can put any number they like into the parameter. While this was quite
    cool at first, now they want the script to only let them roll the dice that are
    used in the game. How could we do that? We need to know that *Dungeons and Dragons*
    uses 4-, 6-, 8-, 10-, 12-, and 20-sided dice, and we’ll also need to read the
    link about parameters given in the text.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our relative explains that sometimes they need to roll more than one die of
    the same type at a time and asks whether there is a way to do this. Well, of course
    there is… let’s write it for them.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They’ve noticed that sometimes they forget to put the number of dice in, and
    they get a total of 0\. How could we stop that from happening?
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’re not always going to be around, and sometimes they aren’t sure what to
    put in the parameters. How could we make it easier for them?
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'They are really trying our patience. Every now and then, they need to roll
    something they call a d100\. This is a 10-sided die, with numbers going up in
    tens: 0, 10, 20, 30, and so on, plus a roll of a normal 10-sided die, which added
    together gives them a number between 1 and 100\. Promising ourselves we’ll never
    babysit for them again, how do we do that?'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
