- en: '19'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '19'
- en: Debugging with GDB
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GDB调试
- en: Bugs happen. Identifying and fixing them is part of the development process.
    There are many different techniques for finding and characterizing program defects,
    including static and dynamic analysis, code review, tracing, profiling, and interactive
    debugging. We will look at tracers and profilers in the next chapter, but here
    I want to concentrate on the traditional approach of watching code execution through
    a debugger, which in our case is the **GNU Debugger** (**GDB**). GDB is a powerful
    and flexible tool. You can use it to debug applications, examine the postmortem
    files (core files) that are created after a program crash, and even step through
    kernel code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 错误是不可避免的，识别并修复它们是开发过程的一部分。找到并表征程序缺陷有许多不同的技术，包括静态和动态分析、代码审查、跟踪、性能分析和交互式调试。我们将在下一章讨论跟踪器和性能分析器，但这里我想专注于通过调试器查看代码执行的传统方法，在我们的案例中是**GNU调试器**（**GDB**）。GDB是一个强大且灵活的工具。你可以用它来调试应用程序、检查程序崩溃后生成的后期文件（核心文件），甚至逐步调试内核代码。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍以下内容：
- en: GNU debugger
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GNU调试器
- en: Preparing to debug
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备调试
- en: Debugging applications
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试应用程序
- en: Just-in-time debugging
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即时调试
- en: Debugging forks and threads
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试分支和线程
- en: Core files
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心文件
- en: GDB user interfaces
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GDB用户界面
- en: Debugging kernel code
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试内核代码
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with the examples, make sure you have the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟上示例的进度，请确保你已经准备好了以下内容：
- en: An Ubuntu 24.04 or later LTS host system with at least 90 GB of free disk space
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台运行Ubuntu 24.04或更高版本LTS的主机系统，且至少有90 GB的空闲磁盘空间
- en: Buildroot 2024.02.6 LTS release
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Buildroot 2024.02.6 LTS版本
- en: Yocto 5.0 (Scarthgap) LTS release
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Yocto 5.0（Scarthgap）LTS版本
- en: A microSD card reader and card
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个microSD卡读卡器和卡
- en: balenaEtcher for Linux
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用于Linux的balenaEtcher
- en: An Ethernet cable and router with an available port for network connectivity
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一根以太网电缆和一台具有可用端口的路由器，用于网络连接
- en: A USB to TTL serial cable with a 3.3 V level
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一条带有3.3 V电平的USB转TTL串口电缆
- en: A Raspberry Pi 4
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台Raspberry Pi 4
- en: A 5 V USB-C power supply capable of delivering 3 A
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一款能够提供3 A电流的5 V USB-C电源
- en: You should have already installed the 2024.02.6 LTS release of Buildroot for
    [*Chapter 6*](Chapter_04.xhtml#_idTextAnchor110). If you have not, then refer
    to the *System requirements section* of *The Buildroot user manual* ([https://buildroot.org/downloads/manual/manual.html](https://buildroot.org/downloads/manual/manual.html))
    before installing Buildroot on your Linux host according to the instructions from
    [*Chapter 6*](Chapter_04.xhtml#_idTextAnchor110).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经安装了Buildroot的2024.02.6 LTS版本，参考[*第六章*](Chapter_04.xhtml#_idTextAnchor110)。如果没有，请在按照[*第六章*](Chapter_04.xhtml#_idTextAnchor110)的说明在你的Linux主机上安装Buildroot之前，参考*系统要求部分*的*Buildroot用户手册*（[https://buildroot.org/downloads/manual/manual.html](https://buildroot.org/downloads/manual/manual.html)）。
- en: You should have already built the 5.0 (Scarthgap) LTS release of Yocto in [*Chapter
    6*](Chapter_04.xhtml#_idTextAnchor110). If you have not, then please refer to
    the *Compatible Linux Distribution* and *Build Host Packages* sections of the
    *Yocto Project Quick Build* guide ([https://docs.yoctoproject.org/brief-yoctoprojectqs/](https://docs.yoctoproject.org/brief-yoctoprojectqs/))
    before building Yocto on your Linux host according to the instructions in [*Chapter
    6*](Chapter_04.xhtml#_idTextAnchor110).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经在[*第六章*](Chapter_04.xhtml#_idTextAnchor110)中构建了Yocto的5.0（Scarthgap）LTS版本。如果还没有，请参考*兼容的Linux发行版*和*构建主机包*部分的*Yocto项目快速构建*指南（[https://docs.yoctoproject.org/brief-yoctoprojectqs/](https://docs.yoctoproject.org/brief-yoctoprojectqs/)），然后按照[*第六章*](Chapter_04.xhtml#_idTextAnchor110)中的说明在你的Linux主机上构建Yocto。
- en: 'The code used in this chapter can be found in the chapter folder in this book’s
    GitHub repository: [https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter19](https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter19).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用的代码可以在本书GitHub仓库的章节文件夹中找到：[https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter19](https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter19)。
- en: GNU debugger
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GNU调试器
- en: GDB is a source-level debugger for compiled languages, primarily C and C++,
    although there is also support for a variety of other languages, such as Go and
    Objective-C. You should read the notes for the version of GDB you are using to
    find out the status of support for the various languages.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: GDB是一个源级调试器，主要用于编译语言，如C和C++，但也支持多种其他语言，如Go和Objective-C。你应该阅读你所使用的GDB版本的说明，以了解对不同语言的支持情况。
- en: The project website is [https://www.gnu.org/software/gdb/](https://www.gnu.org/software/gdb/)
    and it contains a lot of useful information, including the GDB user manual, *Debugging
    with GDB*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 项目网站是[https://www.gnu.org/software/gdb/](https://www.gnu.org/software/gdb/)，上面包含了很多有用的信息，包括GDB用户手册《*调试与GDB*》。
- en: Out of the box, GDB has a command-line user interface that some people find
    off-putting, although, in reality, it is easy to use with a little practice. If
    command-line interfaces are not to your liking, there are plenty of frontend user
    interfaces to GDB, and I will describe three of them later in this chapter.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，GDB有一个命令行用户界面，虽然有些人觉得它不太友好，但实际上只需一些练习就能轻松使用。如果你不喜欢命令行界面，有很多GDB的前端用户界面可以选择，我将在本章稍后描述其中的三个。
- en: Preparing to debug
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备调试
- en: 'You need to compile the code you want to debug with debug symbols. GCC offers
    two options for this: `-g` and `-ggdb`. The latter adds debug information that
    is specific to GDB, whereas the former generates information in an appropriate
    format for whichever target operating system you are using, making it the more
    portable option. Since GDB is the default debugger on Linux, it is best to use
    `-ggdb`. Both options allow you to specify the level of debug information, from
    `0` to `3`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要用调试符号编译你想调试的代码。GCC为此提供了两个选项：`-g`和`-ggdb`。后者添加了专门针对GDB的调试信息，而前者生成适用于你所使用的目标操作系统的格式信息，使其更具可移植性。由于GDB是Linux上的默认调试器，因此最好使用`-ggdb`。这两个选项都允许你指定调试信息的级别，从`0`到`3`：
- en: '`0`: This produces no debug information at all and is equivalent to omitting
    the `-g` or `-ggdb` switch.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`：这不生成任何调试信息，等同于省略`-g`或`-ggdb`选项。'
- en: '`1`: This produces minimal information but includes function names and external
    variables, which is enough to generate a backtrace.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1`：这生成最少的信息，但包括函数名称和外部变量，足以生成回溯。'
- en: '`2`: This is the default and includes information about local variables and
    line numbers so that you can perform source-level debugging and single-step through
    the code.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2`：这是默认设置，包含关于本地变量和行号的信息，以便你可以进行源代码级别的调试并逐步执行代码。'
- en: '`3`: This includes extra information which, among other things, means that
    GDB can handle macro expansions correctly.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`3`：这包括额外的信息，其中包括使GDB能够正确处理宏展开。'
- en: 'In most cases, `-g` suffices: reserve `-g3` or `-ggdb3` for if you are having
    problems stepping through code, especially if it contains macros.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，`-g`就足够了：如果你在逐步执行代码时遇到问题，尤其是当代码包含宏时，可以保留`-g3`或`-ggdb3`。
- en: The next issue to consider is the level of code optimization. Compiler optimization
    tends to destroy the relationship between lines of source code and machine code,
    which makes stepping through the source unpredictable. If you experience problems
    such as this, you will most likely need to compile without optimization, leaving
    out the `-O` compile switch, or using `-Og`, which enables optimizations that
    do not interfere with debugging.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步需要考虑的是代码优化的级别。编译器优化往往会破坏源代码行与机器代码之间的关系，这使得逐步调试变得不可预测。如果你遇到此类问题，很可能需要在不进行优化的情况下编译，省略`-O`编译选项，或者使用`-Og`，该选项启用不会干扰调试的优化。
- en: 'A related issue is that of stack-frame pointers, which are required by GDB
    to generate a backtrace of function calls up to the current one. On some architectures,
    GCC will not generate stack-frame pointers with higher levels of optimization
    (`-O2` and above). If you find yourself in a situation where you really have to
    compile with `-O2` but still want backtraces, you can override the default behavior
    with `-fno-omit-frame-pointer`. Also, look out for code that has been hand-optimized
    to leave out frame pointers through the addition of `-fomit-frame-pointer`: you
    may want to temporarily remove those bits.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一个相关的问题是栈帧指针，这是GDB生成函数调用回溯所必需的。在某些架构中，GCC在更高级别的优化（`-O2`及以上）下不会生成栈帧指针。如果你遇到必须使用`-O2`编译但仍希望生成回溯的情况，你可以通过`-fno-omit-frame-pointer`来覆盖默认行为。此外，注意一些经过手动优化的代码，它通过添加`-fomit-frame-pointer`来省略栈帧指针：你可能需要暂时去除这些部分。
- en: Debugging applications
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试应用程序
- en: 'You can use GDB to debug applications in one of two ways: if you are developing
    code to run on desktops and servers, or indeed any environment where you compile
    and run the code on the same machine, it is natural to run GDB natively. However,
    most embedded development is done using a cross toolchain, and hence you want
    to debug code running on the device but control it from the cross-development
    environment, where you have the source code and the tools. I will focus on the
    latter case, since it is the most likely scenario for embedded developers, but
    I will also show you how to set up a system for native debugging. I am not going
    to describe the basics of using GDB here since there are many good references
    on that topic already, including the GDB user manual and the suggested *Further
    study* section at the end of the chapter.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过两种方式使用 GDB 调试应用程序：如果你正在开发运行在桌面和服务器上的代码，或者在任何你编译并运行代码的相同机器环境下，运行 GDB 本地化是很自然的。然而，大多数嵌入式开发是使用交叉工具链完成的，因此你希望调试在设备上运行的代码，但从交叉开发环境中控制它，在那里你有源代码和工具。我将重点讲解后者的情况，因为它是嵌入式开发者最常见的场景，但我也会展示如何设置一个本地调试的系统。我在这里不会描述
    GDB 的基本使用方法，因为已经有很多很好的参考资料了，包括 GDB 用户手册和本章末尾建议的*进一步学习*部分。
- en: Remote debugging using gdbserver
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 gdbserver 进行远程调试
- en: The key component for remote debugging is the debug agent, **gdbserver**, which
    runs on the target and controls the execution of the program being debugged. `gdbserver`
    connects to a copy of GDB running on the host machine via a network connection
    or a serial interface.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 远程调试的关键组件是调试代理 **gdbserver**，它运行在目标设备上并控制被调试程序的执行。`gdbserver` 通过网络连接或串口接口连接到主机上运行的
    GDB 副本。
- en: 'Debugging through `gdbserver` is almost, but not quite, the same as debugging
    natively. The differences are mostly centered around the fact that there are two
    computers involved, and they have to be in the right state for debugging to take
    place. Here are some things to look out for:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `gdbserver` 进行调试几乎与本地调试相同，但并不完全一样。主要的区别集中在涉及两台计算机的事实上，它们必须处于正确的状态才能开始调试。以下是一些需要注意的事项：
- en: At the start of a debug session, you need to load the program you want to debug
    on the target using `gdbserver` and then separately load GDB from your cross toolchain
    on the host.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调试会话开始时，你需要通过 `gdbserver` 将你要调试的程序加载到目标设备上，然后从主机上的交叉工具链中单独加载 GDB。
- en: GDB and `gdbserver` need to connect to each other before a debug session can
    begin.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GDB 和 `gdbserver` 需要在调试会话开始之前相互连接。
- en: GDB needs to be told where on the host to look for debug symbols and source
    code, especially for shared libraries.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GDB 需要知道在主机上哪里可以找到调试符号和源代码，特别是对于共享库。
- en: The GDB `run` command is not supported.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GDB `run` 命令不被支持。
- en: '`gdbserver` will terminate when the debug session ends, and you will need to
    restart it if you want another debug session.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gdbserver` 在调试会话结束时会终止，如果你想进行另一次调试会话，你需要重新启动它。'
- en: You need debug symbols and source code for the binaries you want to debug on
    the host, but not on the target. Often, there is not enough storage space for
    them on the target, and they will need to be stripped before deploying to the
    target.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要调试符号和源代码来调试主机上的二进制文件，但不需要在目标设备上。这是因为目标设备上通常没有足够的存储空间存放这些符号和代码，它们需要在部署到目标设备之前被剥离。
- en: 'The GDB/`gdbserver` combination does not support all the features of natively
    running GDB: for example, `gdbserver` cannot follow the child process after a
    fork, whereas native GDB can.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GDB/`gdbserver` 组合并不支持本地运行 GDB 的所有功能：例如，`gdbserver` 不能在 `fork` 后跟踪子进程，而本地 GDB
    可以。
- en: Odd things can happen if GDB and `gdbserver` are from different versions of
    GDB or are the same version but configured differently. Ideally, they should be
    built from the same source using your favorite build tool.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 GDB 和 `gdbserver` 来自不同版本的 GDB，或者它们是相同版本但配置不同，可能会发生奇怪的情况。理想情况下，它们应该使用你喜欢的构建工具从相同的源代码构建。
- en: 'Debug symbols increase the size of executables dramatically, sometimes by a
    factor of 10\. As mentioned in [*Chapter 5*](Chapter_05.xhtml#_idTextAnchor138),
    it can be useful to remove debug symbols without recompiling everything. The tool
    for the job is `strip` from the `binutils` package in your cross toolchain. You
    can control the strip level with these switches:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 调试符号会显著增加可执行文件的大小，有时会增加 10 倍。如 [*第 5 章*](Chapter_05.xhtml#_idTextAnchor138)
    所述，移除调试符号而不重新编译所有内容是很有用的。用于此目的的工具是交叉工具链中 `binutils` 包中的 `strip`。你可以通过这些开关来控制剥离级别：
- en: '`--strip-all`: This removes all symbols (default).'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--strip-all`：此选项会移除所有符号（默认设置）。'
- en: '`--strip-unneeded`: This removes symbols not required for relocation processing.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--strip-unneeded`：此选项会移除不需要用于重定位处理的符号。'
- en: '`--strip-debug`: This removes only debug symbols.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--strip-debug`：此选项仅移除调试符号。'
- en: '**IMPORTANT NOTE**'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**重要说明**'
- en: For applications and shared libraries, `--strip-all` (the default) is fine,
    but when it comes to kernel modules, you will find that it will stop the module
    from loading. Use `--strip-unneeded` instead. I am still working on a use case
    for `–-strip-debug`.
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于应用程序和共享库，`--strip-all`（默认设置）是可以的，但当涉及到内核模块时，你会发现它会导致模块无法加载。应该使用`--strip-unneeded`。我仍在为`--strip-debug`寻找一个用例。
- en: With that in mind, let’s look at the specifics involved in debugging with The
    Yocto Project and Buildroot.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 牢记这一点，让我们来看一下使用Yocto项目和Buildroot进行调试时的具体细节。
- en: Setting up The Yocto Project for remote debugging
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置Yocto项目进行远程调试
- en: 'There are two things to be done to debug applications remotely when using The
    Yocto Project: you need to add `gdbserver` to the target image, and you need to
    create an SDK that includes GDB and has debug symbols for the executables that
    you plan to debug. There is detailed documentation on setting up Yocto for remote
    debugging at [https://docs.yoctoproject.org/dev-manual/debugging.html#using-the-gdbserver-method](https://docs.yoctoproject.org/dev-manual/debugging.html#using-the-gdbserver-method).'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Yocto项目进行远程调试时需要做两件事：你需要将`gdbserver`添加到目标镜像中，并且需要创建一个包含GDB并具有调试符号的SDK，针对你打算调试的可执行文件。关于如何设置Yocto进行远程调试，有详细的文档可以参考[https://docs.yoctoproject.org/dev-manual/debugging.html#using-the-gdbserver-method](https://docs.yoctoproject.org/dev-manual/debugging.html#using-the-gdbserver-method)。
- en: 'First, to include `gdbserver` in the target image, you can add the package
    explicitly by adding this to `conf/local.conf`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为了将`gdbserver`包含到目标镜像中，你可以通过在`conf/local.conf`中显式添加以下内容来实现：
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the absence of a serial console, an SSH daemon also needs to be added so
    that you have some way to start `gdbserver` on the target:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有串口控制台，还需要添加一个SSH守护进程，这样你就能通过某种方式在目标设备上启动`gdbserver`：
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Alternatively, you can add `tools-debug` to `EXTRA_IMAGE_FEATURES`, which will
    add `gdbserver`, native `gdb`, and `strace` to the target image (I will talk about
    `strace` in the next chapter):'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以将`tools-debug`添加到`EXTRA_IMAGE_FEATURES`中，这样就会将`gdbserver`、原生`gdb`和`strace`添加到目标镜像中（我将在下一章中讲解`strace`）：
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then rebuild the target image:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然后重新构建目标镜像：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For the second part, you just need to build an SDK as I described in [*Chapter
    6*](Chapter_04.xhtml#_idTextAnchor110):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二部分，你只需要按照我在[*第6章*](Chapter_04.xhtml#_idTextAnchor110)中描述的方式构建一个SDK：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The SDK contains a copy of GDB. It also contains a `sysroot` for thetarget with
    debug symbols for all the programs and libraries that are part of the target image.
    Lastly, the SDK contains the source code for the executables. Instead of the SDK,
    you can use the sysroots inside of the Yocto build directly ([https://docs.yoctoproject.org/sdk-manual/extensible.html#when-using-the-extensible-sdk-directly-in-a-yocto-build](https://docs.yoctoproject.org/sdk-manual/extensible.html#when-using-the-extensible-sdk-directly-in-a-yocto-build)).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: SDK包含一个GDB副本，还包含目标的`sysroot`，其中有所有程序和库的调试符号。最后，SDK还包含可执行文件的源代码。你也可以直接使用Yocto构建中的sysroot，而不是SDK（[https://docs.yoctoproject.org/sdk-manual/extensible.html#when-using-the-extensible-sdk-directly-in-a-yocto-build](https://docs.yoctoproject.org/sdk-manual/extensible.html#when-using-the-extensible-sdk-directly-in-a-yocto-build)）。
- en: The SDK built for the Raspberry Pi 4 for version 5.0.<n> of The Yocto Project
    is installed by default in `/opt/poky/5.0.<n>/`. The `sysroot` for the target
    is `/opt/poky/5.0.<n>/sysroots/cortexa72-poky-linux/`. The programs are in `/bin/`,
    `/sbin/`, `/usr/bin/`, and `/usr/sbin/`, relative to the `sysroot`, and the libraries
    are in `/lib/` and `/usr/lib/`. In each of these directories, you will find a
    subdirectory named `.debug/` that contains the symbols for each program and library.
    GDB knows to look in .`debug`/ when searching for symbol information. The source
    code for the executables is stored in `/usr/src/debug/` relative to the `sysroot`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为版本5.0.<n>的Raspberry Pi 4构建的Yocto项目的SDK默认安装在`/opt/poky/5.0.<n>/`中。目标的`sysroot`位于`/opt/poky/5.0.<n>/sysroots/cortexa72-poky-linux/`。程序位于`/bin/`、`/sbin/`、`/usr/bin/`和`/usr/sbin/`中，这些路径相对于`sysroot`，而库文件则位于`/lib/`和`/usr/lib/`中。在这些目录中，你会找到一个名为`.debug/`的子目录，里面包含每个程序和库的符号。GDB会在`.debug/`中查找符号信息。可执行文件的源代码存储在`/usr/src/debug/`，相对于`sysroot`。
- en: Setting up Buildroot for remote debugging
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置Buildroot进行远程调试
- en: 'Buildroot does not make a distinction between the environment used to build
    and the environment used for application development: there is no SDK. Assuming
    that you are using the Buildroot internal toolchain, you need to enable these
    options to copy GDB to the host and copy `gdbserver` to the target:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Buildroot 不区分构建环境和应用程序开发环境：没有 SDK。假设您正在使用 Buildroot 内部工具链，您需要启用这些选项以将 GDB 复制到主机并将
    `gdbserver` 复制到目标设备：
- en: '`BR2_TOOLCHAIN_EXTERNAL`, in **Toolchain** | **Toolchain type** | **External
    toolchain**'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BR2_TOOLCHAIN_EXTERNAL`，在 **工具链** | **工具链类型** | **外部工具链**'
- en: '`BR2_TOOLCHAIN_EXTERNAL_GDB_SERVER_COPY`, in **Toolchain** | **Copy gdb server
    to the Target**'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BR2_TOOLCHAIN_EXTERNAL_GDB_SERVER_COPY`，在 **工具链** | **将 gdb server 复制到目标设备**'
- en: '`BR2_PACKAGE_GDB`, in **Target packages** | **Debugging, profiling and benchmark**
    | **gdb**'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BR2_PACKAGE_GDB`，在 **目标软件包** | **调试、性能分析和基准测试** | **gdb**'
- en: An external toolchain is needed because the toolchain that Buildroot 2024.02.6
    builds cannot compile `gdbserver`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 需要外部工具链，因为 Buildroot 2024.02.6 构建的工具链无法编译 `gdbserver`。
- en: You also need to build executables with debug symbols, for which you need to
    enable `BR2_ENABLE_DEBUG`, in **Build options** | **build packages with debugging
    symbols**.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要构建带有调试符号的可执行文件，这需要在 **构建选项** | **构建带调试符号的软件包** 中启用 `BR2_ENABLE_DEBUG`。
- en: This will create libraries with debug symbols in `output/host/<arch>/sysroot`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这将会在 `output/host/<arch>/sysroot` 中创建带有调试符号的库。
- en: Starting to debug
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始调试
- en: Now that you have `gdbserver` installed on the target and a cross GDB on the
    host, you can start a debug session.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经在目标设备上安装了 `gdbserver`，并且在主机上有一个交叉编译的 GDB，您可以开始调试会话了。
- en: Connecting GDB and gdbserver
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接 GDB 和 gdbserver
- en: 'The connection between GDB and `gdbserver` can be through a network or serial
    interface. In the case of a network connection, you launch `gdbserver` with the
    TCP port number to listen on and, optionally, an IP address to accept connections
    from. In most cases, you don’t care which IP address is going to connect, so you
    can just provide the port number. In this example, `gdbserver` waits for a connection
    on port `10000` from any host:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: GDB 和 `gdbserver` 之间的连接可以通过网络或串行接口。在网络连接的情况下，您启动 `gdbserver` 时需要指定 TCP 端口号来监听，或者可选地指定一个
    IP 地址来接受连接。大多数情况下，您不关心哪个 IP 地址将进行连接，因此只需提供端口号即可。在这个例子中，`gdbserver` 等待来自任何主机的 `10000`
    端口的连接：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, start the copy of GDB from your toolchain, pointing it at an unstripped
    copy of the program so that GDB can load the symbol table:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，启动从您的工具链复制 GDB，指向一个未剥离的程序副本，以便 GDB 可以加载符号表：
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In GDB, use the target remote command to make the connection to `gdbserver`,
    giving it the IP address or hostname of the target and the port it is waiting
    on:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GDB 中，使用 target remote 命令连接到 `gdbserver`，并提供目标设备的 IP 地址或主机名以及它等待的端口号：
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When `gdbserver` sees the connection from the host, it prints the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `gdbserver` 检测到来自主机的连接时，它会打印以下信息：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The procedure is similar for a serial connection. On the target, you tell `gdbserver`
    which serial port to use:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于串行连接，过程类似。在目标设备上，您告诉 `gdbserver` 使用哪个串行端口：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You may need to configure the port baud rate beforehand using `stty(1)` or
    a similar program. A simple example would be as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能需要事先使用 `stty(1)` 或类似程序配置端口的波特率。一个简单的例子如下：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There are many other options to `stty`, so read the manual page for more details.
    It is worthwhile noting that the port must not be used for anything else. For
    example, you can’t use a port that is being used as the system console.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`stty` 有许多其他选项，详情请阅读手册页。值得注意的是，端口不能被用于其他任何用途。例如，您不能使用正在作为系统控制台的端口。'
- en: 'On the host, you make the connection to `gdbserver` using `target remote` plus
    the serial device at the host end of the cable. In most cases, you will want to
    set the baud rate of the host serial port first, using the GDB command `set serial
    baud`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在主机上，您可以使用 `target remote` 命令加上连接线另一端的串口设备来连接 `gdbserver`。在大多数情况下，您需要先设置主机串口的波特率，使用
    GDB 命令 `set serial baud`：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Even though GDB and `gdbserver` are now connected, we are not ready to set breakpoints
    and start stepping through the source code yet.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 GDB 和 `gdbserver` 已经连接，我们仍然没有准备好设置断点并开始逐步调试源代码。
- en: Setting the sysroot
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置 sysroot
- en: GDB needs to know where to find debug information and source code for the program
    and shared libraries you are debugging. When debugging natively, the paths are
    well known and built into GDB. But when using a cross toolchain, GDB has no way
    to guess where the root of the target filesystem is. You have to provide this
    information.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: GDB 需要知道在哪里找到你正在调试的程序和共享库的调试信息和源代码。在本地调试时，路径是已知的，并且内建在 GDB 中。但在使用交叉工具链时，GDB
    无法猜测目标文件系统的根目录在哪里。你必须提供这些信息。
- en: 'If you built your application using The Yocto Project SDK, the `sysroot` is
    within the SDK, and so you can set it in GDB like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Yocto 项目 SDK 构建了你的应用程序，`sysroot` 就在 SDK 内，因此你可以在 GDB 中这样设置它：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you are using Buildroot, you will find that the `sysroot` is in `output/host/<toolchain>/sysroot`,
    and that `output/staging` is a symbolic link to it. So, for Buildroot, you would
    set the `sysroot` like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Buildroot，你会发现 `sysroot` 在 `output/host/<toolchain>/sysroot` 中，而 `output/staging`
    是它的一个符号链接。所以，对于 Buildroot，你可以这样设置 `sysroot`：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'GDB also needs to find the source code for the files you are debugging. GDB
    has a search path for source files, which you can see using the `show directories`
    command:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: GDB 还需要找到你正在调试的文件的源代码。GDB 有一个源代码搜索路径，你可以通过 `show directories` 命令查看：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'These are the defaults: `$cwd` is the current working directory of the GDB
    instance running on the host; `$cdir` is the directory where the source was compiled.
    The latter is encoded into the object files with the tag `DW_AT_comp_dir`. You
    can see these tags using `objdump --dwarf` like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这是默认值：`$cwd` 是在主机上运行的 GDB 实例的当前工作目录；`$cdir` 是源代码被编译的目录。后者通过标签 `DW_AT_comp_dir`
    被编码到目标文件中。你可以使用 `objdump --dwarf` 查看这些标签，方法如下：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In most cases, the defaults, `$cdir` and `$cwd`, are sufficient, but problems
    arise if the directories have been moved between compilation and debugging. One
    such case occurs with The Yocto Project. Taking a deeper look at the `DW_AT_comp_dir`
    tags for a program compiled using The Yocto Project SDK, you may notice this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，默认值 `$cdir` 和 `$cwd` 是足够的，但如果目录在编译和调试之间发生了移动，就会出现问题。一个这样的情况发生在 Yocto
    项目中。深入查看一个使用 Yocto 项目 SDK 编译的程序的 `DW_AT_comp_dir` 标签，你可能会注意到这一点：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here, you can see multiple references to the directory `/usr/src/debug/glibc/2.39+git`,
    but where is it? The answer is that it is in the `sysroot` for the SDK, so the
    full path is `/opt/poky/5.0.6/sysroots/cortexa72-poky-linux/usr/src/debug/glibc/2.39+git`.
    The SDK contains source code for all of the programs and libraries in the target
    image. GDB has a simple way to cope with an entire directory tree being moved
    like this: `substitute-path`. So, when debugging with The Yocto Project SDK, you
    need to use these commands:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到多次提到目录`/usr/src/debug/glibc/2.39+git`，但它在哪里呢？答案是它在 SDK 的 `sysroot`
    中，所以完整路径是`/opt/poky/5.0.6/sysroots/cortexa72-poky-linux/usr/src/debug/glibc/2.39+git`。SDK
    包含了目标镜像中所有程序和库的源代码。GDB 有一个简单的方式来应对整个目录树被移动的情况：`substitute-path`。因此，在使用 Yocto 项目
    SDK 进行调试时，你需要使用这些命令：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You may have additional shared libraries that are stored outside the `sysroot`.
    In that case, you can use `set solib-search-path`, which can contain a colon-separated
    list of directories to search for shared libraries. GDB searches `solib-search-path`
    only if it cannot find the binary in the `sysroot`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能有其他共享库存储在 `sysroot` 外部。在这种情况下，你可以使用 `set solib-search-path`，它可以包含一个以冒号分隔的目录列表，用来搜索共享库。GDB
    只有在无法在 `sysroot` 中找到二进制文件时，才会搜索 `solib-search-path`。
- en: 'A third way of telling GDB where to look for source code, for both libraries
    and programs, is to use the `directory` command:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 告诉 GDB 寻找源代码的第三种方式，无论是库还是程序，是使用 `directory` 命令：
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Paths added in this way take precedence because they are searched *before* those
    from `sysroot` or `solib-search-path`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式添加的路径优先级更高，因为它们在 `sysroot` 或 `solib-search-path` 之前被搜索。
- en: GDB command files
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GDB 命令文件
- en: 'There are some things that you need to do each time you run GDB, like setting
    the `sysroot`. It is convenient to put such commands into a command file and run
    them each time GDB is started. GDB reads commands from `$HOME/.gdbinit`, then
    from `.gdbinit` in the current directory, and then from files specified on the
    command line with the `-x` parameter. However, recent versions of GDB will refuse
    to load `.gdbinit` from the current directory for security reasons. You can override
    that behavior by adding a line such as this to `$HOME/.gdbinit`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 每次运行 GDB 时，有一些操作是必须进行的，比如设置 `sysroot`。将这些命令放入命令文件中，并在每次启动 GDB 时运行它们非常方便。GDB
    会从 `$HOME/.gdbinit` 读取命令，然后从当前目录中的 `.gdbinit` 文件读取，再从通过 `-x` 参数指定的文件中读取命令。然而，GDB
    的最新版本出于安全原因会拒绝加载当前目录中的 `.gdbinit` 文件。你可以通过在 `$HOME/.gdbinit` 中添加如下行来覆盖这种行为：
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Alternatively, if you don’t want to enable auto-loading globally, you can specify
    a particular directory like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你不想全局启用自动加载，可以像这样指定一个特定目录：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: My personal preference is to use the `-x` parameter to point to the command
    file, which exposes the location of the file so that I don’t forget about it.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人的偏好是使用 `-x` 参数指向命令文件，这样可以暴露文件的位置，避免忘记它。
- en: 'To help you set up GDB, Buildroot creates a GDB command file containing the
    correct `sysroot` command in `output/staging/usr/share/buildroot/gdbinit`. It
    will contain a line like this one:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你设置 GDB，Buildroot 创建了一个包含正确 `sysroot` 命令的 GDB 命令文件，该文件位于 `output/staging/usr/share/buildroot/gdbinit`。该文件包含如下行：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now that GDB is running and can find the information it needs, let’s look at
    some of the commands we can perform with it.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 GDB 正在运行并能找到所需的信息，让我们看看可以执行的一些命令。
- en: Overview of GDB commands
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GDB 命令概览
- en: GDB has many more commands, which are described in the online manual and in
    the resources mentioned in the *Further study* section. To help you get going
    as quickly as possible, here is a list of the most commonly used commands. In
    most cases, there is a short form for commands, which are listed in the following
    tables.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: GDB 还有许多其他命令，具体描述请参考在线手册和*进一步学习*部分提到的资源。为了帮助你尽快上手，下面列出了最常用的命令。在大多数情况下，命令有简短的形式，具体列在以下表格中。
- en: Breakpoints
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 断点
- en: 'These are the commands for managing breakpoints:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是管理断点的命令：
- en: '| **Command** | **Short-form command** | **Use** |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **简短命令** | **用途** |'
- en: '|'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '|'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '| Set a breakpoint on a function name, line number, or line. Examples of locations
    are `main`, `5`, and `sortbug.c:42`. |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 在函数名、行号或行上设置断点。位置示例有 `main`、`5` 和 `sortbug.c:42`。 |'
- en: '|'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '|'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '| List breakpoints. |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 列出断点。 |'
- en: '|'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '|'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '| Delete the breakpoint `<N>`. |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 删除断点 `<N>`。 |'
- en: Running and stepping
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行与单步执行
- en: 'These are commands for controlling the execution of a program:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是控制程序执行的命令：
- en: '| **Command** | **Short-form command** | **Use** |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **简短命令** | **用途** |'
- en: '|'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '|'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '| Load a fresh copy of the program into memory and start running it. *This
    does not work for remote debugging using gdbserver*. |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| 将程序的一个新副本加载到内存并开始运行。*这对使用 gdbserver 进行远程调试无效*。 |'
- en: '|'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE30]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '|'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE31]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '| Continue execution from a breakpoint. |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 从断点继续执行。 |'
- en: '| *Ctrl + C* | - | Stop the program from being debugged. |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| *Ctrl + C* | - | 停止调试中的程序。 |'
- en: '|'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE32]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '|'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE33]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '| Step one line of code, stepping *into* any function that is called. |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| 单步执行一行代码，*进入*任何被调用的函数。 |'
- en: '|'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE34]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '|'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE35]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '| Step one line of code, stepping *over* a function call. |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 单步执行一行代码，*跳过*函数调用。 |'
- en: '|'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE36]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '| - | Run until the current function returns. |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| - | 运行直到当前函数返回。 |'
- en: Getting information
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 获取信息
- en: 'These are commands for getting information regarding the debugger:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是获取调试器信息的命令：
- en: '| **Command** | **Short-form command** | **Use** |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **简短命令** | **用途** |'
- en: '|'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE37]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '|'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE38]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '| List the call stack. |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| 列出调用栈。 |'
- en: '|'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE39]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '|'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE40]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '| Display information about the threads executing in the program. |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| 显示程序中当前执行的线程信息。 |'
- en: '|'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE41]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '|'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE42]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '| Display information about shared libraries currently loaded by the program.
    |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| 显示当前程序加载的共享库信息。 |'
- en: '|'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE43]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '|'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE44]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '| Print the value of the variable. For example, `print foo`. |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| 打印变量的值。例如，`print foo`。 |'
- en: '|'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE45]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '|'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE46]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '| List lines of code around the current program counter. |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| 列出当前程序计数器周围的代码行。 |'
- en: Before we can begin stepping through a program inside a debug session, we first
    need to set an initial breakpoint.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始单步调试程序之前，首先需要设置一个初始断点。
- en: Running to a breakpoint
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行到断点
- en: '`gdbserver` loads the program into memory and sets a breakpoint at the first
    instruction. Then it waits for a connection from GDB. When the connection is made,
    you enter into a debug session. However, you will find that if you try to single-step
    immediately, you will get this message:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`gdbserver`将程序加载到内存中，并在第一条指令处设置断点。然后它会等待GDB的连接。当连接建立时，你将进入调试会话。然而，你会发现如果你立即尝试单步执行，你会看到以下信息：'
- en: '[PRE47]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This is because the program has halted at code written in assembly, which creates
    the runtime environment for C/C++ programs. The first line of C/C++ code is the
    `main()` function. To stop at `main()`, you would set a breakpoint there and then
    use the `continue` command (abbreviation `c`) to tell `gdbserver` to continue
    from the start of the program and stop at `main()`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为程序在汇编代码中暂停，该代码为C/C++程序创建运行时环境。C/C++代码的第一行是`main()`函数。要在`main()`处停下，你需要在该处设置断点，然后使用`continue`命令（缩写`c`）告诉`gdbserver`从程序开始处继续并停在`main()`处：
- en: '[PRE48]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'At this point, you may see the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你可能会看到以下内容：
- en: '[PRE49]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'With older versions of GDB, you may instead see this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在GDB的旧版本中，你可能会看到以下信息：
- en: '[PRE50]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In both cases, the problem is that you have forgotten to set the `sysroot`!
    Take another look at the earlier section on `sysroot`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，问题是你忘记设置`sysroot`！请再看看前面关于`sysroot`的部分。
- en: This is all very different from starting a program natively, where you just
    type `run`. In fact, if you try typing `run` in a remote debug session, you will
    either see a message saying that the remote target does not support the `run`
    command, or, in older versions of GDB, it will just hang without any explanation.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这与本地启动程序非常不同，在本地你只需输入`run`。事实上，如果你在远程调试会话中尝试输入`run`，你将看到一条消息，提示远程目标不支持`run`命令，或者在GDB的旧版本中，它会挂起而没有任何解释。
- en: Extending GDB with Python
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Python扩展GDB
- en: We can embed a full Python interpreter into GDB to extend its functionality.
    This is done by configuring GDB using the `--with-python` option prior to building.
    GDB has an API that exposes much of its internal state as Python objects. This
    API allows us to define our own custom GDB commands as scripts written in Python.
    These extra commands may include useful debugging aids such as tracepoints and
    pretty printers that are not built into GDB.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将一个完整的Python解释器嵌入到GDB中，以扩展其功能。这是通过在构建前使用`--with-python`选项配置GDB来实现的。GDB有一个API，将其内部状态暴露为Python对象。这个API允许我们定义自己的自定义GDB命令，作为Python脚本编写。这些额外的命令可能包括一些有用的调试辅助功能，比如跟踪点和漂亮的打印器，这些功能并没有内建在GDB中。
- en: Building GDB with Python support
  id: totrans-216
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 构建带有Python支持的GDB
- en: We have already covered *Setting up Buildroot for remote debugging*. There are
    some additional steps needed to enable Python support inside GDB. We cannot use
    a toolchain generated by Buildroot to build GDB with Python support because it
    is missing some necessary thread support.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讲解了*为远程调试设置Buildroot*。为了在GDB中启用Python支持，还需要一些额外步骤。我们不能使用Buildroot生成的工具链来构建具有Python支持的GDB，因为它缺少一些必要的线程支持。
- en: 'To build cross GDB for the host with Python support, perform the following
    steps:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建支持Python的交叉GDB，请执行以下步骤：
- en: 'Navigate to the directory where you installed Buildroot:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入你安装Buildroot的目录：
- en: '[PRE51]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Copy the configuration file for the board you wish to build an image for:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制你希望为其构建镜像的板子的配置文件：
- en: '[PRE52]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Clean previous build artifacts from the `output` directory:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清除`output`目录中的先前构建的产物：
- en: '[PRE53]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Activate your configuration file:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 激活你的配置文件：
- en: '[PRE54]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Begin customizing your image:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始自定义你的镜像：
- en: '[PRE55]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Enable the use of an external toolchain by navigating to **Toolchain** | **Toolchain
    type** | **External toolchain** and selecting that option.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过进入**Toolchain** | **Toolchain type** | **External toolchain**并选择该选项来启用外部工具链的使用。
- en: Back out of **External toolchain** and open the **Toolchain** submenu. Select
    a known working toolchain, such as **Linaro AArch64 2018.05**, as your external
    toolchain.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出**外部工具链**，然后打开**工具链**子菜单。选择一个已知有效的工具链，比如**Linaro AArch64 2018.05**，作为你的外部工具链。
- en: Select **Build cross gdb for the host** from the Toolchain page and enable both
    **TUI support** and **Python support**.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从工具链页面选择**为主机构建交叉GDB**，并启用**TUI支持**和**Python支持**。
- en: Drill down into the **GDB debugger Version** submenu from the **Toolchain**
    page and select the newest version of GDB available in Buildroot.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**工具链**页面进入**GDB调试器版本**子菜单，选择Buildroot中可用的最新版本GDB。
- en: Back out of the **Toolchain** page and drill down into **Build options**. Select
    **Build packages with debugging symbols**.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Back out of the **Build options** page, drill down into **System Configuration**,
    and select **Enable root login with password**. Open **Root password** and enter
    a non-empty password in the text field.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Back out of the **System Configuration** page and drill down into **Target packages**
    | **Debugging, profiling and benchmark**. Select the **gdb** package to add `gdbserver`
    to the target image.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Back out of **Debugging, profiling and benchmark** and drill down into **Target
    packages** | **Networking applications**. Select the **dropbear** package to enable
    `scp` and `ssh` access to the target. Note that `dropbear` does not allow `root`
    `scp` and `ssh` access without a password.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the **haveged** entropy daemon, which can be found under **Target packages**
    | **Miscellaneous** so that SSH is available quicker upon booting.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add another package to your image so you have something to debug. I chose the
    `bsdiff` binary patch/diff tool, which is written in C and can be found under
    **Target packages** | **Development tools**.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save your changes and exit Buildroot’s `menuconfig`.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Save your changes to your configuration file:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Build the image for the target:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: A readymade `rpi4_64_gdb_defconfig` file for the Raspberry Pi 4 can be found
    in the code archive for this chapter if you wish to skip the previous `menuconfig`
    steps. Copy that file from `MELD/Chapter19/buildroot/configs/` to your `buildroot/configs`
    directory and run `make` on that if you prefer.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: When the build is done, there should be a bootable `sdcard.img` file in `output/images/`
    that you can write to a microSD card using Etcher. Insert that microSD into your
    target device and boot it. Connect the target device to your local network with
    an Ethernet cable and locate its IP address using `arp-scan --localnet`. SSH into
    the device as `root` and enter the password that you set when configuring your
    image. I specified `temppwd` as the `root` password for my `rpi4_64_gdb_defconfig`
    image.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s debug `bsdiff` remotely using GDB:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'First, navigate to the `/usr/bin` directory on the target:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Then, start `bdiff` with `gdbserver`, as we did with `helloworld` earlier:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'On your Linux host, copy `tp.py` to your home directory:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Next, start the copy of GDB from your toolchain, pointing it at an unstripped
    copy of the program so that GDB can load the symbol table:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'In GDB, set the `sysroot` like this:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Then, use the command target remote to make the connection to `gdbserver`,
    giving it the IP address or hostname of the target and the port it is waiting
    on:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'When `gdbserver` sees the connection from the host, it prints the following:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We can now load Python command scripts such as `tp.py` into GDB and invoke
    these commands like so:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: In this case, `tp` is the name of the *tracepoint* command and `search` is the
    name of a recursive function in `bsdiff`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'Set a breakpoint at `main()`:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Continue:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Continue again:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The `bsdiff` program performs binary diffs and takes three arguments: `oldfile`,
    `newfile`, and `patchfile`. The `patchfile` that `bsdiff` generates serves as
    input to the `bspatch` program for patching binaries. We start the `bsdiff` program
    on the target with `/usr/bin/bzless`, `/usr/bin/bzmore`, and `~/patchfile` as
    arguments. The output from the GDB *tracepoint* command indicates that the `search`
    function at *line 170* of `bsdiff.c` was called 10 times over the course of the
    process.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: The Python support in GDB can also be used to debug Python programs. GDB has
    visibility into CPython’s internals that the standard `pdb` debugger for Python
    does not. It can even inject Python code into a running Python process. This enables
    the creation of powerful Python debugging tools like memory analyzers that would
    otherwise be impossible.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Native debugging
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Running a native copy of GDB on the target is not as common as doing it remotely,
    but it is possible. In addition to installing GDB onto the target image, you will
    also need to install unstripped copies of the executables you wish to debug and
    their corresponding source code. Both The Yocto Project and Buildroot allow you
    to do this.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '**IMPORTANT NOTE**'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: While native debugging is not a common activity for embedded developers, running
    profile and trace tools on the target is very common. These tools usually work
    best if you have unstripped binaries and source code on the target, which is half
    of the story I am telling here. I will return to this topic in the next chapter.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: The Yocto Project
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To begin with, add `gdb` to the target image by adding this to `conf/local.conf`:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: You need the debug information for the packages you want to debug. The Yocto
    Project builds debug variants of packages, which contain the debug info and symbols
    stripped from the binaries. You can add these debug packages selectively to your
    target image by adding `<package name>-dbg` to your `conf/local.conf`. Or, you
    can simply install all debug packages by adding `dbg-pkgs` to `EXTRA_IMAGE_FEATURES`
    as just shown. Be warned that this will increase the size of the target image
    dramatically, perhaps by several hundreds of megabytes.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, you can add source packages to your target image by adding `<package
    name>-src` to your `conf/local.conf`. Or, you can simply install all source packages
    by adding `src-pkgs` to `EXTRA_IMAGE_FEATURES`. Again, this will dramatically
    increase the size of the target image. The source code is installed in `/usr/src/debug/<package
    name>` in the target image. This means that GDB will pick it up without needing
    to run `set substitute-path`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Buildroot
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With Buildroot, you can tell it to install a native copy of GDB in the target
    image by enabling this option:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '`BR2_PACKAGE_GDB_DEBUGGER` in **Target packages** | **Debugging, profiling
    and benchmark** | **Full debugger**'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, to build binaries with debug information and install them in the target
    image without stripping, enable the first and disable the second of these two
    options:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '`BR2_ENABLE_DEBUG` in **Build options** | **Build packages with debugging symbols**'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BR2_STRIP_strip` in **Build options** | **Strip target binaries**'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That’s all I have to say about native debugging. Again, the practice is uncommon
    on embedded devices because the extra source code and debug symbols add bloat
    to the target image. Next, let’s look at another form of remote debugging.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Just-in-time debugging
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, a program will start to misbehave after it has been running for a
    while, and you would like to know what it is doing. The GDB `attach` feature does
    exactly this. I call it just-in-time debugging. It is available with both native
    and remote debug sessions.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of remote debugging, you need to find the PID of the process to
    be debugged and pass it to `gdbserver` with the `--attach` option. For example,
    if the PID is 109, you would type this:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'This forces the process to stop as if it were at a breakpoint, allowing you
    to start your cross GDB in the normal way and connect to `gdbserver`. When you
    are done, you can detach, allowing the program to continue running without the
    debugger:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Attaching to a running process by PID is certainly handy, but what about multi-process
    or multithreaded programs? There are techniques for debugging those types of programs
    with GDB as well.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Debugging forks and threads
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What happens when the program you are debugging forks? Does the debug session
    follow the parent process or the child? This behavior is controlled by `follow-fork-mode`,
    which may be `parent` or `child`, with `parent` being the default. Unfortunately,
    current versions of `gdbserver` do not support this option, so it only works for
    native debugging. If you really need to debug the child process while using `gdbserver`,
    a workaround is to modify the code so that the child loops on a variable immediately
    after the fork, giving you the opportunity to attach a new `gdbserver` session
    to it and then to set the variable so that it drops out of the loop.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: When a thread in a multithreaded process hits a breakpoint, the default behavior
    is for all threads to halt. In most cases, this is the best thing to do as it
    allows you to look at static variables without them being changed by the other
    threads. When you resume execution of the thread, all the stopped threads start
    up, even if you are single-stepping, and it is especially this last case that
    can cause problems. There is a way to modify the way in which GDB handles stopped
    threads, through a parameter called `scheduler-locking`. Normally it is `off`,
    but if you set it to `on`, only the thread that was stopped at the breakpoint
    is resumed and the others remain stopped, giving you a chance to see what the
    thread alone does without interference. This continues to be the case until you
    turn `scheduler-locking` off. `gdbserver` supports this feature.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Core files
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Core files capture the state of a failing program at the point that it terminates.
    You don’t even have to be in the room with a debugger when the bug manifests itself.
    So, when you see `Segmentation fault (core dumped)`, don’t shrug; investigate
    the **core file** and extract the goldmine of information in there.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'The first observation is that core files are not created by default, but only
    when the core file resource limit for the process is non-zero. You can change
    it for the current shell using `ulimit -c`. To remove all limits on the size of
    core files, type the following command:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: By default, the core file is named `core` and is placed in the current working
    directory of the process, which is the one pointed to by `/proc/<PID>/cwd`. There
    are a number of problems with this scheme. Firstly, when looking at a device with
    several files named `core`, it is not obvious which program generated each one.
    Secondly, the current working directory of the process may well be in a read-only
    filesystem, there may not be enough space to store the core file, or the process
    may not have permissions to write to the current working directory.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: There are two files that control the naming and placement of core files. The
    first is `/proc/sys/kernel/core_uses_pid`. Writing a `1` to it causes the PID
    number of the dying process to be appended to the filename, which is somewhat
    useful as long as you can associate the PID number with a program name from log
    files.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: 'Much more useful is `/proc/sys/kernel/core_pattern`, which gives you a lot
    more control over core files. The default pattern is core, but you can change
    it to a pattern composed of these meta characters:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '`%p`: PID'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%u`: Real UID of the dumped process'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%g`: Real GID of the dumped process'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%s`: Number of the signal causing the dump'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%t`: Time of dump expressed as seconds since the Epoch, 1970-01-01 00:00:00
    +0000 (UTC)'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%h`: Hostname'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%e`: Executable filename'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%E`: Path name of executable with slashes (/) replaced by exclamation marks
    (!)'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%c`: Core file size soft resource limit of the dumped process'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can also use a pattern that begins with an absolute directory name so that
    all core files are gathered together in one place. As an example, the following
    pattern puts all core files into the `/corefiles` directory and names them with
    the program name and the time of the crash:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Following a core dump, you would find something like this:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: For more information, refer to the `core(5)` manual page.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: Using GDB to look at core files
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is a sample GDB session looking at a core file:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'This shows that the program stopped at *line 41*. The list command shows the
    code in the vicinity:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The `backtrace` command (shortened to `bt`) shows how we got to this point:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'This is an obvious mistake: `addtree()` was called with a null pointer.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: GDB began as a command-line debugger and many people still use it this way.
    Even though the LLVM Project’s LLDB debugger is gaining in popularity, GCC and
    GDB remain the prominent compiler and debugger for Linux. So far, we have focused
    exclusively on GDB’s command-line interface. Now we will look at some frontends
    to GDB with progressively more modern user interfaces.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: GDB user interfaces
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GDB is controlled at a low level through the GDB machine interface, GDB/MI,
    which can be used to wrap GDB in a user interface or as part of a larger program,
    and it considerably extends the range of options available to you.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, I will describe three that are well suited to debugging embedded
    targets: the **Terminal User Interface** (**TUI**), **Data Display Debugger**
    (**DDD**), and **Visual Studio Code**.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: Terminal User Interface
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Terminal User Interface** (**TUI**) is an optional part of the standard
    GDB package. The main feature is a code window that shows the line of code about
    to be executed, together with any breakpoints. It is a definite improvement on
    the `list` command in command-line mode GDB.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: 'The attraction of the TUI is that it just works without any extra setup, and
    since it is in text mode, it is possible to use over an SSH terminal session,
    for example, when running `gdb` natively on a target. Most cross toolchains configure
    GDB with the TUI. Simply add `-tui` to the command line and you will see the following:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 19.1 – TUI](img/B18466_19_01.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
- en: Figure 19.1 – TUI
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: If you still find the TUI lacking and prefer a truly graphical frontend to GDB,
    the GNU project also offers one of those ([https://www.gnu.org/software/ddd](https://www.gnu.org/software/ddd)).
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: Data Display Debugger
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Data Display Debugger** (**DDD**) is a simple standalone program that gives
    you a graphical user interface to GDB with minimal fuss and bother, and although
    the UI controls look dated, it does everything that is necessary.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: 'The `--debugger` option tells DDD to use GDB from your toolchain, and you can
    use the `-x` argument to give the path to a GDB command file:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The following screenshot shows off one of the nicest features: the data window,
    which contains items in a grid that you can rearrange as you wish. If you double-click
    on a pointer, it is expanded into a new data item and the link is shown with an
    arrow:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 19.2 – DDD](img/B18466_19_02.png)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
- en: Figure 19.2 – DDD
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: If neither of these two GDB frontends is acceptable because you are a full stack
    web developer accustomed to working with the latest tools in your industry, then
    we still have you covered.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Visual Studio Code** is a very popular open-source code editor from Microsoft.
    Because it is an Electron application written in TypeScript, Visual Studio Code
    feels more lightweight and responsive than full-blown IDEs such as Eclipse. There
    is rich language support (code completion, go to definition, etc.) for many languages
    by way of extensions contributed by its large community of users. Remote cross
    GDB debugging can be integrated into Visual Studio Code using extensions for C/C++.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 19.3 – Visual Studio Code](img/B18466_19_03.png)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
- en: Figure 19.3 – Visual Studio Code
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: There are no prescribed workflows for integrating Visual Studio Code with Buildroot
    or Yocto. To enable remote GDB debugging, you need to edit project files like
    `settings.json` and `launch.json`. These project files point at the toolchain
    and `sysroot`. They also contain the target IP and SSH login credentials.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Debugging kernel code
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can use `kgdb` for source-level debugging, in a manner similar to remote
    debugging with `gdbserver`. There is also a self-hosted kernel debugger, `kdb`,
    that is handy for lighter-weight tasks such as seeing whether an instruction is
    executed and getting the backtrace to find out how it got there. Finally, there
    are kernel *Oops* messages and panics, which tell you a lot about the cause of
    a kernel exception.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: Debugging kernel code with kgdb
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When looking at kernel code using a source debugger, you must remember that
    the kernel is a complex system, with real-time behaviors. Don’t expect debugging
    to be as easy as it is for applications. Stepping through code that changes the
    memory mapping or switches context is likely to produce odd results.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '**kgdb** is the name given to the kernel GDB stubs that have been part of mainline
    Linux for many years now. There is a user manual in the kernel DocBook, and you
    can find an online version at [https://kernel.org/doc/html/v6.6/dev-tools/kgdb.html](https://kernel.org/doc/html/v6.6/dev-tools/kgdb.html).'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, you will connect to `kgdb` over the serial interface, which is
    usually shared with the serial console. Hence, this implementation is called **kgdboc**,
    which is short for **kgdb over console**. To work, it requires a platform `tty`
    driver that supports I/O polling instead of interrupts, since `kgdb` has to disable
    interrupts when communicating with GDB. A few platforms support `kgdb` over USB,
    and there have been versions that work over Ethernet but, unfortunately, none
    of them have found their way into mainline Linux.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: The same caveats regarding optimization and stack frames apply to the kernel,
    with the limitation that the kernel is written to assume an optimization level
    of at least `-O1`. You can override the kernel compile flags by setting `KCFLAGS`
    before running `make`.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: 'These, then, are the kernel configuration options you will need for kernel
    debugging:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '`CONFIG_DEBUG_INFO` is in the **Kernel hacking** | **Compile-time checks and
    compiler options** | **Debug information** | **Rely on the toolchain’s implicit
    default DWARF version** menu.'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CONFIG_FRAME_POINTER` may be an option for your architecture and is in the
    **Kernel hacking** | **Compile-time checks and compiler options** | **Compile
    the kernel with frame pointers** menu.'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CONFIG_KGDB` is in the **Kernel hacking | Generic Kernel Debugging Instruments
    | KGDB: kernel debugger** menu.'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CONFIG_KGDB_SERIAL_CONSOLE` is in the **Kernel hacking** | **Generic Kernel
    Debugging Instruments** | **KGDB: kernel debugger** | **KGDB: use kgdb over the
    serial console** menu.'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The kernel image must be in ELF object format so that GDB can load the symbols
    into memory. This is the file called `vmlinux` that is generated in the directory
    where Linux is built. In Yocto, you can request that a copy be included in the
    target image and SDK. It is built as a package named `kernel-vmlinux`, which you
    can install like any other, for example, by adding it to the `IMAGE_INSTALL` list.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: 'The file is put into the `sysroot` boot directory, with a name like this:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: In Buildroot, you will find `vmlinux` in the directory where the kernel was
    built, which is in `output/build/linux-<version string>/vmlinux`.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to tell `kgdb` which serial port to use, either through the kernel
    command line or at runtime via `sysfs`. For the first option, add `kgdboc=<tty>,<baud
    rate>` to the kernel command line:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: A sample debug session
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The best way to show you how `kgdb` works is with a simple example. But before
    you can use `kgdb`, you first need to build it. To build `kgdb` and `kdb`, complete
    *Building GDB with Python support*, then perform these steps:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the directory where you installed Buildroot:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Clean previous build artifacts from the output directory:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Comment out the `miniuart-bt` `dtoverlay` from `board/raspberrypi4-64/config_4_64bit.txt`:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Append the following lines to `board/raspberrypi4-64/config_4_64bit.txt`:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Activate your saved configuration file:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Build your saved configuration:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Begin customizing your kernel:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Enable kernel debugging by navigating to **Kernel hacking** | **Compile-time
    checks and compiler options** | **Debug information** and selecting **Rely on
    the toolchain’s implicit default DWARF version**.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deselect **Reduce debugging information**.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Back out of **Debug information** and select the **Compile the kernel with frame
    pointers** menu.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Back out of **Compile-time checks and compiler options** and drill down into
    **Generic Kernel Debugging Instruments** | **KGDB: kernel debugger**.'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select both **KGDB: use kgdb over the serial console** and **KGDB_KDB: include
    kdb frontend for kgdb**.'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Back out of **Kernel hacking** and drill down into **Kernel Features**.
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deselect **Randomize the address of the kernel image**.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save your changes and exit `linux-menuconfig`.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Rebuild the kernel:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Delete the microSD card image:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Regenerate the microSD card image:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: When the build is done, there should be a bootable `sdcard.img` file in `output/images/`
    that you can write to a microSD card using Etcher. Insert that microSD into your
    target device. Connect a USB-to-TTL serial cable to the Raspberry Pi 4 ([https://learn.adafruit.com/adafruits-raspberry-pi-lesson-5-using-a-console-cable/connect-the-lead](https://learn.adafruit.com/adafruits-raspberry-pi-lesson-5-using-a-console-cable/connect-the-lead)).
    Boot the device.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: 'Connect the target device to your local network with an Ethernet cable and
    locate its IP address using `arp-scan --localnet`. SSH into the device as `root`
    and enter the password that you set when configuring your image. I specified `temppwd`
    as the `root` password for my `rpi4_64_gdb_defconfig` image. Write the terminal
    name to the `/sys/module/kgdboc/parameters/kgdboc` file:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Note that you cannot set the baud rate in this way. If it is the same `tty`
    as the console, then it is set already. If not, use `stty` or a similar program.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can start GDB on the host, selecting the `vmlinux` file that matches
    the running kernel:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: GDB loads the symbol table from `vmlinux` and waits for further input.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, close any terminal emulator that is attached to the console: you are
    about to use it for GDB, and if both are active at the same time, some of the
    debug strings might get corrupted.'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can return to GDB and attempt to connect to `kgdb`. However, you will
    find that the response you get from the target remote at this time is unhelpful:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The problem is that `kgdb` is not listening for a connection at this point.
    You need to interrupt the kernel before you can enter into an interactive GDB
    session with it. Unfortunately, just typing *Ctrl + C* in GDB, as you would with
    an application, does not work. You have to force a trap into the kernel by launching
    another shell on the target, via SSH, for example, and writing `g` to `/proc/sysrq-trigger`
    on the target board:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The target stops dead at this point. Now you can connect to `kgdb` via the
    serial device at the host end of the cable:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'At last, GDB is in charge. You can set breakpoints, examine variables, look
    at backtraces, and so on. As an example, set a break on `__sys_accept4`:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Now the target comes back to life. Exit out of your SSH session and attempt
    to reconnect to the target device. Reconnecting calls `__sys_accept4` and hits
    the breakpoint:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'If you have finished the debug session and want to disable `kgdboc`, just set
    the `kgdboc` terminal to null:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Like attaching to a running process with GDB, this technique of trapping the
    kernel and connecting to `kgdb` over a serial console works once the kernel is
    done booting. But what if the kernel never finishes booting because of a bug?
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: Debugging early code
  id: totrans-419
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The preceding example works in cases where the code you are interested in is
    executed when the system is fully booted. If you need to get in early, you can
    tell the kernel to wait during boot by adding `kgdbwait` to the command line,
    after the `kgdboc` option:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Now, when you boot, you will see this on the console:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: At this point, you can close the console and connect from GDB in the usual way.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: Debugging modules
  id: totrans-425
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Debugging kernel modules presents an additional challenge because the code is
    relocated at runtime, and so you need to find out at what address it resides.
    The information is presented through `sysfs`. The relocation addresses for each
    section of the module are stored in `/sys/module/<module name>/sections`. Note
    that since ELF sections begin with a dot (`.`), they appear as hidden files, and
    you will have to use `ls -a` if you want to list them. The important ones are
    `.text`, `.data`, and `.bss`.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: 'Take as an example a module named `mbx`:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Now you can use these numbers in `kgdb` to load the symbol table for the module
    at those addresses:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Everything should now work as normal: you can set breakpoints and inspect global
    and local variables in the module just as you can in `vmlinux`:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Then, force the device driver to call `mbx_write`, and it will hit the breakpoint:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: If you already use GDB to debug code in user space, then you should feel right
    at home debugging kernel code and modules with `kgdb`. Let’s look at `kdb` next.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: Debugging kernel code with kdb
  id: totrans-436
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although `kdb` does not have the features of `kgdb` and GDB, it does have its
    uses, and, being selfhosted, there are no external dependencies to worry about.
    `kdb` has a simple command-line interface that you can use on a serial console.
    You can use it to inspect memory, registers, process lists, and `dmesg` and even
    set breakpoints to stop at a certain location.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure your kernel so that you can call `kdb` via a serial console, enable
    `kgdb` as shown previously, and then enable this additional option:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: '`CONFIG_KGDB_KDB` in **Kernel hacking** | **Generic Kernel Debugging Instruments**
    | **KGDB: kernel debugger** | **KGDB_KDB: include kdb frontend for kgdb**'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, when you force the kernel into a trap, instead of entering into a GDB
    session, you will see the `kdb` shell on the console:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'There are quite a few things you can do in the `kdb` shell. The `help` command
    will print all of the options. Here is an overview:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting information**:'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ps`: Displays active processes.'
  id: totrans-444
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ps A`: Displays all processes.'
  id: totrans-445
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lsmod`: Lists modules.'
  id: totrans-446
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dmesg`: Displays the kernel log buffer.'
  id: totrans-447
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Breakpoints**:'
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bp`: Sets a breakpoint.'
  id: totrans-449
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bl`: Lists breakpoints.'
  id: totrans-450
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bc`: Clears a breakpoint.'
  id: totrans-451
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bt`: Prints a backtrace.'
  id: totrans-452
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`go`: Continues execution.'
  id: totrans-453
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inspect memory and registers**:'
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`md`: Displays memory.'
  id: totrans-455
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rd`: Displays registers.'
  id: totrans-456
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a quick example of setting a breakpoint:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'The kernel returns to life and the console shows the normal shell prompt. If
    you attempt to reconnect to the target, it hits the breakpoint and enters `kdb`
    again:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '`kdb` is not a source-level debugger, so you can’t see the source code or single-step.
    However, you can display a backtrace using the `bt` command, which is useful for
    getting an idea of program flow and call hierarchy.'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: Looking at an Oops
  id: totrans-462
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the kernel performs an invalid memory access or executes an illegal instruction,
    a kernel **Oops** message is written to the kernel log. The most useful part of
    this is the backtrace, and I want to show you how to use the information there
    to locate the line of code that caused the fault. I will also address the problem
    of preserving Oops messages if they cause the system to crash.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: 'This Oops message was generated by writing to the mailbox driver in `MELD/Chapter19/mbx-driver-oops`:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The line of the Oops that reads `pc` is at `mbx_write+0x2c/0xf8 [mbx]` and
    tells you most of what you want to know: the last instruction was in the `mbx_write`
    function of a kernel module named `mbx`. Furthermore, it was at offset `0x2c`
    bytes from the start of the function, which is `0xf8` bytes long.'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, take a look at the backtrace:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: In this case, we don’t learn much more, merely that `mbx_write` was called from
    the virtual filesystem function, `_vfs_write`.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: 'It would be very nice to find the line of code that relates to `mbx_write+0x2c`,
    for which we can use the GDB command `disassemble` with the `/s` modifier so that
    it shows source and assembler code together. In this example, the code is in the
    `mbx.ko` module, so we load that into `gdb`:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'You can see from *line 97* that `m` has the type struct `mbx_data *`. Here
    is the place where that structure is defined:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'So, it looks like the `m` variable is a null pointer, and that is what is causing
    the Oops. Looking at the code where `m` is initialized, we can see that there
    is a line missing. By initializing the pointer, as shown in the following code
    block, the Oops is eliminated:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Not every Oops is this easy to pinpoint, especially if it occurs before the
    contents of the kernel log buffer can be displayed.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: Preserving the Oops
  id: totrans-477
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Decoding an Oops is only possible if you can capture it in the first place.
    If the system crashes during boot before the console is enabled, or after a suspend,
    you won’t see it. There are mechanisms to log kernel Oops and messages to an MTD
    partition or to persistent memory, but here is a simple technique that works in
    many cases and needs little prior thought.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: 'So long as the contents of memory are not corrupted during a reset (and usually
    they are not), you can reboot into the bootloader and use it to display memory.
    You need to know the location of the kernel log buffer, remembering that it is
    a simple ring buffer of text messages. The symbol is `__log_buf`. Look this up
    in `System.map` for the kernel:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '**IMPORTANT NOTE**'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: From Linux 3.5 onward, there is a 16-byte binary header for each line in the
    kernel log buffer that encodes a timestamp, a log level, and other things. There
    is a discussion about it in the Linux weekly news entitled *Toward more reliable
    logging*, at [https://lwn.net/Articles/492125/](https://lwn.net/Articles/492125/).
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we examined how kernel code can be debugged at the source level
    using `kgdb`. Then we looked at setting breakpoints and printing backtraces inside
    the `kdb` shell. Lastly, we learned how to read kernel Oops messages either from
    a console using `dmesg` or the U-Boot command line.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-484
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Knowing how to use GDB for interactive debugging is a useful tool in the embedded
    system developer’s tool chest. It is a stable, well-documented, and well-known
    entity. It has the ability to debug remotely by placing an agent on the target,
    be it `gdbserver` for applications or `kgdb` for kernel code, and although the
    default command-line user interface takes a while to get used to, there are many
    alternative frontends. The three I mentioned were TUI, DDD, and Visual Studio
    Code. Eclipse is another popular frontend that supports debugging with GDB by
    way of the CDT plugin. I will refer you to the references in the *Further study*
    section for information on how to configure CDT to work with a cross toolchain
    and connect to a remote device.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: A second and equally important way to approach debugging is to collect crash
    reports and analyze them offline. In this category, we looked at application core
    dumps and kernel Oops messages.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: However, this is only one way of identifying flaws in programs. In the next
    chapter, I will talk about profiling and tracing as ways of analyzing and optimizing
    programs.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: Further study
  id: totrans-488
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*The Art of Debugging with GDB, DDD, and Eclipse*, by Norman Matloff and Peter
    Jay Salzman'
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*GDB Pocket Reference*, by Arnold Robbins'
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Python Interpreter in GNU Debugger*, by crazyguitar – [https://www.pythonsheets.com/appendix/python-gdb.html](https://www.pythonsheets.com/appendix/python-gdb.html%0D%0A)'
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Extending GDB with Python*, by Lisa Roach – [https://www.youtube.com/watch?v=xt9v5t4_zvE](https://www.youtube.com/watch?v=xt9v5t4_zvE%0D%0A)'
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Getting to grips with Eclipse: cross compiling* – [https://2net.co.uk/tutorial/eclipse-cross-compile](https://2net.co.uk/tutorial/eclipse-cross-compile%0D%0A)'
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Getting to grips with Eclipse: remote access and debugging* – [https://2net.co.uk/tutorial/eclipse-rse](https://2net.co.uk/tutorial/eclipse-rse)'
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
