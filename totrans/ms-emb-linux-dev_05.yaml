- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Configuring and Building the Kernel
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置和构建内核
- en: The kernel is the third element of embedded Linux. It is the component that
    is responsible for managing resources and interfacing with hardware. As such,
    it affects almost every aspect of your final software build. Each finished kernel
    is usually configured for some specific hardware. However, device trees enable
    us to employ a generic kernel and tailor it for our custom hardware using the
    contents of the DTB, as we saw in [*Chapter 3*](Chapter_03.xhtml#_idTextAnchor061).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 内核是嵌入式Linux的第三个组成部分。它是负责管理资源和与硬件接口的组件。因此，它几乎影响你最终软件构建的方方面面。每个完成的内核通常会为某些特定硬件进行配置。然而，设备树使我们能够使用通用内核，并通过DTB的内容将其定制为我们的硬件，就像我们在[*第3章*](Chapter_03.xhtml#_idTextAnchor061)中看到的那样。
- en: In this chapter, we will look at how to get a kernel for a board and how to
    configure and compile it. We will look again at Bootstrap, this time, focusing
    on the part the kernel plays. We will also look at device drivers and how they
    pick up information from the device tree.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何为一个开发板获取内核，如何配置和编译内核。我们将再次回顾引导过程，这次重点讨论内核的角色。我们还将探讨设备驱动程序以及它们如何从设备树中获取信息。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将覆盖以下主题：
- en: What does the kernel do?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核的作用是什么？
- en: Choosing a kernel
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择一个内核
- en: Configuring the kernel
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置内核
- en: Compiling with `Kbuild`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Kbuild`进行编译
- en: Building and booting the kernel
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建和启动内核
- en: Observing the kernel boot process
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察内核启动过程
- en: Porting Linux to a new board
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Linux移植到新板子上
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with the examples, make sure you have the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随示例，请确保你具备以下设备：
- en: An Ubuntu 24.04 or later LTS-based host system
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个基于Ubuntu 24.04或更高版本LTS的主机系统
- en: A Bootlin `aarch64` toolchain from [*Chapter 2*](Chapter_01.xhtml#_idTextAnchor028)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个来自[*第2章*](Chapter_01.xhtml#_idTextAnchor028)的Bootlin `aarch64`工具链
- en: A microSD card reader and card
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个microSD卡读卡器和卡
- en: A microSD card with U-Boot installed from [*Chapter 3*](Chapter_03.xhtml#_idTextAnchor061)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个安装了U-Boot的microSD卡，来自[*第3章*](Chapter_03.xhtml#_idTextAnchor061)
- en: A USB to TTL serial cable with 3.3V logic level
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一条具有3.3V逻辑电平的USB至TTL串口电缆
- en: The Raspberry Pi 4
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Raspberry Pi 4
- en: The BeaglePlay
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BeaglePlay
- en: A 5V USB-C power supply capable of delivering 3A
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个能够提供3A电流的5V USB-C电源供应器
- en: 'The code used in this chapter can be found in the chapter folder in this book’s
    GitHub repository: [https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter04](https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter04).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用的代码可以在本书GitHub仓库中的章节文件夹中找到：[https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter04](https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter04)。
- en: What does the kernel do?
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内核的作用是什么？
- en: 'Linux began in 1991 when Linus Torvalds started writing an operating system
    for Intel 386- and 486-based personal computers. He was inspired by the MINIX
    operating system written by Andrew S. Tanenbaum four years earlier. Linux differed
    in many ways from MINIX; the main differences being that it was a 32-bit virtual
    memory kernel, and the code was open source, later released under the GPL v2 license.
    He announced it on 25th August 1991 on the `comp.os.minix` newsgroup in a famous
    post that began with:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Linux始于1991年，当时Linus Torvalds开始为Intel 386和486架构的个人计算机编写操作系统。他受到四年前Andrew S.
    Tanenbaum编写的MINIX操作系统的启发。Linux与MINIX在许多方面有所不同；主要的区别是，Linux是一个32位虚拟内存内核，而且它的代码是开源的，后来以GPL
    v2许可证发布。他在1991年8月25日通过`comp.os.minix`新闻组发表了一篇著名的帖子，内容如下：
- en: Hello everybody out there using minix—I’m doing a (free) operating system (just
    a hobby, won’t be big and professional like GNU) for 386(486) AT clones. This
    has been brewing since April, and is starting to get ready. I’d like any feedback
    on things people like/dislike in minix, as my OS resembles it somewhat (same physical
    layout of the filesystem (due to practical reasons) among other things).
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 大家好，正在使用minix的朋友们——我正在为386(486) AT克隆机编写一个（免费的）操作系统（只是一个爱好，不会像GNU那样大而专业）。这个项目自四月以来一直在酝酿，现已开始准备就绪。我希望能得到关于minix中大家喜欢/不喜欢的反馈，因为我的操作系统在某些方面与它相似（例如相同的文件系统物理布局（出于实际原因）等）。
- en: To be strictly accurate, Linus did not write an operating system. He wrote a
    kernel, which is only one component of an operating system. To create a complete
    operating system with user space commands and a shell command interpreter, he
    used components from the GNU project, especially the toolchain, the C library,
    and basic command-line tools. That distinction remains today and gives Linux a
    lot of flexibility in the way it is used.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，Linus 并没有编写一个操作系统。他编写了一个内核，而内核只是操作系统的一个组成部分。为了创建一个完整的操作系统，其中包含用户空间命令和一个
    shell 命令解释器，他使用了来自 GNU 项目的组件，特别是工具链、C 库和基本的命令行工具。这一区别至今仍然存在，并且赋予了 Linux 在使用方式上的极大灵活性。
- en: '**Berkeley Software Distribution** (**BSD**) predates Linux by many years.
    BSD began as a research project at the University of California, Berkeley’s renowned
    Computer Systems Research Group sometime in the late 1970s. Originally known as
    Berkeley Unix, BSD was based on the original Unix source code developed at Bell
    Labs. Now a defunct operating system, BSD lives on in the form of its open source
    descendants including FreeBSD, OpenBSD, and NetBSD. Most notably, the Darwin open
    source operating system used in Apple’s macOS and iOS is a derivative of BSD.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**伯克利软件分发版**（**BSD**）比 Linux 早了很多年。BSD 起源于 1970 年代末期，加利福尼亚大学伯克利分校著名的计算机系统研究小组的一个研究项目。最初称为伯克利
    Unix，BSD 基于贝尔实验室开发的原始 Unix 源代码。如今，BSD 已成为一个废弃的操作系统，但它的开源后代，如 FreeBSD、OpenBSD 和
    NetBSD 仍在延续。最著名的例子是，苹果公司 macOS 和 iOS 操作系统中的开源系统 Darwin 就是 BSD 的衍生版本。'
- en: The Linux kernel can be combined with a GNU user space to create a full Linux
    distribution that runs on desktops and servers, which is sometimes called GNU/Linux.
    It can be combined with an Android user space to create the well-known mobile
    operating system, or it can be combined with a small BusyBox-based user space
    to create a compact embedded system.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 内核可以与 GNU 用户空间结合，创建一个完整的 Linux 发行版，运行在桌面和服务器上，这通常被称为 GNU/Linux。它还可以与 Android
    用户空间结合，创建著名的移动操作系统，或者它可以与一个基于 BusyBox 的小型用户空间结合，创建一个紧凑的嵌入式系统。
- en: Contrast this with the BSD operating systems (FreeBSD, OpenBSD, and NetBSD)
    in which the kernel, toolchain, and user space are combined into a single code
    base. By removing the toolchain, you can deploy slimmer runtime images without
    a compiler or header files. By decoupling user space from the kernel, you gain
    options in terms of init systems (`runit` vs `systemd`), C libraries (`musl` vs
    `glibc`) and package formats (`.apk` vs `.deb`).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 与此对比的是 BSD 操作系统（FreeBSD、OpenBSD 和 NetBSD），在这些系统中，内核、工具链和用户空间被组合成一个统一的代码库。通过去除工具链，你可以部署更简洁的运行时镜像，而不需要编译器或头文件。通过将用户空间与内核解耦，你可以在初始化系统（`runit`
    与 `systemd`）、C 库（`musl` 与 `glibc`）以及软件包格式（`.apk` 与 `.deb`）上获得更多选择。
- en: 'The kernel has three main jobs – to manage resources, to interface with hardware,
    and to provide an API that offers a useful level of abstraction to user space
    programs, as summarized in the following diagram:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 内核有三个主要功能——管理资源、与硬件交互，并提供一个 API，为用户空间程序提供有用的抽象层，概述如下图：
- en: '![Figure 4.1 − User space, kernel space, and hardware](img/B18466_04_01.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 − 用户空间、内核空间和硬件](img/B18466_04_01.png)'
- en: Figure 4.1 − User space, kernel space, and hardware
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 − 用户空间、内核空间和硬件
- en: Applications running in **user space** run at a low CPU privilege level. They
    can do very little other than make library calls. The primary interface between
    user space and **kernel space** is the **C library,** which translates user-level
    functions, such as those defined by POSIX, into kernel system calls. The system
    call interface uses an architecture-specific method, such as a trap or a software
    interrupt, to switch the CPU from low-privilege user mode to high-privilege kernel
    mode. A CPU running in kernel mode has access to all memory addresses and CPU
    registers.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 运行在**用户空间**的应用程序运行在较低的 CPU 特权级别。它们几乎只能做一些库调用。用户空间和**内核空间**之间的主要接口是**C 库**，它将用户级函数（如
    POSIX 定义的函数）转换为内核系统调用。系统调用接口使用架构特定的方法，如陷阱或软件中断，将 CPU 从低特权用户模式切换到高特权内核模式。运行在内核模式下的
    CPU 可以访问所有内存地址和 CPU 寄存器。
- en: The system call handler dispatches the call to the appropriate kernel subsystem.
    Memory allocation calls go to the memory manager, filesystem calls to the filesystem
    code, and so on. Some of those calls require input from the underlying hardware
    and will be passed down to a device driver. In some cases, the hardware itself
    invokes a kernel function by raising an interrupt.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 系统调用处理程序将调用分派给适当的内核子系统。内存分配调用会交给内存管理器，文件系统调用会交给文件系统代码，依此类推。某些调用需要底层硬件的输入，并会传递给设备驱动程序。在某些情况下，硬件本身通过触发中断来调用内核函数。
- en: '**IMPORTANT NOTE**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: 'The diagram in *Figure 4.1* shows that there is a second entry point into kernel
    code: hardware interrupts. Interrupts can only be handled in a device driver,
    never by a user space application.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4.1*中的图示表明，内核代码有第二个入口点：硬件中断。中断只能在设备驱动程序中处理，用户空间应用程序无法处理。'
- en: In other words, all the useful things that your application does are done through
    the kernel. The kernel is therefore one of the most important elements in the
    system. So, it is important to understand how to choose one.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，你的应用程序所做的所有有用的事情，都是通过内核来完成的。因此，内核是系统中最重要的元素之一。所以，理解如何选择一个内核非常重要。
- en: Choosing a kernel
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择内核
- en: The next step is to choose the kernel for your project. It is important to balance
    your desire to always use the latest version of software against the need for
    vendor-specific additions and an interest in the long-term support of the code
    base.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是为你的项目选择内核。需要平衡你总是使用最新软件版本的愿望与对供应商特定补丁的需求，以及对代码库长期支持的兴趣。
- en: Kernel development cycle
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内核开发周期
- en: Linux is developed at a fast pace with a new version being released every 8
    to 12 weeks. The way that the version numbers are constructed has changed over
    the years. Before July 2011, there was a three-number version scheme with version
    numbers that looked like 2.6.39\. The middle number indicated whether it was a
    developer or stable release. Odd numbers (2.1.x, 2.3.x, 2.5.x) were for developers.
    Even numbers were for end users.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 的开发速度非常快，每 8 到 12 周就会发布一个新版本。版本号的构建方式多年来发生了变化。在 2011 年 7 月之前，使用三位数版本方案，版本号像
    2.6.39。中间的数字表示它是开发者版本还是稳定版本。奇数（2.1.x、2.3.x、2.5.x）是给开发者的，偶数版本是给最终用户的。
- en: From version 2.6 onward, the idea of a long-lived development branch (the odd
    numbers) was dropped, as it slowed down the rate at which new features were made
    available to the users. The change in numbering from 2.6.39 to 3.0 in July 2011
    was purely because Linus felt that the numbers were becoming too large.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 从 2.6 版本开始，Linux 放弃了长生命周期的开发分支（奇数版本），因为它减缓了新功能对用户的发布速度。2011 年 7 月，从 2.6.39 到
    3.0 的版本号变更，纯粹是因为 Linus 觉得版本号变得太大了。
- en: 'There was no huge leap in the features or architecture of Linux between those
    two versions. He also took the opportunity to drop the middle number. Since then,
    Linus has bumped the major version three more times: next in April 2015 (3 to
    4), again in March 2019 (4 to 5), and most recently, in October 2022 (5 to 6).
    Each time, he did this purely for neatness, not because of any large architectural
    shift.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个版本之间，Linux 的功能或架构没有发生巨大变化。他还借此机会去掉了中间的数字。从那时起，Linus 已经将主版本号提升了三次：2015 年
    4 月（从 3 升级到 4），2019 年 3 月（从 4 升级到 5），以及最近的 2022 年 10 月（从 5 升级到 6）。每次版本号的提升都是出于整洁的考虑，而不是因为有大的架构变化。
- en: 'Linus manages the development kernel tree. You can follow him by cloning the
    Git tree like so:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Linus 管理着开发内核树。你可以通过克隆 Git 树来关注他，方法如下：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will check the source out into a subdirectory named `linux`. You can keep
    up to date by running the command `git pull` in that directory from time to time.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把源代码检出到一个名为`linux`的子目录。你可以通过时不时在该目录下运行`git pull`命令来保持最新。
- en: A full cycle of kernel development begins with a merge window of two weeks during
    which Linus will accept patches for new features. At the end of the merge window,
    a stabilization phase begins. Once the merge window closes, Linus will produce
    weekly release candidates with version numbers ending in `-rc1`, `-rc2`, and so
    on, usually up to `-rc7` or `-rc8`. During this time, people test the candidates
    and submit bug reports and fixes. When all significant bugs have been fixed, the
    kernel is released.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 内核开发的完整周期始于为期两周的合并窗口，在此期间，Linus 会接受用于新特性的补丁。合并窗口结束时，进入稳定化阶段。一旦合并窗口关闭，Linus 会发布带有版本号
    `-rc1`、`-rc2` 等的每周发布候选版本，通常会发布到 `-rc7` 或 `-rc8`。在此期间，人们会测试候选版本并提交错误报告和修复。当所有重大错误都被修复后，内核正式发布。
- en: The code incorporated during the merge window needs to be fairly mature already.
    Usually, it is pulled from the repositories of the many subsystems and architecture
    maintainers of the kernel. By keeping to a short development cycle, features can
    be merged when they are ready. If a feature is deemed not sufficiently stable
    or well developed by the kernel maintainers, it can simply be delayed until the
    next release.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在合并窗口期间合并的代码通常已经相当成熟。通常，它是从许多子系统和内核架构维护者的仓库中拉取的。通过保持短周期的开发，特性可以在准备好时进行合并。如果内核维护者认为某个特性不够稳定或不够完善，它可以被推迟到下一个版本。
- en: Keeping track of what has changed from release to release is not easy. You can
    read the commit log in Linus’ Git repository but, with so many entries, it is
    not easy to get an overview. Thankfully, there is the Linux **Kernel Newbies**
    website ([https://kernelnewbies.org](https://kernelnewbies.org)) where you can
    find a succinct overview of each version at [https://kernelnewbies.org/LinuxVersions](https://kernelnewbies.org/LinuxVersions).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪每个版本之间的变化并不容易。你可以阅读 Linus 的 Git 仓库中的提交日志，但由于条目过多，很难获得整体概览。幸运的是，Linux 有一个**Kernel
    Newbies**网站（[https://kernelnewbies.org](https://kernelnewbies.org)），你可以在 [https://kernelnewbies.org/LinuxVersions](https://kernelnewbies.org/LinuxVersions)
    上找到每个版本的简明概览。
- en: Stable and long-term support releases
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 稳定版和长期支持版发布
- en: 'The rapid rate of change of Linux is a good thing in that it brings new features
    into the mainline code base, but it does not fit very well with the longer life
    cycle of embedded projects. Kernel developers address this in two ways: stable
    releases and long-term releases. After the release of a mainline kernel (maintained
    by Linus Torvalds), it is moved to the **stable** tree (maintained by Greg Kroah-Hartman).
    Bug fixes are applied to the stable kernel while the mainline kernel begins the
    next development cycle.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 的快速变化速度是一件好事，因为它将新特性引入主线代码库，但它与嵌入式项目较长的生命周期并不完全匹配。内核开发者通过两种方式来解决这个问题：稳定版发布和长期支持版发布。在主线内核（由
    Linus Torvalds 维护）发布后，它会被移到**稳定**树（由 Greg Kroah-Hartman 维护）。错误修复会应用到稳定版内核，而主线内核则进入下一个开发周期。
- en: Point releases of the stable kernel are marked by a third number (3.18.1, 3.18.2,
    and so on). Before version 3, there were four release numbers (2.6.29.1, 2.6.39.2,
    and so on).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 稳定版内核的点版本通过第三个数字来标记（例如 3.18.1、3.18.2 等）。在版本3之前，有四个版本号（例如 2.6.29.1、2.6.39.2 等）。
- en: 'You can get the stable tree by using the following command:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下命令获取稳定树：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can use `git` `checkout` to get a particular version like 6.6.46:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `git` `checkout` 来获取特定版本，例如 6.6.46：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The stable kernel is usually updated only until the next mainline release (8
    to 12 weeks later) so you will see that there are just one or sometimes two stable
    kernels at [https://www.kernel.org/](https://www.kernel.org/). To cater to those
    users who would like updates for longer, some kernels are labeled **long-term**
    and maintained for two or more years. Long-term kernels come with the assurance
    that any bugs will be found and fixed. There is at least one long-term kernel
    release each year.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 稳定版内核通常只会更新到下一个主线版本（大约8到12周后），因此你会看到 [https://www.kernel.org/](https://www.kernel.org/)
    上通常只有一个或两个稳定版内核。为了满足那些需要更长时间更新的用户，一些内核被标记为**长期支持**，并维持两年或更长时间。长期支持内核保证会发现并修复所有错误。每年至少会发布一个长期支持的内核版本。
- en: 'Looking at [https://www.kernel.org/](https://www.kernel.org/) in August of
    2024, there are a total of six long-term kernels: 6.6, 6.1, 5.15, 5.10, 5.4, and
    4.19\. The oldest has been maintained for nearly six years and is at version 4.19.319\.
    If you are building a product that you will have to maintain for this length of
    time, then the latest long-term kernel might well be a good choice.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以 2024 年 8 月查看[https://www.kernel.org/](https://www.kernel.org/)时，共有六个长期维护的内核版本：6.6、6.1、5.15、5.10、5.4
    和 4.19。最老的版本已经维护了近六年，当前版本为 4.19.319。如果你正在构建一个需要长期维护的产品，那么最新的长期维护内核可能是一个不错的选择。
- en: Vendor support
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 供应商支持
- en: In an ideal world, you would be able to download a kernel from [https://www.kernel.org/](https://www.kernel.org/)
    and configure it for any device that claims to support Linux. However, that is
    not always possible. In fact, mainline Linux has solid support for only a small
    subset of the many devices that can run Linux. You may find support for your board
    or SoC from independent open source projects like Linaro ([https://www.linaro.org/](https://www.linaro.org/))
    or The Yocto Project ([https://www.yoctoproject.org/](https://www.yoctoproject.org/)).
    There are some companies that offer paid third-party support for embedded Linux.
    But in many cases, you will be obliged to look to the vendor of your SoC or board
    for a working kernel.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想的情况下，你应该能够从[https://www.kernel.org/](https://www.kernel.org/)下载内核，并为任何声称支持
    Linux 的设备配置它。然而，现实中并非总是如此。事实上，主线 Linux 只对能运行 Linux 的众多设备中的一小部分提供了稳定支持。你可能会在一些独立的开源项目中找到对你的开发板或
    SoC 的支持，比如 Linaro ([https://www.linaro.org/](https://www.linaro.org/)) 或 Yocto
    项目 ([https://www.yoctoproject.org/](https://www.yoctoproject.org/))。有些公司提供嵌入式
    Linux 的付费第三方支持。但在许多情况下，你将不得不依赖于 SoC 或开发板供应商提供的可用内核。
- en: As we know, some vendors are better at supporting Linux than others. My advice
    at this point is to choose vendors who give good support or, even better, who
    take the trouble to get their kernel changes into the mainline. Search the Linux
    kernel mailing list or commit history for recent activity around a candidate SoC
    or board. When upstream changes are absent from the mainline kernel, the verdict
    as to whether a vendor offers good support is largely based on word of mouth.
    Some vendors are notorious for releasing only one kernel code drop before redirecting
    all their energies toward their newer SoCs.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，一些供应商比其他供应商更擅长支持 Linux。在此阶段，我的建议是选择那些提供良好支持的供应商，或者更好的是，选择那些努力将其内核更改提交到主线的供应商。可以通过搜索
    Linux 内核邮件列表或提交历史，查看候选的 SoC 或开发板是否有最近的活动。当主线内核中没有上游更改时，判断一个供应商是否提供良好支持，往往依赖于口碑。有些供应商因只发布一个内核代码版本后，就将所有精力转向更新的
    SoC，声名狼藉。
- en: Licensing
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 许可证
- en: The Linux source code is licensed under GPL v2\. That means you must make the
    source code of your kernel available in one of the ways specified in the license.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 源代码是按照 GPL v2 许可证授权的。这意味着你必须以许可证中规定的某种方式提供你的内核源代码。
- en: The actual text of the license for the kernel is in the file `COPYING`. It begins
    with an addendum written by Linus that states that code calling the kernel from
    user space via the system call interface is not considered a derivative work of
    the kernel and so is not covered by the license. Hence, there is no problem with
    proprietary applications running on top of Linux.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 内核的实际许可证文本位于文件 `COPYING` 中。它以 Linus 撰写的附录开始，声明通过系统调用接口从用户空间调用内核的代码不被视为内核的衍生作品，因此不受许可证约束。因此，专有应用程序运行在
    Linux 上并没有问题。
- en: 'However, there is one area of Linux licensing that causes endless confusion
    and debate: kernel modules. A **kernel module** is simply a piece of code that
    is dynamically linked with the kernel at runtime thereby extending the functionality
    of the kernel. The **General Public License** (**GPL**) makes no distinction between
    static and dynamic linking, so it would appear that the source for kernel modules
    is covered by the GPL. In the early days of Linux, there were debates about exceptions
    to this rule, for example, in connection with the **Andrew File System** (**AFS**).
    This code predates Linux and, therefore (it was argued), is not a derivative work
    so the license does not apply.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Linux 许可证中有一个领域引起了无休止的混淆和争议：内核模块。**内核模块**只是一个在运行时与内核动态链接的代码片段，从而扩展了内核的功能。**通用公共许可证**（**GPL**）并未区分静态链接和动态链接，因此，内核模块的源代码似乎受
    GPL 的覆盖。在 Linux 的早期，关于这个规则的例外存在争议，例如与 **安德鲁文件系统**（**AFS**）相关的争论。因为这个代码早于 Linux，因此（有人辩称）它不是衍生作品，因此不受许可证的约束。
- en: Similar discussions took place over the years with respect to other pieces of
    code with the result that it is now accepted practice that the GPL does not necessarily
    apply to kernel modules. This is codified by the kernel `MODULE_LICENSE` macro,
    which may take the value `Proprietary` to indicate that it is not released under
    the GPL. If you plan to use the same arguments yourself, you may want to read
    through an oft-quoted email thread titled *Linux GPL and binary module exception
    clause?*, which is archived at [https://yarchive.net/comp/linux/gpl_modules.html](https://yarchive.net/comp/linux/gpl_modules.html).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，就其他代码片段进行过类似的讨论，结果现在已接受的做法是，GPL 不一定适用于内核模块。这一点通过内核中的`MODULE_LICENSE`宏进行了规定，该宏可以设置为`Proprietary`，表示该模块没有遵循
    GPL 许可证。如果你打算使用相同的论据，可能需要阅读一封经常被引用的邮件线程，标题为*Linux GPL 和二进制模块例外条款？*，该邮件已存档于[https://yarchive.net/comp/linux/gpl_modules.html](https://yarchive.net/comp/linux/gpl_modules.html)。
- en: The GPL should be considered a good thing because it guarantees that when we
    are working on embedded projects, we can always get the source code for the kernel.
    Without it, embedded Linux would be much harder to use and more fragmented.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: GPL 应该被视为一件好事，因为它确保了我们在进行嵌入式项目时，总是能够获取内核的源码。没有它，嵌入式 Linux 将变得更加难以使用且更加支离破碎。
- en: Best practices
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最佳实践
- en: That said, to choose a kernel, you need to weigh the benefits of using the latest
    version against the need for vendor-specific enhancements and driver stability.
    Also, the rapid Linux development cycle allows features to be integrated quickly,
    with stable and long-term support releases available for extended maintenance.
    The long-term kernels, which receive updates for over two years, are ideal for
    long-term projects. Vendor support is also crucial, so make sure to choose vendors
    who actively support Linux and contribute to the mainline kernel. Lastly, licensing
    under GPL v2 ensures access to the kernel source code, which makes it easier to
    use and maintain for embedded projects.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，选择内核时，你需要权衡使用最新版本的好处与厂商特定增强功能和驱动程序稳定性的需求。此外，快速发展的 Linux 开发周期使得新特性能够迅速集成，并且有稳定的长期支持版本可供扩展维护。长期支持内核会获得超过两年的更新，非常适合长期项目。厂商支持也至关重要，因此，确保选择那些积极支持
    Linux 并为主线内核做出贡献的厂商。最后，GPL v2 许可证确保了内核源码的获取，这使得在嵌入式项目中使用和维护内核变得更加容易。
- en: Configuring the kernel
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置内核
- en: Having decided which kernel to base your image on, the next step is configuring
    the kernel.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦决定了基于哪个内核来构建镜像，接下来的步骤是配置内核。
- en: Getting the source
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取源码
- en: All three of the targets used in this book (Raspberry Pi 4, BeaglePlay, and
    QEMU) are well supported by the mainline kernel. Therefore, it makes sense to
    use the latest long-term kernel available from [https://www.kernel.org/](https://www.kernel.org/),
    which, at the time of writing, was 6.6.46\. When you come to do this for yourself,
    you should check to see if there is a later version of the 6.6 kernel and use
    that instead since it will have fixes for bugs found after 6.6.46 was released.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中使用的三个目标（Raspberry Pi 4、BeaglePlay 和 QEMU）都得到了主线内核的良好支持。因此，使用来自[https://www.kernel.org/](https://www.kernel.org/)的最新长期支持内核是有意义的，在写作时，该内核版本为6.6.46。当你自己操作时，应该检查是否有6.6内核的更新版本，并使用该版本，因为它会修复6.6.46发布后发现的错误。
- en: '**IMPORTANT NOTE**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要说明**'
- en: If there is a later long-term release, you may want to consider using that one.
    However, be aware that there may have been changes that mean that the following
    sequence of commands does not work exactly as given.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有更晚的长期发布版本，你可能希望考虑使用那个版本。但要注意，可能已经有一些变化，意味着以下命令序列无法完全按给定的方式工作。
- en: 'To fetch and extract a release tarball of the 6.6.46 Linux kernel, use the
    following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取并提取6.6.46版本的 Linux 内核发布 tarball，可以使用以下命令：
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To fetch a later version, replace `6.6.46` after `linux-` with the desired long-term
    release.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取更新版本，只需将`linux-`后的`6.6.46`替换为所需的长期支持版本。
- en: 'There is a lot of code here. There are over 81,000 files in the 6.6 kernel
    containing C source code, header files, and assembly code amounting to a total
    of over 24 million lines of code as measured by the SLOCCount utility. Nevertheless,
    it is worth knowing the basic layout of the code and approximately where to look
    for a particular component. The main directories of interest are:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有大量代码。6.6 内核中有超过 81,000 个文件，包含 C 源代码、头文件和汇编代码，总计超过 2400 万行代码，根据 SLOCCount
    工具的测量结果。尽管如此，了解代码的基本布局以及大概在哪个地方查找特定组件是很有价值的。主要的关注目录有：
- en: '`arch`: Contains architecture-specific files. There is one subdirectory per
    architecture.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arch`：包含特定于体系结构的文件。每种体系结构都有一个子目录。'
- en: '`Documentation`: Contains kernel documentation. Always look here first if you
    want to find more information about an aspect of Linux.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Documentation`：包含内核文档。如果想找到有关Linux某方面更多信息，总是首先查看此处。'
- en: '`drivers`: Contains device drivers, thousands of them. There is a subdirectory
    for each type of driver.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drivers`：包含设备驱动程序，数以千计。每种类型的驱动程序都有一个子目录。'
- en: '`fs`: Contains filesystem code.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fs`：包含文件系统代码。'
- en: '`include`: Contains kernel header files including those required when building
    the toolchain.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`include`：包含内核头文件，包括在构建工具链时需要的文件。'
- en: '`init`: Contains the kernel start-up code.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init`：包含内核启动代码。'
- en: '`kernel`: Contains core functions including scheduling, locking, timers, power
    management, and debug/trace code.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kernel`：包含核心功能，包括调度、锁定、定时器、电源管理以及调试/跟踪代码。'
- en: '`mm`: Contains memory management.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mm`：包含内存管理。'
- en: '`net`: Contains network protocols.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`net`：包含网络协议。'
- en: '`scripts`: Contains many useful scripts including the device tree compiler,
    which I described in [*Chapter 3*](Chapter_03.xhtml#_idTextAnchor061).'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scripts`：包含许多有用的脚本，包括设备树编译器，在[*第3章*](Chapter_03.xhtml#_idTextAnchor061)中有描述。'
- en: '`tools`: Contains many useful tools including the Linux performance counters
    tool (`perf`), which I will describe in [*Chapter 20*](Chapter_16.xhtml#_idTextAnchor538).'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tools`：包含许多有用的工具，包括Linux性能计数器工具（`perf`），我将在[*第20章*](Chapter_16.xhtml#_idTextAnchor538)中描述。'
- en: Over time, you will become familiar with this structure and realize that if
    you are looking for the serial port code of a particular SoC, you will find it
    in `drivers/tty/serial` and not in `arch/$ARCH/mach-foo` because it is a device
    driver and not something CPU architecture-specific.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，你会熟悉这种结构，并意识到，如果你要找特定SoC的串口代码，你会在`drivers/tty/serial`找到它，而不是在`arch/$ARCH/mach-foo`中，因为它是设备驱动，而不是特定于CPU架构的内容。
- en: Understanding kernel configuration– Kconfig
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解内核配置– Kconfig
- en: One of the strengths of Linux is the degree to which you can configure the kernel
    to suit different jobs, from a small, dedicated device such as a smart thermostat
    to a complex mobile handset. In current versions, there are many thousands of
    configuration options. Getting the configuration right is a task in itself, but
    before we get into that, I want to show you how it works so that you can better
    understand what is going on.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Linux的一个优点是可以根据不同的需求配置内核，从小型的专用设备（如智能恒温器）到复杂的移动电话。在当前版本中，有成千上万的配置选项。正确配置配置本身就是一项任务，但在深入讨论之前，我想先向你展示它是如何工作的，这样你可以更好地理解正在发生的事情。
- en: The configuration mechanism is called `Kconfig`, and the build system that it
    integrates with is called `Kbuild`. Both are documented in `Documentation/kbuild`.
    `Kconfig`/`Kbuild` is used in a number of other projects besides the kernel including
    Crosstool-NG, U-Boot, Barebox, and BusyBox.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 配置机制被称为`Kconfig`，与之集成的构建系统被称为`Kbuild`。这两者的文档位于`Documentation/kbuild`中。`Kconfig`/`Kbuild`不仅在内核项目中使用，还包括Crosstool-NG、U-Boot、Barebox和BusyBox等其他项目。
- en: The configuration options are declared in a hierarchy of files named `Kconfig`
    using a syntax described in `Documentation/kbuild/kconfig-language.rst`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 配置选项在名为`Kconfig`的一系列文件中声明，使用的语法在`Documentation/kbuild/kconfig-language.rst`中描述。
- en: 'In Linux, the top-level `Kconfig` looks like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，顶层的`Kconfig`看起来像这样：
- en: '[PRE4]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And the first line of `arch/Kconfig` is:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`arch/Kconfig`的第一行是：'
- en: '[PRE5]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: That line includes the architecture-dependent configuration file, which sources
    other `Kconfig` files depending on which options are enabled.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 该行包括依赖于启用了哪些选项的其他`Kconfig`文件的体系结构相关配置文件。
- en: 'Having the architecture play such a prominent role has three implications:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让体系结构发挥如此重要作用有三个含义：
- en: First, you must specify an architecture when configuring Linux by setting `ARCH=<architecture>`;
    otherwise, it will default to the local machine architecture.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，在配置Linux时必须指定一个体系结构，设置`ARCH=<architecture>`；否则，它将默认为本地机器体系结构。
- en: Second, the value you set for `ARCH` usually determines the value of `SRCARCH`
    so you rarely need to set `SRCARCH` explicitly.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，通常情况下，你设置的`ARCH`的值决定了`SRCARCH`的值，因此你很少需要显式设置`SRCARCH`。
- en: Third, the layout of the top-level menu is different for each architecture.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三，每种体系结构的顶级菜单布局都不同。
- en: The value you put into `ARCH` is one of the subdirectories you find in the directory
    `arch` with the oddity that `ARCH=i386` and `ARCH=x86_64` both source `arch/x86/Kconfig`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你在`ARCH`中设置的值是`arch`目录中找到的子目录之一，唯一的特殊情况是`ARCH=i386`和`ARCH=x86_64`都会引用`arch/x86/Kconfig`。
- en: The `Kconfig` files consist largely of menus delineated by the `menu` and `endmenu`
    keywords. Menu items are marked by the keyword `config`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`Kconfig`文件大部分由`menu`和`endmenu`关键字划定的菜单组成。菜单项由`config`关键字标记。'
- en: 'Here is an example taken from `drivers/char/Kconfig`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个来自`drivers/char/Kconfig`的示例：
- en: '[PRE6]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The parameter following `config` names a variable, which, in this case, is
    `DEVMEM`. Since this option is a `bool` (Boolean), it can only have two values:
    if it is enabled, it is assigned `y`, and if it is not enabled, the variable is
    not defined at all. The name of the menu item that is displayed on the screen
    is the string following the `bool` keyword.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 紧跟在`config`后面的参数指定了一个变量，这里是`DEVMEM`。由于此选项是`bool`（布尔值），它只能有两个值：如果启用，它的值为`y`，如果未启用，则该变量根本不定义。屏幕上显示的菜单项名称是`bool`关键字后面的字符串。
- en: This configuration item, along with all the others, is stored in a file named
    `.config`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置项及其他所有配置项存储在名为`.config`的文件中。
- en: '**TIP**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: The leading dot (`.`) in `.config` means that it is a hidden file that will
    not be shown by the `ls` command unless you type `ls -a` to show all files.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`.config`中的前导点（`.`）表示它是一个隐藏文件，默认情况下，`ls`命令不会显示，除非你使用`ls -a`来显示所有文件。'
- en: 'The line corresponding to this configuration item reads:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 与此配置项对应的行是：
- en: '[PRE7]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'There are several other data types in addition to `bool`. Here is the complete
    list:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`bool`之外，还有几种其他数据类型。以下是完整的列表：
- en: '`bool`: Either `y` or not defined.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool`：要么是`y`，要么未定义。'
- en: '`tristate`: Used where a feature can be built as a kernel module or built into
    the main kernel image. The values are `m` for a module, `y` to be built in, and
    not defined if the feature is not enabled.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tristate`：用于某个功能可以作为内核模块或内核映像的一部分进行构建的情况。其值为`m`表示作为模块，`y`表示构建为内核的一部分，若未启用该功能，则未定义。'
- en: '`int`: An integer value using decimal notation.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int`：使用十进制表示法的整数值。'
- en: '`hex`: An unsigned integer value using hexadecimal notation.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hex`：使用十六进制表示法的无符号整数值。'
- en: '`string`: A string value.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string`：字符串值。'
- en: 'There may be dependencies between items expressed by the `depends on` construct,
    as shown here:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 项目之间可能存在依赖关系，依赖关系通过`depends on`构造来表示，如下所示：
- en: '[PRE8]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If `CONFIG_MTD` has not been enabled elsewhere, this menu option is not shown
    and so cannot be selected.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`CONFIG_MTD`在其他地方未启用，则该菜单选项不会显示，因此无法选择。
- en: 'There are also reverse dependencies. The `select` keyword enables other options
    if this one is enabled. The `Kconfig` file in `arch/$ARCH` has numerous `select`
    statements that enable features specific to the architecture, as seen here for
    Arm:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 还有反向依赖关系。`select`关键字在启用某个选项时，会启用其他选项。`arch/$ARCH`中的`Kconfig`文件包含了许多`select`语句，启用了特定于架构的功能，下面是Arm架构的示例：
- en: '[PRE9]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: By selecting `ARCH_CLOCKSOURCE_DATA` and `ARCH_HAS_DEVMEM_IS_ALLOWED`, we are
    assigning a value of `y` to these variables so that these features are built statically
    into the kernel.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择`ARCH_CLOCKSOURCE_DATA`和`ARCH_HAS_DEVMEM_IS_ALLOWED`，我们将这两个变量的值设置为`y`，以便将这些功能静态构建到内核中。
- en: There are several configuration utilities that can read the `Kconfig` files
    and produce a `.config` file. Some of them display the menus on the screen and
    allow you to make choices interactively. `menuconfig` is probably the one most
    people are familiar with but there are also `xconfig` and `gconfig`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种配置工具可以读取`Kconfig`文件并生成`.config`文件。它们中的一些会在屏幕上显示菜单并允许你进行交互式选择。`menuconfig`可能是大多数人熟悉的工具，但也有`xconfig`和`gconfig`。
- en: 'To use `menuconfig`, you first need to have `ncurses`, `flex`, and `bison`
    installed. The following command installs all these prerequisites on Ubuntu:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`menuconfig`之前，你需要先安装`ncurses`、`flex`和`bison`。以下命令在Ubuntu上安装所有这些依赖项：
- en: '[PRE10]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You launch `menuconfig` via the `make` command, remembering that, in the case
    of the kernel, you need to supply an architecture, as illustrated here:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过`make`命令启动`menuconfig`，请记住，在内核的情况下，你需要提供一个架构，如下所示：
- en: '[PRE11]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Make sure that your `PATH` variable points to the 64-bit toolchain you downloaded
    back in [*Chapter 2*](Chapter_01.xhtml#_idTextAnchor028).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的`PATH`变量指向你在[*第2章*](Chapter_01.xhtml#_idTextAnchor028)中下载的64位工具链。
- en: 'Here you can see `menuconfig` with the `DEVMEM` config option highlighted previously:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你可以看到带有先前突出显示的`DEVMEM`配置选项的`menuconfig`：
- en: '![Figure 4.2 − Selecting DEVMEM](img/B18466_04_02.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 − 选择 DEVMEM](img/B18466_04_02.png)'
- en: Figure 4.2 − Selecting DEVMEM
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 − 选择 DEVMEM
- en: The star (`*`) to the left of an item means that the driver has been selected
    to be built statically into the kernel. If it is an `M`, then it has been selected
    to be built as a kernel module for insertion into the kernel at runtime.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 位于项目前的星号（`*`）表示该驱动已被选择为静态编译到内核中。如果是`M`，则表示它已被选择为内核模块，以便在运行时插入内核中。
- en: '**TIP**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: You often see instructions like enable `CONFIG_BLK_DEV_INITRD` but, with so
    many menus to browse through, it can take a while to find the place where that
    configuration is set. All configuration editors have a search function. You can
    access it in `menuconfig` by pressing the forward slash key */*. In `xconfig`,
    it is in the **Edit** menu but make sure you leave off the `CONFIG_` part of the
    configuration item you are searching for.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你经常会看到类似于启用`CONFIG_BLK_DEV_INITRD`的指令，但由于有很多菜单可供浏览，找到设置该配置项的地方可能需要一段时间。所有配置编辑器都有一个搜索功能。你可以在`menuconfig`中通过按下斜杠键`*/`来访问它。在`xconfig`中，它位于**编辑**菜单下，但请确保在搜索配置项时不包括`CONFIG_`部分。
- en: With so many things to configure, it is unreasonable to start with a clean sheet
    each time you want to build a kernel, so there are a set of known working configuration
    files in `arch/$ARCH/configs`, each containing suitable configuration values for
    a single SoC or a group of SoCs.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 由于需要配置的内容太多，每次构建内核时从头开始是不现实的，因此在`arch/$ARCH/configs`中有一组已知的工作配置文件，每个文件包含适用于单个SoC或一组SoC的配置值。
- en: 'You can select one with the `make <configuration file name>` command. For example,
    to configure Linux to run on a wide range of 64-bit Arm SoCs, you would type:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`make <配置文件名称>`命令来选择一个配置。例如，要配置Linux以支持广泛的64位Arm SoC，你需要输入：
- en: '[PRE12]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is a generic kernel that runs on various boards. For a more specialized
    application, like when using a vendor-supplied kernel, the default configuration
    file is part of the board support package. You will need to find out which one
    to use before you can build the kernel.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个通用内核，适用于各种开发板。对于更专业的应用，比如使用厂商提供的内核，默认配置文件是板级支持包的一部分。在你开始构建内核之前，你需要确定使用哪个配置文件。
- en: There is another useful configuration target named `oldconfig`. You use it when
    moving a configuration to a new kernel version. This target takes an existing
    `.config` file and prompts you with questions about new configuration options.
    Copy `.config` from the old kernel to the new source directory and run the `make
    ARCH=arm64 oldconfig` command to bring it up to date.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个有用的配置目标叫做`oldconfig`。当你将配置迁移到新内核版本时使用它。该目标会采用一个现有的`.config`文件，并向你提问有关新配置选项的问题。将旧内核的`.config`文件复制到新源目录并运行`make
    ARCH=arm64 oldconfig`命令，以使其与新版本同步。
- en: The `oldconfig` target can also be used to validate a `.config` file that you
    have edited manually (ignoring the text *Automatically generated file; DO NOT
    EDIT* that occurs at the top).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`oldconfig`目标也可以用来验证你手动编辑过的`.config`文件（忽略顶部出现的文本*自动生成的文件；请勿编辑*）。'
- en: If you do make changes to the configuration, then the modified `.config` file
    becomes part of your board support package and needs to be placed under source
    code control.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对配置进行了更改，那么修改后的`.config`文件将成为你的板级支持包的一部分，并需要放置在源代码管理之下。
- en: When you start the kernel build, a header file named `include/generated/autoconf.h`
    is generated. This header file contains a `#define` for each configuration value
    so that it can be included in the kernel source.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始构建内核时，会生成一个名为`include/generated/autoconf.h`的头文件。这个头文件包含每个配置值的`#define`，以便它可以包含在内核源代码中。
- en: Now that we have settled on a kernel and learned how to configure it, we will
    identify it.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确定了内核并学会了如何配置它，我们将进行标识。
- en: Using LOCALVERSION to identify your kernel
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用LOCALVERSION来标识你的内核
- en: 'You can discover the kernel version and release that you have built using the
    `make kernelversion` and `make kernelrelease` targets:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用`make kernelversion`和`make kernelrelease`目标来发现你构建的内核版本和发布版本：
- en: '[PRE13]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is reported at runtime through the `uname` command and is also used in
    naming the directory where kernel modules are stored.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过`uname`命令在运行时报告，并且也用于命名存储内核模块的目录。
- en: 'If you change the configuration from the default, it is advisable to append
    your version information, which you can configure by setting `CONFIG_LOCALVERSION`
    using `menuconfig`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更改了默认配置，建议你附加版本信息，可以通过在`menuconfig`中设置`CONFIG_LOCALVERSION`来配置：
- en: '[PRE14]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'For example, if I wanted to mark the kernel I am building with the identifier
    `meld` and version `1.0`, then I would define the local version in `menuconfig`
    like this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我想标记我正在构建的内核，使用标识符`meld`和版本`1.0`，那么我会在`menuconfig`中这样定义本地版本：
- en: '![Figure 4.3 – Appending to kernel release version](img/B18466_04_03.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3 – 追加到内核发布版本](img/B18466_04_03.png)'
- en: Figure 4.3 – Appending to kernel release version
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – 追加到内核发布版本
- en: Exit out of `menuconfig` and choose **Yes** when asked to save your new configuration.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 退出`menuconfig`并在被询问是否保存新配置时选择**是**。
- en: 'Run `make prepare` to refresh the `Makefile` with the new `kernelrelease` version:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`make prepare`以使用新的`kernelrelease`版本刷新`Makefile`：
- en: '[PRE15]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Running `make kernelversion` produces the same output as before, but if I run
    `make kernelrelease` now, I see:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`make kernelversion`会产生与之前相同的输出，但如果我现在运行`make kernelrelease`，我会看到：
- en: '[PRE16]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: That was a pleasant detour into kernel versioning, but now let’s get back to
    the business of configuring our kernel for compilation.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个愉快的绕道，关于内核版本管理，但现在让我们回到配置内核以进行编译的正题。
- en: When to use kernel modules
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时使用内核模块
- en: I have mentioned kernel modules several times already. Desktop Linux distributions
    use them extensively so that the correct device and kernel functions can be loaded
    at runtime depending on the hardware detected and features required. Without them,
    every single driver and feature would have to be statically linked into the kernel,
    making it infeasibly large.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经多次提到内核模块了。桌面Linux发行版广泛使用它们，以便根据检测到的硬件和所需的功能在运行时加载正确的设备和内核功能。如果没有内核模块，每个驱动程序和功能都必须静态链接到内核中，这会使内核变得异常庞大。
- en: On the other hand, with embedded devices, the hardware and kernel configuration
    is usually known at the time the kernel is built; therefore, modules are not so
    useful. In fact, they cause a problem because they create a version dependency
    between the kernel and the root filesystem, which can cause boot failures if one
    is updated but not the other. Consequently, it is quite common for embedded kernels
    to be built without any modules at all.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，对于嵌入式设备，硬件和内核配置通常在构建内核时就已知，因此模块不是那么有用。事实上，它们会造成一个问题，因为它们在内核和根文件系统之间创建了版本依赖关系，如果其中一个更新而另一个没有更新，就可能导致引导失败。因此，嵌入式内核通常是构建时没有任何模块的。
- en: 'Here are a few cases where kernel modules are a good idea in embedded systems:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是内核模块在嵌入式系统中是一个好主意的几个场景：
- en: When you have proprietary modules, for the licensing reasons given in the preceding
    section.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你有专有模块时，出于前面部分提到的许可原因。
- en: To reduce boot time by deferring the loading of non-essential drivers.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过推迟加载非必要的驱动程序来减少启动时间。
- en: When there are several drivers to potentially load and it would take up too
    much memory to compile them statically. For example, you have a USB interface
    that supports a range of devices. This is essentially the same argument used in
    desktop distributions.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当有多个驱动程序可能需要加载，而静态编译它们会占用太多内存时。例如，你有一个支持多种设备的USB接口。这基本上与桌面发行版中的相同论点。
- en: Next, let’s learn how to compile a kernel image with or without kernel modules
    using `Kbuild`.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，让我们学习如何使用或不使用内核模块通过`Kbuild`编译内核映像。
- en: Compiling with Kbuild
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Kbuild进行编译
- en: 'The kernel build system (`Kbuild`) is a set of `make` scripts that take the
    configuration information from the `.config` file, work out the dependencies,
    and compile everything necessary to produce a kernel image. This kernel image
    contains all the statically linked components, an optional device tree binary,
    and any kernel modules. The dependencies are expressed within Makefiles inside
    each directory with buildable components. For instance, the following two lines
    are taken from `drivers/char/Makefile`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 内核构建系统（`Kbuild`）是一组`make`脚本，它从`.config`文件中获取配置信息，计算依赖关系，并编译所有必要的内容以生成内核映像。该内核映像包含所有静态链接的组件、可选的设备树二进制文件以及任何内核模块。依赖关系通过每个目录中的Makefile表示，包含可构建组件。例如，以下两行来自`drivers/char/Makefile`：
- en: '[PRE17]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `obj-y` rule unconditionally compiles a file to produce the target, so `mem.c`
    and `random.c` are always part of the kernel. In the second line, `ttyprintk.c`
    is dependent on a configuration parameter. If `CONFIG_TTY_PRINTK` is `y`, then
    it is compiled as a built-in. If it is `m`, then it is built as a module. If the
    parameter is undefined, then it is not compiled at all.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: For most targets, just typing `make` (with the appropriate `ARCH` and `CROSS_COMPILE`)
    will do the job, but it is instructive to take it one step at a time. See the
    last section of [*Chapter 2*](Chapter_01.xhtml#_idTextAnchor028) for the meaning
    of the `CROSS_COMPILE` `make` variable.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Finding out which kernel target to build
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To build a kernel image, you need to know what your bootloader expects. This
    is a rough guide:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '**U-Boot**: Can load a compressed `Image.gz` file for 64-bit Arm. Can also
    load a self-extracting `zImage` file for 32-bit Arm using the `bootz` command.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**x86 targets**: Require a `bzImage` file.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Most other bootloaders**: Require a `zImage` file.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of building an `Image.gz` file for 64-bit Arm:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Make sure that your `PATH` variable points to the 64-bit toolchain you downloaded
    back in [*Chapter 2*](Chapter_01.xhtml#_idTextAnchor028).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '**IMPORTANT NOTE**'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'The first time you run `make` on the kernel source tree, you may be prompted
    to include or omit various features, options, and plugins. Most of these features
    and options offer increased security so there is no harm in adding them. There
    is one notable exception. When prompted for GCC plugins, make sure to enter `n`
    for no as shown:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Otherwise, the build will fail because `make` cannot find `g++`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Remember to replace `<n>` after `make -j` with the number of CPU cores available
    on your host machine to speed up your build.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '**TIP**'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: The `-j<n>` option tells `make` how many jobs to run in parallel, which reduces
    the time it takes to build. `make -j4` runs four jobs. A rough guide is to run
    as many jobs as you have CPU cores.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: The AArch64 kernel does not currently provide a decompressor and, therefore,
    requires decompression (`gzip`, etc.) to be performed by the bootloader if a compressed
    `Image` target (e.g., `Image.gz`) is used.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of which kernel image format we target, the same two build artifacts
    (`vmlinux` and `System.map`) are first created before the bootable image is generated.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Build artifacts
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A kernel build generates two files in the top-level directory: `vmlinux` and
    `System.map`. The first, `vmlinux`, is the kernel as an ELF binary. If you have
    compiled your kernel with debug enabled (`CONFIG_DEBUG_INFO=y`), it will contain
    debug symbols that can be used with debuggers like `kgdb`. You can also use other
    ELF binary tools, such as `size` to measure the length of each segment (`text`,
    `data`, and `bss`) that comprises the `vmlinux` executable:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: A program like the kernel is divided into segments in memory. The `text` segment
    contains executable instructions (code). The `data` segment contains initialized
    global and static variables. The `bss` segment contains uninitialized global and
    static variables. The `dec` and `hex` values are the total file size in decimal
    and hexadecimal, respectively.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '`System.map` contains the symbol table in human-readable form.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'Most bootloaders cannot handle ELF code directly. There is a further stage
    of processing that takes `vmlinux` and places binaries that are suitable for the
    various bootloaders in `arch/$ARCH/boot`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '`Image`: `vmlinux` converted to raw binary format.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zImage`: For the PowerPC architecture, this is just a compressed version of
    `Image`, implying that the bootloader must do the decompression. For all other
    architectures, the compressed `Image` is piggybacked onto a stub of code that
    decompresses and relocates it.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uImage`: `zImage` plus a 64-byte U-Boot header.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While the build is running, you will see a summary of the commands being executed:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When the kernel build fails, it is sometimes useful to see the actual commands
    being executed. To do that, add `V=1` to the command line:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this section, we learned how `Kbuild` takes a precompiled `vmlinux` ELF binary
    and converts it into a bootable kernel image. Next, we will look at how we can
    compile device trees.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Compiling device trees
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The compiled `.dtb` files are generated in the `../build_arm64` output directory.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Compiling modules
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you have configured some features to be built as modules, then you can build
    them separately using the `modules` target:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Replace `<n>` after `make -j` with the number of CPU cores available on your
    host machine to speed up your build.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: The compiled modules have a `.ko` suffix and are generated in the same directory
    as the source code, meaning that they are scattered all around the kernel source
    tree. Finding them is a little tricky, but you can use the `modules_install` target
    to install them in the right place.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'The default location is `/lib/modules` in your development system, which is
    almost certainly not what you want. To install them into the staging area of your
    root filesystem, provide the path using `INSTALL_MOD_PATH`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Kernel modules are put into the directory `/lib/modules/<kernel version>` relative
    to the root of the filesystem.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning kernel sources
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are three make targets for cleaning the kernel source tree:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '**clean**: Removes object files and most intermediates.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**mrproper**: Removes all intermediate files including the `.config` file.
    Use this target to return the source tree to the state it was in immediately after
    cloning or extracting the source code. Mr. Proper is a cleaning product common
    in some parts of the world. The purpose of `make mrproper` is to give the kernel
    sources a really good scrub.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**distclean**: This is the same as `mrproper` but also deletes editor backup
    files, patch files, and other artifacts of software development.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building and booting the kernel
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building and booting Linux is highly device-dependent. In this section, I will
    show you how it works for the Raspberry Pi 4, BeaglePlay, and QEMU. For other
    target boards, you must consult the information from the vendor or from the community
    project if there is one.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Building a kernel for the Raspberry Pi 4
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even though there is support for the Raspberry Pi 4 in the mainline kernel,
    I prefer to use the Raspberry Pi Foundation’s fork of Linux ([https://github.com/raspberrypi/linux](https://github.com/raspberrypi/linux))
    for stability. 6.6 was the latest long-term kernel supported by that fork in August
    2024, so that is the version we shall build.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Since the Raspberry Pi 4 has a 64-bit quad-core Arm Cortex-A72 CPU, we will
    use the Bootlin toolchain from [*Chapter 2*](Chapter_01.xhtml#_idTextAnchor028)*,*
    to cross-compile a 64-bit kernel for it.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'Install a package we need to build the kernel:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now that you have the requisite toolchain and packages installed, clone the
    `6.6.y` branch of the kernel repo one-level deep to a directory named `linux-rpi`
    and export some prebuilt binaries to a `boot` subdirectory:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `--depth=n` argument instructs Git to fetch only the last `n` commits when
    cloning.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the newly cloned `linux-rpi` directory and build the kernel:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Replace `<n>` after `make -j` with the number of CPU cores available on your
    host machine to speed up your build.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'When the build finishes, copy the kernel image, device tree blobs, and boot
    parameters to the boot subdirectory:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The preceding commands are all found in the script `MELD/Chapter04/build-linux-rpi4.sh`.
    Note that the kernel command line written to `cmdline.txt` must be all on one
    line. Let’s break these steps down into stages:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Clone the `rpi-6.6.y` branch of the Raspberry Pi Foundation’s kernel fork into
    a `linux-rpi` directory.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clone the `1.20240529` tag of the Raspberry Pi Foundation’s firmware rep into
    a `firmware-rpi` directory.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move the `boot` subdirectory from the Raspberry Pi Foundation’s `firmware` repo
    to a `boot` directory.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the existing kernel image[s], device tree blobs, and device tree overlays
    from the `boot` directory.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the `linux-rpi` directory, build the 64-bit kernel, modules, and device
    tree for the Raspberry Pi 4.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the newly-built kernel image, device tree blobs, and device tree overlays
    from ./build_rpi/`arch/arm64/boot` to the `boot` directory.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write `config.txt` and `cmdline.txt` files out to the `boot` directory for the
    Raspberry Pi 4’s bootloader to read and pass to the kernel.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s look at the settings in `config.txt`. The `enable_uart=1` line enables
    the serial console during boot, which is disabled by default. The `arm_64bit=1`
    line instructs the Raspberry Pi 4’s bootloader to start the CPU in 64-bit mode
    and load the kernel image from a file named `kernel8.img`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at `cmdline.txt`. The `console=serial0,115200` and `console=tty1`
    kernel command-line parameters instruct the kernel to output log messages to the
    serial console as our kernel boots.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Booting the Raspberry Pi 4
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Raspberry Pi devices use a proprietary bootloader provided by Broadcom instead
    of U-Boot. Unlike previous Raspberry Pi models, the Raspberry Pi 4’s bootloader
    resides on an onboard SPI EEPROM rather than on a microSD card. We still need
    to put the kernel image and device tree blobs for the Raspberry Pi 4 on a microSD
    to boot our 64-bit kernel.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Before proceeding, you need a microSD card with a FAT32 `boot` partition large
    enough to hold the necessary kernel build artifacts. The `boot` partition needs
    to be the first partition on the microSD card. A partition size of 1 GB is sufficient.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: For guidance on connecting a USB-to-TTL serial cable to the Raspberry Pi 4,
    see [https://learn.adafruit.com/adafruits-raspberry-pi-lesson-5-using-a-console-cable/connect-the-lead](https://learn.adafruit.com/adafruits-raspberry-pi-lesson-5-using-a-console-cable/connect-the-lead).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'To prepare a microSD card with your newly built kernel image and boot it on
    your Raspberry Pi 4:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'First, navigate one level above the `boot` directory:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Next, insert the microSD card into your card reader and copy the entire contents
    of the `boot` directory to the `boot` partition.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unmount the card and insert it into the Raspberry Pi 4.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect your USB-to-TTL serial cable to the GND, TXD, and RXD pins on the 40-pin
    GPIO header.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start a terminal emulator like `gtkterm`.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, power on the Raspberry Pi 4.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should see the following output on the serial console:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The sequence will end in a kernel panic because the kernel cannot locate a root
    filesystem on the microSD card. I’ll explain what a kernel panic is later in this
    chapter.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Building a kernel for the BeaglePlay
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is the sequence of commands to build a kernel, modules, and device tree
    for the BeaglePlay:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add the 64-bit Arm toolchain to your `PATH` if you haven’t already:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, navigate back to the mainline Linux source tree:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Set the `ARCH` and `CROSS_COMPILE` environment variables for 64-bit Arm:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Run `make defconfig` to configure a kernel suitable for most 64-bit Arm SoCs:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Run `make menuconfig` to continue configuring the kernel:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Drill down into the **General architecture-dependent options** submenu.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deselect **GCC plugins** if it is set.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Back out of the **General architecture-dependent options** submenu.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drill down into the **Platform selection** submenu.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deselect support for all SoCs except for **Texas Instruments Inc. K3 multicore
    SoC architecture**.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Back out of the **Platform selection** submenu.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drill down into the **Device drivers** | **Graphics support** submenu
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deselect **Direct Rendering Manager**.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Back out of the **Graphics support** and **Device drivers** submenus.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exit out of `menuconfig` and choose **Yes** when asked to save your new configuration.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Lastly, build a kernel, modules, and device tree for the BeaglePlay:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Replace `<n>` after `make -j` with the number of CPU cores available on your
    host machine to speed up your build.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Booting the BeaglePlay
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before proceeding, you need a microSD card with U-Boot installed, as described
    in the section titled *Installing U-Boot* from [*Chapter 3*](Chapter_03.xhtml#_idTextAnchor061):'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: 'First, navigate one level above the `build_beagleplay` directory:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Next, insert the microSD card into your card reader and copy the `build_beagleplay/arch/arm64/boot/Image.gz`
    and `build_beagleplay/arch/arm64/boot/dts/ti/k3-am625-beagleplay.dtb` files to
    the FAT32 `boot` partition.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unmount the card and insert it into the BeaglePlay.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start a terminal emulator like `gtkterm` and be prepared to press the spacebar
    as soon as you see the U-Boot messages appear.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Power on the BeaglePlay while holding down the USR button and press the spacebar.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Lastly, enter the following commands at the U-Boot prompt:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You should see the following output on the serial console:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note that we set the kernel command line to `console=ttyS2`. That tells Linux
    which UART device to use for console output. Without this, we would not see any
    messages after `Starting the kernel...` and so would be unable to tell if it was
    working or not. The sequence ends in a kernel panic, just as it did for the Raspberry
    Pi 4.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Building a kernel for QEMU
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is the sequence of commands to build Linux for the `virt` generic virtual
    platform emulated by QEMU:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add the 64-bit Arm toolchain to your `PATH` if you haven’t already:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, navigate back to the mainline Linux source tree:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Set the `ARCH` and `CROSS_COMPILE` environment variables for 64-bit Arm:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Run `make defconfig` to configure a kernel suitable for most 64-bit Arm SoCs:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Run `make menuconfig` to continue configuring the kernel:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Drill down into the **Platform selection** submenu.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deselect support for all SoCs except for **ARMv8 software model (Versatile Express)**.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Back out of the **Platform selection** submenu.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **ACPI (Advanced Configuration and Power Interface) Support**.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exit out of `menuconfig` and choose **Yes** when asked to save your new configuration.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Lastly, build a kernel, modules, and device tree for QEMU:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Replace `<n>` after `make -j` with the number of CPU cores available on your
    host machine to speed up your build.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: Booting QEMU
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Assuming that you have already installed `qemu-system-aarch64`, you can launch
    QEMU from the mainline kernel source tree as follows:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As with the Raspberry Pi 4 and BeaglePlay, this will end with a kernel panic
    and the system will halt. To exit from QEMU, type *Ctrl + A* and then *x* (two
    separate keystrokes).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Observing the kernel boot process
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, you should have the kernel image files and the device tree blobs
    for the Raspberry Pi 4, BeaglePlay, and QEMU. Let’s start by looking at a kernel
    panic.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Kernel panic
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While things started off well on QEMU, they ended badly:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This is a good example of a kernel panic. A panic occurs when the kernel encounters
    an unrecoverable error. By default, it will print out a message to the console
    and then halt. You can set the panic command-line parameter to allow a few seconds
    before reboots following a panic. In this case, the unrecoverable error is no
    root filesystem, illustrating that a kernel is useless without a user space to
    control it. You can supply a user space by providing a root filesystem, either
    as a RAM disk or on a mountable mass storage device. We will talk about how to
    create a root filesystem in the next chapter, but first, I want to describe the
    sequence of events that leads up to panic.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Early user space
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To transition from kernel initialization to user space, the kernel has to mount
    a root filesystem and execute a program in that root filesystem. This can be achieved
    via a RAM disk or by mounting a real filesystem on a block device. The code for
    all of this is in `init/main.c` starting with the function `rest_init()`, which
    creates the first thread with PID 1 and runs the code in `kernel_init()`. If there
    is a RAM disk, it will try to execute the program `/init`, which will take on
    the task of setting up the user space.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: 'If the kernel fails to find and run `/init`, it tries to mount a filesystem
    by calling the function `prepare_namespace()` in `init/do_mounts.c`. This requires
    a `root=` command line to give the name of the block device to use for mounting
    usually in the form:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Or for SD cards and eMMC:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: For example, for the first partition on an SD card, that would be `root=/dev/mmcblk0p1`.
    If the mount succeeds, it will try to execute `/sbin/init`, followed by `/etc/init`,
    `/bin/init`, and then `/bin/sh`, stopping at the first one that works. The program
    can be overridden on the command line. For a RAM disk, use `rdinit=`. For a filesystem,
    use `init=`.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Kernel messages
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Kernel developers are fond of printing out useful information through the liberal
    use of `printk()` and similar functions. The messages are categorized according
    to importance, with `0` being the highest:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '| **Level** | **Value** | **Meaning** |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
- en: '| `KERN_EMERG` | `0` | The system is unusable |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
- en: '| `KERN_ALERT` | `1` | Action must be taken immediately |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
- en: '| `KERN_CRIT` | `2` | Critical conditions |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
- en: '| `KERN_ERR` | `3` | Error conditions |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
- en: '| `KERN_WARNING` | `4` | Warning conditions |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
- en: '| `KERN_NOTICE` | `5` | Normal but significant conditions |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
- en: '| `KERN_INFO` | `6` | Informational |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
- en: '| `KERN_DEBUG` | `7` | Debug-level messages |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
- en: Table 4.1 – List of kernel messages
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: They are first written to a buffer named `__log_buf`, the size of which is two
    to the power of `CONFIG_LOG_BUF_SHIFT`. For example, if `CONFIG_LOG_BUF_SHIFT`
    is `16`, then `__log_buf` is 64 KB. You can dump the entire buffer using the command
    `dmesg`.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: If the level of a message is less than the console log level, it is displayed
    on the console as well as placed in `__log_buf`. The default console log level
    is `7`. This means that messages of level `6` and lower are displayed while filtering
    out `KERN_DEBUG`, which is level `7`.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: You can change the console log level in several ways, including by using the
    kernel parameter `loglevel=<level>` or the command `dmesg -n <level>`.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: Kernel command line
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The kernel command line is a string that is passed to the kernel by the bootloader
    via the `bootargs` variable in the case of U-Boot. It can also be defined in the
    device tree or set as part of the kernel configuration in `CONFIG_CMDLINE`.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: 'We have seen some examples of the kernel command line already but there are
    many more. There is a complete list in `Documentation/admin-guide/kernel-parameters.txt`.
    Here is a smaller list of the most useful ones:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '`debug`: Sets the console log level to the highest level (`8`) to ensure that
    you see all the kernel messages on the console.'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`init=`: The `init` program to run from a mounted root filesystem. Defaults
    to `/sbin/init`.'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lpj=`: Sets `loops_per_jiffy` to a given constant. There is a description
    of the significance of this in the paragraph following this list.'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`panic=`: Behavior when the kernel panics. If it is greater than zero, it gives
    the number of seconds before rebooting; if it is zero, it waits forever (default);
    or if it is less than zero, it reboots without any delay.'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`quiet`: Sets the console log level to silent, suppressing all but emergency
    messages. Since most devices have a serial console, it takes time to output all
    those strings. Consequently, reducing the number of messages using this option
    reduces boot time.'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rdinit=`: The init program to run from a RAM disk. Defaults to `/init`.'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ro`: Mounts the root device as read-only. Has no effect on a RAM disk, which
    is always read/write.'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`root=`: Device to mount the root filesystem.'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rootdelay=`: Number of seconds to wait before trying to mount the root device.
    Defaults to zero. Useful if the device takes time to probe the hardware. Also
    see `rootwait`.'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rootfstype=`: Filesystem type for the root device. In many cases, it is auto-detected
    during mount, although it is required for jffs2 filesystems.'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rootwait`: Waits indefinitely for the root device to be detected, usually
    necessary with MMC devices.'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rw`: Mounts the root device as read-write (default).'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `lpj` parameter is often mentioned in connection with reducing the kernel
    boot time. During initialization, the kernel loops for approximately 250 ms to
    calibrate a delay loop. The value is stored in the variable `loops_per_jiffy`
    and reported like this:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: If the kernel always runs on the same hardware, it will always calculate the
    same value. You can shave 250 ms off the boot time by adding `lpj=4980736` to
    the command line.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to port Linux to a new board based on
    the BeaglePlay, our hypothetical Nova board.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: Porting Linux to a new board
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Porting Linux to a new board can be easy or difficult, depending on how similar
    your board is to an existing development board. In [*Chapter 3*](Chapter_03.xhtml#_idTextAnchor061)*,*
    we ported U-Boot to a new board named Nova based on the BeaglePlay. Very few changes
    need to be made to the kernel code, so it is very easy. If you are porting to
    completely new and innovative hardware, then there will be more to do. I am only
    going to consider the simple case. We will delve deeper into the topic of additional
    hardware peripherals throughout [*Chapter 12*](#_idTextAnchor126).
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: The organization of architecture-specific code in `arch/$ARCH` differs from
    one system to another. The x86 architecture is fairly clean because most hardware
    details are detected at runtime. The PowerPC architecture organizes SoC- and board-specific
    files into subdirectories under `platforms`. The 32-bit Arm architecture, on the
    other hand, is quite messy because there is a lot of variability between the many
    Arm-based SoCs. Platform-dependent code is put in directories named `mach-*`,
    approximately one per SoC. There are other directories named `plat-*`, which contain
    code common to several versions of an SoC.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, I am going to explain how to create a device tree
    for a new 64-bit Arm board.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: A new device tree
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing to do is create a device tree for the board and modify it to
    describe the additional or changed hardware of the Nova board. In this simple
    case, we just copy `k3-am625-beagleplay`.`dts` to `nova.dts` and change the model
    name to Nova, as shown here:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Complete all the steps from *Building a kernel for the BeaglePlay*.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following dependency to `linux-stable/arch/arm64/boot/dts/ti/Makefile`:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This entry ensures that the device tree for Nova is compiled whenever an AM62x
    target is selected.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: 'Build the Nova device tree binary like this:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We can see the effect of using the Nova device tree by booting the BeaglePlay.
    Follow the same procedure as in *Booting the BeaglePlay*. Insert the same microSD
    card into your card reader and copy the `build_beagleplay/arch/arm64/boot/dts/ti/nova.dtb`
    file to the FAT32 `boot` partition. Use the same `Image.gz` file as before but
    load `nova.dtb` in place of `k3-am625-beagleplay`.`dtb`. The following output
    is the point at which the machine model is printed out:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Now that we have a device tree specifically for the Nova board, we could modify
    it to describe the hardware differences between Nova and BeaglePlay. There are
    quite likely to be changes to the kernel configuration as well. In that case,
    you would create a custom configuration file based on a copy of `arch/arm64/configs/defconfig`.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What makes Linux so powerful is the ability to configure the kernel however
    we need to. The definitive place to get the kernel source code is [https://www.kernel.org/](https://www.kernel.org/),
    but you will probably need to get the source for a particular SoC or board from
    the vendor of that device or a third party that supports that device. The customization
    of the kernel for a particular target may consist of changes to the core kernel
    code, additional drivers for devices that are not in mainline Linux, a default
    kernel configuration file, and a device tree source file.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: Normally, you start with the default configuration for your target board and
    then tweak it by running one of the configuration tools such as `menuconfig`.
    One of the things you should consider at this point is whether the kernel features
    and drivers should be disabled, compiled as modules, or built-in. Kernel modules
    are usually no great advantage for embedded systems where the feature set and
    hardware are usually well defined. However, modules offer a way to import proprietary
    code into the kernel and reduce boot times by loading non-essential drivers after
    booting. Disabling unused kernel features and drivers altogether reduces compile
    times as well as boot times.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: Building the kernel produces a compressed kernel image file named `zImage`,
    `Image.gz`, or `bzImage`, depending on the bootloader you will be using and the
    target architecture. A kernel build will also generate any kernel modules (`.ko`
    files) that you have configured and device tree binaries (`.dtb` files) if your
    target requires them.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: Porting Linux to a new target board can be quite simple or very difficult, depending
    on how different the hardware is from that in the mainline or vendor-supplied
    kernel. If your hardware is based on a well-known reference design, then it may
    be just a question of making changes to the device tree or the platform data.
    You may well need to add device drivers, which we’ll discuss in [*Chapter 11*](Chapter_11.xhtml#_idTextAnchor373).
    However, if the hardware is radically different from a reference design, you may
    need additional core support, which is outside the scope of this book.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: The kernel is the core of a Linux-based system but it cannot work by itself.
    It requires a root filesystem that contains the user space components. The root
    filesystem can be a RAM disk or a filesystem accessed via a block device, which
    will be the subject of the next chapter. As we have seen, booting a kernel without
    a root filesystem results in kernel panic.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: Further study
  id: totrans-395
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*So You Want to Build an Embedded Linux System?* by Jay Carlson – [https://jaycarlson.net/embedded-linux/](https://jaycarlson.net/embedded-linux/)'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Embedded Linux training* – [https://bootlin.com/training/embedded-linux/](https://bootlin.com/training/embedded-linux/%0D%0A)'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Linux Weekly News* – [https://lwn.net/](https://lwn.net/)'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Raspberry Pi Forums* – [https://forums.raspberrypi.com/](https://forums.raspberrypi.com/)'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Linux Kernel Development, Third Edition*, by Robert Love'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
