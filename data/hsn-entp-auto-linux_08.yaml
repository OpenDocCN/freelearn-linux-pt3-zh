- en: Custom Builds with PXE Booting
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 PXE 启动进行自定义构建
- en: When working with physical hardware, it is not a given that you could simply
    clone a virtual machine template to the hard drive and expect it to work. It is,
    of course, entirely possible to do this with the right tools, but it is tricky,
    and there is no guarantee the resulting system will run.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用物理硬件时，并不能保证你可以简单地将虚拟机模板克隆到硬盘上并期待它能正常工作。当然，使用正确的工具，这完全是可能的，但它很棘手，而且无法保证结果系统能正常运行。
- en: For example, cloud-ready images will only have the kernel modules installed
    for the common virtualized network adapters, and so, may not run (or not have
    network connectivity) when installed on a modern piece of hardware.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，云就绪镜像只会安装常见虚拟化网络适配器的内核模块，因此，当安装在现代硬件上时，可能无法运行（或无法连接网络）。
- en: In spite of this, it is still entirely possible to perform automated, standardized
    builds on physical hardware, and this chapter provides a complete hands-on approach
    to doing so. In conjunction with the preceding chapter, by the end of this one,
    you will have practical experience of the automated build process for standardizing
    images for all your platforms, whether they are virtual, cloud-based, or physical.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，在物理硬件上仍然完全可以执行自动化、标准化的构建，本章提供了一个完整的实践方法。结合前一章，到本章结束时，你将获得标准化所有平台镜像的自动化构建过程的实际经验，无论它们是虚拟的、基于云的还是物理的。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: PXE booting basics
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PXE 启动基础
- en: Performing unattended builds
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行无人值守构建
- en: Adding custom scripts to unattended boot configurations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向无人值守启动配置中添加自定义脚本
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we are going to look at the process of PXE booting, for physical
    and virtual servers. You will require two servers on the same network, and it
    is recommended that the network be isolated, as some of the steps performed in
    this chapter could be disruptive and, even, destructive if performed in a live
    operational network.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨 PXE 启动的过程，适用于物理和虚拟服务器。你需要两台在同一网络上的服务器，建议该网络是隔离的，因为本章执行的一些步骤可能会对实际运行的网络产生干扰甚至破坏。
- en: You will need one server (or virtual machine) to be pre-installed with your
    choice of Linux distribution—in our examples, we will use Ubuntu Server 18.04
    LTS. The other server (or virtual machine) should be blank, and suitable for reinstalling.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一台预先安装了你选择的 Linux 发行版的服务器（或虚拟机）——在我们的示例中，我们将使用 Ubuntu Server 18.04 LTS。另一台服务器（或虚拟机）应该是空白的，并且适合重新安装。
- en: All example code discussed in this chapter is available from GitHub at: [https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux/tree/master/chapter06](https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux/tree/master/chapter06).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的所有示例代码都可以从 GitHub 获取，地址是：[https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux/tree/master/chapter06](https://github.com/PacktPublishing/Hands-On-Enterprise-Automation-on-Linux/tree/master/chapter06)。
- en: PXE booting basics
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PXE 启动基础
- en: Before the widespread adoption of virtualization and cloud platforms, there
    was a requirement to generate a standardized operating system build on physical
    servers, without the need to visit a data center and insert some form of installation
    media. PXE booting was created, as one of the common solutions to this requirement,
    and the name comes from the **Pre-eXecution** **Environment** (think of a tiny,
    minimal operating system) that is loaded so that an operating system installation
    can occur.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟化和云平台广泛采用之前，需要在物理服务器上生成标准化的操作系统构建，而无需访问数据中心并插入某种形式的安装介质。PXE 启动应运而生，作为满足这一需求的常见解决方案之一，其名称来源于**预执行**环境（可以理解为一个小型的、最简操作系统），它会加载，以便进行操作系统安装。
- en: 'At a high level, when we talk about the PXE build of a given server, the following
    process is occurring:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 高层次来看，当我们谈论给定服务器的 PXE 构建时，以下过程正在发生：
- en: The server must be configured to use one (or all) of its network adapters for
    network booting. This is commonly a factory default setting for most new hardware.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器必须配置为使用其一个（或所有）网络适配器进行网络启动。这通常是大多数新硬件的出厂默认设置。
- en: Upon power-up, the server brings up the network interfaces, and on each, in
    turn, attempts to contact a DHCP server.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动时，服务器启动网络接口，并依次尝试与 DHCP 服务器联系。
- en: The DHCP server sends back IP address configuration parameters, along with further
    information on where the pre-execution environment should be loaded from.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DHCP 服务器会返回 IP 地址配置参数，并提供进一步的信息，说明预执行环境应从哪里加载。
- en: The server then retrieves the pre-execution environment, typically, using the
    **Trivial File Transfer Protocol** (**TFTP**).
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器然后检索预执行环境，通常使用 **简单文件传输协议**（**TFTP**）。
- en: The PXE environment runs and looks in a known, well-defined location on the
    TFTP server for configuration data.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PXE 环境启动后，会在 TFTP 服务器的已知且定义明确的位置查找配置数据。
- en: The configuration data is loaded, and instructs the PXE environment how to proceed.
    Normally, with Linux, this involves loading a kernel and initial RAMDisk image
    from the TFTP server, which contains just enough Linux to proceed with the installation,
    and pulling further installation sources from another network service (often HTTP).
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置数据被加载，并指示 PXE 环境如何继续。通常，对于 Linux 来说，这涉及从 TFTP 服务器加载内核和初始 RAMDisk 镜像，其中包含足够的
    Linux 系统来继续安装，并从另一个网络服务（通常是 HTTP）中提取更多的安装源。
- en: Although this all sounds rather complex, it is, in fact, quite straightforward
    when broken down into a step-by-step process. As we proceed through this chapter,
    we will walk through the process of building out a PXE boot server that is capable
    of performing an unattended installation of either CentOS 7 or Ubuntu 18.04 Server.
    This will serve as a good hands-on example, and also demonstrates how we can script
    our build processes even on physical hardware, where the VM template processes
    we discussed in the last chapter are not readily available.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这一切听起来相当复杂，但实际上，当分解成一步一步的过程时，它相当简单。在本章中，我们将逐步完成构建一个 PXE 启动服务器的过程，该服务器能够执行
    CentOS 7 或 Ubuntu 18.04 Server 的无人值守安装。这将作为一个很好的动手示例，并展示我们如何在物理硬件上编写构建过程脚本，因为在上一章中讨论的虚拟机模板过程在这里并不容易实现。
- en: Before any process of PXE booting can commence, we must first set up some supporting
    services that provide the necessary network services. In the next section, we
    will look at how these may be set up and configured.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PXE 启动过程开始之前，我们必须先设置一些支持服务，提供所需的网络服务。在下一节中，我们将讨论如何设置和配置这些服务。
- en: Installing and configuring PXE-related services
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和配置 PXE 相关服务
- en: As with just about any Linux setup, the exact way to do this will depend upon
    the Linux distribution on which you are performing the installation, and also,
    the software packages you are going to use. Here, we are going to make use of
    the ISC DHCP server, the venerable TFTP daemon, and nginx. However, you could
    just as feasibly use dnsmasq and Apache.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 与几乎所有的 Linux 设置一样，执行此操作的具体方法将取决于你进行安装的 Linux 发行版，以及你将使用的软件包。在这里，我们将使用 ISC DHCP
    服务器、久负盛名的 TFTP 守护进程和 nginx。然而，你也可以同样使用 dnsmasq 和 Apache。
- en: In many enterprises, these decisions will have already been made—most will have
    some form of DHCP infrastructure already in place, and many businesses with IP
    telephony systems will have a TFTP server too. Thus, this chapter serves to provide
    an example only—real-world implementations will likely be driven by long-established
    corporate standards.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多企业中，这些决策可能已经做出——大多数企业已经有了某种形式的 DHCP 基础设施，许多使用 IP 电话系统的公司也会有 TFTP 服务器。因此，本章仅提供一个示例——实际的实施通常会遵循长期建立的公司标准。
- en: There is no safety mechanism to prevent you from running two DHCP servers on
    the same network. DHCP relies on broadcast messages, and so any DHCP clients on
    the network will receive an answer from whichever server answers them faster.
    As a result, it is entirely possible to stop a network from functioning by setting
    up a second DHCP server. If you follow the process outlined in this chapter, be
    sure you are performing it on an isolated network, suitable for testing.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 没有安全机制来防止你在同一网络上运行两个 DHCP 服务器。DHCP 依赖于广播消息，因此，网络上的任何 DHCP 客户端都将接收到响应最快的服务器的回答。因此，通过设置第二个
    DHCP 服务器，完全有可能使网络无法正常工作。如果你按照本章中概述的过程进行操作，请确保在一个隔离的网络中进行，以便进行测试。
- en: 'For this setup, we are going to assume that we have an isolated network. Our
    PXE server will have the IP address `192.168.201.1`, and the subnet mask will
    be `255.255.255.0`. These details will be important in setting up our DHCP server.
    Let''s now walk through the process of setting up your server to support PXE booting:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此设置，我们假设我们有一个隔离的网络。我们的 PXE 服务器的 IP 地址为 `192.168.201.1`，子网掩码为 `255.255.255.0`。这些细节在设置
    DHCP 服务器时非常重要。现在，让我们一步步完成服务器配置，以支持 PXE 启动：
- en: 'We need to install the following list of required packages:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要安装以下所需的软件包：
- en: DHCP server
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: DHCP 服务器
- en: TFTP server
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: TFTP 服务器
- en: Web server
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web 服务器
- en: 'Assuming an Ubuntu 18.04 host, as discussed earlier, run this command to install
    the packages we will need for this part of the chapter:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们使用的是 Ubuntu 18.04 主机，如前所述，运行以下命令以安装本章所需的包：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'With these installed, the next step is to configure our DHCP server, with which the
    preceding package is configured through the `/etc/dhcp/dhcpd.conf` file. The configuration
    file shown in the following code block is a good, if basic, example for our PXE
    boot network, though naturally, you''ll need to edit the subnet definition to
    match your own test network. The first part of the file contains some important
    global directives and the subnet definition for the network:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装这些后，下一步是配置我们的 DHCP 服务器，通过 `/etc/dhcp/dhcpd.conf` 文件配置前述的软件包。下面代码块中的配置文件是一个适合我们
    PXE 启动网络的良好（虽然基础）示例，当然，你需要编辑子网定义以匹配你自己的测试网络。文件的第一部分包含一些重要的全局指令和网络的子网定义：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The next part of the file then contains configuration directives, to ensure
    that we load the correct pre-execution binary, depending on the type of system
    being used. It is common at the time of writing to find a mix of both BIOS- and
    UEFI-based systems, so the following configuration is important:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的下一部分包含配置指令，确保我们根据使用的系统类型加载正确的预执行二进制文件。编写时，常见的是同时存在 BIOS 和 UEFI 基于的系统，因此以下配置非常重要：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Most of this is fairly self-explanatory if you have worked with DHCP servers
    before. However, the block of text headed `class "pxeclients"` deserves a special
    mention. Some years ago, server hardware relied on the BIOS to boot, and thus
    PXE boot configurations were simple, as there was only one pre-boot environment
    that you needed to load. Most new server hardware now is configured with firmware
    that can operate in either *Legacy BIOS* or *UEFI modes*, and most default to
    UEFI, unless configured otherwise. The pre-execution binary is different, depending
    on the type of firmware in use, and hence, the `if` statements in this block make
    use of a DHCP `option`, returned to the server when the client makes its DHCP
    request.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前使用过 DHCP 服务器，大部分内容是自解释的。然而，标题为 `class "pxeclients"` 的文本块值得特别提及。几年前，服务器硬件依赖于
    BIOS 启动，因此 PXE 启动配置非常简单，因为只需要加载一个预启动环境。现在，大多数新的服务器硬件配置了可以在 *Legacy BIOS* 或 *UEFI
    模式* 中运行的固件，并且大多数默认启用 UEFI，除非另行配置。预执行二进制文件是不同的，具体取决于使用的固件类型，因此，这个块中的 `if` 语句利用了
    DHCP `option`，当客户端发出 DHCP 请求时返回给服务器。
- en: 'With this configuration in place, enable the DHCP server, and restart it, as
    follows:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置完成后，启用 DHCP 服务器，并重新启动它，步骤如下：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The default configuration for the TFTP server will suffice for this example,
    so, let''s also enable this and ensure it is running as follows:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 TFTP 服务器，默认配置足以满足本示例的需求，因此，让我们启用此功能并确保它按如下方式运行：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, we''ll use the default configuration of nginx, and serve all the files
    we need from `/var/www/html`—obviously, in an enterprise environment, you would
    want to do something a bit more advanced, but for the following practical example
    here, this will suffice:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将使用 nginx 的默认配置，并从 `/var/www/html` 提供我们需要的所有文件——显然，在企业环境中，你可能希望做一些更高级的配置，但在下面的实际示例中，这样的配置已经足够：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: That's our server infrastructure configured, but one last task remains. We need
    the pre-execution environment binaries for our TFTP server, to send to the clients.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的服务器基础设施配置完成，但还有一个最后的任务。我们需要为 TFTP 服务器准备预执行环境二进制文件，以发送给客户端。
- en: 'Although these are readily available for most Linux distributions (and Ubuntu
    18.04 is no exception), these packages are often quite old (the last stable release
    of PXELINUX was in 2014), and I have run into known bugs with these, especially
    when working with UEFI hardware. Although you are welcome to try newer snapshots,
    the author has achieved the most success with the release tagged 6.04-pre2, and
    so, we will explain how to build this and copy the files into the correct places
    for our TFTP server, as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些工具对于大多数 Linux 发行版来说都很容易获得（Ubuntu 18.04 也不例外），但这些软件包通常都比较旧（PXELINUX 的最后一个稳定版本发布于
    2014 年），并且我遇到过一些已知的 bug，特别是在处理 UEFI 硬件时。虽然您可以尝试较新的快照版本，但作者在使用版本标签为 6.04-pre2 的版本时取得了最好的成功，因此我们将解释如何构建此版本并将文件复制到我们
    TFTP 服务器的正确位置，如下所示：
- en: 'First of all, download and unpack the required release of SYSLINUX (which contains
    the PXELINUX code) by entering the following code:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，下载并解压所需版本的 SYSLINUX（它包含 PXELINUX 代码），输入以下代码：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we need to install a few build tools to successfully compile the code,
    as follows:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要安装一些构建工具，以便成功编译代码，如下所示：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, we''ll make sure the build directory is clean, and then build the
    code, as follows:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将确保构建目录是干净的，然后构建代码，如下所示：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When the build is complete, the final step is to copy the files into the correct
    places. Recalling our DHCP server configuration from earlier, we know that we
    need to separate out the files related to Legacy BIOS boots, and those released
    to newer UEFI boots. Here, we will step through the process of setting up your
    server for both BIOS and UEFI network boots:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建完成后，最后一步是将文件复制到正确的位置。回想我们之前的 DHCP 服务器配置，我们知道需要将与传统 BIOS 启动相关的文件与新发布的 UEFI
    启动文件分开。在这里，我们将逐步介绍如何为 BIOS 和 UEFI 网络启动设置您的服务器：
- en: 'The default root directory for the TFTP server is `/var/lib/tftpboot` on Ubuntu
    18.04\. Under this path, we will create the two directories referenced by the
    DHCP server configuration, as follows:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Ubuntu 18.04 上，TFTP 服务器的默认根目录是 `/var/lib/tftpboot`。在此路径下，我们将创建 DHCP 服务器配置中提到的两个目录，如下所示：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, we will run this set of commands, to gather up and copy all BIOS-related
    boot files into the newly created `BIOS` directory:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将运行一组命令，将所有与 BIOS 相关的启动文件收集并复制到新创建的 `BIOS` 目录中：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We then repeat this step, except this time, we specify the UEFI-related boot
    files, as follows:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们重复此步骤，不过这次我们指定与 UEFI 相关的启动文件，如下所示：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With those steps completed, we now have a completed, functional PXE server.
    We have not downloaded any operating system images yet, so the boot process wouldn't
    proceed very far, but if you were to execute a test at this point, your server
    firmware should report that it has obtained an IP address from the DHCP server,
    and should present you with some boot-related messages. However, we will build
    this out further before going into any detailed testing in this book, and, in
    the next section, we will look at how to obtain the correct network installation
    images for your chosen Linux distribution.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些步骤后，我们现在已经有了一个完整的、功能正常的 PXE 服务器。我们还没有下载任何操作系统镜像，因此启动过程不会进行得很远，但如果此时进行测试，您的服务器固件应该报告它已从
    DHCP 服务器获取了 IP 地址，并应显示一些与启动相关的消息。然而，在本书中我们将在进一步测试之前继续完善这个过程，在下一节中，我们将介绍如何为您选择的
    Linux 发行版获取正确的网络安装镜像。
- en: Obtaining network installation images
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取网络安装镜像
- en: The next step in our PXE boot setup process is to build out the images required. Luckily,
    obtaining the boot images is quite easy—the kernel and packages are normally contained
    on the DVD ISO images for your chosen Linux distribution. Obviously, this can
    vary from distribution to distribution, so you will need to check this. In this
    chapter, we will show examples for Ubuntu Server and CentOS 7—these principles
    could also be applied to many Debian derivatives, Fedora, and Red Hat Enterprise
    Linux.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 PXE 启动设置过程中，下一步是构建所需的镜像。幸运的是，获取启动镜像非常简单——内核和软件包通常包含在您选择的 Linux 发行版的 DVD
    ISO 镜像中。显然，这可能因发行版而异，因此您需要检查这一点。在本章中，我们将展示 Ubuntu Server 和 CentOS 7 的示例——这些原则也适用于许多
    Debian 派生版、Fedora 和 Red Hat 企业 Linux。
- en: The installation images required for network booting, along with the required
    installation packages, are normally found on the full DVD images—*live* images
    are often not sufficient because they lack either a sufficiently complete set
    of packages to perform the installation, or the network boot-capable kernel is
    missing.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的网络启动安装镜像以及所需的安装包通常可以在完整的 DVD 镜像中找到——*live* 镜像通常不够，因为它们缺少足够完整的安装包，无法完成安装，或者缺少支持网络启动的内核。
- en: 'Let''s make a start with the CentOS 7 image, as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 CentOS 7 镜像开始，如下所示：
- en: 'First of all, download the latest DVD image from your nearest mirror—for example,
    the one shown in the following code block:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，从最近的镜像站点下载最新的 DVD 镜像——例如，下面代码块中显示的镜像：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once downloaded, mount the ISO image to a suitable location so that the files
    can be copied from it, as follows:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载后，将 ISO 镜像挂载到合适的位置，以便可以从中复制文件，如下所示：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, the network boot-capable kernel and initial RAMDisk image should be copied
    to a location of our choosing, under the TFTP server root.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，支持网络启动的内核和初始 RAMDisk 镜像应该被复制到我们选择的位置，位于 TFTP 服务器根目录下。
- en: Note that in the following example, we are only doing this for UEFI booting.
    To set up for **Legacy BIOS booting**, follow exactly the same process, but place
    all files to be served by TFTP in `/var/lib/tftpboot/BIOS` instead. This applies
    throughout the rest of this chapter.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在以下示例中，我们仅为 UEFI 启动进行此操作。要设置 **传统 BIOS 启动**，请完全按照相同的过程进行，但将所有由 TFTP 提供的文件放置在
    `/var/lib/tftpboot/BIOS` 中。本章其余部分也适用这一点。
- en: 'The commands to achieve this on our test system are as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试系统上实现这一点的命令如下：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, we need the web server we installed earlier to serve out the files
    for the installer—once the kernel and initial RAMDisk environment load, the rest
    of the environment will be served over HTTP, which is better suited to large data
    transfers. Again, we''ll create a suitable subdirectory for our CentOS content,
    as follows:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要之前安装的 web 服务器来提供安装程序所需的文件——一旦内核和初始 RAMDisk 环境加载，剩余的环境将通过 HTTP 提供，因为 HTTP
    更适合进行大数据传输。我们将再次为 CentOS 内容创建一个合适的子目录，如下所示：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'That''s all there is to it! Once these steps have been completed, we''ll repeat
    this process for our Ubuntu 18.04 Server boot image, as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！一旦这些步骤完成，我们将对 Ubuntu 18.04 Server 启动镜像重复此过程，如下所示：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With these steps complete, we just have one more configuration stage to go before
    we can perform a network boot of our chosen operating system.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些步骤后，我们只剩下一个配置阶段，然后就可以进行我们选择的操作系统的网络启动了。
- en: The process is almost identical—the only difference is that the NetBoot-capable
    kernel and RAMDisk were sourced from a different directory on the ISO image.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程几乎是相同的——唯一的区别是，支持网络启动的内核和 RAMDisk 是从 ISO 镜像中的另一个目录中获取的。
- en: In the next section, we will configure the PXE boot server we have built so
    far, so as to boot from these installation images.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将配置到目前为止构建的 PXE 启动服务器，以便从这些安装镜像启动。
- en: Performing your first network boot
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行第一次网络启动
- en: Thus far, we have configured our server to give our clients an IP address on
    boot, and have even built two installation trees, such that we can install either
    CentOS 7 or Ubuntu 18.04 Server, without the need for any physical media. However,
    when our target machine boots over the network, how does it know what to boot?
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经配置了服务器，在启动时为客户端分配 IP 地址，并且还构建了两个安装树，这样我们就可以安装 CentOS 7 或 Ubuntu 18.04
    Server，而无需任何物理介质。然而，当目标机器通过网络启动时，它是如何知道该启动什么的呢？
- en: The answer to this comes in the form of the PXELINUX configuration. This is
    very similar in nature to the **GRand Unified Bootloader** (**GRUB**) configuration
    that most Linux installations use, to define their boot options and parameters
    when they boot from disk. Using the installation we have built so far, these configuration
    files are expected to be in `/var/lib/tftpboot/EFIx64/pxelinux.cfg` (or `/var/lib/tftpboot/BIOS/pxelinux.cfg` for
    Legacy BIOS machines).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这一问题的方式是 PXELINUX 配置。这与大多数 Linux 安装使用的 **GRand Unified Bootloader**（**GRUB**）配置非常相似，用于定义从磁盘启动时的启动选项和参数。根据我们迄今为止构建的安装，这些配置文件应位于
    `/var/lib/tftpboot/EFIx64/pxelinux.cfg`（或者对于传统 BIOS 机器，则位于 `/var/lib/tftpboot/BIOS/pxelinux.cfg`）。
- en: Now, a word on file naming. You might want all devices that boot off a network
    interface to perform a network boot. However, consider a server where a valid
    Linux installation is on the local disk, but through some error (perhaps misconfiguration
    of the boot order in the firmware, or a missing boot loader), it boots from the
    network interface instead of the local disk. If you have a full, unattended installation
    configured on your PXE server, this would wipe the local disks, with potentially
    disastrous consequences.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，来谈谈文件命名。你可能希望所有通过网络接口启动的设备都执行网络启动。然而，想象一个服务器，它的本地磁盘上有一个有效的 Linux 安装，但由于某些错误（比如固件中的启动顺序配置错误，或者缺失的引导加载程序），它从网络接口启动，而不是从本地磁盘启动。如果你在
    PXE 服务器上配置了一个完整的无人值守安装，这将会清除本地磁盘，可能导致灾难性的后果。
- en: If you want all servers to perform a network boot regardless, you create a special
    configuration file, called `default`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望所有服务器都执行网络启动，不管其他情况，你可以创建一个特殊的配置文件，名为`default`。
- en: However, if you want to be more targeted, you instead create a configuration
    file with the name based on the MAC address. Suppose we have a server with the
    MAC address `DE:AD:BE:EF:01:23`, and our DHCP server is going to assign it the
    IP address `192.168.10.101/24` (this would most likely be through a static DHCP
    mapping so that we can ensure that this server always gets this IP address). When
    this server network boots using UEFI, it will look initially for `/var/lib/tftpboot/EFIx64/pxelinux.cfg/01-de-ad-be-ef-01-23`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你想更加有针对性地配置，可以根据 MAC 地址创建一个配置文件。假设我们有一台 MAC 地址为`DE:AD:BE:EF:01:23`的服务器，且我们的
    DHCP 服务器将为它分配 IP 地址`192.168.10.101/24`（这很可能是通过静态 DHCP 映射来确保该服务器始终获得这个 IP 地址）。当这台服务器使用
    UEFI 网络启动时，它会首先查找`/var/lib/tftpboot/EFIx64/pxelinux.cfg/01-de-ad-be-ef-01-23`。
- en: If this file is not present, it will look for a file named after the hex-encoded
    IP address. If this does not exist, it then takes one digit off the hexadecimal
    IP address at a time, until it finds a matching file. In this manner, our server
    would look for `/var/lib/tftpboot/EFIx64/pxelinux.cfg/C0A80A65`. If it doesn't
    find it, it cycles through the ever-shortening IP address representations, until
    it runs out of options. If no appropriately named file is found, it finally reverts
    to the `default` file, and if that file isn't present, a boot failure is reported
    by the client.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个文件不存在，它将查找一个以十六进制编码的 IP 地址命名的文件。如果该文件也不存在，它会依次去掉十六进制 IP 地址的每一位，直到找到一个匹配的文件。通过这种方式，我们的服务器会查找`/var/lib/tftpboot/EFIx64/pxelinux.cfg/C0A80A65`。如果没有找到，它会依次循环尝试更短的
    IP 地址表示方式，直到没有更多选项。如果最终找不到合适命名的文件，它会回退到`default`文件，如果这个文件也不存在，客户端将报告启动失败。
- en: 'Thus, the full search sequence for configuration files is as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，配置文件的完整搜索顺序如下：
- en: '`/var/lib/tftpboot/EFIx64/pxelinux.cfg/01-de-ad-be-ef-01-23`'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`/var/lib/tftpboot/EFIx64/pxelinux.cfg/01-de-ad-be-ef-01-23`'
- en: '`/var/lib/tftpboot/EFIx64/pxelinux.cfg/C0A80A65`'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`/var/lib/tftpboot/EFIx64/pxelinux.cfg/C0A80A65`'
- en: '`/var/lib/tftpboot/EFIx64/pxelinux.cfg/C0A80A6`'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`/var/lib/tftpboot/EFIx64/pxelinux.cfg/C0A80A6`'
- en: '`/var/lib/tftpboot/EFIx64/pxelinux.cfg/C0A80A`'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`/var/lib/tftpboot/EFIx64/pxelinux.cfg/C0A80A`'
- en: '`/var/lib/tftpboot/EFIx64/pxelinux.cfg/C0A80`'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`/var/lib/tftpboot/EFIx64/pxelinux.cfg/C0A80`'
- en: '`/var/lib/tftpboot/EFIx64/pxelinux.cfg/C0A8`'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`/var/lib/tftpboot/EFIx64/pxelinux.cfg/C0A8`'
- en: '`/var/lib/tftpboot/EFIx64/pxelinux.cfg/C0A`'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`/var/lib/tftpboot/EFIx64/pxelinux.cfg/C0A`'
- en: '`/var/lib/tftpboot/EFIx64/pxelinux.cfg/C0`'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`/var/lib/tftpboot/EFIx64/pxelinux.cfg/C0`'
- en: '`/var/lib/tftpboot/EFIx64/pxelinux.cfg/C`'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`/var/lib/tftpboot/EFIx64/pxelinux.cfg/C`'
- en: '`/var/lib/tftpboot/EFIx64/pxelinux.cfg/default`'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`/var/lib/tftpboot/EFIx64/pxelinux.cfg/default`'
- en: The idea of shortening the IP address filename is to enable you to create a
    subnet-wide configuration—for example, if all machines in the `192.168.10.0/24`
    subnet needed the same boot configuration, you could create a single file called `/var/lib/tftpboot/EFIx64/pxelinux.cfg/C0A80A`.
    Pay special attention to the case of the letters in the filename—the MAC address-based
    filename requires lowercase letters, while the IP address requires uppercase letters.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 缩短 IP 地址文件名的目的是让你能够创建一个适用于整个子网的配置——例如，如果`192.168.10.0/24`子网中的所有机器都需要相同的启动配置，你可以创建一个名为`/var/lib/tftpboot/EFIx64/pxelinux.cfg/C0A80A`的文件。特别注意文件名中字母的大小写——基于
    MAC 地址的文件名需要使用小写字母，而 IP 地址则需要使用大写字母。
- en: 'There are numerous permutations of configuration for the contents of this configuration
    file, and looking into all the possibilities for this is left as an exercise for
    the reader—there is ample documentation, and examples, available for PXELINUX.
    However, with the specific aim of booting our network install images, let''s consider
    the following file. Initially, we define the header for the menu, with a simple
    title and timeout, as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配置文件的内容有许多配置组合，深入研究所有可能的配置将留给读者作为练习——PXELINUX 有充足的文档和示例可供参考。然而，考虑到我们特别要启动网络安装镜像，让我们来看以下文件。首先，我们定义菜单的头部，简单的标题和超时时间，如下所示：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We then proceed to define the entries for our two operating system install
    images that we have built, as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义了我们所构建的两个操作系统安装镜像的条目，如下所示：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As with other examples in this book, these are real-world, tested examples that
    will work in their own right. However, they should be customized to your own requirements,
    and you should endeavor to read and understand the code before applying it in
    a production environment.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与本书中的其他示例一样，这些是真实的、经过测试的示例，能够独立工作。然而，它们应该根据你的需求进行定制，并且你应该在生产环境中应用之前，阅读并理解这些代码。
- en: In these preceding examples, `192.168.201.1` is the IP address of my PXE server
    in my test setup. Be sure to replace this wherever you see it with the IP address
    of your PXE server.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`192.168.201.1` 是我在测试环境中 PXE 服务器的 IP 地址。确保将它替换为你 PXE 服务器的 IP 地址。
- en: This is, in fact, a very simple example—here, we are defining a simple text
    mode menu with two entries, one for each of our operating systems. Each menu entry
    has a `label`, a title that appears in the menu, and then, a `kernel` and `append` line.
    The `kernel` line tells the client from where to source the kernel on our TFTP
    server, while the `append` line is used to specify the path of the RAMDisk image
    and all supplementary boot parameters.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这是一个非常简单的示例——在这里，我们定义了一个简单的文本模式菜单，包含两个条目，每个条目对应一个操作系统。每个菜单条目都有一个 `label`，即菜单中显示的标题，然后是
    `kernel` 和 `append` 行。`kernel` 行告诉客户端从哪里获取 TFTP 服务器上的内核，而 `append` 行用于指定 RAMDisk
    映像的路径以及所有附加的启动参数。
- en: 'These boot parameters, as you can see, are greatly different for different
    Linux distributions, as are the capabilities of the installers. For example, the
    CentOS 7 installer is graphical (though a text mode option is available) and supports
    a VNC server, which we are configuring in the first menu item, enabling a remote
    installation using a VNC console, using the parameters `inst.vnc` and `inst.vncpassword=password`.
    The other parameters used are the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这些启动参数对于不同的 Linux 发行版差异很大，安装程序的功能也各不相同。例如，CentOS 7 安装程序是图形化的（虽然也有文本模式选项），并且支持
    VNC 服务器，我们在第一个菜单项中配置了它，启用了使用 VNC 控制台的远程安装，使用了 `inst.vnc` 和 `inst.vncpassword=password`
    参数。其他使用的参数如下：
- en: '`method=http://192.168.201.1/centos7`: Sets the address from where our CentOS
    7 repo will be served'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`method=http://192.168.201.1/centos7`：设置我们 CentOS 7 仓库的地址'
- en: '`devfs=nomount`: Tells the kernel not to mount the devfs filesystem'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`devfs=nomount`：告诉内核不要挂载 devfs 文件系统'
- en: '`ip=dhcp`: Tells the pre-boot environment to obtain an IP address using DHCP,
    to then be able to reach the HTTP server'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ip=dhcp`：告诉预启动环境通过 DHCP 获取 IP 地址，以便能够访问 HTTP 服务器'
- en: 'The Ubuntu installer is, by contrast, normally run in text mode, and so does
    not support a VNC server, so a different remote access technology would be required
    to perform an interactive installation, such as **Serial-Over-LAN** (**SOL**).
    Nonetheless, this menu file would be sufficient for us to perform an interactive
    installation of either OS as we choose, and is provided as a template for the
    reader to build on and develop, as they see fit. The parameters in use are the
    following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，Ubuntu 安装程序通常以文本模式运行，因此不支持 VNC 服务器，因此需要不同的远程访问技术来执行交互式安装，例如 **Serial-Over-LAN**（**SOL**）。不过，这个菜单文件足够我们根据需要进行交互式安装，无论是选择哪个操作系统，并且作为模板提供给读者以供扩展和开发。使用的参数如下：
- en: '`vga=normal`: Tells the installer to use the standard VGA mode'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vga=normal`：告诉安装程序使用标准 VGA 模式'
- en: '`locale=en_US.UTF-8`: Sets the locale—adjust this to suit your environment'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`locale=en_US.UTF-8`：设置区域设置——根据你的环境调整此项'
- en: '`mirror/country=manual`: Tells the installer we are manually defining the repository
    mirror'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mirror/country=manual`：告诉安装程序我们正在手动定义仓库镜像'
- en: '`mirror/http/hostname=192.168.201.1`: Sets the hostname of the repository mirror
    we created previously'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mirror/http/hostname=192.168.201.1`：设置我们之前创建的仓库镜像的主机名'
- en: '`mirror/http/directory=/ubuntu1804`: Sets the path on the repository mirror
    host that is serving the repository content'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mirror/http/directory=/ubuntu1804`：设置仓库镜像主机上提供仓库内容的路径'
- en: '`mirror/http/proxy=""`: Tells the installer we are not using a proxy'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mirror/http/proxy=""`：告诉安装程序我们没有使用代理'
- en: '`live-installer/net-image=http://192.168.201.1/ubuntu1804/install/filesystem.squashfs` : The
    URL from where the installer disk image can be downloaded'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`live-installer/net-image=http://192.168.201.1/ubuntu1804/install/filesystem.squashfs`：安装程序磁盘映像可以下载的
    URL'
- en: Of course, in an unattended boot scenario, you would not want to present the
    server with a choice of operating system—you simply want it to boot the one you
    want to install. In this instance, simply remove the menu items that are not needed.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在无人值守启动的情况下，您不会希望服务器提供操作系统选择——您只希望它启动您要安装的操作系统。在这种情况下，只需删除不需要的菜单项。
- en: 'Let''s take a look at this in action. Upon a successful network boot of a test
    machine, we should be presented with the following menu, as defined previously:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实际操作。在成功的网络启动测试机器后，我们应该会看到之前定义的菜单：
- en: '![](img/ac03916d-46c7-4467-94e3-b09a390877f1.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ac03916d-46c7-4467-94e3-b09a390877f1.png)'
- en: 'If we select the CentOS image as our boot target, you will see the kernel and
    base system load, and then ultimately, a screen asking you to connect to the installer
    using a VNC client, as shown in the following screenshot:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们选择 CentOS 镜像作为启动目标，您将看到内核和基础系统加载，然后最终会出现一个屏幕，提示您使用 VNC 客户端连接到安装程序，如下图所示：
- en: '![](img/4a2416cf-e10d-4b1e-a7e2-2aa8ed6550a7.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4a2416cf-e10d-4b1e-a7e2-2aa8ed6550a7.png)'
- en: 'Connecting with a VNC viewer, as instructed, yields the familiar interactive
    CentOS 7 graphical installer, as shown in the following screenshot:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照说明连接到 VNC 查看器，显示出熟悉的交互式 CentOS 7 图形安装程序，如下图所示：
- en: '![](img/724b5e2a-7b6a-4709-b383-1d80a753e19d.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/724b5e2a-7b6a-4709-b383-1d80a753e19d.png)'
- en: 'Thus, a complete remote installation is possible, without the need to visit
    the location of the server, or connect a keyboard and mouse! The same is almost
    true if we boot our Ubuntu Server image, only this time, the console is on the
    host screen, rather than available over VNC, as can be seen in the following screenshot:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，完全远程安装是可能的，无需访问服务器位置，也无需连接键盘和鼠标！如果我们启动我们的 Ubuntu 服务器镜像，情况几乎也是一样的，只不过这次，控制台显示在主机屏幕上，而不是通过
    VNC 提供，如下图所示：
- en: '![](img/c07c98c2-85f3-41b2-af42-e0ffbad7f5e3.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c07c98c2-85f3-41b2-af42-e0ffbad7f5e3.png)'
- en: This lends itself well to either redirecting the console over an SOL implementation
    or a remove KVM option. Neither of these is particularly convenient, especially
    as the goal of this book is automation!
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常适合通过 SOL 实现或远程 KVM 选项来重定向控制台。这两者都不是特别方便，特别是本书的目标是自动化！
- en: Thus, in the next section, we will look at performing automated installations,
    using the concept of *unattended builds*—that is to say, builds where no human
    needs to intervene for the installation to take place.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在下一节中，我们将讨论执行自动化安装，使用*无人值守构建*的概念——也就是说，构建过程中不需要人工干预。
- en: Performing unattended builds
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行无人值守构建
- en: The ultimate goal of this process is to have a server boot over the network
    and configure itself completely, rather than having to have someone interact with
    it. Although this is not a process controlled by Ansible, it is still a vital
    component in our **Standard Operating Environment** (**SOE**) architecture to
    ensure consistency of builds, and that build standards can be well documented
    and version controlled.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程的最终目标是使服务器能够通过网络启动并完全配置，而无需人工干预。虽然这不是由 Ansible 控制的过程，但它仍然是我们**标准操作环境**（**SOE**）架构中的一个重要组件，以确保构建的一致性，并且构建标准可以很好地文档化和版本控制。
- en: Fortunately, both CentOS (Red Hat-based) and Ubuntu (Debian-based) installers
    provide the capability for unattended installs to be completed in a programmatic
    manner. Sadly, there is no common standard for this process and, as you will see
    in this section, the language used for this process is wholly different between
    the two Linux types we are discussing here. Nevertheless, by covering off these
    two technologies, we are giving a good grounding that will enable you to perform
    remote, unattended installations on a wide variety of Linux systems.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，CentOS（基于Red Hat）和Ubuntu（基于Debian）的安装程序都提供了以编程方式完成无人值守安装的能力。遗憾的是，这个过程没有统一的标准，正如你在本节中看到的，两个我们讨论的Linux类型在这一过程中的语言完全不同。然而，通过覆盖这两种技术，我们提供了一个良好的基础，使你能够在各种Linux系统上执行远程、无人值守的安装。
- en: Note that the examples in this chapter are complete and working, and thus are
    provided as hands-on examples—however, they are really just scratching the surface in
    terms of what these unattended installation technologies can do. It is left as
    an exercise for you to expand on these examples, and build them out to your own
    requirements.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，本章中的示例是完整并且可用的，因此它们作为实际操作的示例提供——然而，它们实际上仅仅触及了这些无人值守安装技术的皮毛。如何扩展这些示例并根据自己的需求构建它们，将留给你作为练习。
- en: Let's get started by looking in the next section at how we perform unattended
    builds on Red Hat-based platforms such as CentOS using kickstart files.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧，下一节将介绍如何在基于Red Hat的平台（如CentOS）上使用kickstart文件执行无人值守构建。
- en: Performing unattended builds with kickstart files
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用kickstart文件执行无人值守构建
- en: The Red Hat installer, Anaconda, uses a scripting language called **kickstart**
    to define unattended builds. This is well documented, and there are many examples
    available on the internet for you to work from—in fact, when you manually install
    a Red Hat derivative such as CentOS 7, you will find a kickstart file in `/root/anaconda-ks.cfg`, which
    could be employed to automate future builds! In the following, we will build up
    our own simple kickstart file, based loosely on a minimal install of CentOS 7
    from the interactive installer.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Red Hat安装程序Anaconda使用一种名为**kickstart**的脚本语言来定义无人值守构建。这有很多文档，并且在互联网上有许多示例可以供你参考——事实上，当你手动安装一个Red
    Hat衍生版本如CentOS 7时，你会在`/root/anaconda-ks.cfg`中找到一个kickstart文件，这个文件可以用来自动化未来的构建！接下来，我们将构建一个简单的kickstart文件，基本上是基于CentOS
    7交互式安装程序的最小安装。
- en: 'Let''s start building up our example kickstart file for use in this chapter.
    Consider this block of code:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们开始构建本章中使用的示例kickstart文件。考虑以下这段代码：
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Much of the kickstart file is very readable—in the preceding code block, you
    can see the following: we are defining `sha512` for the password hashing algorithm;
    our repository server is available at `http://192.168.201.1/centos7/`; we are
    performing a `graphical` install, using only `/dev/sda`, and with some `GB` specific
    locale settings. We also tell the installer to `reboot` automatically once the
    install completes successfully.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分kickstart文件是非常易读的——在上面的代码块中，你可以看到以下内容：我们为密码哈希算法定义了`sha512`；我们的仓库服务器可通过`http://192.168.201.1/centos7/`访问；我们正在执行`图形化`安装，仅使用`/dev/sda`，并且设置了某些`GB`特定的地区设置。我们还告诉安装程序在安装成功完成后`自动重启`。
- en: 'We then build on this by setting up the network (note that you must know the
    network device name in advance of creating this file, so you might find it useful
    to boot into a live environment to check this first) by running the following
    code:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们在此基础上通过设置网络来继续（请注意，你必须在创建此文件之前知道网络设备名称，因此你可能会觉得启动到实时环境中先检查一下设备名称是有用的），通过运行以下代码：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This sets the hostname of our newly built server to `ksautomation`, and enables
    IPv6 and IPv4 DHCP on the network device called `ens33`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把我们新建服务器的主机名设置为`ksautomation`，并启用名为`ens33`的网络设备上的IPv6和IPv4 DHCP。
- en: 'We then define the root account password, and—optionally—any additional accounts
    we want to be added as part of the build, by running the following code:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们定义根账户密码，并且—可选地—通过运行以下代码定义我们希望作为构建的一部分添加的任何额外账户：
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Note that the password hashes must be used in this file—there are many ways
    to generate these. I used the following snippet of Python to generate unique hashes
    for the `password` string (you would obviously want to choose a more secure password!):'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个文件中必须使用密码哈希值——有许多方法可以生成这些哈希值。我使用了以下Python代码片段来为`password`字符串生成唯一的哈希值（显然你应该选择更安全的密码！）：
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Running the preceding three lines of code in the shell of any Linux server that
    has Python installed will generate the password hash needed for your kickstart
    file, which you can copy and paste into your installation.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何安装了 Python 的 Linux 服务器的 shell 中运行上述三行代码，将生成你需要的密码哈希值，可以将其复制并粘贴到你的安装中。
- en: The preceding code is used only to generate the password hashes—do not include
    it in your kickstart file!
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码仅用于生成密码哈希值——不要将其包含在你的 kickstart 文件中！
- en: Finally, we set the time zone appropriately, and enable the `chrony` time synchronization
    service. We initialize the disk label on our chosen boot device, `sda`, and make
    use of Anaconda's automated partitioning (designated by the `autopart` directive),
    to set up the disk.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们设置合适的时区，并启用 `chrony` 时间同步服务。我们初始化选定启动设备 `sda` 的磁盘标签，并使用 Anaconda 的自动分区（由
    `autopart` 指令指定）来设置磁盘。
- en: 'Note that `clearpart --none` does not actually clear the partition table—and
    if you run through this example with the kickstart file as defined here, the installation
    will only complete if there is space on the target disk to install CentOS 7\.
    To have the kickstart file wipe the target disk and perform a fresh installation
    of CentOS 7 (which may be desirable to avoid having to manually wipe old machines
    before reuse), perform the following changes to the kickstart file:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`clearpart --none` 实际上并不会清除分区表——如果你按照这里定义的 kickstart 文件运行该示例，安装只有在目标磁盘上有足够空间安装
    CentOS 7 时才能完成。若要让 kickstart 文件清除目标磁盘并执行 CentOS 7 的全新安装（这可能有助于避免在重用旧机器前手动清除数据），请对
    kickstart 文件进行以下修改：
- en: Insert the `zerombr` directive above the `clearpart` statement to ensure the
    boot sector is cleared.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `clearpart` 语句上方插入 `zerombr` 指令，以确保清除启动扇区。
- en: Change the `clearpart` line to read `clearpart --drives=sda --initlabel --all`—be
    sure to only specify the drives you want clearing in the `--drives=` parameter!
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `clearpart` 行修改为 `clearpart --drives=sda --initlabel --all`——请确保在 `--drives=`
    参数中只指定你希望清除的磁盘！
- en: 'The fragment of following code does not include these changes as they are destructive—however,
    you are free to experiment with them as you wish in your test environment:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段未包含这些更改，因为它们是破坏性的——不过，你可以在测试环境中自由尝试这些更改：
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We then define our packages to be installed by default. Here, we are installing
    the `core` package group, the `minimal` system package set, and the `chrony` package.
    We are also disabling `kdump` for our test server, as shown in the following code
    block:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们定义默认安装的包。这里，我们安装了 `core` 包组、`minimal` 系统包集以及 `chrony` 包。我们还为测试服务器禁用了 `kdump`，如以下代码块所示：
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, we can perform additional customization, such as setting a strong
    password policy—the following lines are actually the defaults from the interactive
    installer, and should be customized to your requirements:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以进行额外的自定义，例如设置强密码策略——以下几行实际上是交互式安装程序的默认设置，应该根据你的需求进行自定义：
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When you have built your complete kickstart file, it''s time to test the boot
    process. Remember the PXELINUX boot configuration we used in the last section?
    Well, that is reused almost in its entirety, except this time, we need to tell
    it where to find the kickstart file. I am storing the file we have just created
    in `/var/www/html/centos7-config/centos7unattended.cfg`—thus, it can be downloaded
    from our HTTP server, just like with the packages for the installer. In this case,
    our PXELINUX configuration would look like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成了整个 kickstart 文件的编写后，是时候测试启动过程了。还记得我们在上一节中使用的 PXELINUX 启动配置吗？实际上，它几乎完全被重复使用，只是这次我们需要告诉它从哪里找到
    kickstart 文件。我将刚才创建的文件存储在 `/var/www/html/centos7-config/centos7unattended.cfg`，这样它可以像安装程序的包一样从我们的
    HTTP 服务器下载。在这种情况下，我们的 PXELINUX 配置看起来是这样的：
- en: '[PRE26]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Let's run through the installation process, and see what happens. Initially,
    the process will look identical to the interactive installation we performed earlier
    in this chapter.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行安装过程，看看会发生什么。最初，过程看起来与我们在本章早些时候执行的交互式安装相同。
- en: The preceding PXE boot configuration shown is identical to before, save for
    the `inst.ks` parameter at the end, telling Anaconda where to download our kickstart
    file from.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 上述 PXE 启动配置与之前相同，唯一不同的是末尾的 `inst.ks` 参数，它告诉 Anaconda 从哪里下载我们的 kickstart 文件。
- en: 'Indeed, when you connect to the VNC console of your machine as it is being
    built, things will initially look the same—the graphical installer for CentOS
    7 loads, as shown in the following screenshot:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，当你连接到正在构建中的机器的VNC控制台时，最初的界面将看起来一样——CentOS 7的图形化安装程序会加载，如下图所示：
- en: '![](img/dd4b86f0-8388-482e-858d-de5c83874658.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dd4b86f0-8388-482e-858d-de5c83874658.png)'
- en: 'So far, everything looks like an ordinary interactive installation. However,
    once the installer finishes the various tasks listed (for example, Saving storage
    configuration...), you will note that you are presented with a screen that looks
    complete, save for the Begin Installation button being grayed out (as shown in
    the following screenshot):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切看起来像是一个普通的交互式安装。然而，一旦安装程序完成了列出的各项任务（例如，保存存储配置...），你会注意到你看到的是一个看似完成的界面，除了“开始安装”按钮被禁用（如下图所示）：
- en: '![](img/d56b8cad-7d41-4d05-b9dc-1e72ce64ce97.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d56b8cad-7d41-4d05-b9dc-1e72ce64ce97.png)'
- en: 'Note the differences here—the installation source has now been set to the HTTP
    server we set up for our installation process. All other items that are usually
    completed manually, such as disk selection, have been completed automatically,
    using the configuration in our kickstart script. In fact, if we wait a short while
    longer, you will see that the installation commences automatically, without the
    need to click the Begin Installation button, as shown in the following screenshot:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意这里的区别——安装源现在已经设置为我们为安装过程设置的HTTP服务器。所有通常需要手动完成的项目，例如磁盘选择，已经使用我们的kickstart脚本中的配置自动完成。事实上，如果我们再等一会儿，你会看到安装会自动开始，无需点击“开始安装”按钮，如下图所示：
- en: '![](img/565adc47-7510-44cb-b64d-5bd5597746ba.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/565adc47-7510-44cb-b64d-5bd5597746ba.png)'
- en: The installation now proceeds, using the parameters from our kickstart file.
    Note that the root password and initial user account creation has been completed,
    using the parameters from the kickstart script, and so, these buttons are again
    grayed out. In short, although the installation process appears very similar to
    a normal interactive installation, the user is not able to interact with the process
    in any way.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 安装现在正在进行，使用我们的kickstart文件中的参数。请注意，根密码和初始用户帐户的创建已经完成，使用的是kickstart脚本中的参数，因此这些按钮再次被禁用。简而言之，尽管安装过程看起来与普通的交互式安装非常相似，但用户无法以任何方式与安装过程进行交互。
- en: 'There are only two times when a user will be expected to interact with a kickstart
    installation, as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 用户将在以下两种情况下需要与kickstart安装交互：
- en: A configuration is incomplete or incorrect—in this instance, the installer will
    pause and expect the user to intervene, and (if possible) correct the issue.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置不完整或不正确——在这种情况下，安装程序将暂停，等待用户干预，并（如果可能）修复问题。
- en: If the `reboot` keyword has not been specified in the kickstart file.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在kickstart文件中没有指定`reboot`关键字。
- en: 'In the latter case, the installation will complete, but the installer will
    wait for the Reboot button to be clicked, as shown in the following screenshot:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在后一种情况下，安装将完成，但安装程序会等待点击“重启”按钮，如下图所示：
- en: '![](img/294e8549-4fb9-4db9-abbb-0ef895fbf6c3.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/294e8549-4fb9-4db9-abbb-0ef895fbf6c3.png)'
- en: Rebooting automatically at the end of a kickstart installation is often desirable,
    as it saves the need to connect to the console. However, there are times when
    it is not—perhaps you don't actually want the newly built server to be running
    on the network at the present time. Or, perhaps you are building an image for
    templating purposes, and so don't want the first boot to complete, as it will
    mean log files and other data that subsequently need to be cleaned up.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在kickstart安装结束时自动重启通常是可取的，因为这样可以省去连接控制台的步骤。然而，也有一些情况下这并不可取——或许你现在并不希望新建的服务器连接到网络，或者你正在为模板创建一个镜像，因此不希望第一次启动完成，因为那样会生成日志文件和其他需要清理的数据。
- en: The exact path the installation takes is up to you—the important thing to note
    is that you can connect to the VNC console, as shown in the preceding screenshots,
    and see exactly how the installation is going. If there are any errors or issues,
    you will be alerted.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 安装的确切路径由你决定——需要注意的是，你可以连接到VNC控制台，如前面的截图所示，准确查看安装过程。如果有任何错误或问题，你会收到警告。
- en: 'Test this out, and see how the build performs for you. In the event of any
    issues, the installer runs up several consoles on the physical server that contain
    logging information—you can switch between these using *Alt* + *Tab*, or *Alt*
    + *F<n>*, where *F<n>* is one of the function keys—each of the first six corresponds
    to a different console, which will contain useful logging information. These can
    be queried, to debug any issues that might arise. The instructions are actually
    shown at the bottom of the text mode console screen—see the following screenshot
    for an example:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 测试一下，看看构建表现如何。如果遇到任何问题，安装程序会在物理服务器上启动多个控制台，这些控制台包含日志信息——你可以使用*Alt* + *Tab*，或*Alt*
    + *F<n>*（其中 *F<n>* 是功能键之一）在这些控制台之间切换——前六个控制台分别对应不同的控制台，包含有用的日志信息。你可以查询它们以调试可能出现的问题。实际上，说明会显示在文本模式控制台屏幕的底部——以下是一个示例截图：
- en: '![](img/97a127c9-5481-4cda-85a6-27da340fd7f7.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/97a127c9-5481-4cda-85a6-27da340fd7f7.png)'
- en: In the preceding screenshot, we can see we are on console `1`, entitled `main`.
    Console `2` has a `shell` for debugging purposes, and consoles `3` through `5`
    show `log` files specific to the installation process.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的截图中，我们可以看到我们处于控制台`1`，标题为`main`。控制台`2`用于调试，显示`shell`，控制台`3`到`5`显示与安装过程相关的`log`文件。
- en: However, if all of this goes well, you will see the installer run without any
    intervention required, and then, the server will reboot and present you with a
    login prompt. From there, you should be able to log in, using the password you
    defined via the password hash earlier.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果一切顺利，你将看到安装程序在无需干预的情况下运行，接着，服务器将重启并呈现登录提示。从那里，你应该能够使用之前通过密码哈希定义的密码登录。
- en: That concludes the process of building a CentOS 7 server over the network using
    a kickstart file. The same high-level process can be followed for Ubuntu and other
    Debian derivatives through the use of pre-seed files, as we shall explore in the
    next section.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了通过网络使用 kickstart 文件构建 CentOS 7 服务器的过程。我们将在下一节中介绍如何使用预设文件进行 Ubuntu 及其他 Debian
    派生系统的相同高层次操作。
- en: Performing unattended builds with pre-seed files
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用预设文件进行无人值守构建
- en: Broadly speaking, Ubuntu Server builds (and indeed, other Debian derivative
    operating systems) function exactly the same way. You specify a script file to
    tell the installer what actions to take, in place of a human being selecting options.
    With Ubuntu Server, this is called a pre-seed file. Let's go through this now,
    and build one up.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 广义来说，Ubuntu Server 的构建（以及其他 Debian 派生操作系统的构建）完全相同。你指定一个脚本文件来告诉安装程序执行什么操作，代替人工选择选项。对于
    Ubuntu Server，这被称为预设文件。让我们现在一起探讨并创建一个。
- en: 'The pre-seed files are very powerful, and there is lots of documentation around—however,
    they can sometimes appear more complex to the naked eye. Starting with the following
    lines of code, we set the appropriate locale and keyboard layout for our server:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 预设文件功能强大，且有很多文档可供参考——然而，它们有时看起来对肉眼来说更复杂。从以下几行代码开始，我们为服务器设置了适当的区域设置和键盘布局：
- en: '[PRE27]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We then configure the following network parameters:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们配置以下网络参数：
- en: '[PRE28]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here, you will note that we don''t actually need to know the interface name
    in advance—rather, we can get Ubuntu to guess it, using its automated detection
    algorithm. We are setting the hostname to `automatedubuntu`; however, note that
    the other parameters are used to prevent the installer from prompting for a hostname
    from the user, thus meaning the installation is not truly unattended. Next, we
    add some details about where the installer can download its packages from, as
    shown in the following code block:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你会注意到我们实际上不需要提前知道接口名称——我们可以让 Ubuntu 使用其自动检测算法来猜测它。我们将主机名设置为`automatedubuntu`；不过，请注意，其他参数用于防止安装程序提示用户输入主机名，这意味着安装并非完全无人值守。接下来，我们添加了一些有关安装程序从哪里下载软件包的细节，如下所示的代码块：
- en: '[PRE29]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: These should naturally be adjusted to suit your network, HTTP server setup on
    your PXE server, and so on.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这些应该根据你的网络、PXE 服务器上的 HTTP 服务器设置等自然调整。
- en: Many of these are also set in the kernel parameters, as we saw in our PXELINUX
    configuration earlier—we just need to confirm a few of them here.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 其中许多也设置在内核参数中，正如我们之前在 PXELINUX 配置中看到的——我们只需要在这里确认其中一些。
- en: 'We then set up the root account password, and any additional user accounts,
    as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们设置根账户密码，以及任何其他用户账户，如下所示：
- en: '[PRE30]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Note here that I have specified the passwords in plain text, to highlight the
    possibility to do this here—there are alternative parameters you can specify that
    will accept a password hash, which is far more secure when creating configuration
    files. Here, the root password is set to `password`, and a user account called `automation` is
    set up, with the password `insecure`. As before, our password policy is quite
    weak and could be strengthened here, or later, using Ansible. We then set the
    time zone as appropriate, and turn on NTP synchronization, as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，请注意，我已将密码以明文形式指定，以突出显示在此处可以这样做的可能性—也可以指定其他参数来接受密码哈希，这在创建配置文件时更加安全。在这里，root密码设置为`password`，并设置了一个名为`automation`的用户帐户，密码为`insecure`。像之前一样，我们的密码策略相当弱，可以在这里或稍后使用Ansible来增强。接着，我们根据需要设置时区，并开启NTP同步，如下所示：
- en: '[PRE31]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The most complex block of code in our otherwise simplistic example is the following
    one, which is used to partition and set up the disk:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们这个简化的示例中，最复杂的一段代码是以下这段，用来分区和设置磁盘：
- en: '[PRE32]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Although verbose, this section of the file basically says to automatically
    partition the disk `/dev/sda`, set up LVM, use automated calculations to determine
    the filesystem layout, and then create `ext4` filesystems. As you can see, there
    are many safeguards and confirmation prompts that we have flagged as `true` as
    otherwise, the installer would stop and wait for user input to proceed. If this
    were to happen, our installation would again not be truly unattended. From here,
    we specify the package set we want to be installed, as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管内容较为冗长，但该文件的这一部分基本上是在说自动分区磁盘`/dev/sda`，设置LVM，使用自动计算来确定文件系统布局，然后创建`ext4`文件系统。正如你所看到的，文件中有许多保护措施和确认提示，我们将其标记为`true`，否则安装程序会停止并等待用户输入以继续。如果发生这种情况，我们的安装过程将不会真正是无人值守的。接下来，我们指定要安装的软件包集，如下所示：
- en: '[PRE33]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The preceding lines of code essentially set up a minimal server build with
    the `openssh-server` package and `build-essential` packages on it. The automated
    update policy is configured to not automatically update. Finally, to finish off
    the file, we tell it where to install the boot loader, and to reboot upon successful
    completion, as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码行基本上设置了一个包含`openssh-server`包和`build-essential`包的最小化服务器构建。自动更新策略配置为不自动更新。最后，为了完成文件的配置，我们告诉它安装启动加载程序的位置，并在成功完成后重启，如下所示：
- en: '[PRE34]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As with our CentOS example, we will serve this file from our web server, and
    thus, the PXELINUX boot configuration needs adjusting, to make sure we incorporate
    this file—an appropriate example is shown as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的CentOS示例一样，我们将从我们的Web服务器提供这个文件，因此，PXELINUX启动配置需要调整，以确保我们纳入这个文件—以下是一个适当的示例：
- en: '[PRE35]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Note the following new options in use this time:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这次使用了以下新的选项：
- en: '`url`: Tells the installer from where to obtain our pre-seed file.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`url`：告诉安装程序从哪里获取我们的预种子文件。'
- en: '`console-setup/layoutcode` and `keyboard-configuration/layoutcode`: Prevents
    the installer from asking about keyboard settings when it is first run.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`console-setup/layoutcode`和`keyboard-configuration/layoutcode`：防止安装程序在第一次运行时询问键盘设置。'
- en: '`netcfg/get_hostname`: Although we have set the hostname in the pre-seed file,
    we have to specify this parameter here, otherwise the installer will stop, and
    prompt the user to enter a hostname.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`netcfg/get_hostname`：尽管我们在预种子文件中已经设置了主机名，但我们仍需要在这里指定此参数，否则安装程序将停止，并提示用户输入主机名。'
- en: 'Again, if you test this by booting a server over the network using the preceding
    configuration, you should see the server build complete. Unlike the CentOS 7 installation,
    you will not see any menu options—these will only be presented to you if your
    pre-seed configuration file is incorrect, or is missing some important details.
    Instead, you will simply see a series of progress bars flash by, as the various
    stages of the installation are completed. For example, the following screenshot
    shows that the base system is installed to the disk after the partitions and logical
    volumes have been set up:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，如果你通过使用前述配置从网络启动服务器来进行测试，你应该会看到服务器构建完成。与CentOS 7的安装不同，你不会看到任何菜单选项—这些选项仅在你的预种子配置文件不正确或缺少某些重要细节时才会呈现给你。相反，你会看到一系列进度条快速闪过，表示安装的各个阶段正在完成。例如，以下截图显示了在分区和逻辑卷设置完成后，基础系统已安装到磁盘：
- en: '![](img/abe7682b-af5d-4a53-b371-71d3bed0a352.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](img/abe7682b-af5d-4a53-b371-71d3bed0a352.png)'
- en: 'Assuming all goes well, this process will continue until you are presented
    with a final progress bar, which shows the final tidy-up being completed before
    the server is rebooted. In the following screenshot, the filesystems are being
    unmounted, in preparation for a reboot:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一切顺利，这个过程将继续，直到你看到一个最终的进度条，显示在服务器重启之前完成最后的整理工作。在下面的截图中，文件系统正在被卸载，为重启做准备：
- en: '![](img/fcb62dcc-1ca4-486b-9153-adf3c47e3d6a.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fcb62dcc-1ca4-486b-9153-adf3c47e3d6a.png)'
- en: When this final progress bar completes, your server will reboot, and you will
    be presented with a login prompt, from where you can log in with the credentials
    specified in the pre-seed file `d-i passwd` parameters shown previously. Note
    that if you use different credentials for your build, you must use these here,
    and not those specified previously.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个最终的进度条完成时，你的服务器将重启，并出现登录提示，你可以使用先前在pre-seed文件中指定的凭据登录，`d-i passwd`参数如前所示。请注意，如果你在构建过程中使用了不同的凭据，必须在此处使用这些凭据，而不是先前指定的凭据。
- en: At this stage, you should be able to perform an unattended build of either CentOS
    or Ubuntu Server over the network and perform basic changes, such as selecting
    the required packages and setting credentials. In the next section, we will explore
    methods of additional bespoke customization, beyond the original OS.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，你应该能够通过网络执行CentOS或Ubuntu服务器的无人值守构建，并进行基本更改，例如选择所需的软件包和设置凭据。在接下来的部分中，我们将探索超出原始操作系统的额外定制方法。
- en: Adding custom scripts to unattended boot configurations
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向无人值守启动配置中添加自定义脚本
- en: As you will have seen from the examples in this chapter, the kickstart and pre-seed
    files are quite prescriptive in what they can do. For most purposes, they should
    be perfectly adequate, allowing you to build a machine suitable for further customization
    with Ansible. Indeed, much of the rest of this book is dedicated to how you would
    manage and automate configuration management across an estate of servers, built
    per the details in this and the preceding chapters.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你从本章中的示例所看到的，kickstart和pre-seed文件在它们能做的事情上非常具有限制性。对于大多数目的，它们应该完全足够，允许你构建适合进一步使用Ansible进行自定义的机器。事实上，本书的其余部分主要讲解如何在按本章及前章中详细说明的方式构建的服务器群组上管理和自动化配置管理。
- en: However, what if your enterprise has a task (or tasks) that absolutely has to
    be performed at build time—perhaps for security compliance (which we shall explore
    in [Chapter 13](3d4a9c0a-452f-4fbb-85c8-372149303613.xhtml), *Using CIS Benchmarks*),
    for example? Luckily, both of the technologies we have discussed here provide
    an option for that. Let's first take a look at how you might perform custom commands
    in a kickstart-unattended installation.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你的企业有一个（或多个）任务必须在构建时执行——例如出于安全合规性的需要（我们将在[第13章](3d4a9c0a-452f-4fbb-85c8-372149303613.xhtml)中探讨，*使用CIS基准*）？幸运的是，我们在这里讨论的两种技术都提供了这样的选项。首先，让我们看看如何在kickstart无人值守安装中执行自定义命令。
- en: Customized scripting with kickstart
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用kickstart进行自定义脚本编写
- en: 'As discussed previously, it is recommended for most tasks that you perform
    the post-build configuration with Ansible. However, let''s take a simple and hypothetical
    example—suppose that, for security reasons, you need to disable root SSH logins
    immediately when the server is built, for security compliance. There is no directive
    in kickstart that can perform this task, and leaving the server with this enabled
    while it waits for Ansible to run against it may not be acceptable to a corporate
    security team, as there is a window of opportunity for a potential attacker. Luckily,
    at the bottom of our kickstart file, we can put a `%post` block in that runs any
    shellcode you put into it. Thus, we could run the `sed` utility from within the
    following code block:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，建议大多数任务使用Ansible来执行构建后的配置。然而，让我们以一个简单的假设为例——假设出于安全原因，你需要在服务器构建后立即禁用root
    SSH登录，以满足安全合规性要求。kickstart中没有可以执行此任务的指令，而在服务器等待Ansible运行期间仍然启用该功能，可能会被企业安全团队认为不可接受，因为潜在的攻击者可能会有机会利用这一点。幸运的是，在我们的kickstart文件的底部，我们可以放置一个`%post`块，来运行你放入其中的任何Shell代码。因此，我们可以在以下代码块中运行`sed`工具：
- en: '[PRE36]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This very simple block of code runs after the installation process has finished
    (but before the reboot), and logs its output into `/root/ks.log`. You could customize
    this as you see fit—however, here, for the sake of our simple example, we are
    performing a search and replace operation on the default SSH daemon configuration,
    to ensure that even on first boot, root logins over SSH are disabled.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这段非常简单的代码块在安装过程完成后（但在重启之前）运行，并将其输出日志到`/root/ks.log`。您可以根据需要自定义此内容—然而，在此为了简单的示例，我们执行了对默认SSH守护进程配置的搜索和替换操作，以确保即使在第一次启动时，通过SSH的root登录也被禁用。
- en: In the next section, we'll see how the same thing is achieved in an Ubuntu pre-seed
    file.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到如何在Ubuntu预种子文件中实现相同的操作。
- en: Customized scripting with pre-seed
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用预种子进行定制脚本
- en: 'Suppose we want to perform the same customization with Ubuntu. Ubuntu pre-seed
    files run a single line of commands rather than a block as used in kickstart;
    hence, they lend themselves better to either simple tasks, or indeed to downloading
    a script for more complex operations. We could embed the `sed` command in our
    pre-seed file by adding the following line at the bottom:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们希望在Ubuntu中执行相同的自定义操作。Ubuntu预先种子文件执行的是单行命令，而不是像kickstart中使用的代码块；因此，它们更适合简单任务，或者确实适合下载脚本以执行更复杂的操作。我们可以通过在文件末尾添加以下行，将`sed`命令嵌入到预种子文件中：
- en: '[PRE37]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Suppose, however, we have a much more complex script to run, and that trying
    to write it all on one line would make it difficult both to read and manage—instead,
    we could change the preceding command, to download a script from a chosen place
    and run it, as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，假设我们有一个更复杂的脚本需要运行，并且将它写成一行会使得代码既难以阅读又难以管理——相反，我们可以修改前面的命令，从选定的位置下载脚本并运行它，如下所示：
- en: '[PRE38]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note here that we are using `wget` (which was installed earlier in the build
    process) to download a file called `run.sh` from the `/ubuntu-config/` path on
    our web server. We then make it executable and run it. In this way, far more complex
    command sequences can be run at the end of the build process, just prior to the
    first reboot.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在此使用`wget`（在构建过程中早些时候安装）从我们的Web服务器的`/ubuntu-config/`路径下载名为`run.sh`的文件。然后，我们将其设为可执行并运行。通过这种方式，构建过程结束时，在首次重启之前，可以运行更复杂的命令序列。
- en: In this manner, incredibly complex, bespoke operating system builds can be installed
    remotely, over the network, without any human intervention at all. The use of
    kickstart and pre-seed files also means that the process is scripted and repeatable,
    which is an important principle for us to adhere to.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，可以远程安装非常复杂、定制化的操作系统构建，完全不需要人工干预。使用kickstart和预种子文件也意味着该过程是脚本化和可重复的，这是我们需要遵循的一个重要原则。
- en: Summary
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小结
- en: Even when using bare-metal servers (and some virtualization platforms), it is
    entirely possible to script the installation process, to ensure that all builds
    are consistent and thus adhere to the SOE principle we set out earlier in this
    book. By following the processes set out in this chapter, you will ensure that
    all your servers are built in a consistent manner, regardless of the platform
    on which they are running.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在使用裸金属服务器（以及某些虚拟化平台）时，完全可以通过脚本化安装过程，确保所有构建的一致性，从而遵循我们在本书前面阐述的SOE原则。通过遵循本章中设定的过程，您将确保所有服务器都以一致的方式构建，无论它们运行在哪个平台上。
- en: Specifically, you gained experience of performing an interactive Linux installation
    environment, using PXE network booting. You then learned how to fully automate
    the build process, using kickstart and pre-seed scripts, to ensure that builds
    are completely unattended (and, hence, automated). Finally, you learned how to
    further customize the builds, by adding custom scripts to the build definition.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，您获得了使用PXE网络启动执行交互式Linux安装环境的经验。接着，您学习了如何使用kickstart和预种子脚本完全自动化构建过程，确保构建过程完全无人值守（因此，实现自动化）。最后，您学习了如何通过向构建定义中添加自定义脚本，进一步定制构建。
- en: In the next chapter, we will proceed to look at the use of Ansible to customize
    servers, both when they are newly built, and on an ongoing basis.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续探讨如何使用Ansible定制服务器，无论是在新建时，还是在后续的维护过程中。
- en: Questions
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What does PXE stand for?
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PXE代表什么？
- en: Which basic services are required for a PXE boot?
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PXE启动需要哪些基本服务？
- en: Where would you obtain the installation sources for a network boot?
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将从哪里获取网络启动的安装源？
- en: What is an unattended installation?
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是无人值守安装？
- en: What is the difference between a kickstart file and a pre-seed file?
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: kickstart 文件和 pre-seed 文件有什么区别？
- en: Why would you need to use a `%post` block in a kickstart file?
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么在 kickstart 文件中需要使用 `%post` 块？
- en: What is the purpose of the `BIOS` and `EFIx64` directories under the TFTP server
    root?
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 TFTP 服务器根目录下，`BIOS` 和 `EFIx64` 目录的作用是什么？
- en: How would you create a separate partition for `/home` in a pre-seed file?
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在 pre-seed 文件中为 `/home` 创建一个独立的分区？
- en: Further reading
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: To see all the possible pre-seed file options, please visit [https://help.ubuntu.com/lts/installation-guide/example-preseed.txt](https://help.ubuntu.com/lts/installation-guide/example-preseed.txt).
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要查看所有可能的 pre-seed 文件选项，请访问 [https://help.ubuntu.com/lts/installation-guide/example-preseed.txt](https://help.ubuntu.com/lts/installation-guide/example-preseed.txt)。
- en: To learn more about kickstart files (also works on CentOS), please visit [https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/installation_guide/sect-kickstart-howto](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/installation_guide/sect-kickstart-howto).
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解更多关于 kickstart 文件的信息（同样适用于 CentOS），请访问 [https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/installation_guide/sect-kickstart-howto](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/installation_guide/sect-kickstart-howto)。
- en: To see a syntax reference for kickstart file commands, please visit [https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/installation_guide/sect-kickstart-syntax#sect-kickstart-commands](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/installation_guide/sect-kickstart-syntax#sect-kickstart-commands).
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要查看 kickstart 文件命令的语法参考，请访问 [https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/installation_guide/sect-kickstart-syntax#sect-kickstart-commands](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/installation_guide/sect-kickstart-syntax#sect-kickstart-commands)。
