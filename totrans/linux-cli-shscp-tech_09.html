<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer231">
			<h1 id="_idParaDest-200"><em class="italic"><a id="_idTextAnchor206"/>Chapter 9</em>: An Introduction to Shell Scripting</h1>
			<p>We have come to the part that defines one of the things that Unix (or Linux) is known for – its scripting. When it comes to the so-called <em class="italic">Unix philosophy</em>, being able not only to use tools that the command line offers to you but also being able to create your own is an amazing ability, using shell tools that do one thing really well.</p>
			<p>Scripting is exactly that – the ability to create simple (and complex) tools that, at their core, are a set of commands performing a certain task. We need to clear one thing up before everything else – there is a distinction that some people make between programming and scripting. Strictly speaking, all scripting is programming, but not all programming is scripting. We are talking about disciplines that follow the exact same premises, logic, and ways of thinking, but at the same time, there are major differences between the two. When we talk about scripting, we are in reality creating files that are going to get <em class="italic">interpreted</em> when running, and that means that the shell (or some other <em class="italic">interpreter</em>) is going to read the file line by line and then run the commands. There is another option, and that is to create text files that are <em class="italic">compiled</em> before being run. Usually, this is faster than interpreting them, but at the same time, it both requires a few extra steps and is not as flexible as scripting. </p>
			<p>We are not going to waste our time on anything connected to compiled applications; in this book, we'll be strictly dealing with scripts. </p>
			<p>We will cover the following recipes in this chapter: </p>
			<ul>
				<li>Writing your first Bash shell script</li>
				<li>Serializing basic commands – from simple to complex</li>
				<li>Manipulating shell script input, output, and errors</li>
				<li>Shell script hygiene</li>
			</ul>
			<h1 id="_idParaDest-201"><a id="_idTextAnchor207"/>Technical requirements </h1>
			<p>For this recipe, we're going to use a Linux machine. We are using the same setup as in other chapters:</p>
			<ul>
				<li>A virtual machine with Linux installed, any distribution (in our case, it's going to be <em class="italic">Ubuntu 20.04</em>)</li>
				<li>Bash – the default shell for every major distribution out there</li>
			</ul>
			<p>Scripts in this chapter, and in all the other chapters covering scripting, will probably run in any distribution using Bash. The power of scripting is exactly in this compatibility; if a machine runs Linux, it will run almost any script, and the only problems are going to come from what the script itself expects on the server. </p>
			<h1 id="_idParaDest-202"><a id="_idTextAnchor208"/>Writing your first Bash shell script</h1>
			<p>Before we do a simple <strong class="source-inline">Hello World!</strong> shell script, let's quickly talk about the shell itself and what does it do on a normal<a id="_idIndexMarker653"/> Linux machine. The simplest way of describing it is that the shell is the connection between the user (us) and the kernel (the part of the operating system in charge of everything). We have already talked about that before, but we need to make some points here to make it easier to explain some concepts. </p>
			<p>The shell is an application that usually displays a prompt and finds and runs whatever command<a id="_idIndexMarker654"/> we give it. This is called the <strong class="bold">interactive shell</strong> and is the most-used way of working<a id="_idIndexMarker655"/> in Linux. This is what all the <strong class="bold">Command-Line Interface</strong> (<strong class="bold">CLI</strong>) business is about – having an interface that enables us to execute whatever we need:</p>
			<div>
				<div id="_idContainer228" class="IMG---Figure">
					<img src="Images/Figure_9.1_B16269.jpg" alt="Figure 9.1 – A typical root shell&#13;&#10;" width="1051" height="267"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.1 – A typical root shell</p>
			<p>There is, however, another mode<a id="_idIndexMarker656"/> of operation for a shell called <strong class="bold">non-interactive mode</strong>. This covers all the instances of the shell when it is not acting based on our commands from the command<a id="_idIndexMarker657"/> line but instead by reading a file (our script) line by line and executing the commands. Obviously, we cannot interact with the commands directly, so the mode is aptly called non-interactive. </p>
			<p>Bear in mind that we can interact with the script during execution if we wish (and plan) to; the name refers only to the lack of direct interaction with the shell or having no CLI available. At the same time, this interaction limit means that we get to see our script run as fast as possible, at any time that we need it. Pair that with a myriad of tools at our disposal in a normal Linux system, and we have an extremely powerful feature available to finish our tasks. </p>
			<h2 id="_idParaDest-203"><a id="_idTextAnchor209"/>Getting ready</h2>
			<p>Let's quickly run a few commands and find out about our current shell:</p>
			<p class="source-code">demo@ubuntu:~$ ps -p $$</p>
			<p class="source-code">    PID TTY          TIME CMD</p>
			<p class="source-code">   5329 pts/0    00:00:00 bash</p>
			<p class="source-code">demo@ubuntu:~$ echo $SHELL</p>
			<p class="source-code">/bin/bash</p>
			<p>What happened here? The first command we used was <strong class="source-inline">ps</strong>, and it gave us information about which shell is currently running or, to be precise, which shell is responsible for the current execution of commands that we issue. Using <strong class="source-inline">$$</strong> as the process number, we are asking the <strong class="source-inline">ps</strong> command to give us the number of the process assigned to our current shell. We performed a small trick here – <strong class="source-inline">$$</strong> is a Bash internal variable that gives us the running PID of a process.</p>
			<p>The other command that we used is <strong class="source-inline">echo</strong>, and we used its <strong class="source-inline">$SHELL</strong> variable that automatically resolves to whatever the user's current shell is. </p>
			<p>However, there is a big difference<a id="_idIndexMarker658"/> between these two commands. Depending on the circumstances, they can give us completely different results, since they are referring to completely different things. Let's explain – each user has their <em class="italic">assigned</em> shell, which is going to be executed when the user logs in. The result of the <strong class="source-inline">echo</strong> command is going to give you that, and the shell itself is defined in the <strong class="source-inline">/etc/passwd</strong> file, in the line that describes a particular user. So basically, the output of the command is going to provide the name of your default shell. </p>
			<p>At the same time, every user can run any shell available on the system as a command, and automatically get this shell as their <em class="italic">current</em> shell. By that, we mean that this shell is going to process whatever the user is typing into the command line. This is important, since your script can be run from the command line using a different shell than the one you are supposed to be using, based on information in the <strong class="source-inline">/etc/passwd</strong> file.</p>
			<p>Your shell doesn't have to be <strong class="source-inline">bash</strong>. You can also choose any shell that is available on your system, or you can even install shells that are not currently available on the system you are using but are available as packages. </p>
			<p>With that in mind, when it comes to scripting, <strong class="source-inline">bash</strong> is the shell of choice, even for users running other shells, since <strong class="source-inline">bash</strong> will run on most, if not all, Linux machines. </p>
			<p>Now, let's talk a little bit about the editors used for scripting. </p>
			<p>For chapters dealing with scripting in this book, we are going to use <strong class="source-inline">vim</strong> or <strong class="source-inline">vi</strong>; however, the script examples are going to be displayed as text without any color. We already covered a lot of editors in a separate<a id="_idIndexMarker659"/> chapter. Since the topic of text editors tends to be pretty divisive, and we are a bit pragmatic on this, our suggestion is to use whatever works for you. </p>
			<p>Vim, JOE, nano, vi, Emacs, gedit, Sublime Text, Atom, Notepadqq, Visual Studio Code, and so on are what's available, but it's up to you to choose. For simple scripts, any editor will work, and more often than not, you will choose something that already exists on the system you are working on, just because you need to make a small change in a script. </p>
			<p>When developing scripts on your own machine, you are probably going to go with something more complicated, simply because it makes working much easier. Vim is a good example, since it provides syntax highlighting and formatting for <strong class="source-inline">bash</strong>. Advanced editors are going to provide you with more functions, but our opinion is that you shouldn't rely on too many bells and whistles, since this will make you dependent on a certain application that may or may not be available to you at all times:</p>
			<div>
				<div id="_idContainer229" class="IMG---Figure">
					<img src="Images/Figure_9.2_B16269.jpg" alt="Figure 9.2 – A script opened in Vim – note the color highlights and indentation&#13;&#10;" width="946" height="826"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.2 – A script opened in Vim – note the color highlights and indentation</p>
			<p>In the end, you will end up using two editors, one for developing your scripts and one on servers you are deploying<a id="_idIndexMarker660"/> your scripts to. Remember that you will inevitably have to do some debugging on the systems you are deploying your scripts to, so be prepared that some of your normal tools will be missing. Don't become dependent on them. </p>
			<h2 id="_idParaDest-204"><a id="_idTextAnchor210"/>How to do it…</h2>
			<p>Let's create our first script and see what it is about the shell that we are so concerned with:</p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code"># Hello world script, V1.0 2021/8/1</p>
			<p class="source-code">echo "Hello World!</p>
			<p>First, what does the script<a id="_idIndexMarker661"/> actually do? It simply writes <strong class="source-inline">Hello World!</strong> to the standard output and exits. Although we have three lines in the script itself, only one of them does something, while the other two have different purposes. </p>
			<p>What we are going to do is first unpack the meaning behind the first two lines and then pay attention to the <strong class="source-inline">echo</strong> command. </p>
			<p>Note that we are not counting empty lines in the script, although your editor might. In scripting, empty lines are meaningless to the interpreter, so we are using them to make the script more human-readable and ignoring them when talking about the script – Bash does the same thing when executing the script. </p>
			<p>As a rule, if we use the <strong class="source-inline">#</strong> character anywhere in the script, an interpreter is going to treat everything that comes after that character <em class="italic">in the same</em> line as a comment. Our first two lines are comments, but the first line in the script is special – it defines the shell that is going to run commands in the scripts while also being a comment. This sequence is called a <em class="italic">shebang</em>. We need to explain<a id="_idIndexMarker662"/> that. </p>
			<p>Under Linux, scripting is not confined to using <strong class="source-inline">bash</strong> only or even using any other Bash-compatible shell. In your script, you can actually use whatever scripting language you want. Other than being Bash, it can be Python or Perl – you can use whatever language is available on the system and that you know how to write scripts in. </p>
			<p>Normally a script is run by an interpreter. The interpreter is basically an application that is able to understand what's inside the file and then is able to run the commands that are inside the file, one by one. All the interpreters that we mentioned (Python, Bash, and Perl) use simple plaintext files as inputs, so there needs to be a way of telling what kind of script is in a particular file to let the system know how to run it. </p>
			<p>This can be done in two different ways – one way is to actually call the script directly using the right interpreter, such as the following: </p>
			<p class="source-code">demo@ubuntu:~/scripting$ bash helloworld.sh </p>
			<p class="source-code">Hello World!</p>
			<p>This simply makes sure we are using<a id="_idIndexMarker663"/> the right interpreter for the script; it doesn't make our script any more readable to the system or another user. </p>
			<p>Now, consider another way of doing this. Let's make the script executable, and then run it directly: </p>
			<p class="source-code">demo@ubuntu:~/scripting$ chmod u+x helloworld.sh </p>
			<p class="source-code">demo@ubuntu:~/scripting$ ./helloworld.sh </p>
			<p class="source-code">Hello World!</p>
			<p>The difference between these two is subtle but important, although the end result is going to be the same, since we are running the same script. </p>
			<p>In the first example, we are explicitly telling the system to use a particular interpreter and run our script. In the second example, we are telling the system to run the script using whatever interpreter it needs, and this is when the first line of the script plays its crucial role. What the current shell is going to do is take the first line (the shebang) and try and find the interpreter that this line points to. If it finds it, the system is going to use this interpreter to run whatever is in the rest of the file. The end result is simple – if we follow the convention and put our interpreter as the first-line comment, the system is going to be able to run our script even if we don't mention it explicitly. </p>
			<p>If the first line is something other than the name of the interpreter, our script will work only if we call it by explicitly using the name of the interpreter – if we try to run it directly, the system is going to throw an error. </p>
			<h2 id="_idParaDest-205"><a id="_idTextAnchor211"/>How it works…</h2>
			<p>Linux does not use extensions as a way of identifying files, so a script can have any name that is possible on the filesystem; the extension does not have to be <strong class="source-inline">.sh</strong>. All this means is that in order to have our script work universally, we need to think about the right formatting for the first line. </p>
			<p>The next line in the script is our comment, which identifies the name of the script and the version. Of course, any script will function without comments such as these or, in general, without any comments at all, but comments are extremely important in scripting. We will pay much more attention to the comments later in this chapter. </p>
			<p>The third line is the one actually doing the work, and it simply displays<a id="_idIndexMarker664"/> the string to the standard output that is assigned to the script. Standard input, output, and error handling are things that we will also deal with a little bit later. </p>
			<p>This is our first script. We explained a lot in this part of the chapter, and we focused on everything other than the actual command that performs the script task, but we had to deal with a lot of other things. </p>
			<h3>There's more… </h3>
			<p>We are going to be dealing with scripts a lot more in this chapter and the next few, but we have links to get you started: </p>
			<ul>
				<li>The Bash manual – containing<a id="_idIndexMarker665"/> everything about the Bash shell: <a href="https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html">https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html</a> </li>
				<li>Bash scripting<a id="_idIndexMarker666"/> cheat sheets: <a href="https://devhints.io/bash">https://devhints.io/bash</a> </li>
				<li>How to get a shell script<a id="_idIndexMarker667"/> to actually work: <a href="https://linuxcommand.org/lc3_wss0010.php">https://linuxcommand.org/lc3_wss0010.php</a> </li>
			</ul>
			<h1 id="_idParaDest-206"><a id="_idTextAnchor212"/>Serializing basic commands – from simple to complex</h1>
			<p>Scripts are nothing more than a list of commands<a id="_idIndexMarker668"/> that are executed in a particular order. In its most basic structure, the order is completely linear without any decision making, loops, or conditional branching. </p>
			<p>Commands are executed from first to last, from top to bottom, and from the start of the line to its end. Even if it sounds simple and not very useful, this way of creating scripts can have its uses, since it enables us to quickly run a predefined set of commands instead of repeating them from the command line. In other words, there are problems that require more than a single one-line command but are not complicated enough to require complex logic. This is not to devalue complex Bash scripting logic, as there's a lot of automation in IT that can be implemented by using Bash scripting. </p>
			<p>Let's now imagine a simple task like that, something that we will be using<a id="_idIndexMarker669"/> as a recurring example. We are going to create a simple backup script. Our task is as follows: </p>
			<ol>
				<li>Create a directory under <strong class="source-inline">/opt/backup</strong> that has today's date in its name. </li>
				<li>Copy all the files from the <strong class="source-inline">/root</strong> folder to this directory.</li>
				<li>Send an empty email to the <strong class="source-inline">root</strong> user that will simply say that a backup was done. </li>
				<li>Add a line to a file named <strong class="source-inline">donebackups.lst</strong> in the <strong class="source-inline">/root</strong> folder that will have today's date in it.</li>
			</ol>
			<h2 id="_idParaDest-207"><a id="_idTextAnchor213"/>Getting ready</h2>
			<p>Before we start – a disclaimer. This is a simple script that does not make too much sense for a number of reasons. The most important is that it is oblivious to the context it is running in. We quickly need to talk about this and the other problems first, and then we'll compose a script that solves this task. </p>
			<p>What do we mean by <em class="italic">context</em>? No matter which way we choose to run them, scripts are run by a user, in so-called user space, and they have some things that define their environment that we usually call context. </p>
			<p>Context is the entire<a id="_idIndexMarker670"/> environment that is running the script and offers the following questions: </p>
			<ul>
				<li>Which user is running the script?</li>
				<li>What permissions does this script have?</li>
				<li>Is the script run from the command line as a tool or as a background task?</li>
				<li>What directory is the script running from?</li>
			</ul>
			<p>Other than these, there are usually several other things that can be relevant for the running script, and we will talk about those as we progress through this book. </p>
			<p>Right now, we need<a id="_idIndexMarker671"/> to make clear that context is extremely important and that our scripts should never in any way or form take for granted any element of it. If we want our scripts to run correctly, we should presume nothing, and instead, we should check everything that we expect to be in a certain state. </p>
			<p>A script that is able to check and decide what the possible problems are in the environment that started it requires two things that we haven't yet talked about – controlling the flow of the script and interacting with the system. Right now, it is obvious that we still don't know how to do that. </p>
			<p>Not being able to test things in a script means that, after all, we are going to presume a lot when creating this particular script. Be warned – this is usually the first thing that will lead us into problems. </p>
			<p>Not thinking things through before we even type a single letter is usually the source of all problems; scripts are rarely so simple that they can be created without planning in advance. </p>
			<p>The main reason we are talking about this now is to try and put you in the right mindset when creating your scripts. </p>
			<h2 id="_idParaDest-208"><a id="_idTextAnchor214"/>How to do it…</h2>
			<p>So, how do you create a script? Before you even begin, you should do the following: </p>
			<ul>
				<li>Define your tasks.</li>
				<li>Research commands that you are going to use.</li>
				<li>Check permissions and things required for the individual commands to succeed.</li>
				<li>Try individual commands before using them in the script. </li>
			</ul>
			<p>Think about things that you are presuming: </p>
			<ul>
				<li>If you are reading from or writing to any files, do you expect the files to be there, or do you need to create them? </li>
				<li>If you are referencing some file or directory, does it even exist, and do you have the right permissions? </li>
				<li>Are you using some command that needs to be installed or configured beforehand? </li>
				<li>Are you referencing files by an absolute or relative path? </li>
			</ul>
			<p>This is only the tip of the iceberg<a id="_idIndexMarker672"/> that is usually called <strong class="bold">sanity checks</strong>, and the term <em class="italic">sanity</em>, in this case, refers to the state<a id="_idIndexMarker673"/> your script operates in. <strong class="bold">Sane state</strong> is what we say when we mean<a id="_idIndexMarker674"/> that everything is okay. Any deviation from this, or any error or problem that makes your script behave in an unexpected way, is a problem. This is why we need to think in advance. And that's also the reason why sanity-checked code can take much more effort than regular code that just does the basics. </p>
			<p>But believe us – these kinds of checks will help keep not only the sanity of the environment but also your own sanity intact when dealing with complex tasks. </p>
			<p>Right now, we are bravely ignoring all this and dealing with the basics. For our backup script, we are going to presume that both the <strong class="source-inline">/root</strong> and <strong class="source-inline">/opt</strong> directories exist and are accessible to whatever user is running the script. In our particular case, this means that our script is going to work ONLY if run by a superuser, since this user is required to be able to access files under <strong class="source-inline">/root</strong>. </p>
			<p>Also, we are going to presume that an email system of some kind exists and is running on the local computer. We will also presume that the log file mentioned in the last step is writeable to our script. </p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">When running a script, you are making a lot of presumptions like these, and if any of them is not correct, your script is going to fail in some way. Your main job as a script creator is to prevent this. </p>
			<p>What commands are we going to use? </p>
			<p>Our first task is going to be to create a directory using today's date in its name. Here, we are going to presume that this directory does not exist, and we are going to create it no matter what. This is a significant deviation from the logic that we are going to use later – a command like this would usually check at least if the directory existed, and if the command itself succeeded. A script should fail in some graceful way if any of these are not <strong class="source-inline">true</strong>, or it should create directories that it needs. </p>
			<p>Before you say, <em class="italic">But wait – I can already do that; I know how to do testing in a single command line, </em>let's go back and talk again about how a script is run. </p>
			<p>At this moment, we are trying to create<a id="_idIndexMarker675"/> something that has no logic to control the flow of the script so that commands are run one line at a time. We could try to cheat and do some checks in each individual line, but since we are not controlling the flow of the entire script, this can be even more dangerous than doing no checks at all. </p>
			<p>An interpreter is going to run all the commands no matter what, and even if we are checking for problems and spot them, we will end up running all the commands in the script. The right thing to do if something is not right is to control how the <em class="italic">script</em> behaves, not how a <em class="italic">single command</em> behaves. No matter how simple or complex a scripting task is, you should always think about the aforementioned context and what your script is doing to it. If something fails, your script needs to decide – is the failure something that can be dealt with, or do you need to abort the execution of the entire script? </p>
			<p>If you are aborting execution in the middle of the script, is there something you need to do before your script ends? Usually, when something that forces you to abort a task happens, you will have some way of notifying the system and the user that there was a problem. Sometimes, that will not be enough – your script will have to clean up after itself. </p>
			<p>It could be a matter of deleting some files, but it could be that you need to revert a change or even hundreds of changes that you made to the system. Every failure should be evaluated not only on its severity but also on how it affects the system and the state that your script created on that system. </p>
			<h2 id="_idParaDest-209"><a id="_idTextAnchor215"/>How it works…</h2>
			<p>After creating what is probably the world's largest disclaimer on why our script is so basic, let's get down to work. </p>
			<p>Task by task, how are we going to solve this? </p>
			<p>Creating a directory is simple; we are going to avoid using Bash shell expansion, and we will use the <strong class="source-inline">date</strong> system command. We are cheating a little bit here, since we are referencing the system environment, but the task is simply impossible to accomplish without it, and we are not relying on something that is inherent to Bash itself. Note here that this also demonstrates<a id="_idIndexMarker676"/> that there are usually multiple ways to do any one thing in scripting. The only difference is your creativity. </p>
			<p>The first command will be something like the following: </p>
			<p class="source-code">root@ubuntu:/home/demo/# mkdir /opt/backup/backup$ (date \</p>
			<p class="source-code">+%m%d%Y)</p>
			<p>Please note that we are running this as the <strong class="source-inline">root</strong> user. Let's quickly check what happened: </p>
			<p class="source-code">root@ubuntu:/home/demo/scripting# ls /opt/backup/</p>
			<p class="source-code">backup08202021</p>
			<p>We can see that our directory has been created. Now, let's deal with the copy operation: </p>
			<p class="source-code">root@ubuntu:/home/demo/scripting# ls /opt/backup/backup08202021/</p>
			<p class="source-code">root@ubuntu:/home/demo/scripting# touch /root/testfile</p>
			<p class="source-code">root@ubuntu:/home/demo/scripting# cp /root/* /opt/backup/backup'date +%m%d%Y'</p>
			<p class="source-code">cp: -r not specified; omitting directory '/root/snap'</p>
			<p class="source-code">root@ubuntu:/home/demo/scripting# ls /root</p>
			<p class="source-code">snap  testfile</p>
			<p class="source-code">root@ubuntu:/home/demo/scripting# ls /opt/backup/backup08202021/</p>
			<p class="source-code">testfile</p>
			<p>We were able to create a test file and copy it to our directory. Pay attention to the way we are referencing the directory that we are copying to – since we don't know <em class="italic">when</em> this script is going to run, there is no way for us to know what the current directory we need to copy to is. </p>
			<p>To avoid the hassle of having to read and parse directories, we are simply recreating the directory name the same way we did when we created the directory itself. There is a possible bug here – if, by some freak chance, your script is run exactly at midnight, it is possible that the part where the directory is created is run before midnight and the part we are using to copy the files is run after midnight. This can create an error, since the names will not match. The chance<a id="_idIndexMarker677"/> of this happening is slim, and we are not going to plan for it. </p>
			<p>In a large script, things like this can and will create big problems if not addressed correctly. </p>
			<p>Now, let's do mail functionality: </p>
			<p class="source-code">root@ubuntu:/home/demo# mail -s "Backup done!" root@localhost</p>
			<p class="source-code">Command 'mail' not found, but can be installed with:</p>
			<p class="source-code">apt install mailutils</p>
			<p class="source-code">root@ubuntu:/home/demo/scripting# apt install mailutils</p>
			<p class="source-code">Reading package lists... Done</p>
			<p class="source-code">Building dependency tree……………………………       </p>
			<p>The error here is important. We did it to show the importance of testing commands. In this case, we tried sending mail, and it made us realize that the command we are expecting to use is not installed by default. </p>
			<p>In order to run this script, we actually need to have the <strong class="source-inline">mail</strong> command installed. It is going to be there on servers that have mail service configured but is going to be absent on normal workstations. Since our backup script should work on any server, we need to solve that. </p>
			<p>Blindly installing a package using a package manager is usually safe; the system will either install the package or update it if it was already installed. </p>
			<p>Now, we are going to try that command again, and once again, it is going to fail: </p>
			<p class="source-code">root@ubuntu:/# mail -s "Backup was done!" root@localhost</p>
			<p class="source-code">Cc: </p>
			<p class="source-code">Null message body; hope that's ok</p>
			<p class="source-code">root@ubuntu:/# man mail</p>
			<p class="source-code">You have mail in /var/mail/root</p>
			<p class="source-code">root@ubuntu:/# mail -s "Backup was done!" root@localhost &lt; /dev/null</p>
			<p class="source-code">mail: Null message body; hope that's ok</p>
			<p>We didn't actually fail, but when we invoked the first command, it required us to input some data. It was asking us for the <strong class="source-inline">Cc</strong> address, and we had to press <em class="italic">Ctrl </em>+<em class="italic"> D</em> to finish the body of the email. </p>
			<p>This is another reason<a id="_idIndexMarker678"/> to test commands before using them in a script. </p>
			<p>After realizing that we need to do something to make this command run unattended and reading the manual, we can see it is a matter of simply providing no inputs by redirecting <strong class="source-inline">/dev/null</strong> into the command. </p>
			<p>Now, for the last command that we need to do, we implement the actual reporting of the backup: </p>
			<p class="source-code">root@ubuntu:/home/demo# date +%m%d%Y &gt;&gt; /root/donebackups.lst</p>
			<p>Remember, we need to append to a file. Additionally, what we want to do is reference the file directly using an absolute path; after all, we have no idea where we will be when running this script. </p>
			<p>Okay, we have tried and tested all the commands. How does our script actually look? It's not complicated: </p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code">mkdir /opt/backup/backup'date +%m%d%Y'</p>
			<p class="source-code">cp /root/* /opt/backup/backup'date +%m%d%Y'</p>
			<p class="source-code">mail -s "Backup was done!" root@localhost &lt; /dev/null</p>
			<p class="source-code">date +%m%d%Y &gt;&gt; /root/donebackups.lst</p>
			<p>Now, let's run it.</p>
			<p class="source-code">root@ubuntu:/home/demo/scripting# bash backupexample.sh</p>
			<p class="source-code">cp: -r not specified; omitting directory '/root/snap'</p>
			<p class="source-code">mail: Null message body; hope that's ok</p>
			<p>There are a few things that need our attention. First, note that we have some output from the script that we didn't expect. This is normal and is a direct result of what we saw when we tested<a id="_idIndexMarker679"/> our command – some commands threw errors. The reason we are seeing this error is going to be explained in the next part of this chapter. Another thing that we need to note is that other than the errors, we have no other output. The only way we have to tell whether our script was successful or not will be by having the script itself report it – we need to check the mail and the file mentioned in the script to check whether everything is correct. That points us to another thing we are going to need – the logging. We are going to deal with logs and debugging in later chapters. </p>
			<p>Now, let's elaborate a little on how your script communicates with the environment. </p>
			<h2 id="_idParaDest-210"><a id="_idTextAnchor216"/>There's more…</h2>
			<ul>
				<li>Different operators<a id="_idIndexMarker680"/> for chaining in Bash: <a href="https://www.thegeekdiary.com/6-bash-shell-command-line-chaining-operators-in-linux/%0D">https://www.thegeekdiary.com/6-bash-shell-command-line-chaining-operators-in-linux/</a></li>
				<li>Formatting<a id="_idIndexMarker681"/> dates in Bash: <a href="https://www.cyberciti.biz/faq/linux-unix-formatting-dates-for-display/">https://www.cyberciti.biz/faq/linux-unix-formatting-dates-for-display/</a></li>
			</ul>
			<h1 id="_idParaDest-211"><a id="_idTextAnchor217"/>Manipulating shell script input, output, and errors </h1>
			<p>There are only a few things that are as pragmatic as the idea behind the concept of standard input and standard output on Linux. </p>
			<p>Since the start of Unix, the idea of interoperability between different applications and tools installed on a system was one of the primary prerequisites that every script, tool, and application had to follow. </p>
			<p>Simply put, if you wrote any tool on a system, you could count on three separate channels of communication<a id="_idIndexMarker682"/> to your surroundings. Based on the concept of ANSI C input/output streams called <strong class="bold">standard output</strong> and <strong class="bold">standard input</strong>, everything that runs in a shell<a id="_idIndexMarker683"/> can communicate in three ways – it can receive inputs from standard input, it can output results and information to standard output, and it can report errors<a id="_idIndexMarker684"/> to a separate output that is marked just for this task as <strong class="bold">error output</strong>. </p>
			<p>Pair this idea with the concept that every tool should output text-only information with minimal formatting, and should be ready to accept text input if it is required, and you have a framework that is simple but amazingly robust and portable. </p>
			<h2 id="_idParaDest-212"><a id="_idTextAnchor218"/>Getting ready</h2>
			<p>When we create<a id="_idIndexMarker685"/> scripts, we are going to use these concepts a lot, in a myriad<a id="_idIndexMarker686"/> of different ways. Before we can do that, we need to make sure<a id="_idIndexMarker687"/> that we understand what inputs and outputs actually exist and are available to us, and what is the usual way of using them when scripting. After that, we will deal with some recommendations and how to conform to certain well-established best practices when it comes to user interaction. </p>
			<p>Even before that, we need to define some things. Standard input, output, and error are just<a id="_idIndexMarker688"/> special cases of something called <strong class="bold">file descriptors</strong>. To simplify things a bit, we will not be spending too much time on what a file descriptor actually is; for the sake of this chapter, let's just say that it is a way of referencing an open file. </p>
			<p>Since in Linux everything is considered to be a file, we are basically just assigning a number to something we can write to, read from, or both read and write to, depending on the context. Obviously, our options on reading and writing depend on what the actual device referenced is. </p>
			<p>By default, your script will <em class="italic">open</em> communication with three <em class="italic">files</em> that it can use. Standard input is going to be connected to a keyboard; your script is going to accept information from the keyboard unless you change it to something else, such as some other file or output of another script or application. </p>
			<p>Standard output is, by default, set to the <em class="italic">console</em> or the screen you are running your script from. In some circumstances, we will also call a screen connected<a id="_idIndexMarker689"/> physically to your server a <strong class="bold">console</strong>, but that is not part of what we are dealing with right now. The reason we are mentioning this is to avoid unnecessary confusion. </p>
			<p>We cannot read from a screen or write to a keyboard, and this is why we are usually referring to them as <em class="italic">consoles</em>, which is a common name that more or less describes both the keyboard and the screen. There is a lot more to learn here, but for now, we are going to leave it at this. </p>
			<h2 id="_idParaDest-213"><a id="_idTextAnchor219"/>How to do it…</h2>
			<p>To better explain these two things, you can<a id="_idIndexMarker690"/> do something simple – run a command<a id="_idIndexMarker691"/> called <strong class="source-inline">cat</strong> without any arguments. When executed like this, any command including <strong class="source-inline">cat</strong> will accept standard input and then output the result to the standard<a id="_idIndexMarker692"/> output. In this particular case, <strong class="source-inline">cat</strong> is going to do it one line at a time, since it waits for a line separator before it outputs information. </p>
			<p>In reality, this means that <strong class="source-inline">cat</strong> is going to echo whatever you type in, line by line, until you use <em class="italic">Ctrl </em>+<em class="italic"> D</em> to signal<a id="_idIndexMarker693"/> a special character called <strong class="bold">End of Transmission</strong> (<strong class="bold">EOT</strong>), which tells the system that you decided to end typing. </p>
			<p>This will end the execution of the application. In the screenshot, it looks like we typed each line twice; in fact, one is our input, and the other one is the output from the command: </p>
			<div>
				<div id="_idContainer230" class="IMG---Figure">
					<img src="Images/Figure_9.3_B16269.jpg" alt="Figure 9.3 – cat – the simplest command to demonstrate standard input and output&#13;&#10;" width="947" height="312"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.3 – cat – the simplest command to demonstrate standard input and output</p>
			<p>There is also standard error, which also defaults to the screen but is a separate stream of data; if we output something to standard error, it will be displayed in a way that looks exactly the same as standard output, but that can be redirected if we need to. </p>
			<p>The reason why there are two separate streams handling output is simple – we usually want to have some data as the result of our script, but we do not want errors to be part of it. In this case, we can redirect data into some file and redirect errors to the screen, or even to another file, and then deal with them later. </p>
			<p>Now, remember when we mentioned<a id="_idIndexMarker694"/> that standard input, output, and error are special instances<a id="_idIndexMarker695"/> of a file descriptor? Bash can actually have nine file descriptors<a id="_idIndexMarker696"/> open at the same time, so there are many more things we can do when writing out something in our scripts. This is, however, rarely done, since almost everything can be accomplished by using only the default ones. For now, just remember the following:</p>
			<ul>
				<li>Standard input is file descriptor number <strong class="source-inline">0</strong>.</li>
				<li>Standard output is file descriptor number <strong class="source-inline">1</strong>. </li>
				<li>Standard error is file descriptor number <strong class="source-inline">2</strong>.</li>
			</ul>
			<p>Why do these numbers matter? By using some special characters in the command line and in our scripts, we can do a lot if we know only these three numbers. First, how do we stop a script displaying something on the screen, and how do we output it to a file instead? By simple use of the <strong class="source-inline">&gt;</strong> character. </p>
			<p>Sometimes, you will see a command line containing <strong class="source-inline">1&gt;</strong> instead of just <strong class="source-inline">&gt;</strong>. This is exactly the same as using a single <strong class="source-inline">&gt;</strong> character, but it is sometimes written like this to make sure you understand that you are redirecting standard output. </p>
			<p>You are probably familiar with this form of redirection, since this is one of the first things you learn when dealing with the command line. An important thing to note is that we can redirect to a file in two different ways, depending on what do we want to do with the file if it already exists. </p>
			<p>By using <strong class="source-inline">&gt; filename</strong>, we are going to redirect whatever the script outputted to the standard output to the file named <strong class="source-inline">filename</strong>. If the file does not exist, it will be created, and if the file exists, it will be <em class="italic">overwritten</em>. </p>
			<p>By using just one more bracket, the <strong class="source-inline">&gt;&gt; filename</strong> redirection will be different in the way it treats files that already exist. If we redirect using this symbol, we are going to <em class="italic">append</em> data into an already existing file; data is going to go to the end of the file. </p>
			<p>Having mentioned <strong class="source-inline">1&gt;</strong>, we need to deal with the way more popular <strong class="source-inline">2&gt;</strong> symbol that represents standard error. When something wrong happens in our script, it is going to output it as an error. Usually, you will notice it if you just redirect the script output to a file; if you fail to mention <strong class="source-inline">2&gt;</strong>, you will see that only errors are going to appear on the screen, while everything else is going to end up in the file. </p>
			<p>If we actually<a id="_idIndexMarker697"/> want to output the result<a id="_idIndexMarker698"/> of errors in a particular file, we can<a id="_idIndexMarker699"/> do that by using <strong class="source-inline">2&gt; errorfilename</strong>, and the script will write its errors into a file called <strong class="source-inline">errorfilename</strong>. </p>
			<p>There is also the possibility that we want to output everything into a single file, and there are two ways to do this. One is to do both redirections in one command line separately, using the same filename for both redirects. This has its own advantage of being easy to read when we are trying to understand where the outputs are going. </p>
			<p>The main disadvantage is that this redirection is probably the most used one when it comes to dealing with scripts, especially when we run them unattended, and this makes it <em class="italic">harder</em> to read in most environments. Of course, there is a simple solution to this – instead of using two separate redirects, we can use a single one by using the <strong class="source-inline">&amp;&gt; filename</strong>. In the Bash environment, this means that we want to redirect both standard error and output to the same file: </p>
			<p class="source-code">demo@ubuntu:~/scripting$ bash helloworld.sh 1&gt; outputfile \</p>
			<p class="source-code">2&gt;errorfile</p>
			<p class="source-code">demo@ubuntu:~/scripting$ bash helloworld.sh &amp;&gt;outputfile</p>
			<p>Please note that this trick works only if redirecting both the output and errors to one file; if the output files are different, we need to specify them explicitly one by one.</p>
			<p>When we started discussing outputs, we said that there can be more than just the three predefined ones, and the way to handle them is logical. If we decide to redirect something outputted to file descriptor number <strong class="source-inline">5</strong>, the way to handle it in the command line would be to just redirect <strong class="source-inline">5&gt; filename</strong>. This is something you will not see every day, but it can be extremely useful if you need to create more than one log file or need to create different outputs to different destinations from the same script. This approach is seldom used, since it is much easier to handle redirection directly from the script, and by using variables in the script, anyone debugging your scripts is going to have a much easier job.</p>
			<p>Up to this point, we were dealing with redirection from <em class="italic">outside</em> of our scripts. It is time to move on to how to use this in our everyday work. </p>
			<p>The main thing that we are going to do using redirection is to log things. There are a couple of approaches here. One is to simply use the <strong class="source-inline">echo</strong> command in the script and then do the redirection<a id="_idIndexMarker700"/> for the whole script – for example, we can create a simple<a id="_idIndexMarker701"/> script that just prints<a id="_idIndexMarker702"/> four lines of text: </p>
			<p class="source-code">#!/usr/bin/bash</p>
			<p class="source-code">echo "First line of text!"</p>
			<p class="source-code">echo "Second line of text!"</p>
			<p class="source-code">echo "Third line of text!"</p>
			<p class="source-code">echo "Fourth line of text!"</p>
			<p>Let's name it <strong class="source-inline">simpleecho.sh</strong> and run it using Bash: </p>
			<p class="source-code">demo@ubuntu:~/scripting$ bash simpleecho.sh </p>
			<p class="source-code">First line of text!</p>
			<p class="source-code">Second line of text!</p>
			<p class="source-code">Third line of text!</p>
			<p class="source-code">Fourth line of text!</p>
			<p class="source-code">demo@ubuntu:~/scripting$</p>
			<p>Now, we are going to redirect it to a file: </p>
			<p class="source-code">demo@ubuntu:~/scripting$ bash simpleecho.sh &gt; testfile</p>
			<p class="source-code">demo@ubuntu:~/scripting$ cat testfile </p>
			<p class="source-code">First line of text!</p>
			<p class="source-code">Second line of text!</p>
			<p class="source-code">Third line of text!</p>
			<p class="source-code">Fourth line of text!</p>
			<p>Okay, we can see that our file now contains output for the <strong class="source-inline">echo</strong> commands. For the sake of showing how errors work, we are going to insert an intentional error into our script: </p>
			<p class="source-code">#!/usr/bin/bash</p>
			<p class="source-code">echo "First line of text!"</p>
			<p class="source-code">echo "Second line of text!"</p>
			<p class="source-code">echo "Third line of text!"</p>
			<p class="source-code">bad_command</p>
			<p class="source-code">echo "Fourth line of text!"</p>
			<p>Now, we are going to do the same<a id="_idIndexMarker703"/> procedure again, first<a id="_idIndexMarker704"/> starting the script and then<a id="_idIndexMarker705"/> redirecting it to see what happened: </p>
			<p class="source-code">demo@ubuntu:~/scripting$ bash simpleecho.sh</p>
			<p class="source-code">First line of text!</p>
			<p class="source-code">Second line of text!</p>
			<p class="source-code">Third line of text!</p>
			<p class="source-code">simpleecho.sh: line 5: bad_command: command not found</p>
			<p class="source-code">Fourth line of text!</p>
			<p class="source-code">demo@ubuntu:~/scripting$ bash simpleecho.sh &gt; testfile</p>
			<p class="source-code">simpleecho.sh: line 5: bad_command: command not found</p>
			<p class="source-code">demo@ubuntu:~/scripting$ bash simpleecho.sh &amp;&gt; testfile</p>
			<p class="source-code">demo@ubuntu:~/scripting$ cat testfile </p>
			<p class="source-code">First line of text!</p>
			<p class="source-code">Second line of text!</p>
			<p class="source-code">Third line of text!</p>
			<p class="source-code">simpleecho.sh: line 5: bad_command: command not found</p>
			<p class="source-code">Fourth line of text!</p>
			<p>The main thing to take away here is that error output is always separate from standard output, so we are not going to see errors in our file unless we specifically redirect them.</p>
			<p>Everything up to this point was simple, since our script was using just standard output. Often, communicating with users is not so simple because we want to have our script to be able to provide some information on screen and to a special log file. Things are similar when working with unattended<a id="_idIndexMarker706"/> scripts; having the ability to redirect script output<a id="_idIndexMarker707"/> to a certain file is nice, but more often, we are going to make our script<a id="_idIndexMarker708"/> use a particular log file by itself, without the need for the user or the administrator to do any redirection when executing the script. </p>
			<p>The process required to do this is remarkably simple – we can use the redirection at the command level to redirect our output to a file. There is only one thing you have to remember here. Redirection into a file is limited to a single command; if you redirect anything, the file is going to be closed as soon as the command finishes. This is important primarily because you will always need to append to a file; if you forget to do so, that file is going to get rewritten with new data, making it useless as a log. Since a log is usually used to track multiple executions of a script or service, you will almost universally append to files. </p>
			<h2 id="_idParaDest-214"><a id="_idTextAnchor220"/>How it works…</h2>
			<p>Let's now expand our initial script, adding a little bit of logging. What we are going to do is write separate logs that will contain information about the actions that the script took while running. We are going to write this information to a log file located in the directory that the script was invoked from. This means that our script will at any one time be able to use three separate channels for output; in addition to standard output and standard error, we are also using our log file. The big difference between log files and standard output is that our log is hardcoded, and there is no way of redirecting it to another file. Of course, a solution for this problem exists, but we are not going to spend too much time on it; we already said it is possible to use one of the other file descriptors and map output to it, forwarding the output to whatever stream we need later. This is seldom used, since it requires additional attention when running a script: </p>
			<p class="source-code">#!/usr/bin/bash</p>
			<p class="source-code">echo "We are adding four lines of text!" &gt;&gt; simplelog.txt</p>
			<p class="source-code">echo "First line of text!"</p>
			<p class="source-code">echo "Second line of text!"</p>
			<p class="source-code">echo "Third line of text!"</p>
			<p class="source-code">echo "Fourth line of text!"</p>
			<p class="source-code">echo "Exiting, end of script!" &gt;&gt; simplelog.txt</p>
			<p>This approach gives<a id="_idIndexMarker709"/> us additional flexibility, since we do not have to forward<a id="_idIndexMarker710"/> standard output in order to have logs; our script already<a id="_idIndexMarker711"/> does that. This means that we can start the script either from the command line or as an unattended task and get the same results in the logs. Of course, we can always use redirection and make sure that every output is written and saved. </p>
			<h3>There's more…</h3>
			<ul>
				<li>Standard input<a id="_idIndexMarker712"/> and output (in C): https://www.technologyuk.net/computing/software-development/computer-programming/c-programming/basic-io.shtml</li>
				<li>Standard<a id="_idIndexMarker713"/> input and output (in Bash, with examples): <a href="https://tldp.org/LDP/abs/html/io-redirection.html%0D">https://tldp.org/LDP/abs/html/io-redirection.html</a></li>
			</ul>
			<h1 id="_idParaDest-215"><a id="_idTextAnchor221"/>Shell script hygiene</h1>
			<p>Commenting is not just something you can do; it's an art by itself. In this part of the chapter, we are going to deal with comments<a id="_idIndexMarker714"/> in order to make your life easier when writing scripts, but the advice and best practices that are given here are easily used in any programming language that we can think of. Really understanding how to comment in a useful way is something that you're going to need to learn, since it will help anybody going to use your scripts after you are done writing them.</p>
			<p>So, what are comments? Possibly the easiest way to describe them is to say that they are documentation on what the script is intended to do, how the script works, and who has created the script, and they provide more information on technical details of the script, such as when it was created. </p>
			<p>Commenting is something that you should automatically want to do. Nobody is perfect and nobody has a perfect memory. Comments are there to help you remember what you did inside some script and to provide anybody else with guidance on how the script works and what the different things are that they need to know if they need to change anything in the script. </p>
			<p>One more important point is that commenting<a id="_idIndexMarker715"/> is not the same as providing documentation. Sometimes, people are going to say that they don't need documentation because they already have comments in their code, but this is completely wrong. Unless you're talking about a script that has only 10 lines of code or so, comments are going to help you to understand what the script is doing without looking up the whole documentation, which saves you a lot of time. </p>
			<h2 id="_idParaDest-216"><a id="_idTextAnchor222"/>Getting ready</h2>
			<p>So, let's now talk about different types of comments. When writing code, there is always a part that involves commenting on individual procedures or parts of the script, expected input and output, data types, and data in general. </p>
			<p>In Bash, comments are universally started by the <strong class="source-inline">#</strong> sign. Bash does not recognize multiline comments, unlike some other programming languages. What this means is that we need to pay attention so that every line that contains a comment starts with <strong class="source-inline">#</strong>. The only exception of sorts is the first line in the script, which contains the interpreter that is going to run the script, but the interpreter continues working after that line, so we can say that every line that starts with <strong class="source-inline">#</strong> is actually a comment. The shell is going to ignore everything inside the comment or, to be more precise, it is going to completely ignore the lines that contain the comment. So, understand that the comments are written for you and for other people that are going to be dealing with your scripts. Try to make them easy to understand, precise, and avoid repeating what can actually be deduced from the command itself. For example, if you have a command that is echoing something, try not saying, <em class="italic">Okay, this command is going to echo…</em> whatever text you're trying to output to a user, but try to explain why. This is especially useful when commenting on cryptic output that contains a lot of variables. </p>
			<p>You can and should write comments in front of every block of code in your script, but you should also comment at the start and the end of the script. </p>
			<h2 id="_idParaDest-217"><a id="_idTextAnchor223"/>How to do it…</h2>
			<p>Let's start with the beginning<a id="_idIndexMarker716"/> of the script. What should be the first comment? The first line should, of course, be the name of the interpreter, and after that, we usually give information about the script itself. Generally, the script should start with a comment that gives information on who wrote it, when, and if it is part of the project that is responsible for the script itself. </p>
			<p>This part should also state technical things such as licensing distribution, limitation on warranties, and who is and is not allowed to use the script. </p>
			<p>Having done the header, we should also deal with the arguments and information on how a script should be run and what to expect in terms of input. If there is something special about the input, such as expected types, the number of arguments, or some prerequisites that need to exist or run before the script is running, they should be stated somewhere at the beginning of the script. </p>
			<p>Now, we come to the functions. We are going to deal with the concept of functions later, but we do need to talk about how to comment on them, since this also applies to any other block of code. This is because functions are, by themselves, modular and written as a separate block of code. </p>
			<p>Sharing something separated inside a function gives us the opportunity to comment. We should use this part of the comments to describe what the function or the module does, what variables we are going to change and need, the arguments that your function is going to take, what the function is going to do, and what the output to the function is going to be. If we are dealing with some sort of nonstandard output – for example, if we are dealing with logging to a separate file – we should state that in the function header. We should also note all the return codes that the function outputs if it changes the exit status of the script. </p>
			<p>There are useful ways of using comments to create reminders for yourself and for others to inform what still needs<a id="_idIndexMarker717"/> to be done in a script, which are called <strong class="bold">to do comments</strong>. They are usually written in capital letters – <strong class="bold">TODO</strong>. </p>
			<p>We should also note that there is something called a <strong class="source-inline">heredoc</strong> notation that is sometimes used when we need to create large blocks of comments. This notation uses shell redirection in a very specific way so that it can provide the header and the footer for the comment block without using common signs. We're going to provide you with an example of this notation, since you will run into it when you analyze other people's scripts, but we're not going to use it in our scripts. The main reason for that is that it tends to make scripts less readable. </p>
			<p>For example, this is a perfectly<a id="_idIndexMarker718"/> valid way of creating a comment: </p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code">echo "Comment block starts after this!"</p>
			<p class="source-code">&lt;&lt;COMMENTBLOCK</p>
			<p class="source-code">    Comment line</p>
			<p class="source-code">    Another comment line</p>
			<p class="source-code">    Third one</p>
			<p class="source-code">COMMENTBLOCK</p>
			<p class="source-code">echo "This is going to get executed"</p>
			<p>Now, what do we actually comment? </p>
			<p>Let's start with some general things: </p>
			<ul>
				<li>State clearly who wrote the script and when was it created.</li>
				<li>Version your script – if there are any changes, update the version so that you can track which script you are using on different computers.</li>
				<li>Explain any complicated part of the code – things such as regular expressions, calling outside sources, and general references to anything outside of your script should be commented. </li>
				<li>Comment on individual blocks of code.</li>
				<li>Clearly note all the old parts of code that you commented out and left in your script. </li>
			</ul>
			<p>We'll talk a bit about all these points. </p>
			<p>Clearly marking the script author and creation date is crucial. Your scripts are probably going to end up being maintained by people other than you. The worst thing that can happen to you when you open a script with a couple of hundred lines of code is not knowing who to talk to when something goes wrong. Some people think that they are going to avoid being constantly pestered by other admins by not signing the script, but this is simply wrong. You wrote that script; be proud of it.</p>
			<p>After you mention<a id="_idIndexMarker719"/> the author, always note when the script was created. This helps people prioritize possible changes, especially to some outside resources that you may be using in the script itself. Also, write when the last change was made, since it is relevant information for everybody maintaining the script, including you. </p>
			<p>After mentioning changes, learn to version. Versioning<a id="_idIndexMarker720"/> is a way of keeping track of different changes that you make in a script and making sure you know which version you are using at any given moment. Versioning itself is a simple concept of using a scheme that enables you to track how your script progresses and what has changed. </p>
			<p>There are a couple of ways this can be done, since there is no official standard on how to write down versions, although a lot of people<a id="_idIndexMarker721"/> tend to use semantic versioning (<strong class="source-inline">https://semver.org/</strong>). Usually, versions more or less strictly follow either changes in the source code or the time when a particular version was created. Both schemes have their merits, but when writing scripts, we think that tracking changes is a much better idea, since we can deduce very little from versions using dates as a reference. </p>
			<p>Before we commit to any versioning scheme, we will quickly go over some examples. The way we handle versions in different software is directly related to the type of software we are dealing with and the number of changes between versions. </p>
			<p>General-purpose applications usually stick to a <em class="italic">normal</em> versioning scheme that has a structure using two numbers representing major and minor versions of the application. For example, we can have App v1.0, then App v1.1, then App v2.0, and so on. The first number represents major changes made to the applications; the second number usually represents minor changes or bug fixes. This is practically the norm for large applications on the market today. </p>
			<p>In our scripts, we are going to use the same scheme, but we are going to implement semantic versioning, so a version will be <strong class="source-inline">1.0.0</strong> or <strong class="source-inline">3.2.4</strong>. The third number represents small changes and makes sense when the number of changes is small, but changes are significant. Note that some applications take this approach to the extreme, so you will inevitably run into things such as Version <strong class="source-inline">2.1.2.1-33.PL2</strong>. When dealing with scripts, this will just complicate your work, so don't do it. </p>
			<p>Another way of dealing with versions is by referencing time, as most operating systems do now. So, for example, there is Ubuntu 20.04 and 20.10, representing releases that came out in April and October of 2020 respectively. The reason for this is the enormous number of changes. Releasing a new version<a id="_idIndexMarker722"/> of an entire operating system each time something changes is simply impossible; you would need to release a new version practically every few hours. </p>
			<p>There is also a sequential numbering scheme that is usually<a id="_idIndexMarker723"/> paired with one of the two approaches we mentioned. Microsoft uses this versioning style, having major releases with names such as <em class="italic">Windows 10</em>, update releases named something such as 20.04 or 21H1 that represent the time of the release, and then using build versions to denote minor changes in the operating systems. </p>
			<p>All of these schemes have their good and bad sides, but whatever you choose, we have only one recommendation – stick to it. Don't mix different versioning schemes, since it will confuse people. </p>
			<p>While talking about versioning, we should also talk about change tracking. When creating <em class="italic">a new version</em> of a script, most of the time, you will make many changes to the script itself. It can be that you will fix bugs, or make your code quicker or more reliable. Some of these changes will have to be documented in some way other than by increasing the version number. This is important in order to remember what you did to the script. There are a couple of ways to do that. One is to keep track of all the changes in a separate file (usually, we use a <strong class="source-inline">ChangeLog</strong> file for that purpose). This makes your comments and the script itself much more legible, but now you have another file whose updates you need to care about. It also makes it easier for everyone else to read the code, as it gets developed and changed with each new version. Another way is to keep a list of all the changes in the script itself. A benefit of that is that you can quickly check what has changed, but your script now has extra text that you need to skip through. There is also a version that keeps the changes in line with the place where they were created, usually before the line of code that contains the changes. </p>
			<p>Let's see how all this looks in practice: </p>
			<p class="source-code">#!/bin/bash</p>
			<p class="source-code"># V1.2 by Author, under GPLV2 licence</p>
			<p class="source-code"># V1.0 - Hello world script, V1.0 1/8/2021</p>
			<p class="source-code"># V1.1 - Added changes to comments on 2/8/2021 </p>
			<p class="source-code"># V1.2 - Added more changes to comments 3/8/2021 </p>
			<p class="source-code">echo "Hello World!"</p>
			<p>We are going to stop here, since we will cover<a id="_idIndexMarker724"/> this and a lot more in further chapters, learning as we go along. </p>
			<h2 id="_idParaDest-218"><a id="_idTextAnchor224"/>There's more…</h2>
			<ul>
				<li>Commenting<a id="_idIndexMarker725"/> in Bash – examples: https://git.savannah.gnu.org/cgit/bash.git/tree/examples</li>
				<li>Identifying files<a id="_idIndexMarker726"/> in Linux: <a href="https://man7.org/linux/man-pages/man4/magic.4.html">https://man7.org/linux/man-pages/man4/magic.4.html</a></li>
			</ul>
		</div>
	</div></body></html>