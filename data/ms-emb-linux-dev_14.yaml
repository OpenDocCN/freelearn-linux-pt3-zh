- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Interfacing with Device Drivers
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与设备驱动程序接口
- en: Kernel device drivers are the mechanism by which the underlying hardware is
    exposed to the rest of the system. As a developer of embedded systems, you need
    to know how these device drivers fit into the overall architecture and how to
    access them from user space programs. Your system will probably have some novel
    pieces of hardware and you will have to work out a way of accessing them. In many
    cases, you will find that there are device drivers provided for you and you can
    achieve everything you want without writing any kernel code. For example, you
    can manipulate GPIO pins and LEDs using files in `sysfs`, and there are libraries
    you can use to access serial buses including **SPI** (**Serial Peripheral Interface**)
    and **I2C** (**Inter-Integrated Circuit**).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 内核设备驱动程序是将底层硬件暴露给系统其余部分的机制。作为嵌入式系统开发人员，你需要了解这些设备驱动程序如何融入整体架构，以及如何从用户空间程序访问它们。你的系统可能会有一些新颖的硬件，你需要找出一种访问它们的方法。在许多情况下，你会发现有现成的设备驱动程序可以使用，而你无需编写任何内核代码就能实现你想要的功能。例如，你可以通过`sysfs`中的文件操作GPIO引脚和LED，并且可以使用库来访问包括**SPI**（**串行外设接口**）和**I2C**（**集成电路之间接口**）在内的串行总线。
- en: There are many places to find out how to write a device driver, but few tell
    you why you would want to and the choices you have in doing so. This is what I
    want to cover here. However, remember that this is not a book dedicated to writing
    kernel device drivers and that the information given here is to help you navigate
    the territory but not necessarily set up home there. There are many good books
    and blog posts that will help you write device drivers, some of which are listed
    at the end of this chapter in the *Further study* section.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多地方可以了解如何编写设备驱动程序，但很少有地方会告诉你为什么要编写设备驱动程序，以及你在编写时的选择。这正是我想在这里讨论的内容。然而，请记住，这不是一本专门讲解编写内核设备驱动程序的书籍，这里提供的信息是帮助你了解相关领域，但不一定能让你在其中扎根。很多优秀的书籍和博客文章可以帮助你编写设备驱动程序，其中一些将在本章末的*进一步学习*部分列出。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Role of device drivers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备驱动程序的作用
- en: Character devices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符设备
- en: Block devices
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 块设备
- en: Network devices
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络设备
- en: Finding out about drivers at runtime
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时了解驱动程序
- en: Finding the right device driver
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找合适的设备驱动程序
- en: Device drivers in user space
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户空间中的设备驱动程序
- en: Writing a kernel device driver
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写内核设备驱动程序
- en: Discovering the hardware configuration
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现硬件配置
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with the examples, make sure you have the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随示例进行操作，请确保你有以下设备：
- en: A Linux-based host system
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于Linux的主机系统
- en: A microSD card reader and card
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一张microSD卡读卡器和卡
- en: A BeaglePlay
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BeaglePlay
- en: A 5V USB-C power supply capable of delivering 3A
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种能够提供3A电流的5V USB-C电源
- en: An Ethernet cable and router with an available port for network connectivity
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一根以太网电缆和一个有可用端口的路由器，用于网络连接
- en: 'The code used in this chapter can be found in the chapter folder in this book’s
    GitHub repository: [https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter11](https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter11).'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用的代码可以在本书GitHub仓库的章节文件夹中找到：[https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter11](https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development/tree/main/Chapter11)。
- en: Role of device drivers
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设备驱动程序的作用
- en: As I mentioned in [*Chapter 4*](Chapter_04.xhtml#_idTextAnchor096), one of the
    functions of the kernel is to encapsulate the many hardware interfaces of a computer
    system and present them in a consistent manner to user space programs. The kernel
    has frameworks designed to make it easy to write a device driver, which is the
    piece of code that mediates between the kernel above and the hardware below. A
    device driver may be written to control physical devices such as a UART or an
    MMC controller, or it may represent a virtual device such as the null device (`/dev/null`)
    or a RAMdisk. One driver may control multiple devices of the same kind.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在[*第4章*](Chapter_04.xhtml#_idTextAnchor096)中提到的，内核的一个功能是封装计算机系统的众多硬件接口，并以一致的方式向用户空间程序呈现它们。内核有一些框架，旨在简化设备驱动程序的编写，设备驱动程序是连接上层内核和下层硬件的代码。设备驱动程序可以控制物理设备，例如UART或MMC控制器，或者它可以代表虚拟设备，如空设备(`/dev/null`)或RAM磁盘。一个驱动程序可能控制多个相同类型的设备。
- en: Kernel device driver code runs at a high privilege level, as does the rest of
    the kernel. It has full access to the processor address space and hardware registers.
    It can handle interrupts and DMA transfers. It can also make use of the sophisticated
    kernel infrastructure for synchronization and memory management. However, you
    should be aware that there is a downside to this; if something goes wrong in a
    buggy driver, it can go really wrong and bring the system down.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 内核设备驱动代码以较高的特权级别运行，和其余的内核一样。它可以完全访问处理器地址空间和硬件寄存器。它能够处理中断和DMA传输。它还可以利用复杂的内核基础设施来进行同步和内存管理。然而，你应该注意，这也有缺点；如果驱动程序有问题，可能会导致系统崩溃。
- en: Consequently, there is a principle that device drivers should be as simple as
    possible by just providing information to applications (where the real decisions
    are made). You often hear this being expressed as *no policy in the kernel*. It
    is the responsibility of user space to set the policy that governs the overall
    behavior of the system. For example, loading kernel modules in response to external
    events, such as plugging in a new USB device, is the responsibility of the `udev`
    user space program, not the kernel. The kernel just supplies a means of loading
    a kernel module.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，有一个原则，设备驱动程序应该尽可能简单，仅仅为应用程序提供信息（实际决策由应用程序做出）。你经常会听到这个被表达为*内核中没有策略*。制定管理系统整体行为的策略是用户空间的责任。例如，响应外部事件（如插入新USB设备）来加载内核模块的任务是`udev`用户空间程序的责任，而不是内核的。内核只是提供了一种加载内核模块的手段。
- en: 'In Linux, there are three main types of device drivers:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，设备驱动程序主要有三种类型：
- en: '**Character**: This is for unbuffered I/O with a rich range of functions and
    a thin layer between the application code and the driver. It is the first choice
    when implementing custom device drivers.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字符设备**：这是为无缓冲I/O提供的，具有丰富的功能范围，且在应用代码和驱动程序之间有一个薄层。在实现自定义设备驱动时，它是首选。'
- en: '**Block**: This has an interface tailored for block I/O to and from mass storage
    devices. There is a thick layer of buffering designed to make disk reads and writes
    as fast as possible, which makes it unsuitable for anything else.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**块设备**：这是为大容量存储设备的块I/O设计的接口。它有一层厚厚的缓冲层，旨在使磁盘读写尽可能快，这使得它不适用于其他用途。'
- en: '**Network**: This is similar to a block device but is used for transmitting
    and receiving network packets rather than disk blocks.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络设备**：这类似于块设备，但用于传输和接收网络数据包，而不是磁盘块。'
- en: There is also a fourth type that presents itself as a group of files in one
    of the pseudo filesystems. For example, you might access the GPIO driver through
    a group of files in `/sys/class/gpio`, as I will describe later in this chapter.
    Let’s begin by looking at these three basic device types in more detail.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 还有第四种类型，它以伪文件系统中的一组文件呈现。例如，你可能通过`/sys/class/gpio`中的一组文件访问GPIO驱动程序，正如我将在本章后面描述的那样。让我们从更详细地了解这三种基本设备类型开始。
- en: Character devices
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符设备
- en: 'Character devices are identified in user space by a special file called a **device
    node**. This filename is mapped to a device driver using the major and minor numbers
    associated with it. Broadly speaking, the **major number** maps the device node
    to a particular device driver, while the **minor number** tells the driver which
    interface is being accessed. For example, the device node of the first serial
    port on the Arm Versatile PB is named `/dev/ttyAMA0` and has a major number of
    `204` and a minor number of `64`. The device node for the second serial port has
    the same major number but the minor number is `65`. We can see the numbers for
    all four serial ports in the directory listing:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 字符设备在用户空间通过一个叫做**设备节点**的特殊文件来标识。这个文件名通过与之关联的主次设备号映射到一个设备驱动程序。广义上说，**主设备号**将设备节点映射到特定的设备驱动，而**次设备号**则告诉驱动程序访问的是哪个接口。例如，Arm
    Versatile PB的第一个串口设备节点命名为`/dev/ttyAMA0`，主设备号为`204`，次设备号为`64`。第二个串口的设备节点主设备号相同，但次设备号是`65`。我们可以在目录列表中看到所有四个串口的设备号：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The list of standard major and minor numbers can be found in the kernel documentation
    in `Documentation/admin-guide/devices.txt`. The list does not get updated very
    often and does not include the `ttyAMA` device described in the preceding paragraph.
    Nevertheless, if you look at the kernel source code in `drivers/tty/serial/amba-pl011.c`,
    you will see where the major and minor numbers are declared:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 标准主次编号的列表可以在内核文档 `Documentation/admin-guide/devices.txt` 中找到。这个列表更新不频繁，且不包括前面提到的
    `ttyAMA` 设备。然而，如果你查看内核源代码中的 `drivers/tty/serial/amba-pl011.c`，你将看到主次编号的声明位置：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Where there is more than one instance of a device, as with the `ttyAMA` driver,
    the convention for forming the name of the device node is to take a base name
    (`ttyAMA`) and append the instance number from `0` to `3`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设备有多个实例，例如 `ttyAMA` 驱动程序，设备节点的命名约定是使用基准名称（`ttyAMA`）并附加实例号，范围从 `0` 到 `3`。
- en: 'As I mentioned in [*Chapter 5*](Chapter_05.xhtml#_idTextAnchor138), device
    nodes can be created in several ways:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在 [*第 5 章*](Chapter_05.xhtml#_idTextAnchor138) 中提到的，设备节点可以通过几种方式创建：
- en: '`devtmpfs`: The device node is created when the device driver registers a new
    device interface using a base name supplied by the driver (`ttyAMA`) and an instance
    number.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`devtmpfs`：当设备驱动程序使用驱动程序提供的基准名称（`ttyAMA`）和实例号注册一个新设备接口时，会创建设备节点。'
- en: '`udev` or `mdev` (without `devtmpfs`): These are essentially the same as `devtmpfs`,
    except that a user space daemon program has to extract the device name from `sysfs`
    and create the node.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`udev` 或 `mdev`（没有 `devtmpfs`）：这些与 `devtmpfs` 基本相同，只是用户空间的守护程序需要从 `sysfs` 中提取设备名称并创建节点。'
- en: '`mknod`: If you are using static device nodes, they are created manually using
    `mknod`.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mknod`：如果你使用静态设备节点，它们是通过 `mknod` 手动创建的。'
- en: You may have gotten the impression from the numbers I used here that both major
    and minor numbers are 8-bit numbers in the range of 0 to 255\. In fact, the major
    number is 12 bits long, which gives valid major numbers from 1 to 4,095, and the
    minor number is 20 bits long, from 0 to 1,048,575.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能从我这里使用的数字中得到这样的印象：主次编号都是 8 位数字，范围从 0 到 255。事实上，主编号是 12 位的，允许有效的主编号范围从 1 到
    4095，而次编号是 20 位的，范围从 0 到 1,048,575。
- en: When you open a character device node, the kernel checks whether the major and
    minor numbers fall into a range registered by a character device driver. If so,
    it passes the call to the driver; otherwise, the `open(2)` call fails. The device
    driver can extract the minor number to find out which hardware interface to use.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打开一个字符设备节点时，内核会检查主次编号是否属于字符设备驱动程序已注册的范围。如果是，内核将调用驱动程序；否则，`open(2)` 调用会失败。设备驱动程序可以提取次编号以确定使用哪个硬件接口。
- en: 'To write a program that accesses a device driver, you need to have some knowledge
    of how it works. In other words, a device driver is not the same as a file: the
    things you do with it change the state of the device. A simple example is the
    `urandom` pseudorandom number generator, which returns bytes of random data every
    time you read it.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写一个访问设备驱动程序的程序，你需要了解它的工作原理。换句话说，设备驱动程序不同于文件：你对它所做的操作会改变设备的状态。一个简单的例子是 `urandom`
    伪随机数生成器，每次读取时都会返回一组随机数据字节。
- en: 'Here is a program that does just this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个实现此功能的程序：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can find the full source code and a BitBake recipe for this program in the
    `MELD/Chapter11/meta-device-drivers/recipes-local/read-urandom` directory.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 `MELD/Chapter11/meta-device-drivers/recipes-local/read-urandom` 目录下找到该程序的完整源代码和
    BitBake 配方。
- en: The nice thing about the Unix driver model is that once we know that there is
    a device named `urandom`, then every time we read from it, it returns a fresh
    set of pseudorandom data, so we don’t need to know anything else about it. We
    can just use standard functions such as `open(2)`, `read(2)`, and `close(2)`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Unix 驱动程序模型的优点是，一旦我们知道有一个名为 `urandom` 的设备，每次从中读取时，它都会返回一组新的伪随机数据，因此我们无需了解关于它的其他信息。我们可以直接使用标准函数，如
    `open(2)`、`read(2)` 和 `close(2)`。
- en: '**TIP**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: You could use the stream I/O functions known as `fopen(3)`, `fread(3)`, and
    `fclose(3)` instead, but the buffering implicit in these functions often causes
    unexpected behavior. For example, `fwrite(3)` usually only writes to the user
    space buffer, not to the device. You need to call `fflush(3)` to force the buffer
    to be written out. Therefore, it is best to not use stream I/O functions when
    calling device drivers.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用流 I/O 函数，如 `fopen(3)`、`fread(3)` 和 `fclose(3)`，但这些函数中隐含的缓冲机制往往会导致意外的行为。例如，`fwrite(3)`
    通常只写入用户空间缓冲区，而不是设备。你需要调用 `fflush(3)` 强制将缓冲区写出。因此，最好不要在调用设备驱动程序时使用流 I/O 函数。
- en: Most device drivers employ a character interface. Mass storage devices are a
    notable exception. Reading and writing to disk requires a block interface for
    maximum speed.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数设备驱动程序使用字符接口。大容量存储设备是一个显著的例外。读取和写入磁盘需要使用块接口以获得最大速度。
- en: Block devices
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 块设备
- en: Block devices are also associated with a device node that also has major and
    minor numbers.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 块设备还与一个设备节点相关联，该节点也具有主设备号和次设备号。
- en: '**Tip**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: Although character and block devices are identified using major and minor numbers,
    they are in different namespaces. A character driver with a major number of 4
    is in no way related to a block driver with a major number of 4\.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管字符设备和块设备是通过主设备号和次设备号来标识的，但它们位于不同的命名空间中。主设备号为 4 的字符驱动程序与主设备号为 4 的块驱动程序没有任何关系。
- en: 'With block devices, the major number is used to identify the device driver,
    and the minor number is used to identify the partition. Let’s look at the MMC
    driver on the BeaglePlay:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于块设备，主设备号用于标识设备驱动程序，次设备号用于标识分区。让我们来看一下 BeaglePlay 上的 MMC 驱动程序：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here, `mmcblk0` is the eMMC chip, which has two partitions, and `mmcblk1` is
    the microSD card slot, which has a card also with two partitions. The major number
    for the MMC block driver is `179` (you can look it up in `devices.txt`). The minor
    numbers are used in ranges to identify different physical MMC devices and the
    partitions of the storage medium that are on that device. In the case of the MMC
    driver, the ranges are eight minor numbers per device: the minor numbers from
    `0` to `7` are for the first device, the numbers from `8` to `15` are for the
    second, and so on. Within each range, the first minor number represents the entire
    device as raw sectors, and the others represent up to seven partitions. On the
    BeaglePlay’s eMMC chip, there are two 4 MB areas of memory reserved for use by
    a bootloader. These are represented as two devices known as `mmcblk0boot0` and
    `mmcblk0boot1`, and they have minor numbers of `256` and `512`, respectively.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`mmcblk0` 是 eMMC 芯片，它有两个分区，而 `mmcblk1` 是 microSD 卡槽，卡槽上也有一张带有两个分区的卡。MMC
    块设备驱动的主设备号是 `179`（你可以在 `devices.txt` 文件中查找）。次设备号用于标识不同的物理 MMC 设备以及该设备上存储介质的分区。在
    MMC 驱动程序的情况下，每个设备的次设备号范围为八个：`0` 到 `7` 的次设备号用于第一个设备，`8` 到 `15` 用于第二个设备，以此类推。在每个范围内，第一个次设备号表示整个设备的原始扇区，其他次设备号表示最多七个分区。在
    BeaglePlay 的 eMMC 芯片上，有两个 4 MB 的内存区域被保留用于引导加载程序。这两个区域分别表示为 `mmcblk0boot0` 和 `mmcblk0boot1`，其次设备号分别为
    `256` 和 `512`。
- en: As another example, you are probably aware of the SCSI disk driver known as
    `sd`, which is used to control a range of disks that use the SCSI command set,
    including SCSI, SATA, USB mass storage, and **Universal Flash Storage** (**UFS**).
    It has the major number `8` and ranges of `16` minor numbers per interface or
    disk.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是，你可能熟悉名为 `sd` 的 SCSI 磁盘驱动程序，它用于控制使用 SCSI 命令集的一系列磁盘，包括 SCSI、SATA、USB 大容量存储和
    **通用闪存存储** (**UFS**) 。它的主设备号是 `8`，每个接口或磁盘有 `16` 个次设备号范围。
- en: The minor numbers from `0` to `15` are for the first interface with device nodes
    named `sda` up to `sda15`; the numbers from `16` to `31` are for the second disk
    with device nodes `sdb` up to `sdb15`; and so on. This continues up to the 16th
    disk from `240` to `255` with the node name `sdp`. There are other major numbers
    reserved for them because SCSI disks are so popular, but we needn’t worry about
    that here.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `0` 到 `15` 的次设备号用于第一个接口，设备节点名称为 `sda` 到 `sda15`；从 `16` 到 `31` 的次设备号用于第二个磁盘，设备节点名称为
    `sdb` 到 `sdb15`；以此类推。这一过程一直持续到第 16 个磁盘，从 `240` 到 `255`，设备节点名称为 `sdp`。由于 SCSI 磁盘非常流行，因此为它们保留了其他主设备号，但在这里我们不需要担心这个。
- en: Both the MMC and SCSI block drivers expect to find a partition table at the
    start of the disk. The partition table is created using utilities such as `fdisk`,
    `sfidsk`, and `parted`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: MMC 和 SCSI 块驱动程序都期望在磁盘的开始处找到分区表。分区表可以通过 `fdisk`、`sfidsk` 和 `parted` 等工具创建。
- en: A user space program can open and interact with a block device directly via
    the device node. This is not a common thing to do, though. It is usually only
    done to perform administrative operations such as creating partitions, formatting
    a partition with a filesystem, and mounting. Once the filesystem has been mounted,
    you interact with the block device indirectly through the files in that filesystem.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 用户空间程序可以通过设备节点直接打开和与块设备交互。尽管如此，这并不是一个常见的操作，通常只用于执行管理操作，例如创建分区、使用文件系统格式化分区和挂载。一旦文件系统被挂载，您通过该文件系统中的文件间接与块设备交互。
- en: Most block devices will have a kernel driver that works, so we rarely need to
    write our own. The same goes for network devices. Just like a filesystem abstracts
    the details of a block device, the network stack eliminates the need to interact
    directly with a network device.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数块设备都将有一个有效的内核驱动程序，因此我们很少需要编写自己的驱动程序。网络设备也是如此。就像文件系统抽象了块设备的细节一样，网络堆栈消除了直接与网络设备交互的需求。
- en: Network devices
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络设备
- en: 'Network devices are not accessed through device nodes, and they do not have
    major and minor numbers. Instead, a network device is allocated a name by the
    kernel based on a string and an instance number. Here is an example of the way
    a network driver registers an interface:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 网络设备不通过设备节点访问，也没有主要和次要编号。相反，内核基于字符串和实例号为网络设备分配名称。以下是网络驱动程序注册接口的示例方式：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This creates a network device named `net0` the first time it is called, `net1`
    the second time, and so on. More common names include `lo`, `eth0`, `enp2s0`,
    `wlan0,` and `wlp1s0`. Note that this is the name it starts off with; device managers
    such as `udev` may change it to something different later.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在第一次调用时创建名为`net0`的网络设备，第二次调用时创建`net1`，依此类推。更常见的名称包括`lo`、`eth0`、`enp2s0`、`wlan0`和`wlp1s0`。请注意，这是它启动时的名称；设备管理器如`udev`可能会稍后将其更改为其他名称。
- en: Usually, the network interface name is only used when configuring the network
    using utilities such as `ip` to establish a network address and route. Thereafter,
    you interact with the network driver indirectly by opening sockets and letting
    the network layer decide how to route them to the right interface.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，网络接口名称仅在使用诸如`ip`等实用程序配置网络地址和路由时使用。之后，您通过打开套接字间接与网络驱动程序交互，让网络层决定如何将其路由到正确的接口。
- en: 'However, it is possible to access network devices directly from the user space
    by creating a socket and using the `ioctl` commands listed in `include/linux/sockios.h`.
    Here is a program that uses `SIOCGIFHWADDR` to query the network driver for a
    hardware (MAC) address:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通过创建套接字并使用`include/linux/sockios.h`中列出的`ioctl`命令，可以从用户空间直接访问网络设备。以下是使用`SIOCGIFHWADDR`查询网络驱动程序硬件（MAC）地址的程序示例：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You will find the full source code and a BitBake recipe for this program in
    the `MELD/Chapter11/meta-device-drivers/recipes-local/show-mac-address` directory.
    The `show-mac-address` program takes a network interface name as an argument.
    After opening a socket, we copy the interface name to a struct and pass that struct
    into the `ioctl` call on the socket before printing out the resulting MAC address.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过读取`MELD/Chapter11/meta-device-drivers/recipes-local/show-mac-address`目录中的完整源代码和BitBake配方来查找此程序的完整源代码和BitBake配方。`show-mac-address`程序将网络接口名称作为参数。打开套接字后，我们将接口名称复制到结构体中，并将该结构体传递到套接字上的`ioctl`调用中，然后打印出结果的MAC地址。
- en: Now that we know what the three categories of device drivers are, how do we
    list the different drivers that are in use on our system?
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道设备驱动程序的三个类别，如何列出系统中使用的不同驱动程序呢？
- en: Finding out about drivers at runtime
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在运行时查找驱动程序
- en: Once you have a running Linux system, it is useful to know which device drivers
    have been loaded and what state they are in. You can find out a lot by reading
    the files in `/proc` and `/sys`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有一个运行中的Linux系统，了解已加载的设备驱动程序及其状态非常有用。通过阅读`/proc`和`/sys`中的文件，您可以获取很多信息。
- en: 'List the character and block device drivers that are currently loaded and active
    by reading `/proc/devices`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通过读取`/proc/devices`列出当前加载和活动的字符和块设备驱动程序：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: For each driver, you can see the major number and the base name. However, this
    does not tell you how many devices each driver is attached to. It only shows `ttyAMA`
    but it gives you no clue as to whether it is attached to four real serial ports.
    I will come back to that later when we look at `sysfs`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个驱动程序，你可以看到主设备号和基本名称。然而，这并不能告诉你每个驱动程序连接了多少设备。它只显示了`ttyAMA`，但并未给出它是否连接了四个实际的串口。我会在后面讨论`sysfs`时再回到这个问题。
- en: 'Network devices do not appear in this list because they do not have device
    nodes. Instead, you can use the `ip` tool to get a list of network devices:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 网络设备不出现在这个列表中，因为它们没有设备节点。相反，你可以使用`ip`工具获取网络设备的列表：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can also find out about devices attached to USB or PCI buses using the well-known
    `lsusb` and `lspci` commands, respectively. There is information about them in
    the respective manual pages and plenty of online guides, so I will not describe
    them any further here.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过著名的`lsusb`和`lspci`命令分别查看连接到USB或PCI总线的设备。关于它们的信息可以在各自的手册页中找到，也有大量在线指南，因此我在这里就不再详细描述了。
- en: The really interesting information is in `sysfs`, which is the next topic we’ll
    cover.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 真正有趣的信息在`sysfs`中，这也是我们接下来要讨论的话题。
- en: Getting information from sysfs
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从sysfs获取信息
- en: 'You can define `sysfs` in a pedantic way as a representation of kernel objects,
    attributes, and relationships. A kernel object is a **directory**, an attribute
    is a **file**, and a relationship is a **symbolic link** from one object to another.
    From a more practical point of view, since the Linux device driver model represents
    all devices and drivers as kernel objects, you can see the kernel’s view of the
    system laid out before you by looking in `/sys`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从细致的角度定义`sysfs`为内核对象、属性和关系的表示。一个内核对象是一个**目录**，一个属性是一个**文件**，而一个关系是一个从一个对象到另一个对象的**符号链接**。从更实用的角度来看，由于Linux设备驱动模型将所有设备和驱动程序表示为内核对象，你可以通过查看`/sys`来看到内核对系统的视图：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the context of discovering information about devices and drivers, I will
    look at three of these directories: `devices`, `class`, and `block`.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索设备和驱动程序信息的过程中，我将关注这三个目录：`devices`、`class`和`block`。
- en: Devices – /sys/devices
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设备 – /sys/devices
- en: 'This is the kernel’s view of the devices that have been discovered since boot
    and how they are connected to each other. It is organized at the top level by
    the system bus, so what you see varies from one system to another. Here is the
    QEMU emulation of the Arm Versatile board:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是内核在启动后发现的设备以及它们如何相互连接的视图。它按系统总线在顶层进行组织，因此你看到的内容会因系统而异。以下是QEMU仿真中的Arm Versatile板的示例：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'There are three directories that are present on all systems:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 所有系统中都有三个目录：
- en: '`system/`: This contains devices at the heart of the system including CPUs
    and clocks.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`system/`：包含系统核心的设备，包括CPU和时钟。'
- en: '`virtual/`: This contains devices that are memory-based. You will find the
    memory devices that appear as `/dev/null`, `/dev/random`, and `/dev/zero` in `virtual/mem`.
    You will also find the `lo` loopback device in `virtual/net`.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`virtual/`：包含基于内存的设备。你会在`virtual/mem`中找到像`/dev/null`、`/dev/random`和`/dev/zero`这样的内存设备。你还会在`virtual/net`中找到`lo`回环设备。'
- en: '`platform/`: This is a catch-all for devices that are not connected via a conventional
    hardware bus. This may be almost everything on an embedded device.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`platform/`：这是一个包含所有未通过常规硬件总线连接的设备的目录。在嵌入式设备上，几乎所有的东西都可能属于这个目录。'
- en: The other devices appear in directories that correspond to actual system buses.
    For example, the PCI root bus, if there is one, appears as `pci0000:00`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 其他设备出现在与实际系统总线相对应的目录中。例如，如果存在PCI根总线，它会显示为`pci0000:00`。
- en: Navigating this hierarchy is quite hard because it requires some knowledge of
    the topology of your system and the pathnames become quite long and hard to remember.
    To make life easier, `/sys/class` and `/sys/block` offer two different views of
    the devices.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览这个层次结构相当困难，因为它需要一些对系统拓扑的了解，并且路径名变得相当长且难以记住。为了简化操作，`/sys/class`和`/sys/block`提供了两种不同的设备视图。
- en: Drivers – /sys/class
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 驱动程序 – /sys/class
- en: This is a view of the device drivers presented by their type. In other words,
    it is a software view rather than a hardware view. Each of the subdirectories
    represents a class of drivers and is implemented by a component of the driver
    framework. For example, UART devices are managed by the `tty` layer, so you will
    find them in `/sys/class/tty`. Likewise, you will find network devices in `/sys/class/net`,
    input devices such as keyboard, touchscreen, and mouse in `/sys/class/input`,
    and so on.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是按照设备驱动类型展示的视图。换句话说，这是一个软件视图，而非硬件视图。每个子目录代表一种驱动类，并由驱动框架中的一个组件实现。例如，UART 设备由
    `tty` 层管理，因此你会在 `/sys/class/tty` 目录下找到它们。同样，你可以在 `/sys/class/net` 找到网络设备，在 `/sys/class/input`
    找到输入设备，如键盘、触摸屏和鼠标，等等。
- en: There is a symbolic link in each subdirectory for each instance of that type
    of device pointing to its representation in `/sys/device`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 每个子目录中都有一个符号链接，指向该类型设备在 `/sys/device` 中的表示。
- en: 'Let’s look at the serial ports on the Versatile PB. We can see that there are
    four of them:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下 Versatile PB 上的串行端口。我们可以看到它们共有四个：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Each directory is a representation of the kernel object that is associated
    with an instance of a device interface. Looking within one of these directories,
    we can see the attributes of the object, represented as files, and the relationships
    with other objects, represented by links:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 每个目录都是与设备接口实例关联的内核对象的表示。查看这些目录中的某一个，我们可以看到该对象的属性（以文件形式表示）以及与其他对象的关系（通过链接表示）：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The link called `device` points to the hardware object for the device. The link
    called `subsystem` points back to the parent subsystem at `/sys/class/tty`. The
    remaining directory entries are attributes. Some are specific to a serial port,
    such as `xmit_fifo_size`, while others apply to many types of devices, such as
    `irq` for the interrupt number and `dev` for the device number. Some attribute
    files are writable and allow you to tune parameters in the driver at runtime.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 名为 `device` 的链接指向该设备的硬件对象。名为 `subsystem` 的链接指向 `/sys/class/tty` 中的父子系统。其余的目录项是属性。某些属性特定于串行端口，如
    `xmit_fifo_size`，而其他一些则适用于多种类型的设备，例如 `irq`（中断号）和 `dev`（设备号）。有些属性文件是可写的，允许你在运行时调整驱动程序的参数。
- en: 'The `dev` attribute is particularly interesting. If you look at its value,
    you will find the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`dev` 属性尤其有趣。如果你查看它的值，你会发现以下内容：'
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: These are the major and minor numbers of the device. This attribute is created
    when the driver registers the interface. It is from this file that `udev` and
    `mdev` find the major and minor numbers of the device driver.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是设备的主次号。这个属性是在驱动程序注册接口时创建的。正是通过这个文件，`udev` 和 `mdev` 才能找到设备驱动的主次号。
- en: Block drivers – /sys/block
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 块设备驱动 – /sys/block
- en: 'There is one more view of the device model that is important to this discussion:
    the block driver view that you will find in `/sys/block`. There is a subdirectory
    for each block device. This listing is from a BeaglePlay:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个关于设备模型的重要视图：你可以在 `/sys/block` 中找到的块设备驱动视图。这里有每个块设备的子目录。以下是来自 BeaglePlay
    的一部分：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you look inside `mmcblk0`, which is the eMMC chip on this board, you will
    see the attributes of the interface and the partitions within it:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 `mmcblk0` 目录，这是该开发板上的 eMMC 芯片，你将看到接口的属性和其中的分区信息：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In conclusion, you can learn a lot about the devices (the hardware) and the
    drivers (the software) that are present on a system by reading `sysfs`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，你可以通过阅读 `sysfs` 来了解很多关于系统中设备（硬件）和驱动程序（软件）的信息。
- en: Finding the right device driver
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找合适的设备驱动
- en: A typical embedded board is based on a reference design from the manufacturer
    with changes to make it suitable for a particular application. The BSP that comes
    with the reference board should support all the peripherals on that board. Then
    you customize the design, perhaps by adding a temperature sensor attached via
    I2C, some lights and buttons connected via GPIO pins, a display panel via a MIPI
    interface, or many other things. Your job is to create a custom kernel to control
    all of these, but where do you start looking for device drivers that support all
    these peripherals?
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的嵌入式开发板通常基于制造商提供的参考设计，并做出一些更改以使其适用于特定的应用。随参考板一起提供的 BSP 应该支持该板上的所有外设。然后你可以定制设计，可能是通过
    I2C 连接的温度传感器、通过 GPIO 引脚连接的灯光和按钮、通过 MIPI 接口连接的显示面板，或者其他许多东西。你的任务是创建一个定制的内核来控制所有这些外设，但你该从哪里开始寻找支持这些外设的设备驱动呢？
- en: The most obvious place to look is the driver support page on the manufacturer’s
    website, or you could ask them directly. In my experience, this seldom gets you
    the result you want. Hardware manufacturers are not particularly Linux-savvy,
    and they often give you misleading information. They may have proprietary drivers
    as binary blobs or source code for a different version of the kernel than the
    one you have. So, by all means, try this route. Personally, I will always try
    to find an open-source driver for the task at hand.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最明显的查询途径是查看制造商网站上的驱动支持页面，或者直接向他们询问。根据我的经验，这种方式很少能得到你想要的结果。硬件制造商通常对Linux不太熟悉，他们往往会提供误导性的信息。可能他们提供的是二进制格式的专有驱动，或者是与你当前内核版本不匹配的源代码。因此，尽管如此，你可以尝试这种方式。就我个人而言，我总是会尽量寻找适合当前任务的开源驱动程序。
- en: 'There may be support in your kernel already: there are many thousands of drivers
    in mainline Linux and there are many vendor-specific drivers in the vendor kernels.
    Begin by running `make menuconfig` (or `xconfig`) and search for the product name
    or number. If you do not find an exact match, try more generic searches allowing
    for the fact that most drivers handle a range of products from the same family.
    Next, try searching through the code in the `drivers` directory (`grep` is your
    friend here).'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你的内核中可能已经有支持：主线Linux中有成千上万的驱动程序，厂商内核中也有许多厂商特定的驱动程序。首先运行`make menuconfig`（或`xconfig`），并搜索产品名称或编号。如果没有找到完全匹配的项，尝试进行更通用的搜索，考虑到大多数驱动程序支持同一家族的多个产品。接下来，尝试在`drivers`目录中查找代码（`grep`是你的好帮手）。
- en: If you still don’t have a driver, you can try searching online and asking in
    the relevant forums to see if there is a driver for a later version of Linux.
    If you find one, you should seriously consider updating the BSP to use the later
    kernel. Sometimes, this is not practical, so you may have to think about backporting
    the driver to your kernel. If the kernel versions are similar, it may be easy,
    but if they are more than 12 to 18 months apart, then chances are that the code
    will have changed to the extent that you will have to rewrite a chunk of the driver
    to integrate it with your kernel. If all these options fail, you will have to
    find a solution yourself by writing the missing kernel driver. However, this is
    not always necessary. We will look at an alternative in the next section.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍然没有找到驱动程序，可以尝试在线搜索并在相关论坛中询问，看是否有适用于较新版本Linux的驱动程序。如果找到了，应该认真考虑更新BSP，以使用更新的内核。有时，这样做并不实际，因此你可能需要考虑将驱动程序回移植到当前内核。如果内核版本相似，移植可能比较简单，但如果版本相差超过12到18个月，那么代码变化可能非常大，你可能需要重写驱动程序的一部分来将其与当前内核集成。如果这些方法都失败了，你将不得不自己编写缺失的内核驱动程序。然而，这并不总是必要的。我们将在下一节中探讨一种替代方法。
- en: Device drivers in user space
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户空间中的设备驱动程序
- en: Before you start writing a device driver, pause for a moment to consider whether
    it is really necessary. There are generic device drivers for many common types
    of devices that allow you to interact with hardware directly from user space,
    without having to write a line of kernel code. User space code is certainly easier
    to write and debug. It is also not covered by the GPL, although I don’t feel that
    is a good reason to do it this way.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编写设备驱动程序之前，先停下来思考一下它是否真的必要。对于许多常见类型的设备，已经有通用的设备驱动程序，允许你直接在用户空间与硬件交互，而无需编写一行内核代码。用户空间代码当然更容易编写和调试。而且它不受GPL的约束，尽管我认为这并不是采取这种方式的好理由。
- en: 'These drivers fall into two broad categories: those that you control through
    files in `sysfs`, including GPIO and LEDs, and serial buses that expose a generic
    interface through a device node, such as I2C.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这些驱动程序大致分为两类：一类是通过`sysfs`中的文件进行控制的驱动，包括GPIO和LED，另一类是通过设备节点暴露通用接口的串行总线，如I2C。
- en: 'Let’s build a Yocto image for the BeaglePlay with some examples installed:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为BeaglePlay构建一个包含一些示例的Yocto镜像：
- en: 'Navigate one level above the directory where you cloned Yocto:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到你克隆Yocto的目录的上一层：
- en: '[PRE15]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Copy the meta-device-driver layers from the book’s Git repo:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从本书的Git仓库中复制meta-device-driver层：
- en: '[PRE16]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Set up your BitBake work environment for the BeaglePlay:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为BeaglePlay设置你的BitBake工作环境：
- en: '[PRE17]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This sets up a bunch of environment variables and puts you back in the `build-beagleplay`
    directory you populated during the *Layers* section from [*Chapter 6*](Chapter_04.xhtml#_idTextAnchor110).
    Repeat the exercise where you add your own `meta-nova` layer and build `core-image-minimal`
    for the BeaglePlay if you have since deleted that work.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将设置一系列环境变量，并将你带回到`build-beagleplay`目录，这是你在[*第6章*](Chapter_04.xhtml#_idTextAnchor110)的*层*部分中填充的目录。如果你已经删除了之前的工作，可以重复该练习，添加自己的`meta-nova`层，并为BeaglePlay构建`core-image-minimal`。
- en: 'Remove the `meta-nova` layer:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除`meta-nova`层：
- en: '[PRE18]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add the `meta-device-drivers` layer:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`meta-device-drivers`层：
- en: '[PRE19]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Confirm that your layer structure is set up correctly:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认你的层结构是否设置正确：
- en: '[PRE20]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Modify `conf/local.conf` so that the example programs and dummy driver are
    installed:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`conf/local.conf`，使示例程序和虚拟驱动程序被安装：
- en: '[PRE21]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Enable the legacy `/sys/class/gpio` interface in the kernel:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在内核中启用传统的`/sys/class/gpio`接口：
- en: '[PRE22]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Ensure that the `CONFIG_EXPERT`, `CONFIG_GPIO_SYSFS`, `CONFIG_DEBUG_FS`, and
    `CONFIG_DEBUG_FS_ALLOW_ALL` options are enabled. Ensure that the `CONFIG_KEYBOARD_GPIO`
    option is disabled.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保启用了`CONFIG_EXPERT`、`CONFIG_GPIO_SYSFS`、`CONFIG_DEBUG_FS`和`CONFIG_DEBUG_FS_ALLOW_ALL`选项。确保禁用了`CONFIG_KEYBOARD_GPIO`选项。
- en: Enable the `/sys/class/leds` interface in the kernel by ensuring that the `CONFIG_LEDS_CLASS`,
    `CONFIG_LEDS_GPIO`, and `CONFIG_LEDS_TRIGGER_TIMER` options are enabled.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在内核中启用`/sys/class/leds`接口，确保启用了`CONFIG_LEDS_CLASS`、`CONFIG_LEDS_GPIO`和`CONFIG_LEDS_TRIGGER_TIMER`选项。
- en: Save the modified kernel `.config` and exit `menuconfig`.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存修改后的内核`.config`并退出`menuconfig`。
- en: 'Build `core-image-minimal`:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建`core-image-minimal`：
- en: '[PRE23]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Write the finished image to a microSD using balenaEtcher, insert the microSD
    into your BeaglePlay, and boot it as described in the *Running the BeaglePlay
    target* section from [*Chapter 6*](Chapter_04.xhtml#_idTextAnchor110).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用balenaEtcher将完成的镜像写入microSD卡，将microSD插入BeaglePlay并启动，如[*第6章*](Chapter_04.xhtml#_idTextAnchor110)中的*运行BeaglePlay目标*部分所述。
- en: GPIO
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GPIO
- en: '**General-Purpose Input/Output** (**GPIO**) is the simplest form of digital
    interface since it gives you direct access to individual hardware pins, each of
    which can be in one of two states: either high or low. In most cases, you can
    configure the GPIO pin to be either an input or an output. You can even use a
    group of GPIO pins to create higher-level interfaces such as I2C or SPI by manipulating
    each bit in software, a technique that is called **bit banging**. The main limitation
    is the speed and accuracy of the software loops and the number of CPU cycles you
    want to dedicate to them. Generally, it is hard to achieve timer accuracy better
    than a millisecond unless you configure a real-time kernel, as we shall see in
    [*Chapter 21*](Chapter_19.xhtml#_idTextAnchor654). More common use cases for GPIO
    are for reading push buttons and digital sensors and controlling LEDs, motors,
    and relays.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**通用输入/输出**（**GPIO**）是最简单的数字接口形式，因为它为你提供对单个硬件引脚的直接访问，每个引脚可以处于两种状态之一：高或低。在大多数情况下，你可以将GPIO引脚配置为输入或输出。你甚至可以使用一组GPIO引脚，通过软件操作每个比特，创建更高级别的接口，如I2C或SPI，这种技术称为**位接入**。主要的限制是软件循环的速度和准确性，以及你愿意为此分配的CPU周期数。通常，除非你配置实时内核，否则很难达到毫秒级别以下的定时器准确度，正如我们将在[*第21章*](Chapter_19.xhtml#_idTextAnchor654)中看到的那样。GPIO的更常见用例是读取按键和数字传感器，以及控制LED、马达和继电器。'
- en: Most SoCs have a lot of GPIO bits grouped together in GPIO registers, usually
    32 bits per register. On-chip GPIO bits are routed through to GPIO pins on the
    chip package via a multiplexer known as a **pin mux**. There may be additional
    GPIO pins available off-chip in the power management chip and in dedicated GPIO
    extenders connected through I2C or SPI buses. All this diversity is handled by
    a kernel subsystem known as `gpiolib`, which is not actually a library, but the
    infrastructure GPIO drivers use to expose I/O in a consistent way. There are details
    about the implementation of `gpiolib` in the kernel source under `Documentation/driver-api/gpio/`,
    and the code for the drivers themselves is in `drivers/gpio/`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数SoC将大量GPIO位组装在一起，通常每个寄存器32位。在芯片上的GPIO位通过一个称为**引脚复用**（**pin mux**）的多路复用器路由到芯片封装上的GPIO引脚。通过I2C或SPI总线连接的电源管理芯片和专用GPIO扩展器上，可能还会有额外的GPIO引脚。所有这些多样性都由一个内核子系统`gpiolib`处理，`gpiolib`实际上不是一个库，而是GPIO驱动程序用来以一致方式公开I/O的基础设施。有关`gpiolib`实现的详细信息，可以在内核源代码的`Documentation/driver-api/gpio/`中找到，驱动程序本身的代码位于`drivers/gpio/`。
- en: 'Applications can interact with `gpiolib` through files in the `/sys/class/gpio/`
    directory. Here is what you would see on a typical embedded board like a BeaglePlay:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以通过 `/sys/class/gpio/` 目录中的文件与 `gpiolib` 进行交互。以下是在像 BeaglePlay 这样的典型嵌入式板上看到的内容：
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The directories named `gpiochip512` through to `gpiochip631` represent four
    GPIO registers, each with a variable number of GPIO bits. If you look in one of
    the `gpiochip` directories, you will see the following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `gpiochip512` 到 `gpiochip631` 命名的目录表示四个 GPIO 寄存器，每个寄存器有一个可变数量的 GPIO 位。如果你查看其中一个
    `gpiochip` 目录，你将看到以下内容：
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The file named `base` contains the number of the first GPIO pin in the register,
    while `ngpio` contains the number of bits in the register. In this case, `gpiochip512/base`
    is `512` and `gpiochip512/ngpio` is `3`, which tells you that it contains GPIO
    bits `512` to `514`. It is possible for there to be a gap between the last GPIO
    in one register and the first GPIO in the next.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 名为 `base` 的文件包含寄存器中第一个 GPIO 引脚的编号，而 `ngpio` 包含寄存器中的位数。在这个例子中，`gpiochip512/base`
    是 `512`，`gpiochip512/ngpio` 是 `3`，这告诉你它包含 GPIO 位 `512` 到 `514`。一个寄存器中的最后一个 GPIO
    和下一个寄存器中的第一个 GPIO 之间可能会有间隙。
- en: 'To control a GPIO bit from user space, you first need to export it from kernel
    space, which you can do by writing the GPIO number to `/sys/class/gpio/export`.
    This example shows the process for GPIO 640, which is wired to the INT pin of
    the mikroBUS connector on the BeaglePlay:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要从用户空间控制 GPIO 位，首先需要从内核空间导出它，你可以通过将 GPIO 编号写入 `/sys/class/gpio/export` 来实现。这个示例展示了
    GPIO 640 的过程，它与 BeaglePlay 上的 mikroBUS 连接器的 INT 引脚相连：
- en: '[PRE26]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, there is a new `gpio640` directory containing the files you need to control
    the pin.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有一个新的 `gpio640` 目录，其中包含你需要控制引脚的文件。
- en: '**Important note**'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: 'If the GPIO bit is already claimed by the kernel, you will not be able to export
    it in this way:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 GPIO 位已被内核占用，你将无法以这种方式导出它：
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `gpio640` directory contains these files:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`gpio640` 目录包含以下文件：'
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The pin begins as an input that is valid for the INT (interrupt) pin of the
    mikroBUS connector. To convert a GPIO to an output, write `out` to the `direction`
    file. The `value` file contains the current state of the pin, which is `0` for
    low and `1` for high. If it is an output, you can change the state by writing
    `0` or `1` to `value`. Sometimes the meaning of low and high is reversed in hardware
    (hardware engineers enjoy doing that sort of thing), so writing `1` to `active_low`
    inverts the meaning of `value` so that a low voltage is reported as `1` and a
    high voltage is reported as `0`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 引脚开始时是一个有效的输入，用于 mikroBUS 连接器的 INT（中断）引脚。要将 GPIO 转换为输出，请将 `out` 写入 `direction`
    文件。`value` 文件包含引脚的当前状态，`0` 表示低电平，`1` 表示高电平。如果它是输出，你可以通过写入 `0` 或 `1` 来改变状态。有时硬件中的低电平和高电平意义会被反转（硬件工程师喜欢做这种事情），因此写入
    `1` 到 `active_low` 会反转 `value` 的意义，使低电压显示为 `1`，高电压显示为 `0`。
- en: Conversely, you can remove a GPIO from user space control by writing the GPIO
    number to `/sys/class/gpio/unexport`, as you did for export.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你可以通过将 GPIO 编号写入 `/sys/class/gpio/unexport` 来从用户空间移除 GPIO 控制，就像你为导出所做的那样。
- en: Handling interrupts from GPIO
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理来自 GPIO 的中断
- en: 'In many cases, a GPIO input can be configured to generate an interrupt when
    it changes state. This allows you to wait for the interrupt rather than polling
    in an inefficient software loop. If the GPIO bit can generate interrupts, a file
    called `edge` exists. Initially, it has the value called `none`, meaning that
    it does not generate interrupts. To enable interrupts, you can set it to one of
    these values:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，GPIO 输入可以配置为在状态变化时生成中断。这使你可以等待中断，而不是在低效的软件循环中轮询。如果 GPIO 位能够生成中断，则会存在一个名为
    `edge` 的文件。它的初始值为 `none`，表示不生成中断。要启用中断，你可以将其设置为以下值之一：
- en: '`rising`: Interrupt on the rising edge.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rising`：在上升沿触发中断。'
- en: '`falling`: Interrupt on the falling edge.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`falling`：在下降沿触发中断。'
- en: '`both`: Interrupt on both rising and falling edges.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`both`：在上升沿和下降沿触发中断。'
- en: '`none`: No interrupts (default).'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`none`：没有中断（默认）。'
- en: 'To determine which GPIO the USR button on the BeaglePlay is assigned to:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定 BeaglePlay 上的 USR 按钮分配到哪个 GPIO：
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If you want to wait for a falling edge on GPIO 557 (USR button), you must first
    enable interrupts:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想等待 GPIO 557（USR 按钮）上的下降沿，你必须首先启用中断：
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here is a program that waits for an interrupt from the GPIO:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个等待来自 GPIO 的中断的程序：
- en: '[PRE31]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here is how the code for the `gpio-int` program works. First, call `epoll_create`
    to create the `epoll` notification facility. Next, open the GPIO and read out
    its initial value. Call `epoll_ctl` to register the GPIO’s file descriptor with
    `POLLPRI` as the event. Lastly, wait for an interrupt using the `epoll_wait` function.
    When you press the USR button on the BeaglePlay, the program will print `Button
    pressed:` followed by the number of bytes and value read from the GPIO.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`gpio-int`程序的工作原理。首先，调用`epoll_create`创建`epoll`通知功能。接下来，打开GPIO并读取其初始值。调用`epoll_ctl`将GPIO的文件描述符注册为`POLLPRI`事件。最后，使用`epoll_wait`函数等待中断。当你按下BeaglePlay上的USR按钮时，程序将打印出`Button
    pressed:`，后跟从GPIO读取的字节数和值。
- en: While we could have used `select` and `poll` to handle interrupts, unlike those
    other two system calls, the performance of `epoll` does not degrade rapidly as
    the number of file descriptors being monitored increases.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们本可以使用`select`和`poll`来处理中断，但与其他两个系统调用不同，`epoll`的性能在监视的文件描述符数量增加时不会迅速下降。
- en: The complete source code for this program, as well as a BitBake recipe and GPIO
    configuration script, can be found inside the `MELD/Chapter11/meta-device-drivers/recipes-local/gpio-int`
    directory.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的完整源代码，以及BitBake配方和GPIO配置脚本，可以在`MELD/Chapter11/meta-device-drivers/recipes-local/gpio-int`目录下找到。
- en: Like GPIOs, LEDs are accessible from `sysfs`. The interface, however, is noticeably
    different.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 与GPIO一样，LED通过`sysfs`访问。然而，它的接口有明显不同。
- en: LEDs
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LED灯
- en: LEDs are often controlled through a GPIO pin, but there is another kernel subsystem
    that offers more specialized control specifically for this purpose. The `leds`
    kernel subsystem adds the ability to set brightness, should the LED have that
    ability, and it can handle LEDs connected in other ways than a simple GPIO pin.
    It can be configured to trigger the LED on an event, such as block device access
    or a heartbeat, to show that the device is working. You will have to configure
    your kernel with the `CONFIG_LEDS_CLASS` option and with the LED trigger actions
    that are appropriate to you. There is more information in `Documentation/leds/`
    and the drivers are in `drivers/leds/`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: LED通常通过GPIO引脚进行控制，但还有一个内核子系统提供了更专门的控制，特别是为此目的。`leds`内核子系统增加了设置亮度的功能（如果LED具备此能力），并且能够处理以其他方式连接的LED，而不仅仅是简单的GPIO引脚。它可以配置为在事件发生时触发LED点亮，例如块设备访问或心跳，用以显示设备正在工作。你需要在内核中启用`CONFIG_LEDS_CLASS`选项，并配置适合你的LED触发动作。更多信息请参阅`Documentation/leds/`，驱动程序位于`drivers/leds/`。
- en: 'As with GPIOs, LEDs are controlled through a `sysfs` interface in the `/sys/class/leds/`
    directory. In the case of the BeaglePlay, the user LED names are encoded in the
    device tree in the form of `:function`, as shown here:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 与GPIO一样，LED通过`/sys/class/leds/`目录下的`sysfs`接口进行控制。在BeaglePlay中，用户LED的名称以`：function`的形式编码在设备树中，如下所示：
- en: '[PRE32]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, we can look at the attributes of one of the LEDs:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以查看其中一个LED的属性：
- en: '[PRE33]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note that leading backslashes are required by the shell to escape any colons
    in the path.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，路径中的冒号需要通过反斜杠进行转义，这是shell的要求。
- en: 'The `brightness` file controls the brightness of the LED and can be a number
    between `0` (off) and `max_brightness` (fully on). If the LED doesn’t support
    intermediate brightness, any non-zero value turns it on. The file called `trigger`
    lists the events that trigger the LED to turn on. The list of triggers is implementation-dependent.
    Here is an example:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`brightness`文件控制LED的亮度，值可以在`0`（关闭）和`max_brightness`（完全开启）之间。如果LED不支持中间亮度，则任何非零值都将其点亮。名为`trigger`的文件列出了触发LED点亮的事件。触发器的列表依赖于实现。以下是一个示例：'
- en: '[PRE34]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The trigger currently selected is shown in square brackets. You can change
    it by writing one of the other triggers to the file. If you want to control the
    LED entirely through brightness, select `none`. If you set trigger to `timer`,
    two extra files will appear that allow you to set the on and off times in milliseconds:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当前选择的触发器显示在方括号中。你可以通过将其他触发器写入文件来更改它。如果你想完全通过亮度控制LED，请选择`none`。如果设置触发器为`timer`，将会出现两个额外的文件，允许你设置开关时间，单位为毫秒：
- en: '[PRE35]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If the LED has on-chip timer hardware, the blinking takes place without interrupting
    the CPU.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果LED具有芯片内定时器硬件，闪烁操作将在不打断CPU的情况下进行。
- en: I2C
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: I2C
- en: I2C is a simple low-speed 2-wire bus that is common on embedded boards. It is
    typically used to access peripherals that are not on the SoC such as display controllers,
    camera sensors, GPIO extenders, and so on. There is a related standard known as
    **system management bus** (**SMBus**) that is found on PCs and is used to access
    temperature and voltage sensors. SMBus is a subset of I2C.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: I2C 是一种简单的低速两线总线，常见于嵌入式板上。它通常用于访问不在 SoC 上的外设，如显示控制器、摄像头传感器、GPIO 扩展器等。还有一个相关标准叫做
    **系统管理总线**（**SMBus**），它通常用于 PC 上访问温度和电压传感器。SMBus 是 I2C 的一个子集。
- en: I2C is a master-slave protocol with the master being one or more host controllers
    on the SoC. Slaves have a 7-bit address assigned by the manufacturer (read the
    data sheet) allowing up to 128 nodes per bus, but 16 are reserved, so only 112
    nodes are allowed in practice. The master may initiate read or write transactions
    with one of the slaves. Frequently, the first byte is used to specify a register
    on the slave, while the remaining bytes are the data that’s read from or written
    to that register.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: I2C 是一种主从协议，主设备是 SoC 上的一个或多个主控制器。每个从设备有一个由制造商分配的 7 位地址（请参考数据手册），允许每条总线最多有 128
    个节点，但其中 16 个已被保留，因此实际允许最多 112 个节点。主设备可以与其中一个从设备发起读写事务。通常，第一个字节用于指定从设备上的寄存器，而剩余的字节是从该寄存器读取或写入的数据。
- en: 'There is one device node for each host controller. This SoC has five:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 每个主控制器有一个设备节点。该 SoC 有五个设备节点：
- en: '[PRE36]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The device interface provides a series of `ioctl` commands that query the host
    controller and send the read and write commands to I2C slaves. There is a package
    named `i2c-tools` that uses this interface to provide basic command-line tools
    to interact with I2C devices. The tools are as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 设备接口提供了一系列 `ioctl` 命令，用于查询主控制器并将读写命令发送到 I2C 从设备。有一个名为 `i2c-tools` 的软件包，使用该接口提供基本的命令行工具与
    I2C 设备进行交互。以下是这些工具：
- en: '`i2cdetect`: Lists the I2C adapters and probes the bus.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i2cdetect`：列出 I2C 适配器并探测总线。'
- en: '`i2cdump`: Dumps data from all the registers of an I2C peripheral.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i2cdump`：从 I2C 外设的所有寄存器中转储数据。'
- en: '`i2cget`: Reads data from an I2C slave.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i2cget`：从 I2C 从设备读取数据。'
- en: '`i2cset`: Writes data to an I2C slave.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i2cset`：向 I2C 从设备写入数据。'
- en: The `i2c-tools` package is available in Buildroot and The Yocto Project as well
    as most mainstream distributions. Writing a user space program to talk to the
    device is straightforward as long as you know the address and protocol of the
    slave. The example that follows shows how to read the first four bytes from the
    FT24C32A-ELR-T EEPROM, which is mounted on the BeaglePlay on I2C bus 0\. The EEPROM
    has a slave address of `0x50`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`i2c-tools` 包在 Buildroot 和 Yocto 项目中都有提供，也在大多数主流发行版中可用。编写一个用户空间程序与设备通信是直接的，只要你知道从设备的地址和协议。以下示例展示了如何从
    FT24C32A-ELR-T EEPROM 中读取前四个字节，该 EEPROM 被安装在 BeaglePlay 上的 I2C 总线 0。该 EEPROM 的从设备地址是
    `0x50`。'
- en: 'Here is the code for a program that reads the first four bytes from an I2C
    address:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个程序代码，它从 I2C 地址读取前四个字节：
- en: '[PRE37]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This `i2c-eeprom-read` program prints `0xaa 0x55 0x33 0x33` when executed on
    a BeaglePlay. That four-byte sequence is the magic number for the EEPROM. The
    complete source and a BitBake recipe for this program can be found inside the
    `MELD/Chapter11/meta-device-drivers/recipes-local/i2c-eeprom-read` directory.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `i2c-eeprom-read` 程序在 BeaglePlay 上执行时会打印 `0xaa 0x55 0x33 0x33`。这四个字节的序列是
    EEPROM 的魔术数字。该程序的完整源代码和 BitBake 配方可以在 `MELD/Chapter11/meta-device-drivers/recipes-local/i2c-eeprom-read`
    目录下找到。
- en: Note that a device on the other end of the I2C bus can be little-endian or big-endian.
    Little-endian and big-endian refer to the order of bytes within a data word. A
    32-bit word contains four bytes. Little-endian means that the least significant
    byte is at index 0 and the most significant byte is at index 3\. In contrast,
    big-endian means that the most significant byte is at index 0 and the least significant
    byte is at index 3\. Big-endian is also referred to as *network order* corresponding
    to the order in which the bytes are transmitted over the wire in network protocols.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，I2C 总线另一端的设备可能是小端（little-endian）或大端（big-endian）。小端和大端指的是数据字内字节的顺序。一个 32
    位的数据字包含四个字节。小端表示最低有效字节位于索引 0，最高有效字节位于索引 3。相反，大端表示最高有效字节位于索引 0，最低有效字节位于索引 3。大端也被称为
    *网络字节序*，对应于网络协议中字节通过网络传输的顺序。
- en: This program is like `i2cget` except that the address and register bytes being
    read from are both hardcoded rather than passed in as arguments. We can use `i2cdetect`
    to discover the addresses of any peripherals on an I2C bus. `i2cdetect` can leave
    I2C peripherals in a bad state or lock up the bus, so it’s good practice to reboot
    after using it. A peripheral’s data sheet tells us what the registers map to.
    With that information, we can then use `i2cset` to write to its registers over
    I2C. These I2C commands can easily be converted into a library of C functions
    for interfacing with the peripheral.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序类似于`i2cget`，但要读取的地址和寄存器字节都是硬编码的，而不是作为参数传递。我们可以使用`i2cdetect`来发现I2C总线上任何外围设备的地址。使用`i2cdetect`可能会使I2C外围设备处于不良状态或锁定总线，因此使用后最好重启。外围设备的数据手册告诉我们寄存器映射的内容。有了这些信息，我们可以使用`i2cset`通过I2C写入其寄存器。这些I2C命令可以轻松地转换为用于与外围设备交互的C函数库。
- en: '**Important note**'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: There is more information about the Linux implementation of I2C in `Documentation/i2c/dev-interface.rst`.
    The host controller drivers are in `drivers/i2c/busses/`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Linux实现的更多I2C信息，请参阅`Documentation/i2c/dev-interface.rst`。主控制器驱动程序位于`drivers/i2c/busses/`中。
- en: Another popular communication protocol is the **SPI**, which utilizes a 4-wire
    bus.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种流行的通信协议是**SPI**，它使用4线总线。
- en: SPI
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SPI
- en: The SPI bus is similar to I2C but is a lot faster by up to tens of MHz. The
    interface uses four wires with separate send and receive lines, which allow it
    to operate in full duplex. Each chip on the bus is selected with a dedicated chip
    select line. It is commonly used to connect to touchscreen sensors, display controllers,
    and serial NOR flash devices.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: SPI总线类似于I2C，但速度更快，可高达数十MHz。该接口使用四根线分别发送和接收线，允许全双工操作。总线上的每个芯片都通过专用的芯片选择线选中。它通常用于连接触摸屏传感器、显示控制器和串行NOR闪存设备。
- en: 'As with I2C, it is a master-slave protocol, with most SoCs implementing one
    or more master host controllers. There is a generic SPI device driver that you
    can enable through the `CONFIG_SPI_SPIDEV` kernel configuration. This creates
    a device node for each SPI controller, which allows you to access SPI chips from
    user space. The device nodes are named `spidev<bus>.<chip select>`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 与I2C类似，SPI也是一种主从协议，大多数SoC都实现了一个或多个主机控制器。可以通过`CONFIG_SPI_SPIDEV`内核配置启用通用SPI设备驱动程序。这会为每个SPI控制器创建一个设备节点，允许您从用户空间访问SPI芯片。设备节点命名为`spidev<bus>.<chip
    select>`：
- en: '[PRE38]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: For examples of using the `spidev` interface, please refer to the example code
    in `Documentation/spi/`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 有关使用`spidev`接口的示例，请参阅`Documentation/spi/`中的示例代码。
- en: So far, the device drivers we’ve seen all have longstanding upstream support
    within the Linux kernel. Because all these device drivers are generic (GPIO, LEDs,
    I2C, and SPI), accessing them from user space is straightforward. At some point,
    you will encounter a piece of hardware that lacks a compatible kernel device driver.
    That hardware may be the centerpiece of your product (LiDAR, SDR, and so on).
    There may also be an FPGA in between the SoC and this hardware. Under these circumstances,
    you may have no other recourse than to write your own kernel module(s).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到的设备驱动程序都在Linux内核中得到了长期的上游支持。因为所有这些设备驱动程序都是通用的（GPIO、LED、I2C和SPI），所以从用户空间访问它们很简单。在某些情况下，您可能会遇到一个硬件设备缺乏兼容的内核设备驱动程序。这种硬件可能是您产品的核心（如LiDAR、SDR等）。在SoC和该硬件之间可能还有一个FPGA。在这种情况下，您可能别无选择，只能编写自己的内核模块。
- en: Writing a kernel device driver
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写内核设备驱动程序
- en: Eventually, when you have exhausted all the previous user space options, you
    will find yourself having to write a device driver to access a piece of hardware
    attached to your device. Character drivers are the most flexible and should cover
    90% of all your needs; network drivers apply if you are working with a network
    interface; and block drivers are for mass storage. The task of writing a kernel
    driver is complex and beyond the scope of this book. There are some references
    at the end that will help you on your way. In this section, I want to outline
    the options available for interacting with a driver – a topic not normally covered
    – and show you the bare bones of a character device driver.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，当你耗尽所有先前的用户空间选项时，你会发现自己不得不编写一个设备驱动程序来访问附加到设备的硬件。字符驱动是最灵活的，应该能满足你90%的需求；如果你正在处理网络接口，则使用网络驱动；块设备驱动则用于大容量存储。编写内核驱动的任务非常复杂，超出了本书的范围。书末有一些参考资料，能帮助你继续前进。在这一部分，我将概述与驱动程序交互的选项——这是一个通常不被涵盖的话题——并向你展示字符设备驱动的基本骨架。
- en: Designing a character driver interface
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计字符驱动接口
- en: 'The main character driver interface is based on a stream of bytes, as you would
    have with a serial port. However, many devices don’t fit this description: a controller
    for a robot arm needs functions to move and rotate each joint, for example. Luckily,
    there are other ways to communicate with device drivers than just `read` and `write`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的字符驱动接口基于一个字节流，就像你在串行端口上看到的那样。然而，许多设备并不符合这个描述：例如，机器人臂的控制器需要能够移动和旋转每个关节的功能。幸运的是，除了
    `read` 和 `write` 之外，还有其他方式与设备驱动程序进行通信：
- en: '`ioctl`: The `ioctl` function allows you to pass two arguments to your driver.
    These arguments can have any meaning you like. By convention, the first argument
    is a command that selects one of several functions in your driver, while the second
    is a pointer to a structure that serves as a container for the input and output
    parameters. This is a blank canvas that allows you to design any program interface
    you like. It is pretty common when the driver and application are closely linked
    and written by the same team. However, `ioctl` is deprecated in the kernel, and
    you will find it hard to get any drivers with new uses of `ioctl` accepted upstream.
    The kernel maintainers dislike `ioctl` because it makes kernel code and application
    code too interdependent, and it is hard to keep both of them in step across kernel
    versions and architectures.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ioctl`：`ioctl` 函数允许你向驱动程序传递两个参数。这些参数可以有任何你想要的意义。根据惯例，第一个参数是一个命令，用来选择驱动程序中的某个功能，而第二个参数是指向一个结构体的指针，这个结构体用作输入和输出参数的容器。这就像一张空白画布，允许你设计任何你喜欢的程序接口。当驱动和应用程序紧密关联并由同一团队编写时，这种做法非常常见。然而，`ioctl`
    在内核中已经被弃用，你会发现很难让任何新使用 `ioctl` 的驱动被上游接受。内核维护者不喜欢 `ioctl`，因为它让内核代码和应用代码过于依赖，且很难确保两者在不同的内核版本和架构间保持同步。'
- en: '`sysfs`: This is the preferred way to do things now, with a good example being
    the LED interface described earlier. The advantage is that it is somewhat self-documenting,
    so long as you choose descriptive names for the files. It is also scriptable because
    the file’s content is usually text strings. On the other hand, the requirement
    for each file to contain a single value makes it hard to achieve atomicity if
    you need to change more than one value at a time. Conversely, `ioctl` passes all
    its arguments in a structure, via a single function call.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sysfs`：这是当前首选的方法，一个很好的例子就是之前提到的LED接口。它的优势在于，文件命名只要具有描述性，便可以部分自我文档化。它还可以脚本化，因为文件的内容通常是文本字符串。另一方面，每个文件必须包含一个单一值的要求，使得如果你需要一次性更改多个值时，很难实现原子性。相对地，`ioctl`
    通过一个函数调用将所有参数打包在一个结构体中传递。'
- en: '`mmap`: You can get direct access to kernel buffers and hardware registers
    by mapping kernel memory into user space, thus bypassing the kernel. You may still
    need some kernel code to handle interrupts and DMA. There is a subsystem that
    encapsulates this idea known as `uio`, which is short for **user I/O**. There
    is more documentation in `Documentation/driver-api/uio-howto.rst` and there are
    example drivers in `drivers/uio/`.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mmap`：你可以通过将内核内存映射到用户空间，直接访问内核缓冲区和硬件寄存器，从而绕过内核。你可能仍然需要一些内核代码来处理中断和DMA。有一个封装了这一思想的子系统，称为
    `uio`，即**用户I/O**。更多的文档可以在 `Documentation/driver-api/uio-howto.rst` 中找到，示例驱动程序则在
    `drivers/uio/` 目录下。'
- en: '`sigio`: You can send a signal from a driver using the kernel function named
    `kill_fasync()` to notify applications of an event such as input becoming ready
    or an interrupt being received. By convention, the signal called `SIGIO` is used,
    but it could be any. You can see some examples in `drivers/uio/uio.c` and `drivers/char/rtc.c`.
    The main problem is that it is difficult to write reliable signal handlers in
    user space, so it remains a little-used facility.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sigio`：您可以使用名为`kill_fasync()`的内核函数从驱动程序发送信号，以通知应用程序某个事件，如输入准备就绪或接收到中断。按照惯例，使用名为`SIGIO`的信号，但也可以是任何信号。您可以在`drivers/uio/uio.c`和`drivers/char/rtc.c`中看到一些示例。主要问题是，在用户空间编写可靠的信号处理程序很困难，因此它仍然是一个不常使用的功能。'
- en: '`debugfs`: This is another pseudo filesystem that represents kernel data as
    files and directories, like `proc` and `sysfs`. The main distinction is that `debugfs`
    must not contain information that is needed for the normal operation of the system;
    it is for debug and trace information only. It is mounted via `mount -t debugfs
    debug /sys/kernel/debug`. There is a good description of `debugfs` in `Documentation/filesystems/debugfs.rst`.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`debugfs`：这是另一个伪文件系统，将内核数据表示为文件和目录，类似于`proc`和`sysfs`。主要区别在于，`debugfs`不得包含系统正常运行所需的信息；它仅用于调试和追踪信息。它通过`mount
    -t debugfs debug /sys/kernel/debug`进行挂载。在`Documentation/filesystems/debugfs.rst`中有关于`debugfs`的详细描述。'
- en: '`proc`: The `proc` filesystem is deprecated for all new code unless it relates
    to processes, which was what the filesystem was originally intended for. However,
    you can use `proc` to publish any information you choose. And, unlike `sysfs`
    and `debugfs`, it is available to non-GPL modules.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proc`：`proc`文件系统对于所有新代码已被弃用，除非它与进程有关，这是该文件系统最初的用途。然而，您可以使用`proc`发布您选择的任何信息。而且，与`sysfs`和`debugfs`不同，它对非GPL模块也可用。'
- en: '`netlink`: This is a socket protocol family. `AF_NETLINK` creates a socket
    that links kernel space to user space. It was originally created so that network
    tools could communicate with the Linux network code to access the routing tables
    and other details. It is also used by `udev` to pass events from the kernel to
    the `udev` daemon. It is very rarely used in general device drivers.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`netlink`：这是一个套接字协议族。`AF_NETLINK`创建一个套接字，将内核空间与用户空间连接起来。最初创建它是为了让网络工具能够与Linux网络代码进行通信，以访问路由表和其他细节。它也被`udev`用来将事件从内核传递到`udev`守护进程。在一般的设备驱动程序中很少使用。'
- en: There are many examples of all the preceding filesystems in the kernel source
    code, and you can design really interesting interfaces to your driver code. The
    only universal rule is the *principle of least astonishment*. In other words,
    application writers who are using your driver should find that everything works
    in a logical way without any quirks or oddities.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在内核源代码中有许多前述文件系统的示例，您可以为驱动程序代码设计非常有趣的接口。唯一的通用规则是*最小惊讶原则*。换句话说，使用您驱动程序的应用程序编写者应该发现一切都以逻辑的方式工作，没有任何奇怪或异常的地方。
- en: Anatomy of a device driver
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设备驱动程序的构成
- en: It’s time to draw some threads together by looking at the code for a simple
    device driver.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候通过查看一个简单设备驱动程序的代码来将一些线程联系起来了。
- en: 'Here is the start of a device driver named `dummy`, which creates four devices
    that can be accessed through `/dev/dummy0` to `/dev/dummy3`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个名为`dummy`的设备驱动程序的开头，它创建了四个可以通过`/dev/dummy0`到`/dev/dummy3`访问的设备：
- en: '[PRE39]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, we will define the `dummy_open()`, `dummy_release()`, `dummy_read()`,
    and `dummy_write()` functions for the character device interface:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定义字符设备接口的`dummy_open()`、`dummy_release()`、`dummy_read()`和`dummy_write()`函数：
- en: '[PRE40]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'After that, we need to initialize a `file_operations` structure and define
    the `dummy_init()` and `dummy_exit()` functions, which are called when the driver
    is loaded and unloaded:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们需要初始化一个`file_operations`结构，并定义`dummy_init()`和`dummy_exit()`函数，这些函数在驱动程序加载和卸载时调用：
- en: '[PRE41]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'At the end of the code, the macros called `module_init` and `module_exit` specify
    the functions to be called when the module is loaded and unloaded:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的末尾，名为`module_init`和`module_exit`的宏指定了在模块加载和卸载时要调用的函数：
- en: '[PRE42]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The closing three macros, named `MODULE_*`, add some basic information about
    the module:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的三个宏，命名为`MODULE_*`，添加了一些关于模块的基本信息：
- en: '[PRE43]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This information can be retrieved from the compiled kernel module using the
    `modinfo` command. The complete source code, as well as a `Makefile` for this
    driver, can be found inside the `MELD/Chapter11/meta-device-drivers/recipes-kernel/dummy-driver`
    directory.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这些信息可以通过`modinfo`命令从编译后的内核模块中获取。完整的源代码以及该驱动程序的`Makefile`可以在`MELD/Chapter11/meta-device-drivers/recipes-kernel/dummy-driver`目录中找到。
- en: When the module is loaded, the `dummy_init()` function is called. The point
    at which it becomes a character device is when it makes the call to `register_chrdev`
    passing a pointer to `struct file_operations` containing pointers to the four
    functions that the driver implements. While `register_chrdev` tells the kernel
    that there is a driver with a major number of `42`, it doesn’t say anything about
    the class of the driver, so it will not create an entry in `/sys/class/`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当模块被加载时，会调用`dummy_init()`函数。它成为字符设备的时刻，是它调用`register_chrdev`并传递指向`struct file_operations`的指针，`struct
    file_operations`中包含了驱动程序实现的四个函数的指针。虽然`register_chrdev`告诉内核有一个主设备号为`42`的驱动程序，但它没有说明驱动程序的类别，因此不会在`/sys/class/`中创建条目。
- en: Without an entry in `/sys/class/`, the device manager cannot create device nodes.
    So, the next few lines of code create a device class named `dummy` and four devices
    of that class called `dummy0` to `dummy3`. The result is that the `/sys/class/dummy/`
    directory is created containing subdirectories `dummy0` to `dummy3` when the driver
    is initialized. Each of the subdirectories contains a `dev` file that contains
    the major and minor numbers of the device. This is all that a device manager needs
    to create device nodes `/dev/dummy0` to `/dev/dummy3`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`/sys/class/`中没有条目，设备管理器将无法创建设备节点。因此，接下来的几行代码创建了一个名为`dummy`的设备类，并创建了四个该类的设备，分别叫做`dummy0`到`dummy3`。结果是，在驱动程序初始化时，会创建`/sys/class/dummy/`目录，并包含子目录`dummy0`到`dummy3`。每个子目录中都有一个`dev`文件，包含设备的主设备号和次设备号。这就是设备管理器创建设备节点`/dev/dummy0`到`/dev/dummy3`所需要的全部内容。
- en: The `dummy_exit()` function has to release the resources claimed by `dummy_init()`
    by freeing up the device class and major number.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`dummy_exit()`函数必须通过释放设备类和主设备号来释放`dummy_init()`所申请的资源。'
- en: 'The file operations for this driver are implemented by `dummy_open()`, `dummy_read()`,
    `dummy_write()`, and `dummy_release()`. They are called when a user space program
    calls `open(2)`, `read(2)`, `write(2)`, and `close(2)`, respectively. They just
    print a kernel message so that you can see that they were called. You can demonstrate
    this from the command line using the `echo` command:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 该驱动程序的文件操作由`dummy_open()`、`dummy_read()`、`dummy_write()`和`dummy_release()`实现。当用户空间程序调用`open(2)`、`read(2)`、`write(2)`和`close(2)`时，会分别调用这些函数。它们仅打印内核消息，以便你可以看到它们是否被调用。你可以通过命令行使用`echo`命令来演示这一点：
- en: '[PRE44]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In this case, the messages appear because I was logged on to the console, and
    kernel messages are printed to the console by default. If you are not logged on
    to the console, you can still see the kernel messages by using the `dmesg` command.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，消息会出现是因为我已经登录到控制台，而内核消息默认会打印到控制台。如果你没有登录到控制台，仍然可以通过使用`dmesg`命令查看内核消息。
- en: The full source code for this driver is less than 100 lines, but it is enough
    to illustrate how the linkage between a device node and driver code works, how
    the device class is created, and how the data is moved between the user and kernel
    spaces. Next, you need to build it.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这个驱动程序的完整源代码不到100行，但足以说明设备节点与驱动代码之间的关联、设备类的创建以及数据在用户空间和内核空间之间的传输。接下来，你需要构建它。
- en: Compiling kernel modules
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译内核模块
- en: At this point, you have some driver code that you want to compile and test on
    your target system. You can copy it into the kernel source tree and modify makefiles
    to build it, or you can compile it as a module out of tree. Let’s start by building
    out of tree.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你已经有了一些驱动程序代码，想要在目标系统上进行编译和测试。你可以将其复制到内核源代码树中，并修改makefile进行构建，或者你也可以将其作为模块进行树外编译。让我们从树外编译开始。
- en: 'You will need a simple `Makefile` that uses the kernel build system to do all
    the hard work:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你将需要一个简单的`Makefile`，它利用内核构建系统来完成所有繁重的工作：
- en: '[PRE45]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Yocto sets `KERNEL_SRC` to the directory of the kernel for your target device
    that you will be running the module on. The `obj-m := dummy.o` code will invoke
    the kernel build rule to take the `dummy.c` source file and create a `dummy.ko`
    kernel module. I will show you how to load kernel modules in the next section.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Yocto 将 `KERNEL_SRC` 设置为目标设备的内核目录，你将在该设备上运行该模块。`obj-m := dummy.o` 代码将调用内核构建规则，将
    `dummy.c` 源文件转换为 `dummy.ko` 内核模块。我将在下一节向你展示如何加载内核模块。
- en: '**Important note**'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: 'Kernel modules are not binary compatible between kernel releases and configurations:
    the module will only load on the kernel it was compiled with.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 内核模块在内核发布版本和配置之间不具有二进制兼容性：该模块只能在它编译的内核上加载。
- en: 'If you want to build a driver in the kernel source tree, the procedure is quite
    simple. Choose a directory appropriate to the type of driver you have. The driver
    is a basic character device, so I would put `dummy.c` in `drivers/char/`. Then,
    edit the makefile in the directory and add a line to build the driver unconditionally
    as a module, like so:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在内核源码树中构建一个驱动程序，过程非常简单。选择一个适合你驱动程序类型的目录。这个驱动程序是一个基本的字符设备，所以我会把`dummy.c`放在`drivers/char/`目录下。接着，编辑目录中的
    makefile，并添加一行代码，无条件地构建这个驱动程序作为一个模块，像这样：
- en: '[PRE46]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Alternatively, you can add the following line to build it unconditionally as
    a built-in:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以添加以下行来无条件地将其构建为内置模块：
- en: '[PRE47]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: If you want to make the driver optional, you can add a menu option to the `Kconfig`
    file and make the compilation conditional on the configuration option, as I described
    in the *Understanding kernel configuration* section of [*Chapter 4*](Chapter_04.xhtml#_idTextAnchor096).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望驱动程序是可选的，你可以在 `Kconfig` 文件中添加一个菜单选项，并且根据配置选项进行条件编译，就像我在 [*第4章*](Chapter_04.xhtml#_idTextAnchor096)
    的 *理解内核配置* 部分描述的那样。
- en: Loading kernel modules
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载内核模块
- en: 'You can load, list, and unload modules using the simple `modprobe`, `lsmod`,
    and `rmmod` commands. Here, they are loading and unloading the dummy driver:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用简单的 `modprobe`、`lsmod` 和 `rmmod` 命令来加载、列出和卸载模块。这里，它们正在加载和卸载虚拟驱动程序：
- en: '[PRE48]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If the module is placed in a subdirectory in `/lib/modules/<kernel release>`,
    you can create a modules dependency database using the `depmod -a` command, like
    so:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模块被放置在 `/lib/modules/<kernel release>` 的子目录中，你可以使用 `depmod -a` 命令创建一个模块依赖数据库，像这样：
- en: '[PRE49]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The information in the `modules.*` files is used by the `modprobe` command to
    locate a module by name rather than its full path. `modprobe` has many other features,
    all of which are described on the `modprobe(8)` manual page.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`modules.*` 文件中的信息由 `modprobe` 命令用于按名称而非完整路径定位模块。`modprobe` 还有许多其他功能，所有这些功能都在
    `modprobe(8)` 手册页中有描述。'
- en: Now that we have written and loaded our dummy kernel module, how do we get it
    to talk to some real piece of hardware? We need to bind our driver to that hardware
    either by way of the device tree or platform data. Discovering hardware and linking
    that hardware to a device driver is the topic of the next section.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编写并加载了虚拟内核模块，那么我们如何让它与真实硬件交流？我们需要通过设备树或平台数据将我们的驱动程序绑定到该硬件上。发现硬件并将其与设备驱动程序绑定是下一节讨论的主题。
- en: Discovering the hardware configuration
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现硬件配置
- en: The dummy driver demonstrates the structure of a device driver, but it lacks
    interaction with real hardware since it only manipulates memory structures. Device
    drivers are usually written to interact with hardware. Part of that is being able
    to discover the hardware in the first place, bearing in mind that it may be at
    different addresses in different configurations.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟驱动程序展示了设备驱动程序的结构，但它缺乏与真实硬件的交互，因为它只操纵内存结构。设备驱动程序通常被编写来与硬件交互。其中一部分是能够首先发现硬件，记住它在不同配置中可能在不同地址。
- en: In some cases, the hardware provides the information itself. Devices on a discoverable
    bus such as PCI or USB have a query mode that returns resource requirements and
    a unique identifier. The kernel matches the identifier and possibly other characteristics
    with the device drivers and marries them up.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，硬件本身提供信息。在可发现总线上的设备（如 PCI 或 USB）具有查询模式，返回资源需求和唯一标识符。内核将标识符及可能的其他特征与设备驱动程序进行匹配。
- en: However, most of the hardware blocks on an embedded board do not have such identifiers.
    You have to provide the information yourself in the form of a **device tree**
    or as C structures known as **platform data**.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，大多数嵌入式板上的硬件模块没有这样的标识符。你必须以 **设备树** 的形式或称为 **平台数据** 的 C 结构形式提供信息。
- en: 'In the standard driver model for Linux, device drivers register themselves
    with the appropriate subsystem: PCI, USB, open firmware (device tree), platform
    device, and so on. The registration includes an identifier and a callback function
    called a `probe` function that is called if there is a match between the ID of
    the hardware and the ID of the driver. For PCI and USB, the ID is based on the
    vendor and the product IDs of the devices. For device trees and platform devices,
    it is a name (a text string).'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 的标准驱动模型中，设备驱动会在适当的子系统中注册自己：PCI、USB、开放固件（设备树）、平台设备等。注册包括一个标识符和一个回调函数，即
    `probe` 函数，只有当硬件的 ID 与驱动的 ID 匹配时，`probe` 函数才会被调用。对于 PCI 和 USB，ID 是基于设备的厂商和产品 ID。而对于设备树和平台设备，ID
    是一个名称（文本字符串）。
- en: Device trees
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设备树
- en: I gave you an introduction to device trees in [*Chapter 3*](Chapter_03.xhtml#_idTextAnchor061).
    Here, I want to show you how the Linux device drivers hook up with this information.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[*第 3 章*](Chapter_03.xhtml#_idTextAnchor061)中给你介绍了设备树。在这里，我想向你展示 Linux 设备驱动如何与这些信息连接。
- en: 'As an example, I will use the Arm Versatile board (`arch/arm/boot/dts/versatile-ab.dts`)
    for which the Ethernet adapter is defined here:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，我将使用 Arm Versatile 板（`arch/arm/boot/dts/versatile-ab.dts`），该板定义了以太网适配器：
- en: '[PRE50]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Pay special attention to the `compatible` property of this node. This string
    value will reappear later in the source code for the Ethernet adapter. We will
    learn more about device trees in [*Chapter 12*](Chapter_04.xhtml#_idTextAnchor126).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意此节点的 `compatible` 属性。这个字符串值稍后会在以太网适配器的源代码中再次出现。我们将在[*第 12 章*](Chapter_04.xhtml#_idTextAnchor126)中进一步学习设备树。
- en: Platform data
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平台数据
- en: In the absence of device tree support, there is a fallback method of describing
    hardware using C structures, known as the platform data.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有设备树支持的情况下，有一种回退方法，通过使用 C 结构体描述硬件，这种方法称为平台数据。
- en: 'Each piece of hardware is described by `struct platform_device`, which has
    a name and a pointer to an array of resources. The resource’s type is determined
    by flags, which include the following:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 每个硬件组件都通过`struct platform_device`进行描述，该结构体包含一个名称和指向资源数组的指针。资源的类型由标志决定，标志包括以下内容：
- en: '`IORESOURCE_MEM`: This is the physical address of a region of memory.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IORESOURCE_MEM`：这是一个内存区域的物理地址。'
- en: '`IORESOURCE_IO`: This is the physical address or port number of I/O registers.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IORESOURCE_IO`：这是 I/O 寄存器的物理地址或端口号。'
- en: '`IORESOURCE_IRQ`: This is the interrupt number.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IORESOURCE_IRQ`：这是中断号。'
- en: 'Here is an example of the platform data for an Ethernet controller taken from
    `arch/arm/machversatile/core.c`, which has been edited for clarity:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是来自 `arch/arm/machversatile/core.c` 的以太网控制器平台数据示例，已进行编辑以提高可读性：
- en: '[PRE51]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'It has a memory area of 64 KB and an interrupt. The platform data is usually
    registered with the kernel when the board is initialized:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 它有一个 64 KB 的内存区域和一个中断。平台数据通常会在板卡初始化时注册到内核：
- en: '[PRE52]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The platform data shown here is functionally equivalent to the previous device
    tree source except for the `name` field, which takes the place of the `compatible`
    property.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示的的平台数据在功能上与之前的设备树源代码等效，唯一不同的是 `name` 字段，它取代了 `compatible` 属性的位置。
- en: Linking hardware with device drivers
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 硬件与设备驱动的连接
- en: In the preceding section, you saw how an Ethernet adapter is described using
    a device tree or platform data. The corresponding driver code is in `drivers/net/ethernet/smsc/smc91x.c`
    and it works with both the device tree and platform data.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，你已经看到如何使用设备树或平台数据描述以太网适配器。对应的驱动代码在 `drivers/net/ethernet/smsc/smc91x.c`
    中，它同时支持设备树和平台数据。
- en: 'Here is the initialization code, once again edited for clarity:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是初始化代码，再次进行了编辑以提高可读性：
- en: '[PRE53]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: When the driver is initialized, it calls `platform_driver_register()` pointing
    to `struct platform_driver`, in which there is a callback to a `probe` function,
    a driver name of `smc91x`, and a pointer to `struct of_device_id`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 当驱动程序初始化时，它会调用 `platform_driver_register()`，并指向 `struct platform_driver`，其中包含一个指向
    `probe` 函数的回调、驱动名称 `smc91x` 和指向 `struct of_device_id` 的指针。
- en: If this driver has been configured by the device tree, the kernel will look
    for a match between the `compatible` property in the device tree node and the
    string being pointed to by the compatible structure element. For each match, it
    calls the `probe` function.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果该驱动已经由设备树配置，内核将查找设备树节点中的 `compatible` 属性与 compatible 结构元素指向的字符串之间的匹配。对于每个匹配，它都会调用
    `probe` 函数。
- en: On the other hand, if it was configured through platform data, the probe function
    will be called for each match on the string pointed to by `driver.name`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果它是通过平台数据配置的，则`probe`函数会针对`driver.name`指向的字符串中的每个匹配项进行调用。
- en: 'The `probe` function extracts information about the interface:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`probe`函数提取有关接口的信息：'
- en: '[PRE54]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The calls to `platform_get_resource()` extract the memory and `irq` information
    from either the device tree or the platform data. It is up to the driver to map
    the memory and install the interrupt handler. The third parameter (`0` in both
    of the previous cases) comes into play if there is more than one resource of that
    particular type.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`platform_get_resource()`可以从设备树或平台数据中提取内存和`irq`信息。由驱动程序负责映射内存并安装中断处理程序。第三个参数（前两种情况中的`0`）在存在多个该类型资源时发挥作用。
- en: '[PRE55]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: For most drivers, specific bindings are documented in `Documentation/devicetree/bindings/`.
    For this particular driver, the information is in `Documentation/devicetree/bindings/net/smsc,lan9115.yaml`.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数驱动程序，具体的绑定信息可以在`Documentation/devicetree/bindings/`中找到。对于这个特定的驱动程序，信息存放在`Documentation/devicetree/bindings/net/smsc,lan9115.yaml`中。
- en: The main thing to remember here is that drivers should register a `probe` function
    and enough information for the kernel to call `probe` as it finds matches with
    the hardware it knows about. The linkage between the hardware described by the
    device tree and the device driver is done through the `compatible` property. The
    linkage between platform data and a driver is done through the name.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要记住的主要内容是，驱动程序应该注册一个`probe`函数，并提供足够的信息，以便内核在找到与已知硬件匹配的设备时能够调用`probe`函数。设备树描述的硬件与设备驱动程序之间的关联是通过`compatible`属性完成的。平台数据与驱动程序之间的关联则是通过名称完成的。
- en: Summary
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'Device drivers have the job of handling devices, usually physical hardware
    but sometimes virtual interfaces, and presenting them to the user space in a consistent
    and useful way. Linux device drivers fall into three broad categories: character,
    block, and network. Of the three, the character driver interface is the most flexible
    and, therefore, the most common. Linux drivers fit into a framework known as the
    driver model, which is exposed through `sysfs`. Pretty much the entire state of
    the devices and drivers is visible in `/sys/`.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 设备驱动程序负责处理设备，通常是物理硬件，但有时也包括虚拟接口，并以一致且有用的方式将其呈现给用户空间。Linux 设备驱动程序分为三大类：字符设备、块设备和网络设备。三者中，字符设备接口最为灵活，因此也是最常见的。Linux
    驱动程序适配于一个名为驱动模型（driver model）的框架，该框架通过`sysfs`对外暴露。几乎所有设备和驱动程序的状态都可以在`/sys/`中看到。
- en: Each embedded system has its own unique set of hardware interfaces and requirements.
    Linux provides drivers for most standard interfaces, and by selecting the right
    kernel configuration, you can get a working target board very quickly. This leaves
    you with the non-standard components for which you will have to add your own device
    support.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 每个嵌入式系统都有其独特的硬件接口和要求。Linux 为大多数标准接口提供了驱动程序，通过选择正确的内核配置，您可以非常快速地获得一个可用的目标板。这时，剩下的就是那些非标准组件，您需要为它们添加自己的设备支持。
- en: In some cases, you can sidestep the issue by using generic drivers for GPIO,
    I2C, and SPI, and instead, write user space code to do the work. I recommend this
    as a starting point as it gives you the chance to become familiar with the hardware
    without writing kernel code. Writing kernel drivers is not particularly difficult,
    but you do need to code carefully so as not to compromise the stability of the
    system.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您可以通过使用通用驱动程序来避开这个问题，例如 GPIO、I2C 和 SPI，然后编写用户空间代码来完成工作。我推荐将此作为起点，因为它可以让您在不编写内核代码的情况下熟悉硬件。编写内核驱动程序并不特别困难，但您需要小心编写代码，以免破坏系统的稳定性。
- en: 'I have talked about writing the kernel driver code: if you go down this route,
    you will inevitably want to know how to check whether it is working correctly
    and detect any bugs. I will cover that topic in [*Chapter 19*](Chapter_19.xhtml#_idTextAnchor611).'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经讲解了如何编写内核驱动代码：如果您选择这条路，您不可避免地想知道如何检查它是否正常工作以及如何检测错误。我将在[*第 19 章*](Chapter_19.xhtml#_idTextAnchor611)中讲解这个话题。
- en: The next chapter demonstrates techniques for rapid prototyping with single board
    computers and add-on boards.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章展示了如何使用单板计算机和附加板进行快速原型设计的技巧。
- en: Further study
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步学习
- en: '*Linux Kernel Development, 3rd Edition*, by Robert Love'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Linux 内核开发，第 3 版*，作者：Robert Love'
- en: '*Linux Weekly News* – [https://lwn.net/Kernel](https://lwn.net/Kernel%0D%0A)'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Linux 每周新闻* – [https://lwn.net/Kernel](https://lwn.net/Kernel%0D%0A)'
- en: '*Async IO on Linux: select, poll, and epoll*, by Julia Evans – [https://jvns.ca/blog/2017/06/03/async-io-on-linux--select--poll--and-epoll/](https://jvns.ca/blog/2017/06/03/async-io-on-linux--select--poll--and-epoll/%0D%0A)'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Linux 上的异步 IO：select、poll 和 epoll》*，作者：Julia Evans – [https://jvns.ca/blog/2017/06/03/async-io-on-linux--select--poll--and-epoll/](https://jvns.ca/blog/2017/06/03/async-io-on-linux--select--poll--and-epoll/%0D%0A)'
- en: '*Essential Linux Device Drivers, 1st Edition*, by Sreekrishnan Venkateswaran'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Linux 必备设备驱动程序，第1版》*，作者：Sreekrishnan Venkateswaran'
- en: Join our community on Discord
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的社区，参与 Discord 讨论
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers: https://packt.link/embeddedsystems'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，和作者及其他读者一起讨论： https://packt.link/embeddedsystems
- en: '![](img/QR_Code12308107448340296.png)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code12308107448340296.png)'
