<html><head></head><body>
<div id="_idContainer094">
<h1 class="chapter-number" id="_idParaDest-139"><a id="_idTextAnchor160"/><span class="koboSpan" id="kobo.1.1">9</span></h1>
<h1 id="_idParaDest-140"><a id="_idTextAnchor161"/><span class="koboSpan" id="kobo.2.1">Analyzing Physical Storage Performance</span></h1>
<p class="author-quote"><em class="italic"><span class="koboSpan" id="kobo.3.1">"</span></em><span class="koboSpan" id="kobo.4.1">When you have eliminated the impossible, whatever remains, however improbable, must be the truth." </span><span class="koboSpan" id="kobo.4.2">— Sir Arthur Conan Doyle</span></p>
<p><span class="koboSpan" id="kobo.5.1">Now that we’re done with understanding the nitty gritty of the storage landscape in Linux, we can put that understanding to practical use. </span><span class="koboSpan" id="kobo.5.2">I always like to compare the I/O stack with the OSI model in networking, where each layer has a dedicated function and uses a different data unit for communication. </span><span class="koboSpan" id="kobo.5.3">Over the course of the </span><em class="italic"><span class="koboSpan" id="kobo.6.1">first eight chapters</span></em><span class="koboSpan" id="kobo.7.1">, we’ve increased our understanding of the layered hierarchy of the storage stack and its conceptual model. </span><span class="koboSpan" id="kobo.7.2">If you are still following along, you may have gained some understanding of how even the most basic requests from an application have to navigate through numerous layers before being processed by the </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">underlying disks.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">Being the good folks that we are, when we work with someone, we can be too willing to be captious and tend to enjoy nitpicking. </span><span class="koboSpan" id="kobo.9.2">This leads us to the next phase in our journey – how do we gauge and measure the performance of our storage? </span><span class="koboSpan" id="kobo.9.3">There is always going to be a significant performance gap between the compute and storage resources, as a disk is orders of magnitude slower than a processor and memory. </span><span class="koboSpan" id="kobo.9.4">This makes performance analysis a very broad and complex domain. </span><span class="koboSpan" id="kobo.9.5">How do you determine, how much is too much, and how slow is too slow? </span><span class="koboSpan" id="kobo.9.6">A set of values might be perfectly suitable for an environment, while the same set would ring alarm bells elsewhere. </span><span class="koboSpan" id="kobo.9.7">Depending upon workloads, these variables differ in </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">every environment.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">There are a lot of tools and tracing mechanisms available in Linux that can assist in identifying potential bottlenecks in overall system performance. </span><span class="koboSpan" id="kobo.11.2">We’re going to keep our focus on the storage subsystem in particular and use these tools to get a sense of what is happening behind the scenes. </span><span class="koboSpan" id="kobo.11.3">Some of the tools are available by default in most Linux distributions, which serve as a good </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">starting point.</span></span></p>
<p><span class="koboSpan" id="kobo.13.1">Here’s a summary of what we’ll cover in </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">the chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.15.1">How do we </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">gauge performance?</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Understanding </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">storage topology</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Analyzing </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">physical storage</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">Using disk I/O </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">analysis tools</span></span></li>
</ul>
<h1 id="_idParaDest-141"><a id="_idTextAnchor162"/><span class="koboSpan" id="kobo.23.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.24.1">This chapter is a lot more hands-on and requires prior experience with the Linux command line. </span><span class="koboSpan" id="kobo.24.2">Most of the readers might already be aware of some of the tools and technologies discussed in this chapter. </span><span class="koboSpan" id="kobo.24.3">Having basic system administration skills will be helpful, as these tools deal with resource monitoring and analysis. </span><span class="koboSpan" id="kobo.24.4">It would be best to have the required privileges (root or sudo) to run these tools. </span><span class="koboSpan" id="kobo.24.5">Depending upon the Linux distribution of your choice, you’ll need to install the relevant packages. </span><span class="koboSpan" id="kobo.24.6">To install </span><strong class="source-inline"><span class="koboSpan" id="kobo.25.1">iostat</span></strong><span class="koboSpan" id="kobo.26.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.27.1">iotop</span></strong><span class="koboSpan" id="kobo.28.1"> on Debian/Ubuntu, use </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.30.1">
apt install sysstat iotop</span></pre>
<p><span class="koboSpan" id="kobo.31.1">To install </span><strong class="source-inline"><span class="koboSpan" id="kobo.32.1">iostat</span></strong><span class="koboSpan" id="kobo.33.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.34.1">iotop</span></strong><span class="koboSpan" id="kobo.35.1"> on Fedora/Red Hat, use </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.37.1">
yum install sysstat iotop</span></pre>
<p><span class="koboSpan" id="kobo.38.1">To install Performance Co-Pilot, you can refer to the installation instructions in their official documentation at the following </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">link:</span></span><span class="No-Break"> </span><a href="https://pcp.readthedocs.io/en/latest/HowTos/installation/index.html"><span class="No-Break"><span class="koboSpan" id="kobo.40.1">https://pcp.readthedocs.io/en/latest/HowTos/installation/index.html</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.41.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.42.1">The usage of these commands is the same on all </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">Linux distributions.</span></span></p>
<h1 id="_idParaDest-142"><a id="_idTextAnchor163"/><span class="koboSpan" id="kobo.44.1">How do we gauge performance?</span></h1>
<p><span class="koboSpan" id="kobo.45.1">There are different lenses through which we can assess the performance of a system. </span><span class="koboSpan" id="kobo.45.2">A common approach is to equate the overall system performance with the speed of the processor. </span><span class="koboSpan" id="kobo.45.3">If go back to simpler times when single-processor systems were the order of the day and compare them with modern multi-socket, multi-core systems, we’ll see that the processor performance has increased by, to put it simply, an epic proportion. </span><span class="koboSpan" id="kobo.45.4">If we compare the improvement factor for processor performance with that of a disk, the processor is a </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">runaway winner.</span></span></p>
<p><span class="koboSpan" id="kobo.47.1">The response times for storage devices are usually measured in milliseconds. </span><span class="koboSpan" id="kobo.47.2">For processors and memory, that value is in nanoseconds. </span><a id="_idTextAnchor164"/><span class="koboSpan" id="kobo.48.1">This results in a state of incongruity between the application requirements and what the underlying storage can actually deliver. </span><span class="koboSpan" id="kobo.48.2">The performance of the storage subsystem has not progressed at the same rate. </span><span class="koboSpan" id="kobo.48.3">Therefore, the argument about equating system performance with processor performance has faded away. </span><span class="koboSpan" id="kobo.48.4">Just like a chain is only as strong as its weakest link, the overall system performance is also dependent on its </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">slowest component.</span></span></p>
<p><span class="koboSpan" id="kobo.50.1">Most tools and utilities tend to focus solely on disk performance and do not give much insight into the performance of the higher layers. </span><span class="koboSpan" id="kobo.50.2">As we’ve discovered on this journey, there’s a whole plethora of operations happening behind the scenes when an application sends an I/O request to the storage device. </span><span class="koboSpan" id="kobo.50.3">Keeping this in mind, we will divide our performance analysis into the following </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">two parts:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.52.1">An analysis of </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">physical storage</span></span></li>
<li><span class="koboSpan" id="kobo.54.1">An analysis of higher layers in the I/O stack such as filesystems and </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">block layer</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.56.1">For both cases, we’re going to explain the relevant metrics and how they can affect performance. </span><span class="koboSpan" id="kobo.56.2">An analysis of filesystems and the block layer will be covered in </span><a href="B19430_10.xhtml#_idTextAnchor184"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.57.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.58.1">. </span><span class="koboSpan" id="kobo.58.2">We’ll also see how we can check these metrics through the available tools in </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">Linux distributions.</span></span></p>
<h1 id="_idParaDest-143"><a id="_idTextAnchor165"/><span class="koboSpan" id="kobo.60.1">Understanding storage topology</span></h1>
<p><span class="koboSpan" id="kobo.61.1">Most enterprise environments usually contain a mix of the following types </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">of storage.</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.63.1">Direct Attached Storage (DAS)</span></strong><span class="koboSpan" id="kobo.64.1">: This is the most common type of storage and is attached directly to a system, such as the hard drive in your laptop. </span><span class="koboSpan" id="kobo.64.2">Since data center environments need to have a certain level of redundancy at every layer, the directly attached storage in enterprise servers consists of several disks that are grouped in a RAID configuration to improve performance and </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">data protection.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.66.1">Fibre Channel storage area network</span></strong><span class="koboSpan" id="kobo.67.1">: This is a block-level storage protocol that makes use of fibre channel technology and allows servers to access storage devices. </span><span class="koboSpan" id="kobo.67.2">It offers extremely high performance and low response times compared to traditional DAS and is used to run mission-critical applications. </span><span class="koboSpan" id="kobo.67.3">It is also far more expensive than other options, as it requires specialized hardware, such as fibre channel adapters, fibre channel switches, and </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">storage arrays.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.69.1">iSCSI SAN</span></strong><span class="koboSpan" id="kobo.70.1">: This is also a block storage protocol that can use the existing network infrastructure and allow hosts to access storage devices. </span><span class="koboSpan" id="kobo.70.2">iSCSI SANs utilize the TCP/IP network as a means to transport SCSI packets between the source and target block storage. </span><span class="koboSpan" id="kobo.70.3">As it doesn’t make use of a dedicated network such as FC SAN, it has a lower performance than FC SAN. </span><span class="koboSpan" id="kobo.70.4">However, it is far easier and inexpensive to implement iSCSI SAN, as it doesn’t require specialized adapters </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">or switches.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.72.1">Network-Attached Storage (NAS)</span></strong><span class="koboSpan" id="kobo.73.1">: NAS is a file-level storage protocol. </span><span class="koboSpan" id="kobo.73.2">Like iSCSI SANs, NAS arrays also rely on the existing network infrastructure and do not require any additional hardware. </span><span class="koboSpan" id="kobo.73.3">However, since the storage is accessed through file-level mechanisms, the performance is on the lower side. </span><span class="koboSpan" id="kobo.73.4">Nevertheless, NAS arrays are the most inexpensive of the lot and are usually used to store </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">long-term backups.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.75.1">A simplified comparison of these technologies is shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.76.1">Figure 9</span></em></span><em class="italic"><span class="koboSpan" id="kobo.77.1">.1</span></em><span class="koboSpan" id="kobo.78.1">. </span><span class="koboSpan" id="kobo.78.2">To focus solely on the differences involved in accessing each type of storage, the additional details in the higher layers have been </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">left out:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer086">
<span class="koboSpan" id="kobo.80.1"><img alt="Figure 9.1 – The different storage topologies" src="image/B19430_09_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.81.1">Figure 9.1 – The different storage topologies</span></p>
<p><span class="koboSpan" id="kobo.82.1">We’re not going to include fibre switches or any SAN arrays in our discussion. </span><span class="koboSpan" id="kobo.82.2">However, keep in mind that there are a lot of components involved in accessing the different types of storage technologies. </span><span class="koboSpan" id="kobo.82.3">Every layer warrants careful examination, and as such, you should always have a topology map in mind when diagnosing </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">storage environments.</span></span></p>
<h1 id="_idParaDest-144"><a id="_idTextAnchor166"/><span class="koboSpan" id="kobo.84.1">Analyzing physical storage</span></h1>
<p><span class="koboSpan" id="kobo.85.1">Performance defines how well a disk drive functions when accessing, retrieving, or saving data. </span><span class="koboSpan" id="kobo.85.2">There are quite a few yardsticks that can help to define the performance of the disk subsystem. </span><span class="koboSpan" id="kobo.85.3">For those of you who have worked with storage vendors while evaluating and purchasing high-end storage arrays, IOPS will be a very familiar term. </span><span class="koboSpan" id="kobo.85.4">Vendors like to throw this acronym around a lot and cite a storage system’s IOPS as one of its main </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">selling points.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.87.1">Input Output Operations per Second</span></strong><span class="koboSpan" id="kobo.88.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.89.1">IOPS</span></strong><span class="koboSpan" id="kobo.90.1">) might very well be an entirely useless figure, unless it is coupled with other capabilities of a storage system, such as the response time, the read and write ratio, throughput, and block size. </span><span class="koboSpan" id="kobo.90.2">The IOPS figure is usually referred to as </span><em class="italic"><span class="koboSpan" id="kobo.91.1">hero numbers</span></em><span class="koboSpan" id="kobo.92.1">, and it rarely provides any insight into the capabilities of the system unless it is coupled with other metrics. </span><span class="koboSpan" id="kobo.92.2">When you purchase a vehicle, you need to know the intricate details, such as its acceleration, fuel economy, and how well it will handle bends and corners. </span><span class="koboSpan" id="kobo.92.3">You rarely think about its top speed. </span><span class="koboSpan" id="kobo.92.4">Similarly, you need to know all the capabilities of the </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">storage system.</span></span></p>
<p><span class="koboSpan" id="kobo.94.1">Keeping our focus on the physical disk, we’ll first define the </span><strong class="bold"><span class="koboSpan" id="kobo.95.1">time-based performance metrics</span></strong><span class="koboSpan" id="kobo.96.1">, since they are the ones that explain how and where time is spent. </span><span class="koboSpan" id="kobo.96.2">Any time you hear the word </span><strong class="bold"><span class="koboSpan" id="kobo.97.1">latency</span></strong><span class="koboSpan" id="kobo.98.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.99.1">delay</span></strong><span class="koboSpan" id="kobo.100.1"> while analyzing performance, that usually is an indication of </span><em class="italic"><span class="koboSpan" id="kobo.101.1">lost time</span></em><span class="koboSpan" id="kobo.102.1">. </span><span class="koboSpan" id="kobo.102.2">It is the time that could have been spent while working on something, but instead, it was spent waiting for something </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">to happen.</span></span></p>
<h2 id="_idParaDest-145"><a id="_idTextAnchor167"/><span class="koboSpan" id="kobo.104.1">Understanding disk service time</span></h2>
<p><span class="koboSpan" id="kobo.105.1">Let us first develop an understanding of the time-dependent metrics that we need to look for when analyzing physical disks. </span><span class="koboSpan" id="kobo.105.2">Once we’ve gained a conceptual understanding, we’ll use specific tools to look for potential bottlenecks. </span><span class="koboSpan" id="kobo.105.3">The following figure represents the most common </span><em class="italic"><span class="koboSpan" id="kobo.106.1">time-centered</span></em><span class="koboSpan" id="kobo.107.1"> metrics to gauge </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">disk performance:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer087">
<span class="koboSpan" id="kobo.109.1"><img alt="Figure 9.2 – Disk service times" src="image/B19430_09_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.110.1">Figure 9.2 – Disk service times</span></p>
<p><span class="koboSpan" id="kobo.111.1">It’s important to state here that the aforementioned metrics do not account for the time spent going through the kernel’s I/O hierarchy, such as filesystems, the block layer, and scheduling. </span><span class="koboSpan" id="kobo.111.2">We’re going to take a look at them separately. </span><span class="koboSpan" id="kobo.111.3">For now, we’re only going to focus on the </span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">physical layer.</span></span></p>
<p><span class="koboSpan" id="kobo.113.1">The terms used in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.114.1">Figure 9</span></em></span><em class="italic"><span class="koboSpan" id="kobo.115.1">.2</span></em><span class="koboSpan" id="kobo.116.1"> are </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">explained here:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.118.1">I/O wait</span></strong><span class="koboSpan" id="kobo.119.1">: An I/O request can either wait in a queue or be actively served. </span><span class="koboSpan" id="kobo.119.2">An I/O request is inserted into the disk’s queue before being dispatched for servicing. </span><span class="koboSpan" id="kobo.119.3">The amount of time spent waiting in the queue is quantified as </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">I/O wait.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.121.1">I/O service time</span></strong><span class="koboSpan" id="kobo.122.1">: The I/O service time amounts to the time during which the disk controller actively serviced the I/O request. </span><span class="koboSpan" id="kobo.122.2">In other words, it is the amount of time an I/O request was not waiting in a queue. </span><span class="koboSpan" id="kobo.122.3">The servicing time includes </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">the following:</span></span><ul><li><span class="koboSpan" id="kobo.124.1">The </span><em class="italic"><span class="koboSpan" id="kobo.125.1">disk seek time</span></em><span class="koboSpan" id="kobo.126.1"> is the time taken to move the disk read-write head, with radial movement, to the </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">specified track.</span></span></li><li><span class="koboSpan" id="kobo.128.1">Once the read-write head is placed on the correct track, the platter surface rotates to move the exact sector (from where data is to be read from or written to) and line it up with the read-write head. </span><span class="koboSpan" id="kobo.128.2">The amount of time spent here is known as </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.129.1">rotational latency</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">.</span></span></li><li><span class="koboSpan" id="kobo.131.1">Once the read-write head is positioned over the correct sector, the actual I/O operation is performed. </span><span class="koboSpan" id="kobo.131.2">This amounts to the </span><em class="italic"><span class="koboSpan" id="kobo.132.1">transfer time</span></em><span class="koboSpan" id="kobo.133.1">. </span><span class="koboSpan" id="kobo.133.2">Transfer time is the time taken to transfer data to/from the disk from/to the </span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">host system.</span></span></li></ul></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.135.1">Response time</span></strong><span class="koboSpan" id="kobo.136.1">: The response time or latency is the aggregate of service and wait times and can be thought of as the </span><em class="italic"><span class="koboSpan" id="kobo.137.1">round trip time</span></em><span class="koboSpan" id="kobo.138.1"> of an I/O request. </span><span class="koboSpan" id="kobo.138.2">It is expressed in milliseconds and is the most consequential term when working with storage devices, as it denotes the entire time from the issuance of an I/O request to its actual completion, as depicted in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.139.1">Figure 9</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.140.1">.3</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">:</span></span></li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer088">
<span class="koboSpan" id="kobo.142.1"><img alt="Figure 9.3 – Disk latency" src="image/B19430_09_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.143.1">Figure 9.3 – Disk latency</span></p>
<p><span class="koboSpan" id="kobo.144.1">As shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.145.1">Figure 9</span></em></span><em class="italic"><span class="koboSpan" id="kobo.146.1">.4</span></em><span class="koboSpan" id="kobo.147.1">, storage vendors usually mention the following seek </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">time specifications:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.149.1">Full stroke</span></strong><span class="koboSpan" id="kobo.150.1">: This represents the time taken by the read write head to move from the innermost to the outermost track on </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">the disk</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.152.1">Average</span></strong><span class="koboSpan" id="kobo.153.1">: This is the average time taken by the read write head to move from one random track </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">to another</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.155.1">Track to track</span></strong><span class="koboSpan" id="kobo.156.1">: This is the time taken by the read write head to move between two </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">adjacent tracks</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.158.1">The disk seek time specifications are shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.159.1">Figure 9</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.160.1">.4</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer089">
<span class="koboSpan" id="kobo.162.1"><img alt="Figure 9.4 – The disk seek time specifications" src="image/B19430_09_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.163.1">Figure 9.4 – The disk seek time specifications</span></p>
<p><span class="koboSpan" id="kobo.164.1">The transfer rate can be broken down into internal and external </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">transfer rates:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.166.1">Internal transfer rate</span></strong><span class="koboSpan" id="kobo.167.1">: This is the speed at which data is transferred from the disk’s platter surface to its internal cache </span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">or buffer.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.169.1">External transfer rate</span></strong><span class="koboSpan" id="kobo.170.1">: Once the data has been fetched in the buffer, it is then transferred to the host bus adapter controller via the disk’s supported interface or protocol. </span><span class="koboSpan" id="kobo.170.2">As highlighted in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.171.1">Figure 9</span></em></span><em class="italic"><span class="koboSpan" id="kobo.172.1">.5</span></em><span class="koboSpan" id="kobo.173.1">, the speed at which data is transferred from the buffer to the host bus adapter determines the external </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">transfer rate:</span></span></li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer090">
<span class="koboSpan" id="kobo.175.1"><img alt="Figure 9.5 – The disk transfer rates" src="image/B19430_09_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.176.1">Figure 9.5 – The disk transfer rates</span></p>
<p><span class="koboSpan" id="kobo.177.1">As we explained in </span><a href="B19430_08.xhtml#_idTextAnchor134"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.178.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.179.1">, unlike mechanical drives, SSDs do not use any mechanical </span><a id="_idIndexMarker228"/><span class="koboSpan" id="kobo.180.1">components. </span><span class="koboSpan" id="kobo.180.2">Therefore, concepts </span><a id="_idIndexMarker229"/><span class="koboSpan" id="kobo.181.1">such as rotational latency and seek time do not apply to them. </span><span class="koboSpan" id="kobo.181.2">The </span><em class="italic"><span class="koboSpan" id="kobo.182.1">response time</span></em><span class="koboSpan" id="kobo.183.1"> encapsulates all the time-related aspects, and it is the term that is most frequently used when checking for </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">performance-related issues.</span></span></p>
<h2 id="_idParaDest-146"><a id="_idTextAnchor168"/><span class="koboSpan" id="kobo.185.1">Disk access patterns</span></h2>
<p><span class="koboSpan" id="kobo.186.1">The </span><a id="_idIndexMarker230"/><span class="koboSpan" id="kobo.187.1">mechanical drives are most affected by the I/O access patterns. </span><span class="koboSpan" id="kobo.187.2">The I/O pattern generated by an application can be a combination of sequential and </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">random operations:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.189.1">Sequential I/O</span></strong><span class="koboSpan" id="kobo.190.1">: Sequential I/O operations refer to I/O requests that read from or write data to </span><a id="_idIndexMarker231"/><span class="koboSpan" id="kobo.191.1">consecutive or contiguous disk locations. </span><span class="koboSpan" id="kobo.191.2">For mechanical drives, this results in a major performance boost, as this requires a very small movement from the read write head. </span><span class="koboSpan" id="kobo.191.3">This reduces the disk </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">seek time.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.193.1">Random I/O</span></strong><span class="koboSpan" id="kobo.194.1">: Random I/O requests</span><a id="_idIndexMarker232"/><span class="koboSpan" id="kobo.195.1"> are performed on non-contiguous locations on the disk, and as you can guess, this results in longer disk seek times, which has a negative impact on </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">disk performance.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.197.1">Again, the random I/O operations impact the rotating mechanical drives and do not affect the SSDs as such. </span><span class="koboSpan" id="kobo.197.2">Although, since reading adjacent bytes on a disk requires a much smaller effort from the controller, sequential operations on SSDs are faster than random operations. </span><span class="koboSpan" id="kobo.197.3">However, this difference is much smaller compared to </span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">mechanical drives.</span></span></p>
<h2 id="_idParaDest-147"><a id="_idTextAnchor169"/><span class="koboSpan" id="kobo.199.1">Determining reads/writes ratio and I/O size</span></h2>
<p><span class="koboSpan" id="kobo.200.1">IOPS alone do </span><a id="_idIndexMarker233"/><span class="koboSpan" id="kobo.201.1">not paint the full picture of the disk’s performance and should always be taken with a grain of salt. </span><span class="koboSpan" id="kobo.201.2">It is important to look at the size of I/O requests and the ratio of read and write operations. </span><span class="koboSpan" id="kobo.201.3">For instance, complex storage systems are designed for specific read-write ratios and I/O sizes, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.202.1">70/30 read write</span></strong><span class="koboSpan" id="kobo.203.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.204.1">32 KB</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.205.1">block sizes.</span></span></p>
<p><span class="koboSpan" id="kobo.206.1">Different applications have different requirements and expectations from the underlying drives. </span><span class="koboSpan" id="kobo.206.2">It is important to have a rough estimate of the percentage of types of I/O operations that will be performed on a storage device. </span><span class="koboSpan" id="kobo.206.3">For instance, online transaction processing applications usually consist of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">70/30 read write</span></strong><span class="koboSpan" id="kobo.208.1"> ratio. </span><span class="koboSpan" id="kobo.208.2">On the other hand, a logging application might always be busy writing and might require </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">fewer reads.</span></span></p>
<p><span class="koboSpan" id="kobo.210.1">The size of the I/O request </span><a id="_idIndexMarker234"/><span class="koboSpan" id="kobo.211.1">by an application also varies, depending upon the type of the application. </span><span class="koboSpan" id="kobo.211.2">In some cases, it is a far more effective approach to transmit larger blocks. </span><span class="koboSpan" id="kobo.211.3">The time required to process such a request is longer than a single smaller request. </span><span class="koboSpan" id="kobo.211.4">On the other hand, considering the same amount of data, the combined processing and response time of many smaller requests might be greater than a single </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">larger request.</span></span></p>
<h2 id="_idParaDest-148"><a id="_idTextAnchor170"/><span class="koboSpan" id="kobo.213.1">Disk cache</span></h2>
<p><span class="koboSpan" id="kobo.214.1">Modern </span><a id="_idIndexMarker235"/><span class="koboSpan" id="kobo.215.1">drives come</span><a id="_idIndexMarker236"/><span class="koboSpan" id="kobo.216.1"> with an onboard </span><strong class="bold"><span class="koboSpan" id="kobo.217.1">disk cache</span></strong><span class="koboSpan" id="kobo.218.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.219.1">buffer</span></strong><span class="koboSpan" id="kobo.220.1">. </span><span class="koboSpan" id="kobo.220.2">The disk buffer is the embedded memory in a disk drive that acts as a buffer between the </span><strong class="bold"><span class="koboSpan" id="kobo.221.1">host bus adapter</span></strong><span class="koboSpan" id="kobo.222.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.223.1">HBA</span></strong><span class="koboSpan" id="kobo.224.1">) and </span><a id="_idIndexMarker237"/><span class="koboSpan" id="kobo.225.1">the disk platter or flash memory that is used </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">for storage.</span></span></p>
<p><span class="koboSpan" id="kobo.227.1">The following table highlights the effect of cache on different types of </span><span class="No-Break"><span class="koboSpan" id="kobo.228.1">I/O patterns:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-7">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.229.1">I/O type</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.230.1">Read</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.231.1">Write</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.232.1">Random</span></span></p>
</td>
<td class="No-Table-Style">
<p><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.233.1">This is difficult to cache and pre-fetch, as a pattern cannot </span></span><span class="No-Break" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.234.1">be predicted.</span></span></p>
</td>
<td class="No-Table-Style">
<p><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.235.1">Caching is extremely effective, as random writes require a lot of disk </span></span><span class="No-Break" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.236.1">seek time.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.237.1">Sequential</span></span></p>
</td>
<td class="No-Table-Style">
<p><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.238.1">Caching is extremely effective, as data can be </span></span><span class="No-Break" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.239.1">easily pre-fetched.</span></span></p>
</td>
<td class="No-Table-Style">
<p><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.240.1">Caching is effective and can be flushed quickly, as data is to be written to </span></span><span class="No-Break" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.241.1">contiguous locations.</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.242.1">Table 9.1 – The effect of a cache on read/writes</span></p>
<p><span class="koboSpan" id="kobo.243.1">The use of a cache speeds up the process of storing and accessing data from the hard disk. </span><span class="koboSpan" id="kobo.243.2">Enterprise storage arrays usually have a huge amount of cache available for </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">this purpose.</span></span></p>
<h2 id="_idParaDest-149"><a id="_idTextAnchor171"/><span class="koboSpan" id="kobo.245.1">IOPS and throughput</span></h2>
<p><span class="koboSpan" id="kobo.246.1">Along with latency, IOPS and throughput define the fundamental characteristics of </span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">physical storage:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.248.1">IOPS</span></strong><span class="koboSpan" id="kobo.249.1">: IOPS represent the rate at which I/O operations can take place within a specific time period. </span><span class="koboSpan" id="kobo.249.2">The measurement of IOPS will give you the operations per second that the storage system </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">currently delivers.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.251.1">Throughput</span></strong><span class="koboSpan" id="kobo.252.1">: Throughput refers to the volume of data that is transferred from or to the disk drive – in other words, the amount of pizza that you can eat at once. </span><span class="koboSpan" id="kobo.252.2">This is also referred to as bandwidth. </span><span class="koboSpan" id="kobo.252.3">As throughput measures the actual amount of data transfer, it is expressed in MB or GB </span><span class="No-Break"><span class="koboSpan" id="kobo.253.1">per second.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.254.1">Here are a couple of important things </span><span class="No-Break"><span class="koboSpan" id="kobo.255.1">to remember:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.256.1">The IOPS figure should always be correlated with latency, read-write ratios, and the I/O request size. </span><span class="koboSpan" id="kobo.256.2">When used independently, it does not have </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">much value.</span></span></li>
<li><span class="koboSpan" id="kobo.258.1">When processing large amounts of data, the bandwidth statistics might be more relevant </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">than IOPS.</span></span></li>
</ul>
<h2 id="_idParaDest-150"><a id="_idTextAnchor172"/><span class="koboSpan" id="kobo.260.1">Queue depth</span></h2>
<p><span class="koboSpan" id="kobo.261.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.262.1">queue depth</span></strong><span class="koboSpan" id="kobo.263.1"> dictates the number of I/O requests that can be concurrently handled at one time. </span><span class="koboSpan" id="kobo.263.2">In general, this value will not need to be altered. </span><span class="koboSpan" id="kobo.263.3">For large-scale SAN environments, in which hosts are connected to storage arrays using Fibre channel HBAs, this becomes a significant value. </span><span class="koboSpan" id="kobo.263.4">In that case, there are separate queue depth values for disks, HBAs, and the storage </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">array ports.</span></span></p>
<p><span class="koboSpan" id="kobo.265.1">If the number of issued I/O requests exceeds the supported queue depth, any new requests will not be entertained by the storage device. </span><span class="koboSpan" id="kobo.265.2">Instead, it will return a “queue full” message to the host. </span><span class="koboSpan" id="kobo.265.3">Once there is room in the queue, the host will have to resend the failed I/O request. </span><span class="koboSpan" id="kobo.265.4">The queue depth settings can impact both mechanical drives and SSDs. </span><span class="koboSpan" id="kobo.265.5">Mechanical drives and SSDs that use SATA and SAS interfaces only support a single queue, with 32 and 256 commands. </span><span class="koboSpan" id="kobo.265.6">Conversely, NVMe drives have 64,000 queues and 64,000 commands </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">per queue.</span></span></p>
<p><span class="koboSpan" id="kobo.267.1">In most cases, the default settings for queue depth might be sufficient. </span><span class="koboSpan" id="kobo.267.2">Each component in a storage environment has some queue depth settings. </span><span class="koboSpan" id="kobo.267.3">For instance, a RAID controller also has its own queue depth, which can be larger than the combined queue depth of the </span><span class="No-Break"><span class="koboSpan" id="kobo.268.1">individual disks.</span></span></p>
<h2 id="_idParaDest-151"><a id="_idTextAnchor173"/><span class="koboSpan" id="kobo.269.1">Determining disk busyness</span></h2>
<p><span class="koboSpan" id="kobo.270.1">There are a couple of concepts that determine how much the disk is actually used. </span><span class="koboSpan" id="kobo.270.2">They are described </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">as follows:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.272.1">Utilization</span></strong><span class="koboSpan" id="kobo.273.1">: Disk utilization is a fairly common metric that you’ll see being reported by various tools. </span><span class="koboSpan" id="kobo.273.2">Utilization means that the disk was actively used for a given interval. </span><span class="koboSpan" id="kobo.273.3">This value is represented as a percentage of time. </span><span class="koboSpan" id="kobo.273.4">For example, a 70% utilization value indicates that if the kernel looked up the disk 100 times, on 70 occasions, it was busy while performing some I/O request. </span><span class="koboSpan" id="kobo.273.5">Similarly, a disk that is being 100% utilized means that it constantly serves I/O requests. </span><span class="koboSpan" id="kobo.273.6">Again, a fully utilized disk may or may not become a bottleneck. </span><span class="koboSpan" id="kobo.273.7">This value needs to be correlated with a few other metrics, such as the associated latency and queue depth. </span><span class="koboSpan" id="kobo.273.8">It could be that, although the I/O requests are issued continuously, they’re fairly small and sequential; hence, the disk is able to serve them in a timely manner. </span><span class="koboSpan" id="kobo.273.9">Similarly, RAID arrays have the ability to handle requests in parallel, and as such, a 100% utilized disk might not </span><span class="No-Break"><span class="koboSpan" id="kobo.274.1">be problematic.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.275.1">Saturation</span></strong><span class="koboSpan" id="kobo.276.1">: Saturation means that the amount of requests issued to a disk might be more than what it can actually deliver. </span><span class="koboSpan" id="kobo.276.2">This means that we’re trying to exceed its rated capacity. </span><span class="koboSpan" id="kobo.276.3">When saturation happens, the applications have to wait before being able to read from or write data to disk. </span><span class="koboSpan" id="kobo.276.4">Saturation will result in increased response times and impact the overall performance of </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">a system.</span></span></li>
</ul>
<h2 id="_idParaDest-152"><a id="_idTextAnchor174"/><span class="koboSpan" id="kobo.278.1">I/O wait</span></h2>
<p><span class="koboSpan" id="kobo.279.1">Quite understandably, </span><strong class="bold"><span class="koboSpan" id="kobo.280.1">I/O wait</span></strong><span class="koboSpan" id="kobo.281.1"> is often the most misunderstood metric when checking for performance issues. </span><span class="koboSpan" id="kobo.281.2">Although it has an </span><em class="italic"><span class="koboSpan" id="kobo.282.1">I/O</span></em><span class="koboSpan" id="kobo.283.1"> in name, I/O wait time is actually a CPU metric, but it doesn’t indicate issues with CPU performance. </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">Get it?</span></span></p>
<p><span class="koboSpan" id="kobo.285.1">I/O wait time is the percentage of time that a CPU was idle, during which the system had pending disk I/O requests. </span><span class="koboSpan" id="kobo.285.2">What makes this difficult to comprehend is that it is possible to have a healthy system with a high I/O wait percentage, and it is also possible to have a slow-performing system without a low I/O wait percentage. </span><span class="koboSpan" id="kobo.285.3">A high I/O wait means that the CPU is idle while waiting for disk requests to be completed. </span><span class="koboSpan" id="kobo.285.4">Let’s explain this with a couple </span><span class="No-Break"><span class="koboSpan" id="kobo.286.1">of examples:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.287.1">For instance, if a process has sent some I/O requests and the underlying disk is unable to immediately fulfill that request, the CPU is said to be in a waiting state, as it is waiting for the request to be completed. </span><span class="koboSpan" id="kobo.287.2">Here, the waiting indicates that CPU cycles are wasted and the underlying disk might be slow to respond to </span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">I/O requests.</span></span></li>
<li><span class="koboSpan" id="kobo.289.1">Then, there’s the opposite case. </span><span class="koboSpan" id="kobo.289.2">Let’s say that process A is extremely CPU-intensive and constantly keeps the CPU busy. </span><span class="koboSpan" id="kobo.289.3">Another process running on the system, process B is I/O-intensive and occupies the disk. </span><span class="koboSpan" id="kobo.289.4">Even if the disk is slow to respond to requests of process B and becomes a source of a bottleneck for the system, the I/O wait value will be very low in this case. </span><span class="koboSpan" id="kobo.289.5">Why? </span><span class="koboSpan" id="kobo.289.6">Because the CPU is not idle, as it is wrapped up while serving process A. </span><span class="koboSpan" id="kobo.289.7">Therefore, although the I/O wait is on the low side, there could be a potential bottleneck with </span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">the storage.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.291.1">High I/O wait values can be caused by anyone or a combination of the </span><span class="No-Break"><span class="koboSpan" id="kobo.292.1">following factors:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.293.1">Bottlenecks in the </span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">physical storage</span></span></li>
<li><span class="koboSpan" id="kobo.295.1">A large queue of </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">I/O requests</span></span></li>
<li><span class="koboSpan" id="kobo.297.1">Disks nearing saturation or </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">fully saturated</span></span></li>
<li><span class="koboSpan" id="kobo.299.1">Processes in an uninterruptible sleep state, known as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">D</span></strong><span class="koboSpan" id="kobo.301.1"> state (this is fairly common when storage is accessed through </span><strong class="bold"><span class="koboSpan" id="kobo.302.1">network </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.303.1">filesystem</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.304.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.305.1">NFS</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">))</span></span></li>
<li><span class="koboSpan" id="kobo.307.1">Slow network speed in the case </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">of NFS</span></span></li>
<li><span class="koboSpan" id="kobo.309.1">High </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">swapping activity</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.311.1">I think we’ve covered quite a few things to watch out for when doing an analysis of storage devices. </span><span class="koboSpan" id="kobo.311.2">Again, if your storage environment contains all the components in a traditional SAN environment, then you need to look for a few more things, such as </span><strong class="bold"><span class="koboSpan" id="kobo.312.1">fibre channel</span></strong><span class="koboSpan" id="kobo.313.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.314.1">FC</span></strong><span class="koboSpan" id="kobo.315.1">) switches and any potential bottlenecks on the storage array. </span><span class="koboSpan" id="kobo.315.2">To troubleshoot FC switches, you need to establish a basic understanding of the </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">FC protocol.</span></span></p>
<p><span class="koboSpan" id="kobo.317.1">Let’s see how we can identify these red flags using the </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">available tools.</span></span></p>
<h1 id="_idParaDest-153"><a id="_idTextAnchor175"/><span class="koboSpan" id="kobo.319.1">Using disk I/O analysis tools</span></h1>
<p><span class="koboSpan" id="kobo.320.1">We now have developed a basic understanding of what to look for when diagnosing problems with the underlying storage. </span><span class="koboSpan" id="kobo.320.2">Most of the time, the problematic behavior is first reported at the application layer, and multiple layers are checked before the actual identification of the issue. </span><span class="koboSpan" id="kobo.320.3">The problematic scenario can also be intermittent in nature, which could make it even more difficult to detect. </span><span class="koboSpan" id="kobo.320.4">Fortunately, Linux has a broad range of utilities in its toolbox that can be used to identify such problematic behavior. </span><span class="koboSpan" id="kobo.320.5">We’ll take a look at them one by one and highlight the things of value to look for when </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">troubleshooting performance.</span></span></p>
<h2 id="_idParaDest-154"><a id="_idTextAnchor176"/><span class="koboSpan" id="kobo.322.1">Establish a baseline using top</span></h2>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">top</span></strong><span class="koboSpan" id="kobo.324.1"> is one of the most frequently used commands when troubleshooting performance issues. </span><span class="koboSpan" id="kobo.324.2">What makes it so effective is that it can quickly give you the current status of a system and possibly give you a hint about the potential problem. </span><span class="koboSpan" id="kobo.324.3">Although most people use it for CPU and memory analysis, there is one particular field that can indicate a problem with underlying storage. </span><span class="koboSpan" id="kobo.324.4">As shown in the following output, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">top</span></strong><span class="koboSpan" id="kobo.326.1"> command can quickly provide a summarized view of the current </span><span class="No-Break"><span class="koboSpan" id="kobo.327.1">system state:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.328.1">
top - 19:11:56 up 96 days, 12:38,  0 users,  load average: 9.44, 6.71, 3.75
Tasks: 498 total,   14 running, 484 sleeping,   0 stopped,   0 zombie
%Cpu(s): 20.6%us,  7.9%sy,  0.0%ni, 13.4%id, 57.1%wa,  0.1%hi,  0.9%si,  0.0%st
KiB Mem : 19791910+total, 10557456 free, 80016952 used, 10734470+buff/cache
KiB Swap:  8388604 total,  5058092 free,  3330512 used. </span><span class="koboSpan" id="kobo.328.2">11555254+avail Mem</span></pre>
<p><span class="koboSpan" id="kobo.329.1">As we discussed earlier, a high I/O wait is an indication of a bottleneck at the storage layer. </span><span class="koboSpan" id="kobo.329.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">wa</span></strong><span class="koboSpan" id="kobo.331.1"> field is the wait average and indicates the potion of time that the CPU had to wait because of the disk. </span><span class="koboSpan" id="kobo.331.2">High wait averages mean that the disk does not respond in a timely manner. </span><span class="koboSpan" id="kobo.331.3">Although not discussed here, load averages can also increase because of higher wait averages. </span><span class="koboSpan" id="kobo.331.4">This is because load averages include disk </span><span class="No-Break"><span class="koboSpan" id="kobo.332.1">waiting activity.</span></span></p>
<p><span class="koboSpan" id="kobo.333.1">The top utility has several options that can provide insight into CPU and memory consumption, but we’re not going to focus on them. </span><span class="koboSpan" id="kobo.333.2">As our primary concern here is storage, we need to watch out for high values in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">wa</span></strong><span class="koboSpan" id="kobo.335.1"> column and the </span><span class="No-Break"><span class="koboSpan" id="kobo.336.1">load averages.</span></span></p>
<h2 id="_idParaDest-155"><a id="_idTextAnchor177"/><span class="koboSpan" id="kobo.337.1">The iotop utility</span></h2>
<p><span class="koboSpan" id="kobo.338.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">iotop</span></strong><span class="koboSpan" id="kobo.340.1"> command is a </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">top</span></strong><span class="koboSpan" id="kobo.342.1">-like utility to monitor disk-related activity. </span><span class="koboSpan" id="kobo.342.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">top</span></strong><span class="koboSpan" id="kobo.344.1"> command, by default, sorts output on the basis of CPU usage. </span><span class="koboSpan" id="kobo.344.2">Similarly, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">iotop</span></strong><span class="koboSpan" id="kobo.346.1"> command sorts processes by the amount of data read and written by each process. </span><span class="koboSpan" id="kobo.346.2">It displays columns that highlight the top disk bandwidth consumers in your system. </span><span class="koboSpan" id="kobo.346.3">Additionally, it also displays the proportion of time that the thread/process was engaged in swapping and waiting for I/O operations. </span><span class="koboSpan" id="kobo.346.4">The I/O priority, both in terms of class and level, is indicated for </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">each process.</span></span></p>
<p><span class="koboSpan" id="kobo.348.1">It’s better to run </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">iotop</span></strong><span class="koboSpan" id="kobo.350.1"> with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">-o</span></strong><span class="koboSpan" id="kobo.352.1"> flag, as it will show processes that currently write </span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">to disk:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.354.1">
Total DISK READ :       231.10 K/s | Total DISK WRITE :     556.40 K/s
Actual DISK READ:       233.13 K/s | Actual DISK WRITE:     593.72 K/s
  TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO&gt;    COMMAND
23744 be/2 root        0.00 B/s  519.08 K/s  0.00 %  3.03 %  mysql
10395 be/4 root        231.10 K/s   37.32 K/s  0.00 % 1.58 % java</span></pre>
<p><strong class="bold"><span class="koboSpan" id="kobo.355.1">What to look for</span></strong><span class="koboSpan" id="kobo.356.1">: The </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">iotop</span></strong><span class="koboSpan" id="kobo.358.1"> command shows the amount of data being read from or written to the disk by a process. </span><span class="koboSpan" id="kobo.358.2">Check the supported disk read and write speeds, and compare them with the throughput of the top processes. </span><span class="koboSpan" id="kobo.358.3">This can also help to identify unusual disk activity by applications and determine whether any process can read or write an abnormal amount of data to </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">underlying disks.</span></span></p>
<p><span class="koboSpan" id="kobo.360.1">Sometimes, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">iotop</span></strong><span class="koboSpan" id="kobo.362.1"> command might complain that delay accounting is not enabled in the kernel. </span><span class="koboSpan" id="kobo.362.2">This can be fixed </span><span class="No-Break"><span class="koboSpan" id="kobo.363.1">as follows:</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">sysctl kernel.task_delayacct = 1</span></strong></p>
<h2 id="_idParaDest-156"><a id="_idTextAnchor178"/><span class="koboSpan" id="kobo.365.1">The iostat utility</span></h2>
<p><span class="koboSpan" id="kobo.366.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">iostat</span></strong><span class="koboSpan" id="kobo.368.1"> command is the most popular tool for disk analysis, as it displays a wide variety of information that can be of help to analyze performance issues. </span><span class="koboSpan" id="kobo.368.2">Most of the metrics that were explained earlier, such as disk saturation, utilization, and I/O wait, can be analyzed </span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">through </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">iostat</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.372.1">The first line of the output in </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">iostat</span></strong><span class="koboSpan" id="kobo.374.1">’s disk statistics is a summary since the most recent boot, which shows the mean for the entire time the system has been up. </span><span class="koboSpan" id="kobo.374.2">Subsequent lines are displayed as per-second statistics, calculated using the interval specified on the command line, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer091">
<span class="koboSpan" id="kobo.376.1"><img alt="Figure 9.6 – The iostat command" src="image/B19430_09_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.377.1">Figure 9.6 – The iostat command</span></p>
<p><span class="koboSpan" id="kobo.378.1">This is what to </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">look for:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.380.1">The first line, </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">avg-cpu</span></strong><span class="koboSpan" id="kobo.382.1">, shows the percentage of CPU utilization that occurred while executing in </span><span class="No-Break"><span class="koboSpan" id="kobo.383.1">each state.</span></span></li>
<li><span class="koboSpan" id="kobo.384.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">r/s</span></strong><span class="koboSpan" id="kobo.386.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">w/s</span></strong><span class="koboSpan" id="kobo.388.1"> numbers give a breakdown of the number of read and write requests issued to the device </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">per second.</span></span></li>
<li><span class="koboSpan" id="kobo.390.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">avgqu-sz</span></strong><span class="koboSpan" id="kobo.392.1"> represents the count of operations that were in either a queued state or actively being serviced. </span><span class="koboSpan" id="kobo.392.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">await</span></strong><span class="koboSpan" id="kobo.394.1"> value corresponds to the average duration between placing a request in a queue and its completion. </span><span class="koboSpan" id="kobo.394.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">r_await</span></strong><span class="koboSpan" id="kobo.396.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">w_await</span></strong><span class="koboSpan" id="kobo.398.1"> columns show the average wait time for read and write operations. </span><span class="koboSpan" id="kobo.398.2">If you see consistently high values here, the device might be </span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">nearing saturation.</span></span></li>
<li><span class="koboSpan" id="kobo.400.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">%util</span></strong><span class="koboSpan" id="kobo.402.1"> column shows the amount of time during which the disk was busy serving at least one I/O request. </span><span class="koboSpan" id="kobo.402.2">The utilization value might be misleading if the underlying storage is a </span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">RAID-based volume.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.404.1">The general assumption is that as a device’s utilization approaches 100%, it becomes more saturated. </span><span class="koboSpan" id="kobo.404.2">This holds true when referring to a storage device that represents a single disk. </span><span class="koboSpan" id="kobo.404.3">However, SAN arrays or RAID volumes consist of multiple drives and can serve multiple requests simultaneously. </span><span class="koboSpan" id="kobo.404.4">The kernel does not have direct visibility on how the I/O device is designed, which makes this a dubious figure in </span><span class="No-Break"><span class="koboSpan" id="kobo.405.1">some cases.</span></span></p>
<h2 id="_idParaDest-157"><a id="_idTextAnchor179"/><span class="koboSpan" id="kobo.406.1">Performance Co-Pilot</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.407.1">Performance Co-Pilot</span></strong><span class="koboSpan" id="kobo.408.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.409.1">PCP</span></strong><span class="koboSpan" id="kobo.410.1">) is an open source framework and toolkit designed to monitor, analyze, and respond to various aspects of real-time and past system performance data. </span><span class="koboSpan" id="kobo.410.2">PCP also includes some utilities to analyze storage system performance. </span><span class="koboSpan" id="kobo.410.3">The tools provided by PCP are very similar to the ones included in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">sysstat</span></strong><span class="koboSpan" id="kobo.412.1"> package. </span><span class="koboSpan" id="kobo.412.2">The PCP tools also include a GUI application to create graphs from the generated metrics and have the ability to save historical data for later viewing. </span><span class="koboSpan" id="kobo.412.3">A couple of tools that can assist in storage analysis are </span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">as follows:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">pcp atop</span></strong><span class="koboSpan" id="kobo.415.1">: This provides information similar to both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">iotop</span></strong><span class="koboSpan" id="kobo.417.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">atop</span></strong><span class="koboSpan" id="kobo.419.1"> commands. </span><span class="koboSpan" id="kobo.419.2">The command lists the processes that perform I/O, along with the disk bandwidth they use. </span><span class="koboSpan" id="kobo.419.3">Like </span><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">ioto</span></strong><span class="koboSpan" id="kobo.421.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">top</span></strong><span class="koboSpan" id="kobo.423.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.424.1">pcp atop</span></strong><span class="koboSpan" id="kobo.425.1"> is a good tool for quickly grasping changes occurring on </span><span class="No-Break"><span class="koboSpan" id="kobo.426.1">a system.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">pcp iostat</span></strong><span class="koboSpan" id="kobo.428.1">: The </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">pcp iostat</span></strong><span class="koboSpan" id="kobo.430.1"> command reports live disk I/O statistics, much like the </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">iostat</span></strong><span class="koboSpan" id="kobo.432.1"> command we saw earlier. </span><span class="koboSpan" id="kobo.432.2">As shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.433.1">Figure 9</span></em></span><em class="italic"><span class="koboSpan" id="kobo.434.1">.7</span></em><span class="koboSpan" id="kobo.435.1">, the columns in the output are similar to that </span><span class="No-Break"><span class="koboSpan" id="kobo.436.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">iostat</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.438.1">:</span></span></li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer092">
<span class="koboSpan" id="kobo.439.1"><img alt="Figure 9.7 – pcp iostat" src="image/B19430_09_07.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.440.1">Figure 9.7 – pcp iostat</span></p>
<p><span class="koboSpan" id="kobo.441.1">When troubleshooting disk performance or resource-related issues, </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">vmstat</span></strong><span class="koboSpan" id="kobo.443.1"> can provide valuable information, as it can help to identify disk I/O congestion, excessive paging, or </span><span class="No-Break"><span class="koboSpan" id="kobo.444.1">swapping activity.</span></span></p>
<h2 id="_idParaDest-158"><a id="_idTextAnchor180"/><span class="koboSpan" id="kobo.445.1">The vmstat command</span></h2>
<p><span class="koboSpan" id="kobo.446.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">vmstat</span></strong><span class="koboSpan" id="kobo.448.1"> command, derived from “virtual memory statistics,” is a native monitoring utility included in nearly all Linux distributions. </span><span class="koboSpan" id="kobo.448.2">As shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.449.1">Figure 9</span></em></span><em class="italic"><span class="koboSpan" id="kobo.450.1">.8</span></em><span class="koboSpan" id="kobo.451.1">, it reports information about processes, memory, paging, disks, and </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">processor activity:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer093">
<span class="koboSpan" id="kobo.453.1"><img alt="Figure 9.8 – The vmstat command" src="image/B19430_09_08.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.454.1">Figure 9.8 – The vmstat command</span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.455.1">What to look for</span></strong><span class="koboSpan" id="kobo.456.1">: The </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">b</span></strong><span class="koboSpan" id="kobo.458.1"> column in the output shows the number of processes blocked while waiting for a resource, such as disk I/O. </span><span class="koboSpan" id="kobo.458.2">Additional information most useful for troubleshooting I/O issues is </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">as follows:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">si</span></strong><span class="koboSpan" id="kobo.461.1">: This field represents the amount of memory, in kilobytes, that is swapped in from the swap space on the disk to the system’s memory per second. </span><span class="koboSpan" id="kobo.461.2">A higher value in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">si</span></strong><span class="koboSpan" id="kobo.463.1"> field indicates increased swapping activity, suggesting that the system frequently retrieves data from the </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">swap space.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">so</span></strong><span class="koboSpan" id="kobo.466.1">: This field represents the amount of memory, in kilobytes, that is swapped out from the system’s memory to the swap space on disk per second. </span><span class="koboSpan" id="kobo.466.2">A higher value in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">so</span></strong><span class="koboSpan" id="kobo.468.1"> field indicates increased swapping activity, which can occur when the system is under memory pressure and needs to free up </span><span class="No-Break"><span class="koboSpan" id="kobo.469.1">physical memory.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.470.1">bi</span></strong><span class="koboSpan" id="kobo.471.1">: This field specifically refers to the data transfer rate from disk to memory. </span><span class="koboSpan" id="kobo.471.2">A higher value in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">bi</span></strong><span class="koboSpan" id="kobo.473.1"> field indicates increased disk </span><span class="No-Break"><span class="koboSpan" id="kobo.474.1">read activity.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">bo</span></strong><span class="koboSpan" id="kobo.476.1">: This reflects the output activity or the amount of data written from the system’s memory to the disk. </span><span class="koboSpan" id="kobo.476.2">A higher value in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">bo</span></strong><span class="koboSpan" id="kobo.478.1"> field suggests increased disk write activity, indicating that data is written from memory to the </span><span class="No-Break"><span class="koboSpan" id="kobo.479.1">disk frequently.</span></span></li>
<li><strong class="source-inline"><a id="_idTextAnchor181"/><span class="koboSpan" id="kobo.480.1">wa</span></strong><span class="koboSpan" id="kobo.481.1">: This</span><a id="_idIndexMarker238"/><span class="koboSpan" id="kobo.482.1"> field represents the percentage of time that the CPU is idle while the system waits for I/O operations to complete. </span><span class="koboSpan" id="kobo.482.2">A higher value in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">wa</span></strong><span class="koboSpan" id="kobo.484.1"> field suggests that</span><a id="_idIndexMarker239"/><span class="koboSpan" id="kobo.485.1"> the system experiences I/O bottlenecks or delays, with the CPU frequently waiting for I/O operations </span><span class="No-Break"><span class="koboSpan" id="kobo.486.1">to complete.</span></span></li>
</ul>
<h2 id="_idParaDest-159"><a id="_idTextAnchor182"/><span class="koboSpan" id="kobo.487.1">Pressure Stall Index</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.488.1">Pressure Stall Index</span></strong><span class="koboSpan" id="kobo.489.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.490.1">PSI</span></strong><span class="koboSpan" id="kobo.491.1">) is a </span><a id="_idIndexMarker240"/><span class="koboSpan" id="kobo.492.1">relatively new </span><a id="_idIndexMarker241"/><span class="koboSpan" id="kobo.493.1">addition to the troubleshooting toolset in Linux and offers a new way to obtain utilization metrics for memory, CPU, and disk I/O. </span><span class="koboSpan" id="kobo.493.2">Latency spikes can occur when there is contention for CPU, memory, or I/O devices, resulting in increased waiting times for workloads. </span><span class="koboSpan" id="kobo.493.3">The PSI feature identifies this and prints a summarized view of this information in </span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">real time.</span></span></p>
<p><span class="koboSpan" id="kobo.495.1">The PSI values are accessed through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">/proc pseudo</span></strong><span class="koboSpan" id="kobo.497.1"> filesystem. </span><span class="koboSpan" id="kobo.497.2">The raw global PSI values appear in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">/proc/pressure</span></strong><span class="koboSpan" id="kobo.499.1"> directory in files called </span><strong class="source-inline"><span class="koboSpan" id="kobo.500.1">cpu</span></strong><span class="koboSpan" id="kobo.501.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">io</span></strong><span class="koboSpan" id="kobo.503.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">memory</span></strong><span class="koboSpan" id="kobo.505.1">. </span><span class="koboSpan" id="kobo.505.2">Let’s take a look at the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">io</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.507.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.508.1">
[root@linuxbox ~]# cat /proc/pressure/io
some avg10=51.30 avg60=41.28 avg300=23.33 total=84845633
full avg10=48.28 avg60=39.22 avg300=22.78 total=75033948</span></pre>
<p><strong class="bold"><span class="koboSpan" id="kobo.509.1">What to look for</span></strong><span class="koboSpan" id="kobo.510.1">: The </span><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">avg</span></strong><span class="koboSpan" id="kobo.512.1"> fields represent the </span><em class="italic"><span class="koboSpan" id="kobo.513.1">percentage</span></em><span class="koboSpan" id="kobo.514.1"> of time in the last 10, 60, and 300 seconds, respectively, that processes were starved of disk I/O. </span><span class="koboSpan" id="kobo.514.2">The line prefixed with </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">some</span></strong><span class="koboSpan" id="kobo.516.1"> represents the portion of time during which one or more tasks were delayed due to insufficient resources. </span><span class="koboSpan" id="kobo.516.2">The line prefixed with </span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">full</span></strong><span class="koboSpan" id="kobo.518.1"> represents the percentage of time when all tasks were delayed due to resource constraints, indicating the extent of unproductive time.This is a bit similar to the load averages in </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">top</span></strong><span class="koboSpan" id="kobo.520.1">. </span><span class="koboSpan" id="kobo.520.2">The output here shows high values for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">10</span></strong><span class="koboSpan" id="kobo.522.1">-, </span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">60</span></strong><span class="koboSpan" id="kobo.524.1">- and </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">300</span></strong><span class="koboSpan" id="kobo.526.1">-second interval averages, which indicates that processes are </span><span class="No-Break"><span class="koboSpan" id="kobo.527.1">being stalled.</span></span></p>
<p><span class="koboSpan" id="kobo.528.1">To summarize, Linux offers a plethora of utilities to analyze the performance of your system. </span><span class="koboSpan" id="kobo.528.2">The tools that we covered here are not only used for storage analysis but also to establish an overall picture of a system, including its processor and memory subsystem. </span><span class="koboSpan" id="kobo.528.3">Every tool offers a </span><a id="_idIndexMarker242"/><span class="koboSpan" id="kobo.529.1">wide range of options that can be used if we want to analyze a particular aspect. </span><span class="koboSpan" id="kobo.529.2">We</span><a id="_idIndexMarker243"/><span class="koboSpan" id="kobo.530.1"> highlighted the major indicators to look for when using each of these tools, but since every environment consists of different variables, there is no </span><em class="italic"><span class="koboSpan" id="kobo.531.1">fixed</span></em><span class="koboSpan" id="kobo.532.1"> approach </span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">to troubleshooting.</span></span></p>
<h1 id="_idParaDest-160"><a id="_idTextAnchor183"/><span class="koboSpan" id="kobo.534.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.535.1">Troubleshooting performance issues is a complex matter, as it can take a long time to diagnose and analyze them. </span><span class="koboSpan" id="kobo.535.2">Of the three major components in an environment – storage, compute, and memory – storage is the slowest. </span><span class="koboSpan" id="kobo.535.3">There is always going to be a mismatch in their performance, and any degradation in disk performance can impact the overall operation of </span><span class="No-Break"><span class="koboSpan" id="kobo.536.1">the system.</span></span></p>
<p><span class="koboSpan" id="kobo.537.1">Keeping this objective in mind, we divided this chapter into two sections. </span><span class="koboSpan" id="kobo.537.2">In the first section, we explained the most important metrics that you should understand before troubleshooting any issues. </span><span class="koboSpan" id="kobo.537.3">We discussed the time-related metrics related to storage devices, CPU wait averages, disk saturation, and disk utilization, and the different access patterns when reading from or writing to </span><span class="No-Break"><span class="koboSpan" id="kobo.538.1">physical disks.</span></span></p>
<p><span class="koboSpan" id="kobo.539.1">In the second part, we saw the different ways in which we can analyze the metrics highlighted in the first section. </span><span class="koboSpan" id="kobo.539.2">There are a lot of mechanisms available in Linux that can assist to identify potential bottlenecks in overall system performance. </span><span class="koboSpan" id="kobo.539.3">We used tools such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.540.1">top</span></strong><span class="koboSpan" id="kobo.541.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.542.1">PSI</span></strong><span class="koboSpan" id="kobo.543.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.544.1">iostat</span></strong><span class="koboSpan" id="kobo.545.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">iotop</span></strong><span class="koboSpan" id="kobo.547.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">vmstat</span></strong><span class="koboSpan" id="kobo.549.1"> to analyze </span><span class="No-Break"><span class="koboSpan" id="kobo.550.1">disk performance.</span></span></p>
<p><span class="koboSpan" id="kobo.551.1">In the next chapter, we will continue our analysis of the storage stack and focus on the higher layers, such as the block layer and filesystems. </span><span class="koboSpan" id="kobo.551.2">For this purpose, we’ll make use of the different tracing mechanisms available </span><span class="No-Break"><span class="koboSpan" id="kobo.552.1">in Linux.</span></span></p>
</div>
</body></html>