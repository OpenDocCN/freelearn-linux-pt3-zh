- en: '17'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '17'
- en: Load Balancing and HTTP
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 负载均衡与 HTTP
- en: We’re going to take a slightly different approach with this chapter, so buckle
    up. On the one hand, we’re going to review some background on the **Hypertext
    Transfer Protocol** (**HTTP**) and focus on some misconceptions that trip up many
    web developers in the real world.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将采取一种稍微不同的方式，因此请系好安全带。一方面，我们将回顾一些关于**超文本传输协议**（**HTTP**）的背景知识，并重点讨论一些常见的误解，这些误解常常让许多开发人员在实际工作中踩坑。
- en: On the other hand, we’re going to keep this practical and cover one of the most
    powerful standard HTTP tools that’s available on the command line, `curl`. Specifically,
    we’re going to teach you the basics of `curl` in the context of how you can use
    it to troubleshoot common web application issues.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们将保持实用，讲解一个在命令行上非常强大的标准 HTTP 工具——`curl`。具体来说，我们将教授你在使用 `curl` 排查常见的 web
    应用问题时的基础知识。
- en: We assume that if you’re a web developer, you already know your way around HTTP.
    So, while the goal of this chapter is not to teach you the absolute basics of
    this protocol, we are going to review some of those basics to get you up to speed
    if it’s been a while. If you *are* totally new to HTTP, there is lots of excellent
    documentation on the web that you can use. For what it’s worth, we highly recommend
    MDN by Mozilla as your source for this information.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设你作为 web 开发者，已经对 HTTP 有一定了解。所以，虽然本章的目标不是教授你这一协议的基础知识，但我们会回顾一些基本内容，帮助你尽快跟上进度，特别是如果你有一段时间没接触过它。如果你*完全*不懂
    HTTP，网上有很多优秀的文档可以帮助你。至于推荐，我们强烈建议你参考 Mozilla 提供的 MDN 文档。
- en: Instead, we want to focus on the common misunderstandings and pitfalls around
    HTTP and how it’s used in the real world, which often catch people by surprise.
    These misunderstandings often come from the fact that as a developer, you write
    web applications in a very simple local environment but run them in complicated
    production setups that look quite different from the laptop you built and tested
    them on.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 其实，我们更希望聚焦在 HTTP 的常见误解和在实际应用中的陷阱，这些问题常常会让人吃惊。这些误解通常源于这样一个事实：作为开发者，你在非常简单的本地环境中编写
    web 应用，但在复杂的生产环境中运行它们，这些环境与用于构建和测试的笔记本电脑大不相同。
- en: This difference between what an application interacts with when in development
    on a local machine, and the infrastructure around it after it has been deployed
    to a staging or production environment, is the source of much confusion and many
    subtle bugs.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 开发环境中应用与本地机器的交互方式与应用在部署到暂存或生产环境后的基础设施之间的差异，是许多混淆和细微错误的源头。
- en: 'In this chapter, we’ll cover the most important of these differences: you’ll
    learn about gateways, upstreams, and other concepts that intersect with the infrastructure
    layer around a modern website or web application. Then we’ll cover some of the
    most common mistakes people make with HTTP that cause hard-to-debug issues with
    headers, status codes, and more. We’ll look at some of the modern security features
    that have been added, such as **Cross-Origin Resource Sharing** (**CORS**), along
    with the history of HTTP and the versions you’re likely to come across. Finally,
    you’ll learn a bit about how load balancing is done: knowing the basics will prevent
    you from having an incorrect model of the client request path in your mind, which
    is a common source of design problems at the application/infrastructure boundary.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论这些差异中最重要的内容：你将了解网关、上游服务器以及与现代网站或 web 应用的基础设施层交叉的其他概念。然后我们将讲解一些关于 HTTP
    的常见错误，这些错误通常会导致调试困难的头部、状态码等问题。我们还会介绍一些现代安全功能，例如**跨域资源共享**（**CORS**），以及 HTTP 的历史和你可能会遇到的版本。最后，你将学习负载均衡的基本概念：了解这些基础知识能帮助你避免对客户端请求路径的错误理解，这是应用程序/基础设施边界处常见的设计问题源。
- en: 'You’ll learn:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你将学习：
- en: Some basic terminology that you’ll need to understand the more complex web infrastructure
    we discuss later in the chapter.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解本章后续讨论的更复杂的 web 基础设施所需的一些基本术语。
- en: Common misunderstandings about HTTP statuses, which when fully understood, can
    help you write cleaner and more correct status-handling code.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 HTTP 状态码的常见误解，充分理解这些误解有助于你编写更简洁、更准确的状态处理代码。
- en: HTTP headers, and some related problems you might see in your own web applications.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP 头部，以及你在自己的网站应用中可能遇到的一些相关问题。
- en: The different HTTP versions you might encounter in the wild.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你在实际使用中可能遇到的不同 HTTP 版本。
- en: How load balancing works, and why you need to understand it as a developer,
    even if you never plan on touching application infrastructure.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解负载均衡是如何工作的，以及作为开发者为什么即使你从不打算接触应用程序基础设施，也需要理解它。
- en: How to troubleshoot web issues relating to all of these topics from the command
    line with a tool called `curl`.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用名为 `curl` 的工具，通过命令行排查与所有这些主题相关的 Web 问题。
- en: The only prerequisite knowledge for this chapter is a basic understanding of
    how HTTP requests work, and a basic idea of the developer tooling that exists
    for web applications (for example, you should know how to use your browser’s console
    and other dev tools to debug basic HTTP issues).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章唯一的前提知识是对 HTTP 请求工作原理的基本了解，以及对 Web 应用程序开发工具的基本认识（例如，你应该知道如何使用浏览器的控制台和其他开发工具来调试基本的
    HTTP 问题）。
- en: Let’s start with some basic terminology that will come in handy when we get
    to troubleshooting.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一些基本术语开始，这些术语在我们进行故障排除时会派上用场。
- en: Basic terminology
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本术语
- en: Later sections will use a few terms you may not be familiar with, so let’s quickly
    cover them here.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 后续章节将使用一些你可能不熟悉的术语，所以我们在这里快速覆盖一下这些术语。
- en: Gateway
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网关
- en: In today’s world, the gateway is usually an HTTP reverse proxy, a load balancer,
    and frequently a combination of both. This can be an HTTP server, such as nginx
    or Apache, a physical load balancer in the classical sense, or a cloud variant
    of this same idea. It can also be a **content-delivery network** (**CDN**). So,
    when you receive an HTTP status code mentioning an error related to the gateway,
    it’s one of these gateway devices or applications talking to you.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今的世界中，网关通常是一个 HTTP 反向代理、负载均衡器，或者两者的组合。这可以是一个 HTTP 服务器，如 nginx 或 Apache，一个传统意义上的物理负载均衡器，或是这种思路的云变体。它也可以是一个**内容分发网络**（**CDN**）。所以，当你收到一个
    HTTP 状态码，提到与网关相关的错误时，就是这些网关设备或应用程序在与你通信。
- en: Upstream
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上游
- en: The upstream is the service that an application proxies to. In most situations,
    this will be the actual application or service, for example, an HTTP service you
    wrote. It is good to keep in mind that one can cascade or layer proxies, so there
    might be another intermediate proxy between the first proxy and the actual web
    application. For example, in many cloud infrastructures there is an ingress load
    balancer that handles and filters incoming traffic, behind which is an application
    load balancer that actually inspects the HTTP traffic and routes it to the right
    application server pool.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 上游是指应用程序代理的服务。在大多数情况下，这将是实际的应用程序或服务，例如，你编写的 HTTP 服务。需要记住的是，代理可以级联或层叠，因此，可能在第一个代理和实际
    Web 应用程序之间还有一个中间代理。例如，在许多云基础设施中，有一个入口负载均衡器负责处理和过滤传入流量，后面则是一个应用负载均衡器，实际上检查 HTTP
    流量并将其路由到正确的应用服务器池。
- en: Now that we’ve covered a few bits of terminology that go beyond HTTP, you’re
    prepared for the later sections of this chapter. Let’s now take a closer look
    at a few commonly misunderstood parts of HTTP and start using the `curl` tool
    to practice common CLI troubleshooting commands.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经介绍了一些超越 HTTP 的术语，你已经为本章后续的内容做好了准备。接下来，让我们更详细地了解一些 HTTP 中常见的误解部分，并开始使用
    `curl` 工具来练习常见的 CLI 排查命令。
- en: Common misunderstandings about HTTP
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于 HTTP 的常见误解
- en: When developing web applications and HTTP APIs, it can pay to be aware of a
    few details that many developers miss. Let’s look at a few of the key areas where
    knowing a bit extra can really pay off in terms of the reliability of the applications
    you create. The `curl` skills we cover in this chapter will also give you the
    ability to start troubleshooting something as vague as “the website is down” from
    the command line.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发 Web 应用程序和 HTTP API 时，了解一些很多开发者容易忽略的细节是很有价值的。让我们来看一下几个关键领域，掌握这些额外的知识对你所创建的应用程序的可靠性非常有帮助。本章中我们介绍的
    `curl` 技能，也将使你能够从命令行开始排查像“网站无法访问”这样模糊的问题。
- en: HTTP statuses
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP 状态码
- en: In the following sections, we will cover some of the common HTTP statuses you’ll
    encounter. We’ll also consider some important information and myths about these
    statuses that you should keep in mind.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将介绍一些你可能会遇到的常见 HTTP 状态码。我们还将讨论一些关于这些状态码的重要信息和误解，你需要牢记这些内容。
- en: Don’t just check for 200 OK
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不要只检查 200 OK
- en: A common way to check for errors is only checking for a 200 or the whole 2xx
    range of status codes to know whether a request was a success. There are some
    caveats to be aware of when doing this, though.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 检查错误的常见方法是只检查200或整个2xx范围的状态码，以确定请求是否成功。然而，进行此操作时需要注意一些陷阱。
- en: The 200 range (2xx, as in, every status code between 200 and 299) tends to indicate
    success and many APIs return 204 No Content to indicate that an operation was
    successful, especially when the API usually returns the resource that was created
    or modified, but in certain scenarios, like DELETEs or when it would be a waste
    of resources, it does not.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 200范围（2xx，即200到299之间的每个状态码）通常表示成功，许多API返回204 No Content来表示操作成功，尤其是当API通常返回已创建或已修改的资源时，但在某些场景下，例如DELETE请求，或者当返回资源会浪费资源时，则不会返回。
- en: Checking to see whether a response status is inside the 2xx range might be enough
    for some applications, but it is important to understand that application logic
    like “if it’s not a 200, log an error” is wrong. Neither the 1xx range nor the
    3xx range indicate an error, even though they aren’t 200s.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 检查响应状态是否在2xx范围内，对于某些应用来说可能足够，但重要的是要理解像“如果不是200，记录错误”这样的应用逻辑是错误的。1xx范围和3xx范围都不表示错误，即使它们不是200。
- en: It’s somewhat rare to see the 1xx range without expecting it, since the most
    common situations involving 100s are things like switching to WebSockets, but
    that doesn’t make them errors. The 3xx status code is returned quite often to
    inform the client about redirections, and while it might indicate that some action
    is needed – perhaps updating a path for some content that has moved – it’s definitely
    not a failure on its own.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 1xx范围的状态码在没有预期的情况下出现是相对罕见的，因为涉及100的最常见情况是切换到WebSocket，但这并不意味着它们是错误。3xx状态码经常被返回，用于通知客户端重定向，虽然它可能表示需要某些操作——例如更新已移动内容的路径——但它本身绝对不是失败。
- en: One status code in the 3xx range that tends to be seen a lot more often in production
    than in development is 304 Not Modified. This can be easily overlooked at development
    time and might also appear due to infrastructure changes or library updates that
    improve or introduce new caching behaviors. This status code is used when the
    client, such as a browser or an HTTP library, sends the request with an If-Not-Modified
    header, especially to take advantage of caching.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 3xx范围中一个在生产环境中比开发环境中更常见的状态码是304 Not Modified。在开发时，这个状态码很容易被忽视，也可能由于基础设施变化或库更新，改进或引入了新的缓存行为。这个状态码在客户端（如浏览器或HTTP库）发送带有If-Not-Modified头的请求时使用，特别是为了利用缓存。
- en: 'For these reasons, it usually makes sense to only consider status codes starting
    with 400 to be any kind of potential error, instead of considering only 2xx status
    codes to be a success. This still lends itself to neat logic inside your application:
    checking if a status code is greater than or equal to 400 is just as concise as
    checking to see if it’s in the 2xx range.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通常只将以400开头的状态码视为任何潜在错误，而不是仅仅将2xx状态码视为成功。这仍然有助于应用程序内部保持简洁的逻辑：检查状态码是否大于或等于400，与检查其是否在2xx范围内一样简洁。
- en: 404 Not Found
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 404 Not Found
- en: Something important to keep in mind is that the Not Found status code can mean
    different things depending on the application. 404 can be returned by (file) servers
    and gateways, but also by the application. It can imply that a route does not
    exist, but also that a specific resource (for example, a post or comment) does
    not exist for some reason (for example, if, it was deleted).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的一点是，Not Found状态码根据应用程序的不同可能意味着不同的事情。404可以由（文件）服务器和网关返回，也可以由应用程序返回。它可以表示某个路由不存在，也可以表示某个特定资源（例如，帖子或评论）因某种原因（例如被删除）而不存在。
- en: This is why 404 is often part of the normal response set returned by a healthy
    application that’s working as designed. In some situations, a client might even
    depend on this behavior, for example to verify that something doesn’t exist –
    before creating a certain resource or when indicating to a user whether a certain
    resource or resource name is already taken.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么404常常是健康应用正常响应集的一部分，且该应用按设计工作。在某些情况下，客户端甚至可能依赖这种行为，例如在创建某个资源之前或在告诉用户某个资源或资源名称是否已被占用时，验证某个内容是否不存在。
- en: In other words, the 404 status code alone (without more context about the application
    and the request) isn’t enough to indicate a problem. As you just saw, it may even
    indicate a success on multiple levels and layers. This is sometimes avoided by
    not using it in the application layer and signaling any “Not Found” situations
    differently, for example by still returning a status code of 200\. What the right
    way is depends on both the application and what a team or standard agrees on,
    and which architectural style is used in your application.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，单独的404状态码（没有关于应用程序和请求的更多上下文）不足以表明一个问题。正如你刚刚看到的，它可能在多个层面和层次上表示成功。有时可以通过在应用层避免使用它，并以不同的方式表示“未找到”情况，例如仍然返回200状态码，来避免这种情况。正确的做法取决于应用程序、团队或标准的约定，以及你应用程序使用的架构风格。
- en: 502 Bad Gateway
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 502 错误网关
- en: This status code means that the gateway didn’t understand what the upstream
    returned; in other words, the response to the request that the gateway forwarded
    wasn’t a complete and valid HTTP response. This typically indicates a problem
    with the upstream service.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个状态码意味着网关没有理解上游返回的内容；换句话说，网关转发请求的响应不是一个完整且有效的HTTP响应。这通常表示上游服务有问题。
- en: 503 Service Unavailable
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 503 服务不可用
- en: A 503 usually means that the upstream service isn’t reachable on the port that
    the gateway is configured to try. Practically, this means that the web application
    might have crashed, or that it’s not listening for HTTP requests, or that it’s
    listening on the wrong port, or that it’s blocked by a firewall rule or a broken
    routing rule, or a myriad of other reasons.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 503 通常意味着上游服务在网关配置的端口上无法访问。实际上，这意味着Web应用程序可能崩溃了，或者它没有监听HTTP请求，或者它监听的是错误的端口，或者它被防火墙规则或破损的路由规则阻止，或者有其他无数原因。
- en: 504 Gateway Timeout
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 504 网关超时
- en: When a gateway creates a connection to an upstream, this connection times out
    at some point. This is important because hanging processes consume resources on
    both ends; on the gateway *and* the service. Usually, such timeouts only occur
    if this is unexpected and there are no bytes being written or read.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当网关与上游建立连接时，这个连接会在某个时刻超时。这一点很重要，因为挂起的进程会消耗双方的资源；无论是网关*还是*服务。通常，只有在这种情况出乎意料且没有字节被写入或读取时，才会发生这种超时。
- en: If the upstream service has a long-running request caused by waiting for computation
    or something similar, one option is to increase the time a request can take until
    this timeout occurs. However, it is usually advisable to take a different approach.
    For example, making that endpoint asynchronous or starting to write bytes earlier
    (such as by streaming data) can help.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上游服务有一个需要长时间运行的请求（例如等待计算等），一种选择是增加请求的超时时间。然而，通常建议采取不同的方法。例如，可以将该端点改为异步，或者通过提前开始写入字节（例如通过数据流式传输）来帮助解决问题。
- en: The reason for this is that until there is a timeout, resources are used up
    and the requesting side doesn’t know whether the application will ever return
    a response. So, if the web service malfunctions, neither the gateway nor the client
    will know about it. This might also cause the gateway to think that the malfunctioning
    service is still up and running, instead of quickly detecting the problem and
    failing over to another instance of the service.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的原因是，在超时之前，资源会被消耗，而请求方并不知道应用程序是否会返回响应。因此，如果Web服务出现故障，网关和客户端都不会知道。这可能还会导致网关认为故障的服务仍在运行，而不是快速检测问题并切换到服务的其他实例。
- en: 'Introduction to curl: checking HTTP response status'
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: curl简介：检查HTTP响应状态
- en: If you learn only one command-line tool to help you troubleshoot HTTP, you would
    do well to learn `curl`. As we continue to talk about areas of HTTP that are useful
    to understand in more depth, we’ll add sections like this to show you practical
    `curl` commands you can use while troubleshooting common issues related to the
    aspects of HTTP we just covered.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只学习一个命令行工具来帮助你排查HTTP问题，`curl`是一个不错的选择。当我们继续深入讨论HTTP的各个方面时，我们会添加类似这样的章节，展示你可以在排查与HTTP相关的常见问题时使用的实用`curl`命令。
- en: 'The simplest `curl` invocation is something like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的`curl`调用如下所示：
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is just like pasting the URL into the browser – except it cuts out the
    browser and directly returns the web server’s response on the command line. Not
    the most exciting way to browse the web, to be sure. Let’s do something that’s
    a bit more useful for your next troubleshooting script: checking the status of
    an HTTP response!'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像将 URL 粘贴到浏览器中——只是它跳过了浏览器，直接返回 web 服务器的响应到命令行。虽然这并不是浏览网页最激动人心的方式，但它更适合你下一个故障排除脚本的需求：检查
    HTTP 响应的状态！
- en: 'Curl can easily be used to check whether a web server is up and responding
    to requests:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Curl 可以轻松地用来检查一个 web 服务器是否正常运行并响应请求：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Based on this output, we know that the web server is up and the `/` route is
    responding with a 200 OK status. You also see the HTTP version here (HTTP/2),
    which we’ll discuss later. Specifically, this command issues a HEAD request (`-I`
    or `--head`), muting curl’s progress and error messages (`-s` or `--silent`).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个输出，我们知道 web 服务器已经启动，并且 `/` 路由正在响应 200 OK 状态。你还可以看到这里的 HTTP 版本（HTTP/2），我们稍后会讨论。具体来说，这个命令发出了一个
    HEAD 请求（`-I` 或 `--head`），静默了 curl 的进度和错误信息（`-s` 或 `--silent`）。
- en: 'You’ll still see error messages when something is wrong, though, thanks to
    the `-S` (or `--show-error`) option:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通过 `-S`（或 `--show-error`）选项，你仍然会看到错误信息，当出现问题时：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Finally, we’re chopping off most of the headers and only looking for the status
    code, which is the first line (`| head -n 1`).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将截取大部分头部，只查看状态码，这是第一行（`| head -n 1`）。
- en: However, you’ll often want to see the headers when troubleshooting. Let’s look
    at a few header-related HTTP gotchas and then try using `curl` to inspect headers.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在故障排除时，你通常需要查看头部信息。让我们看几个与头部相关的 HTTP 陷阱，然后尝试使用 `curl` 检查头部。
- en: HTTP headers
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP 头部
- en: Case-insensitive headers
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 头部不区分大小写
- en: The headers in HTTP are case-insensitive. Some software relies on this fact,
    and as a result certain gateways might modify and “normalize” these headers. Fortunately,
    it is rare for developers to directly interact with raw header values when writing
    a web application. Instead, they use web libraries, which abstract most of this
    complexity away and take care of these kinds of details. However, you should still
    make sure this is the case and normalize them, for example by lower-casing headers
    that your web application sets. This can also prevent situations where response
    headers are accidentally added multiple times with different letter casings.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 中的头部是不区分大小写的。某些软件依赖于这一点，结果某些网关可能会修改并“规范化”这些头部。幸运的是，开发人员在编写 web 应用程序时很少直接与原始头部值交互。相反，他们使用
    web 库，这些库会将大部分复杂性抽象化，并处理这些细节。然而，你仍然应该确保这一点，并规范化它们，例如通过将你 web 应用程序设置的头部转换为小写。这样也可以防止响应头部因字母大小写不同而被意外添加多次。
- en: Custom headers
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义头部
- en: When you create custom HTTP headers for an application, be aware of the prefix
    you decide to use. It used to be common to prefix custom headers with `X-`, for
    example `X-My-Header`. This practice is now considered bad (see RFC 6648, which
    deprecates it). Instead, it makes sense to create a custom prefix, such as the
    name of the project, product, or company, or an abbreviation of it. This prevents
    situations where that header will be reused by other developers who mistake it
    for an official part of the HTTP standard.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当你为应用程序创建自定义 HTTP 头部时，要注意你决定使用的前缀。过去，通常会使用 `X-` 作为自定义头部的前缀，例如 `X-My-Header`。这种做法现在已被认为是不好的（参见
    RFC 6648，已经弃用该做法）。相反，更合适的是创建一个自定义前缀，例如项目、产品或公司名称，或者它的缩写。这可以避免其他开发人员误将这个头部当作 HTTP
    标准的一部分而重复使用。
- en: Viewing HTTP headers with curl
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 curl 查看 HTTP 头部
- en: 'The `-I` option we introduced in the previous `curl` example is useful for
    viewing the response headers, which can help reveal caching problems, content-type
    mismatches, and other issues. Let’s see what the tutorialinux server has to say
    in its headers:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的 `curl` 示例中介绍的 `-I` 选项对于查看响应头非常有用，这可以帮助发现缓存问题、内容类型不匹配以及其他问题。让我们看看 tutorialinux
    服务器的头部信息：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There’s nothing wrong with the server at the moment, but these headers already
    give me a few ideas of how to improve my nginx configuration: leaking software
    names and version numbers is usually a bad idea from a security perspective, and
    no one receiving HTML or JSON from this server needs to know that the backend
    is using PHP.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 目前服务器没有问题，但这些头部信息已经给了我一些如何改进 nginx 配置的想法：从安全角度来看，泄露软件名称和版本号通常是不好的做法，而没有人需要知道从这个服务器接收
    HTML 或 JSON 的用户，后台正在使用 PHP。
- en: HTTP versions
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP 版本
- en: To explain some of the newer HTTP features you’ll see used, we’ll give you a
    brief history of the protocol. HTTP has been around for a while and has changed
    a lot, especially in recent years as web applications have come into vogue. The
    main concepts and primitives have largely remained the same since HTTP’s inception,
    however, some tricks, optimizations, and behaviors have changed. Being aware of
    the protocol version can help with debugging or preventing issues and reduce unnecessary
    or counter-productive optimizations and workarounds.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明一些你将看到的新 HTTP 特性，我们将简要回顾一下这个协议的历史。HTTP 已经存在一段时间，并且发生了很多变化，特别是在近年来，随着 Web
    应用的流行，变化尤为显著。自 HTTP 起源以来，主要的概念和原语基本保持不变，然而，一些技巧、优化和行为已经发生了变化。了解协议版本有助于调试或预防问题，并减少不必要或适得其反的优化和变通方法。
- en: HTTP/0.9
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTTP/0.9
- en: You’re unlikely to come across this version of HTTP anymore. It is the most
    minimal HTTP one can imagine. HTTP/0.9 allows for sending a `GET` request to a
    server and receiving what we now call the *body* of an HTTP request. No headers
    were sent or returned, not even a version header or a status code.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你不太可能再遇到这个版本的 HTTP 它是一个极简的 HTTP 版本。HTTP/0.9 允许向服务器发送一个 `GET` 请求并接收我们现在称之为 HTTP
    请求 *主体* 的内容。没有发送或返回头部，甚至没有版本头或状态码。
- en: HTTP/1.0 and HTTP/1.1
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTTP/1.0 和 HTTP/1.1
- en: HTTP/1.0 and especially HTTP/1.1 came a lot closer to what people think of when
    they think of HTTP today. While HTTP/1.0 added a version number and headers, HTTP/1.1
    paved the way for methods and a substantial number of extensions, usually in the
    form of headers.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/1.0，特别是 HTTP/1.1，离人们今天对 HTTP 的理解更近了。虽然 HTTP/1.0 添加了版本号和头部，但 HTTP/1.1 为方法和大量扩展（通常以头部的形式）铺平了道路。
- en: HTTP/1.1 also added (and defaults to) pipelining. This means that multiple requests
    could be sent using the same TCP connection. Another widely used addition is the
    `Host` header, which allows for the same server or IP to use multiple hostnames.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/1.1 还增加了（并默认启用）管道化。这意味着多个请求可以通过同一个 TCP 连接发送。另一个广泛使用的新增功能是 `Host` 头，它允许同一服务器或
    IP 使用多个主机名。
- en: For example, a web server could now be configured to respond with requests for
    `http://example.org/`, `http://www.example.org/`, `http://forum.example.org/`,
    and `http://blog.example.org/` without requiring a separate IP address for each
    of them.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Web 服务器现在可以配置为响应 `http://example.org/`、`http://www.example.org/`、`http://forum.example.org/`
    和 `http://blog.example.org/` 的请求，而无需为每一个请求使用单独的 IP 地址。
- en: 'HTTP/1.1 also enabled many extensions: caching, compression, various authentication
    schemes, content negotiation, and even things like WebSockets. All of these are
    widely used in today’s web.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/1.1 还启用了许多扩展：缓存、压缩、各种身份验证方案、内容协商，甚至是像 WebSockets 这样的功能。所有这些在今天的 Web 中被广泛使用。
- en: HTTP/2
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTTP/2
- en: There are many articles extolling the virtues of HTTP/2\. It is a huge and controversial
    step in a new direction for HTTP. While HTTP/1.1 was a text-based protocol that
    allowed anyone to create complete and valid requests in a terminal or text editor,
    HTTP/2 is a binary protocol that also handles streams, which are a mechanism to
    create a lightweight variant of a TCP connection.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多文章赞扬 HTTP/2 的优点。它是 HTTP 向新方向迈出的巨大且具有争议的一步。虽然 HTTP/1.1 是一个基于文本的协议，允许任何人在终端或文本编辑器中创建完整有效的请求，但
    HTTP/2 是一个二进制协议，它还处理流，这是创建轻量级 TCP 连接变体的一种机制。
- en: The binary format and header compression mean that dedicated tools are now required
    to talk to an HTTP server (or client). The overall concepts, however, have remained
    the same as in earlier versions of HTTP, so as a web developer you’ll only notice
    the differences in specific situations.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制格式和头部压缩意味着现在需要专用工具来与 HTTP 服务器（或客户端）进行通信。然而，整体概念与早期版本的 HTTP 保持一致，因此作为一名 Web
    开发者，你只会在特定情况下注意到差异。
- en: While HTTP/2 also adds a lot of entirely new features, many of them are rarely
    used in user-facing web applications and might not even be implemented by browsers.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 HTTP/2 也增加了许多全新的功能，但其中许多在面向用户的 Web 应用中很少使用，甚至可能没有被浏览器实现。
- en: While this isn’t technically part of the official standard, HTTP/2 in the browser
    is typically limited to HTTPS.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这在技术上并不是官方标准的一部分，但在浏览器中，HTTP/2 通常仅限于 HTTPS。
- en: In most situations, web applications will benefit from enhancements such as
    using a single TCP connection with multiple streams, especially when many requests,
    such as those for static files and AJAX, are made in parallel. This can render
    some optimizations, like sprite sheets or combining many files into a single one,
    unnecessary. When some of these optimizations lead to redundant data being transferred,
    they might even be counterproductive.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，Web 应用将从增强功能中受益，例如使用单个 TCP 连接并进行多个流传输，尤其是在许多请求（如静态文件和 AJAX 请求）并行发出时。这可以使某些优化方法（如精灵图或将多个文件合并为一个文件）变得不再必要。当这些优化导致冗余数据传输时，甚至可能适得其反。
- en: Some applications designed for HTTP/1.1 might require changes when switching
    to HTTP/2, because things like keeping connections alive might have unpredictable
    side-effects. For this and other reasons, it’s a good idea to test web applications
    before converting them to HTTP/2\. There are even instances where people have
    found that switching their applications to HTTP/2 increases page load times or
    increases resource use.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一些为 HTTP/1.1 设计的应用在切换到 HTTP/2 时可能需要进行修改，因为像保持连接活动这样的操作可能会产生不可预测的副作用。基于这一点和其他原因，建议在将应用程序转换为
    HTTP/2 前进行测试。有时，甚至会发现将应用程序切换到 HTTP/2 会增加页面加载时间或增加资源使用。
- en: This means that real life tests and monitoring to compare the differences between
    HTTP protocols are a good idea. Since many of the benefits of HTTP/2 target real-life
    usage by web browsers, a simple command-line load test might not give the same
    results as real users accessing the web application. A typical mistake, for example,
    is not taking HTTP/1.1’s pipelining feature into consideration.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着进行实际测试和监控，以比较 HTTP 协议之间的差异是一个好主意。由于 HTTP/2 的许多优点针对的是 Web 浏览器的实际使用，简单的命令行负载测试可能无法与真实用户访问
    Web 应用时的结果相同。例如，一个常见的错误是不考虑 HTTP/1.1 的流水线功能。
- en: However, for most real-life websites, HTTP/2 will bring benefits. For internal
    HTTP APIs on microservices, many companies are choosing to keep using HTTP/1.1
    or gRPC.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于大多数现实生活中的网站来说，HTTP/2 将带来好处。对于微服务中的内部 HTTP API，许多公司选择继续使用 HTTP/1.1 或 gRPC。
- en: HTTP/3 and QUIC
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTTP/3 和 QUIC
- en: HTTP/3 builds on the developments of HTTP/2 and moves its concepts to a UDP-based
    transport protocol called QUIC (instead of TCP, which all other HTTP versions
    use).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/3 基于 HTTP/2 的发展，并将其概念迁移到一种基于 UDP 的传输协议 QUIC（而不是其他 HTTP 版本使用的 TCP）。
- en: Like the previous version of HTTP, HTTP/3 uses streams as a lightweight alternative
    to establishing a new TCP connection. Unlike HTTP/2 this isn’t done by initiating
    streams inside an existing TCP connection, but rather by using QUIC, which is
    a protocol designed to allow for such streams.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 像之前版本的 HTTP 一样，HTTP/3 使用流作为建立新 TCP 连接的轻量级替代方案。与 HTTP/2 不同，HTTP/3 并不是通过在现有的 TCP
    连接内启动流来实现，而是通过使用 QUIC，它是一个专门为支持此类流而设计的协议。
- en: QUIC has some advantages over TCP for common HTTP use cases. For example, because
    it’s UDP-based – UDP is the User Datagram Protocol, a more bare-bones but faster
    alternative to TCP – QUIC prevents situations where the whole connection can stall
    because a single packet hasn’t arrived (yet), even if that packet is destined
    for a different stream. QUIC is also optimized for quickly establishing that initial
    connection, including initiating TLS to secure the connection between the client
    and server. QUIC itself was created with extensibility and support for future
    versions in mind, and shortly after its standardization many such extensions were
    already on their way to being standardized.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: QUIC 在常见的 HTTP 使用场景中相比于 TCP 有一些优势。例如，由于 QUIC 基于 UDP——UDP 是用户数据报协议，一种比 TCP 更简化但更快速的替代方案——它可以防止因单个数据包尚未到达（即便该数据包是传输给不同流的）而导致整个连接停滞的情况。QUIC
    还针对快速建立初始连接进行了优化，包括启动 TLS 以确保客户端与服务器之间的连接安全。QUIC 本身是为了支持未来版本的扩展性而创建的，在标准化后不久，许多此类扩展已经开始标准化。
- en: Since HTTP/3 is based on UDP and designed to avoid *protocol ossification*,
    many traditional forms of intermediate nodes and gateways become obsolete.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 HTTP/3 基于 UDP 并旨在避免 *协议僵化*，许多传统的中间节点和网关形式变得过时。
- en: '**Note**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Protocol ossification is what happens when intermediate nodes (or anything that
    interacts with a protocol) require a protocol to keep a certain form, thereby
    making it hard to continue developing and changing that protocol (for example
    by adding extensions).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 协议僵化指的是当中间节点（或任何与协议交互的部分）要求协议保持某种形式时，导致协议的持续开发和更改变得困难（例如，添加扩展）。
- en: 'Let’s look at how these basic HTTP concepts fit into the larger infrastructure
    that most of your web applications will be running in. In an architecture like
    this, it’s rarely just a single web server and a client (like your web browser
    or `curl`): there are usually several layers of HTTP communication happening,
    and simple problems can compound and become hard to troubleshoot.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些基本的HTTP概念如何融入大多数Web应用程序所运行的更大基础设施中。在这样的架构中，通常不仅仅是一个单独的Web服务器和客户端（像你的Web浏览器或`curl`）：通常会有几个HTTP通信层次，简单的问题可能会累积并变得难以排查。
- en: As usual, we’ll give you the most important concepts you need to understand,
    followed by a few practical tips on troubleshooting more complex web infrastructures
    using `curl` on the command line.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如常，我们将为你提供你需要理解的最重要概念，随后是一些使用`curl`命令行工具排查更复杂Web基础设施问题的实用技巧。
- en: Load balancing
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 负载均衡
- en: Load balancing is a way to spread the load destined for a service across many
    instances of that service. While this is certainly not limited to HTTP and web
    services, HTTP is one of the most common contexts in which load balancing is used
    today.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 负载均衡是一种将目标服务的负载分散到该服务的多个实例上的方法。虽然这并不仅限于HTTP和Web服务，但HTTP是目前负载均衡最常见的应用场景之一。
- en: It’s important for you to understand how web application load balancing works,
    because it affects how bugs and problems show up in production. For example, in
    your local development environment, you are usually dealing with a single client
    (your browser or another API consumer) and a single server (the web application
    or service you’re working on). In the real world, there are often multiple layers
    of servers between your client and the application, each speaking and relaying
    your HTTP traffic and possibly introducing its own problems or bugs into the flow.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 了解Web应用负载均衡的工作原理非常重要，因为它会影响在生产环境中如何出现错误和问题。例如，在本地开发环境中，你通常只处理单一客户端（你的浏览器或其他API消费者）和单一服务器（你正在开发的Web应用或服务）。但在真实世界中，客户端和应用之间通常会有多个服务器层，每一层都负责转发HTTP流量，并可能在流量中引入自己的问题或错误。
- en: The material in this section will give you a high-level understanding of the
    moving parts that become part of the application as a whole, even though they’re
    not part of the application code you write.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 本节材料将帮助你高层次地理解那些虽然不属于你编写的应用代码，但却成为整个应用一部分的活动组件。
- en: 'HTTP load balancing is usually achieved by putting a layer of infrastructure
    in front of the application to proxy HTTP requests; usually one of the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP负载均衡通常是通过在应用前面放置一层基础设施来代理HTTP请求；通常有以下几种方式：
- en: Gateway service, such as an HTTP server supporting it (such as nginx or Apache)
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网关服务，例如支持的HTTP服务器（如nginx或Apache）
- en: Dedicated service (such as HAProxy or relayd)
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 专用服务（如HAProxy或relayd）
- en: Cloud service (GCP’s Load Balancer, AWS’s ELB or ALB, and so on)
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 云服务（如GCP的负载均衡器、AWS的ELB或ALB等）
- en: Hardware load balancer
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 硬件负载均衡器
- en: Sometimes, engineers choose to use a custom service or a DNS-based solution,
    especially in the context of regional load balancing which is often used as an
    additional layer in front of one of the other methods mentioned above. Container
    orchestrators and dedicated service discovery mechanisms also usually provide
    yet another mechanism for load balancing.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，工程师选择使用自定义服务或基于DNS的解决方案，尤其是在区域性负载均衡的场景中，这通常作为前置层添加在上述提到的其他方法之前。容器编排工具和专用的服务发现机制通常也提供另一种负载均衡的方式。
- en: Introducing load balancers into the mix pulls in a few other concepts to understand
    – specifically around how these load balancers actually map requests coming from
    a client to a server running an instance of the web application that you lovingly
    crafted.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 引入负载均衡器会涉及到理解一些其他概念——尤其是如何将来自客户端的请求映射到正在运行你精心设计的Web应用实例的服务器上。
- en: Session and cookie management becomes complex, because long-running sessions
    are no longer guaranteed to hit the same server every time. One server in your
    application pool going down becomes an issue – will your users’ experience be
    interrupted, or will they lose data? Will you, as an engineer troubleshooting
    your own web application, be unable to replicate an issue because it’s only happening
    on a single server out of tens or hundreds?
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 会话和 cookie 管理变得复杂，因为长期运行的会话不再保证每次都会命中相同的服务器。应用池中的一台服务器出现故障会成为问题 —— 用户体验会中断吗？他们会丢失数据吗？作为工程师的你在排查自己
    web 应用程序的问题时，是否无法重现问题，因为它只发生在数十台或数百台服务器中的一台上？
- en: Understanding how modern load balancing works is essential to avoid application
    design flaws or troubleshooting woes like this, and the next few sections will
    equip you with a basic mental model that you can use to avoid them.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 了解现代负载均衡是如何工作的，对于避免应用设计缺陷或类似这种排查困难的麻烦至关重要，接下来的几节将为你提供一个基本的思维模型，帮助你避免这些问题。
- en: Sticky sessions, cookies, and deterministic hashing
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 粘性会话、cookies 和确定性哈希
- en: When setting up load balancing for HTTP services, one of the first questions
    to ask is whether a service requires sticky sessions. Sticky sessions are a mechanism
    for tying a client to a specific application server for the duration of the session;
    they’re often required for applications that keep session state on the application
    server itself.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在为 HTTP 服务设置负载均衡时，第一个需要问的问题是该服务是否需要粘性会话。粘性会话是一种将客户端与特定应用服务器绑定在一起的机制，通常对于那些将会话状态保存在应用服务器上的应用程序是必须的。
- en: This is one of the reasons why it’s best practice to design “stateless” applications,
    which write state to a shared data layer – in these applications, it doesn’t matter
    if a client’s first request is handled by a different server than that client’s
    second request. Thankfully in today’s world, especially when relying on a cloud-based
    infrastructure, sticky sessions are usually not required. However, this is something
    to keep in mind, especially when troubleshooting issues that mysteriously only
    crop up in load-balanced production environments.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是为什么设计“无状态”应用程序的最佳实践之一，因为这些应用程序将状态写入共享数据层 —— 在这些应用程序中，客户端的第一次请求是否由不同的服务器处理与第二次请求无关。幸运的是，在今天的世界中，尤其是在依赖基于云的基础设施时，通常不需要粘性会话。然而，这一点值得记住，特别是在排查只在负载均衡的生产环境中神秘出现的问题时。
- en: While there are many ways to create sticky sessions in HTTP, the most common
    way is through cookies. This can either be via application cookies (such as session
    cookies) that the load balancer is aware of, or via dedicated cookies that the
    load balancer manages on its own.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有许多方法可以在 HTTP 中创建粘性会话，但最常见的方法是通过 cookies。这可以通过负载均衡器可以识别的应用程序 cookies（如会话 cookies）来实现，也可以通过负载均衡器自己管理的专用
    cookies 来实现。
- en: Implementing sticky sessions by storing additional state on the load balancer
    is fraught with its own problems, though. If a load balancer must keep an internal
    mapping of IP addresses to application servers, what happens if that load balancer
    goes down and is replaced, losing that state? You can see that we’ve simply moved
    the state problem from the application server to the load balancer, and are hoping
    that nothing bad happens there. However, as the adage says, hope is not a viable
    strategy.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通过在负载均衡器上存储额外的状态来实现粘性会话本身也存在一些问题。如果负载均衡器必须保持 IP 地址到应用服务器的内部映射，那么如果该负载均衡器崩溃并被替换，导致状态丢失，会发生什么？你会发现，我们只是将状态问题从应用服务器转移到了负载均衡器上，并希望那里不会发生任何不好的事情。然而，正如俗话所说，希望并不是一种可行的策略。
- en: One clever way to achieve sticky sessions without dealing with the problem of
    needing to store state on the load balancer is to load balance using an IP hash.
    To achieve this, a hash of the client’s IP is created and used to map request
    IPs to instances of a service. As long as the IP of the client stays the same,
    the session will be “sticky” to that particular application instance.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 实现粘性会话的一个巧妙方法是通过使用 IP 哈希进行负载均衡，而不需要处理在负载均衡器上存储状态的问题。为了实现这一点，会创建客户端 IP 的哈希值，并用于将请求的
    IP 映射到服务实例上。只要客户端的 IP 不变，会话就会对该特定的应用实例保持“粘性”。
- en: Now, one or many load balancers will deterministically match IPs to application
    servers, without needing to communicate or share state. Servers can come and go
    as they please, and each new server will make the same matching decisions as all
    other servers, since they’re all using the same hashing algorithm and will always
    match a given IP to the same application server.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一个或多个负载均衡器将确定性地将IP地址与应用服务器匹配，无需通信或共享状态。服务器可以随意进出，每个新服务器都会做出与其他服务器相同的匹配决定，因为它们都使用相同的哈希算法，并且始终将给定的IP地址匹配到相同的应用服务器。
- en: Round-robin load balancing
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 轮询负载均衡
- en: If sticky sessions aren’t required, the most common mechanism for balancing
    load is round-robin. This means that every new connection or request is routed
    to the next instance. In mathematical terms this means that the instance is chosen
    by `request_count % instance_count` (% being modulo).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不需要粘性会话，最常见的负载均衡机制是轮询。这意味着每个新的连接或请求都会被路由到下一个实例。从数学角度来看，这意味着实例是通过`request_count
    % instance_count`（%表示取余）来选择的。
- en: Other mechanisms
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他机制
- en: You now have a high-level overview of how HTTP load balancing works in the real
    world. Of course, there are many other mechanisms that can be chosen, such as
    spreading the load based on resource usage, but you should be careful to really
    understand the effects of added complexity – many “clever” load-balancing algorithms
    are not without major pitfalls.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在对HTTP负载均衡在现实世界中的工作原理有了一个高层次的概览。当然，还有许多其他的机制可以选择，例如基于资源使用情况的负载分配，但你应该小心真正理解增加复杂性所带来的影响——许多“聪明”的负载均衡算法并非没有重大陷阱。
- en: For example, resource-utilization-based load balancers can encounter problems
    handling short spikes in load, which can cause underutilization of one instance
    and over-utilization of another, because the real-life workload the service deals
    is spiky and the load measurements come at the wrong time and don’t even out these
    spikes.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，基于资源利用率的负载均衡器在处理短暂的负载峰值时可能会遇到问题，这可能导致一个实例的利用率不足而另一个实例的利用率过高，因为服务实际处理的工作负载具有波动性，而负载测量的时间不合适，未能平衡这些峰值。
- en: Adding another layer of complexity to even out such spikes might cause other
    issues such as having many of these spikes stack on top of each other. If you
    find yourself leaving the well-trodden path of more established load-balancing
    mechanisms, make sure your team is putting enough technical consideration into
    the architecture and the context of the actual application and its usage.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了平衡这样的负载峰值，可能会增加额外的复杂性，这也可能带来其他问题，比如这些峰值会堆叠在一起。如果你发现自己偏离了更为成熟的负载均衡机制，确保你的团队已经充分考虑了架构和实际应用及其使用场景的技术细节。
- en: High availability
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 高可用性
- en: While a primary goal of load balancing might be to ensure quick responses, a
    load balancer will typically keep track of which services are reachable. It might
    use health checking to verify that the servers it sends requests to are fully
    functional. This means that load balancing is also a way to achieve high availability
    and often also an integral part of a zero-downtime architecture where a service
    can be replaced (for example, when a new version is deployed) without clients
    noticing.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然负载均衡的主要目标可能是确保快速响应，但负载均衡器通常会跟踪哪些服务是可达的。它可能会使用健康检查来验证它发送请求的服务器是否完全正常。这意味着负载均衡也是实现高可用性的一种方式，通常也是零停机架构的一个组成部分，在这种架构中，服务可以被替换（例如，当部署新版本时），而客户端不会察觉。
- en: This can be achieved by allowing some form of graceful shutdown of instances,
    where connections to clients aren’t simply dropped, but connections will remain
    active until they are fully processed, while new connections are only routed to
    updated instances. When the last session ends the outdated instance can be fully
    shut down.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过允许实例以某种形式优雅地关闭来实现，其中与客户端的连接不会被简单地断开，而是保持活跃直到完全处理完毕，而新的连接只会被路由到已更新的实例。当最后一个会话结束时，过时的实例可以完全关闭。
- en: Health checks allow a load balancer to determine whether a service is fully
    operational. The most basic check, of course, is whether a connection can be established.
    However in microservice architectures, an external dependency (like another service)
    not being reachable can prevent a service from properly responding to requests.
    This can also be indicated via a dedicated status endpoint.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 健康检查使负载均衡器能够判断服务是否完全正常运行。当然，最基本的检查是是否能够建立连接。然而，在微服务架构中，无法访问外部依赖（比如另一个服务）可能会阻止服务正确响应请求。这也可以通过一个专门的状态端点来指示。
- en: Many application and infrastructure teams agree on a route like `/healthcheck`,
    whose status code indicates whether requests should be routed to the service.
    In some more complex environments, such a route might even indicate which *kinds*
    of requests can be routed to the instance.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序和基础设施团队会达成一致，使用像 `/healthcheck` 这样的路由，其状态码指示请求是否应路由到该服务。在一些更复杂的环境中，这样的路由甚至可能指示可以路由到实例的*请求类型*。
- en: When skilled application developers and platform/SRE teams get together, healthcheck
    routes can even be built to signal situations that require action from the infrastructure,
    such as the instance being critically unhealthy and needing to be replaced. If
    such routes are well designed, they typically also respond with additional context
    and information on the problem to ease debugging production issues.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当熟练的应用开发人员和平台/SRE 团队聚集在一起时，健康检查路由甚至可以构建为在基础设施需要采取行动时发出信号，比如实例出现严重故障需要替换。如果这些路由设计得当，通常也会提供关于问题的额外上下文和信息，以便简化生产环境中的调试工作。
- en: As the infrastructure that supports a web application grows larger and more
    complex, the number of things that can go wrong increases exponentially, and is
    highly dependent on the specific architecture and application. One class of problem
    that becomes more likely the more layers of proxying and routing a web infrastructure
    has is redirect loops and general redirection errors.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 随着支撑 web 应用的基础设施变得越来越大和复杂，可能出现的问题也呈指数级增加，并且高度依赖于具体的架构和应用程序。一类问题是在 web 基础设施拥有更多代理和路由层时更容易出现的，即重定向循环和一般的重定向错误。
- en: Thankfully, this is something that a command-line tool like `curl` is perfectly
    positioned to troubleshoot.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，像 `curl` 这样的命令行工具正好可以用来排查这个问题。
- en: Troubleshooting redirects with curl
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 curl 排查重定向问题
- en: 'As we just mentioned, redirects can be a common symptom of bugs, problems,
    and more generally unexpected behavior in a web application and its surrounding
    infrastructure. Use curl’s `-L` (or `--location`) option to follow them:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚刚提到的，重定向可以是 web 应用及其周边基础设施中的常见故障、问题，甚至是一些意外行为的表现。使用 curl 的 `-L`（或 `--location`）选项来跟踪它们：
- en: '[PRE4]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You’ll see that the server replies with a `301` (Moved Permanently) and the
    correct location, [https://tutorialinux.com/](https://tutorialinux.com/). `curl`
    follows the redirect and makes a request to that new location, where it gets a
    200 (OK) status.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到服务器返回 `301`（永久移动）和正确的位置，[https://tutorialinux.com/](https://tutorialinux.com/)。`curl`
    跟踪该重定向并向新位置发起请求，在那里它得到了一个 200（OK）状态。
- en: This redirect is working as expected, but you can use this `curl` command to
    do things like identify redirect loops in an application or troubleshoot caching
    and routing issues in multi-layer load balancer setups.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个重定向按预期工作，但你可以使用这个 `curl` 命令来做一些事情，例如识别应用程序中的重定向循环，或者排查多层负载均衡设置中的缓存和路由问题。
- en: Sometimes, though, you’ll need to go deeper and send data to a web application
    to troubleshoot it. `curl` can help there, too!
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时你需要深入并向 web 应用发送数据来进行故障排除。`curl` 也可以帮助解决这个问题！
- en: Using curl as an API testing tool
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 curl 作为 API 测试工具
- en: 'Having a quick `curl` command loaded up in your brain for API testing comes
    in handy more than you’d think. Especially when dealing with JSON APIs that accept
    POST data, it’s common to want to send some test data to an endpoint to make sure
    the backend is returning what you expect:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个快速的 `curl` 命令用于 API 测试，比你想象的更有用。特别是在处理接受 POST 数据的 JSON API 时，通常会希望向某个端点发送一些测试数据，以确保后端返回了你期望的内容：
- en: '[PRE5]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This command uses a few flags that you’ll want to remember. First, the `--header`
    (`-H`) argument lets you specify a header string to set (you can supply multiple
    headers by simply repeating this argument). Next, the `--request` (or `-X`) flag
    lets you specify the HTTP request type (by default, `curl` performs GET requests,
    but using this flag lets you change that). And when you’re POSTing or PATCHing
    some data, as in this case, you’ll want the `--data` (or `-d`) argument, which
    lets you send data.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令使用了一些你需要记住的标志。首先，`--header` (`-H`) 参数允许你指定一个头部字符串（你可以通过重复此参数来提供多个头部）。接下来，`--request`（或
    `-X`）标志允许你指定 HTTP 请求类型（默认情况下，`curl` 执行 GET 请求，但使用此标志可以改变请求类型）。当你进行 POST 或 PATCH
    数据请求时，如本例所示，你需要使用 `--data`（或 `-d`）参数，这样可以发送数据。
- en: 'In the case of `--data`, remember that bash escape characters play a role here,
    so for complex data you’ll probably find it easier to use the `--data` option,
    like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `--data` 时，记住 bash 转义字符在这里发挥作用，因此对于复杂的数据，你可能会发现使用 `--data` 选项会更方便，如下所示：
- en: '[PRE6]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Remember to prepend the `@` character to your filepath. If you’re sending complex
    data, read up on `--data-raw`, `--data-binary`, and `--data-urlencode` as well.
    You may need to send extra headers as well, depending on what your web application
    expects.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在文件路径前添加 `@` 字符。如果你发送的是复杂数据，也可以查阅 `--data-raw`、`--data-binary` 和 `--data-urlencode`。根据你的
    web 应用程序的要求，你可能还需要发送额外的头部。
- en: 'You’ve now seen how to get more interactive with the web applications you’re
    troubleshooting, using `curl` to send them custom data. But there’s one last `curl`
    trick we want to show you: TLS (short for Transport Layer Security, the way we
    encrypt modern web traffic in HTTPS) is not necessarily a “misunderstood” aspect
    of web applications, but it’s a common failure point that `curl` can help with.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经了解了如何通过 `curl` 向你正在故障排除的 web 应用程序发送自定义数据，使其更具互动性。但我们还想展示最后一个 `curl` 技巧：TLS（传输层安全性，HTTPS
    中加密现代 Web 流量的方式）不一定是 web 应用程序中一个“被误解”的方面，但它是一个常见的故障点，`curl` 可以帮助解决。
- en: Accepting and displaying bad TLS certificates with curl
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `curl` 接受并显示无效的 TLS 证书
- en: '`curl` gives us the `--insecure` option, which allows it to accept invalid
    TLS certificates from a server, and continue the request. This can come in handy
    when troubleshooting misconfigured servers:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`curl` 为我们提供了 `--insecure` 选项，允许它接受来自服务器的无效 TLS 证书并继续请求。在故障排除配置错误的服务器时，这非常有用：'
- en: '[PRE7]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `--insecure` (`-k`) option will make `curl` behave as if the TLS certificate
    is valid, even if it isn’t. Obviously, this is a security risk and should only
    be used for troubleshooting, but it can make `curl` continue in cases where TLS
    certificate validation would fail and `curl` would normally abort the request.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`--insecure` (`-k`) 选项会让 `curl` 假装 TLS 证书是有效的，即使它实际上无效。显然，这是一个安全隐患，仅应在故障排除时使用，但它可以让
    `curl` 在 TLS 证书验证失败并且 `curl` 通常会中止请求的情况下继续执行。'
- en: 'Let’s take a quick look at one last piece of HTTP that’s worth learning a bit
    about if you have anything to do with building or troubleshooting web applications:
    CORS.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速了解一下最后一部分关于 HTTP 的内容，如果你从事构建或故障排除 web 应用程序的工作，这部分内容值得学习：CORS。
- en: CORS
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CORS
- en: CORS stands for Cross-Origin Resource Sharing. That is a fancy word for saying
    resources, such as images, videos, HTML, JavaScript, or even **Asynchronous Javascript
    and XML** (**AJAX**) responses will be coming from a different hostname. To prevent
    situations where resources are loaded from a third party, the browser first asks
    that third party whether it is allowed to do so. This is called a pre-flight request.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: CORS 代表跨源资源共享。这个术语是用来表示资源，例如图片、视频、HTML、JavaScript，甚至是**异步 JavaScript 和 XML**（**AJAX**）响应将来自不同的主机名。为了防止从第三方加载资源的情况，浏览器首先会询问该第三方是否允许这么做。这被称为预检请求。
- en: A pre-flight request is an `OPTIONS` request that expects a response containing
    HTTP headers informing whether the request is allowed or not. Such a response
    typically has a 204 (No Content) status code and only contains the headers. If
    no such headers are found or the headers do not indicate that such a request is
    allowed, no subsequent request of the resource will be triggered.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 预检请求是一个 `OPTIONS` 请求，期望得到一个包含 HTTP 头部的响应，告知请求是否被允许。这样的响应通常会有一个 204（无内容）状态码，并且只包含头部。如果没有找到这样的头部，或者头部没有指示该请求被允许，则不会触发对资源的后续请求。
- en: Here is an example of what such an exchange might look like.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这样的交换可能是什么样的例子。
- en: 'A browser opening [https://www.example.org/](https://www.example.org/) asks
    whether it is okay to POST to `/api/test` on `api.example.org`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器打开[https://www.example.org/](https://www.example.org/)时，会询问是否允许向`api.example.org`的`/api/test`进行POST请求：
- en: '[PRE8]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'An accepting response would look like this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一个接受的响应应该是这样的：
- en: '[PRE9]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Since this indicates that the request is allowed, the browser can subsequently
    send the original request, which is now authorized:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这表示请求被允许，浏览器随后可以发送原始请求，这时请求已获得授权：
- en: '[PRE10]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the case of a request that’s not allowed, there is no response with an error
    status that signals a rejection per se – just a lack of the expected `Access-Control-Allow-Origin`
    header. In this case, the client sees that the request is not authorized and logs
    an error.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不被允许的请求，并没有通过错误状态返回信号来表示拒绝——只是缺少预期的`Access-Control-Allow-Origin`头信息。在这种情况下，客户端会看到请求未被授权并记录错误。
- en: 'You can see errors like this as they happen in your browser’s developer console.
    They’ll look something like this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在浏览器的开发者控制台中看到类似的错误。它们会像这样显示：
- en: '[PRE11]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is just a quick introduction to CORS, because it’s a topic that’s important
    for web developers to understand. While it’s not specific to the command line,
    it’s not out of the ordinary for a developer to have to understand these concepts
    and check their web client for these kinds of error logs. For a deeper treatment
    of this material, we recommend MDN’s article on the subject, which you can find
    at [https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是对CORS的简要介绍，因为它是Web开发者必须理解的重要主题。尽管它与命令行无关，但开发者理解这些概念并检查Web客户端中这些错误日志是很常见的。想要深入了解该主题，我们推荐MDN上的相关文章，链接是[https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)。
- en: Conclusion
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: In this chapter, you learned what you need to know to avoid some of the common
    misunderstandings, bugs, and frustrating design flaws that we see when web applications
    leave a developer’s laptop and start to interact with the real world through complex
    infrastructure. You learned about some of the infrastructure that mediates access
    to your applications, like gateways and upstreams.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了避免一些常见误解、bug和令人沮丧的设计缺陷所需的知识，这些问题通常出现在Web应用程序从开发者的笔记本电脑中走出来，通过复杂的基础设施开始与现实世界互动时。你了解了调解访问你应用程序的一些基础设施，如网关和上游服务。
- en: You also saw some of the most common mistakes that we see developers make with
    HTTP, and you’ll be able to use that knowledge to avoid hard-to-debug issues with
    headers, incorrect or vague status codes, and more. You learned about **Cross-Origin
    Resource Sharing** (**CORS**) and how HTTP has evolved into its current form.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你还看到了一些我们常见的开发者在使用HTTP时犯的错误，你将能利用这些知识避免一些难以调试的头信息问题、不正确或模糊的状态码等问题。你了解了**跨域资源共享**（**CORS**）以及HTTP是如何发展成现在的形式。
- en: Maybe most importantly, you saw how you can level up your game as a developer
    by learning a command-line tool like `curl` and combining it with your theoretical
    knowledge of HTTP.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 或许最重要的是，你看到如何通过学习像`curl`这样的命令行工具并将其与HTTP的理论知识结合起来，从而提升你作为开发者的能力。
- en: What you learned in this chapter makes it possible for you to quickly and accurately
    troubleshoot web application issues, whether it’s identifying a redirect loop
    on a broken WordPress site, pinpointing a subtle caching issue by inspecting the
    headers returned by a Ruby-on-Rails application, or replicating a production bug
    (and verifying a fix) at four in the morning by POSTing specific JSON data to
    a development server.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中你学到的内容使你能够快速且准确地排查Web应用程序问题，无论是识别损坏的WordPress网站中的重定向循环，通过检查Ruby-on-Rails应用程序返回的头信息定位微妙的缓存问题，还是在凌晨四点通过向开发服务器POST特定的JSON数据来重现生产环境中的bug（并验证修复）。
- en: Learn more on Discord
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Discord上了解更多
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入本书的Discord社区——在这里你可以分享反馈、向作者提问并了解新版本——请扫描下面的二维码：
- en: '[https://packt.link/SecNet](https://packt.link/SecNet)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/SecNet](https://packt.link/SecNet)'
- en: '![](img/QR_Code1768422420210094187.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code1768422420210094187.png)'
