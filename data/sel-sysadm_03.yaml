- en: '*Chapter 2*: Understanding SELinux Decisions and Logging'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第2章*：理解SELinux决策和日志记录'
- en: Once we enable SELinux on the system, it starts its access control functionality,
    as described in the previous chapter. Once it starts, administrators need to keep
    a close eye on its actions, and often need to deal with unexpected behavior if
    one or more applications are not acting according to the SELinux policy. Through
    SELinux logging, we learn how SELinux enforces its policies toward the applications
    on the system.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在系统上启用SELinux，它就会启动其访问控制功能，如上一章所述。一旦启动，管理员需要密切关注其行为，并且通常需要处理如果一个或多个应用程序未按照SELinux策略运行时的意外行为。通过SELinux日志记录，我们了解SELinux如何对系统上的应用程序执行其策略。
- en: Administrators have to know how to switch between SELinux in full-enforcement
    mode (resembling a host-based intrusion prevention system) versus its permissive,
    logging-only mode, and use its various methods to toggle the SELinux state (enabled
    or disabled; permissive or enforcing). Furthermore, we should know how to disable
    SELinux's enforcement for a single domain rather than an entire system, and learn
    to interpret the SELinux log events that describe which activities SELinux has
    prevented. We will finish with an overview of common methods for analyzing these
    logging events in day-to-day operations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 管理员需要了解如何在SELinux的完全强制模式（类似于基于主机的入侵防御系统）与其宽容日志记录模式之间切换，并使用其各种方法切换SELinux的状态（启用或禁用；宽容或强制）。此外，我们还应了解如何禁用SELinux对单个域的强制执行，而不是整个系统，并学习如何解释SELinux日志事件，这些事件描述了SELinux阻止了哪些活动。最后，我们将介绍一些常见的方法，用于在日常操作中分析这些日志事件。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Switching SELinux on and off
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开启和关闭SELinux
- en: SELinux logging and auditing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SELinux日志记录与审计
- en: Getting help with denials
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取拒绝请求的帮助
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3dFaUXm](https://bit.ly/3dFaUXm)'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，了解代码的实际操作：[https://bit.ly/3dFaUXm](https://bit.ly/3dFaUXm)
- en: Switching SELinux on and off
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开启和关闭SELinux
- en: This is perhaps a weird section to begin with, but disabling SELinux is a commonly
    requested activity. Some vendors do not support their application running on a
    platform that has SELinux enabled, as those vendors do not have the expertise
    to develop SELinux policies for their own applications, or are not able to educate
    their own support lines to deal with SELinux.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这也许是一个奇怪的开始部分，但禁用SELinux是一个常见的请求活动。一些供应商不支持其应用程序在启用SELinux的平台上运行，因为这些供应商没有开发SELinux策略的专业能力，或者无法培训自己的支持团队来处理SELinux。
- en: Furthermore, system administrators are generally reluctant to use security controls
    they do not understand or find too complex to maintain. Luckily, SELinux is becoming
    a de facto standard technology in several Linux distributions, which is increasing
    its exposure and understanding among administrators. SELinux is also capable of
    selectively disabling its access controls for a part of a system rather than requiring
    us to disable it for a complete system.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，系统管理员通常不愿使用他们不理解或觉得过于复杂的安全控制。幸运的是，SELinux正在成为多个Linux发行版中的事实标准技术，这增加了其在管理员中的曝光度和理解。SELinux还能够选择性地禁用其访问控制，仅针对系统的一部分，而不是要求我们禁用整个系统。
- en: Setting the global SELinux state
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置全局SELinux状态
- en: 'SELinux supports three major states that it can be in: `disabled`, `permissive`,
    and `enforcing`. These states are set in the `/etc/selinux/config` file, through
    the `SELINUX` variable, as illustrated in the following code snippet:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux支持三种主要的状态：`disabled`、`permissive`和`enforcing`。这些状态通过`/etc/selinux/config`文件中的`SELINUX`变量进行设置，如以下代码片段所示：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When the `init` system process loads the SELinux policy, the SELinux code checks
    the state that the administrator has configured. The states are described as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当`init`系统进程加载SELinux策略时，SELinux代码会检查管理员配置的状态。各个状态的描述如下：
- en: If the state is `disabled`, then the SELinux code disables further support,
    booting the system further without activating SELinux.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果状态为`disabled`，则SELinux代码会禁用进一步的支持，系统启动时不会激活SELinux。
- en: If the state is `permissive`, then SELinux is active but will not enforce its
    policy on the system. Instead, SELinux will report any violation against the policy,
    but will not prevent the action itself. This is sometimes called **host intrusion
    detection** as it works in reporting-only mode.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果状态是`宽容`，则表示 SELinux 处于活动状态，但不会强制执行其政策。相反，SELinux 会报告任何违反政策的行为，但不会阻止这些行为本身。这有时被称为**主机入侵检测**，因为它仅在报告模式下工作。
- en: If the state is `enforcing`, then SELinux is active and will enforce its policy
    on the system. Violations are reported and denied. This is sometimes called **host
    intrusion prevention**, as it enforces the rules while logging the actions it
    takes.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果状态是`强制`，则表示 SELinux 处于活动状态，并将强制执行其政策。违反规则的行为会被报告并拒绝。这有时被称为**主机入侵防护**，因为它在执行规则的同时记录其采取的操作。
- en: 'We can use the `getenforce` command or the `sestatus` command to get information
    about the current state of SELinux, like so:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`getenforce`命令或`sestatus`命令获取 SELinux 当前状态的信息，如下所示：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It is also possible to query the `/sys/fs/selinux/enforce` pseudo-file to get
    similar information. If the file returns `1`, then SELinux is in enforcing mode.
    If it returns `0`, then it is in permissive mode. The following code snippet shows
    SELinux in enforcing mode:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以查询`/sys/fs/selinux/enforce`伪文件来获取类似的信息。如果该文件返回`1`，则 SELinux 处于强制模式。如果返回`0`，则处于宽容模式。以下代码片段显示
    SELinux 处于强制模式：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When we change the `/etc/selinux/config` file, then we need to reboot the system
    for the changes to take effect. However, if we boot a system without SELinux support
    (`disabled`), re-enabling SELinux support alone will not suffice: the administrator
    will need to make sure that all files on the system are relabeled (the context
    of all files needs to be set). Without SELinux support, Linux will create and
    update files without updating or setting the SELinux labels on those files. When
    the system is later rebooted with SELinux support, SELinux will not have any knowledge
    of the context of a file unless the labels are reset.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们修改`/etc/selinux/config`文件时，需要重启系统以使更改生效。然而，如果我们启动一个不支持 SELinux 的系统（`禁用`），仅重新启用
    SELinux 支持是不够的：管理员还需要确保系统上的所有文件都已重新标记（所有文件的上下文需要被设置）。如果没有 SELinux 支持，Linux 会创建和更新文件，但不会更新或设置这些文件的
    SELinux 标签。当系统后来重新启动并启用 SELinux 支持时，除非重新设置标签，否则 SELinux 将无法知道文件的上下文。
- en: Relabeling the filesystem is covered in [*Chapter 4*](B16276_04_Final_VK.xhtml#_idTextAnchor095),
    *Using File Contexts and Process Domains*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统重新标记的内容在[*第 4 章*](B16276_04_Final_VK.xhtml#_idTextAnchor095)，*使用文件上下文和进程域*中有介绍。
- en: 'In many situations, administrators often want to disable SELinux when it starts
    preventing certain tasks. This is careless to say the least, and here''s why:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在很多情况下，当管理员发现 SELinux 阻止某些任务时，他们常常想禁用 SELinux。这样做至少可以说是草率的，原因如下：
- en: SELinux is a security component—part of the operating system. Disabling SELinux
    is like disabling a firewall because it is blocking some communication. It might
    help because it's a faster way of getting something to work again, but you're
    removing measures that were enabled to protect you.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SELinux 是一个安全组件——操作系统的一部分。禁用 SELinux 就像禁用防火墙，因为它在阻止某些通信。虽然禁用 SELinux 可能帮助快速让某些功能恢复工作，但这实际上是在移除本来是为了保护你的安全措施。
- en: Just as with a firewall, SELinux is configurable by rules. If an application
    is prevented from working correctly, we need to update the rules for that application,
    just as with additional firewall rules that enable a particular network flow.
    We will start updating SELinux policy rules from [*Chapter 5*](B16276_05_Final_VK.xhtml#_idTextAnchor138),
    *Controlling Network Communications,* onward.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 就像防火墙一样，SELinux 是通过规则进行配置的。如果某个应用程序无法正常工作，我们需要更新该应用程序的规则，就像更新额外的防火墙规则以启用特定的网络流量一样。我们将在[*第
    5 章*](B16276_05_Final_VK.xhtml#_idTextAnchor138)，*控制网络通信*中开始更新 SELinux 策略规则。
- en: In the worst case, when we want to allow every action an application performs
    unconditionally, we can still leave SELinux on and just run this application in
    an unrestricted SELinux domain, called a *permissive* domain.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在最坏的情况下，当我们希望无条件允许应用程序执行的每一个操作时，我们仍然可以保持 SELinux 启用，并将该应用程序运行在一个不受限制的 SELinux
    域中，称为*宽容*域。
- en: Distributions put significant effort in the integration of SELinux within their
    products, and they have awesome support channels to help you out if all things
    fail.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 各个发行版在将 SELinux 集成到产品中付出了大量的努力，并且提供了优秀的支持渠道，以防万一一切失败时帮助你。
- en: Switching to permissive or enforcing mode
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 切换到宽容模式或强制模式
- en: Most distribution-provided Linux kernels allow switching between enforcing and
    permissive mode through a simple administrative command. This feature is called
    the `CONFIG_SECURITY_SELINUX_DEVELOP` kernel configuration parameter. This kernel
    parameter, if set, also has the Linux kernel boot in permissive mode first, unless
    a specific boot option (`enforcing=1`) is set.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数发行版提供的Linux内核允许通过一个简单的管理命令在强制模式和宽松模式之间切换。这个功能被称为`CONFIG_SECURITY_SELINUX_DEVELOP`内核配置参数。如果启用该内核参数，Linux内核也会首先以宽松模式启动，除非设置了特定的启动选项（`enforcing=1`）。
- en: Although we could consider this development mode a risk (all a malicious person
    would need to do is switch SELinux to permissive mode to disable its access controls),
    switching the mode requires strong administrative privileges (like the `root`
    user has), which most application domains don't have.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可以认为这种开发模式存在风险（恶意用户只需要将SELinux切换到宽松模式就能禁用其访问控制），但切换模式需要强大的管理权限（例如`root`用户拥有的权限），而大多数应用程序领域并不具备这种权限。
- en: 'The command to switch between permissive mode and enforcing mode is the `setenforce`
    command. It takes a single argument: `0` (permissive) or `1` (enforcing). The
    `permissive` and `enforcing` strings are allowed by the command as well.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 切换宽松模式和强制模式的命令是`setenforce`命令。它接受一个参数：`0`（宽松模式）或`1`（强制模式）。该命令也允许使用`permissive`和`enforcing`字符串。
- en: 'The change takes effect immediately. For instance, we can use the following
    command to switch to permissive mode:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 改动会立即生效。例如，我们可以使用以下命令切换到宽松模式：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The effect of `setenforce` is the same as writing the right integer value into
    the `/sys/fs/selinux/enforce` pseudo-file, as illustrated in the following code
    snippet:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`setenforce`的效果与将正确的整数值写入`/sys/fs/selinux/enforce`伪文件的效果相同，如下代码片段所示：'
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Switching between permissive and enforcing mode can be of interest for policy
    developers or system administrators who are modifying the system to use SELinux
    properly. We can also use it to quickly verify whether an application warning
    or error is due to SELinux access controls or not—assuming the application is
    not SELinux-aware, which we will talk about in the *Understanding SELinux-aware
    applications* section.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在修改系统以正确使用SELinux时，切换宽松模式和强制模式可能对策略开发人员或系统管理员很有用。我们也可以用它来快速验证应用程序警告或错误是否由于SELinux访问控制引起—假设该应用程序没有SELinux感知，我们将在*理解SELinux感知的应用程序*部分讨论这个问题。
- en: On production systems, it might be of interest to disable the ability to switch
    to permissive mode. Disabling this feature usually requires the Linux kernel to
    be rebuilt, but SELinux policy developers have also thought of a different way
    to disallow users from toggling the SELinux state. The privileges that users need
    to switch to permissive mode are conditional, and system administrators can easily
    toggle this to disable switching back from enforcing mode to permissive mode.
    The condition is implemented through an SELinux Boolean called `secure_mode_policyload`
    whose default value is `off` (meaning switching SELinux state is allowed).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产系统上，可能需要禁用切换到宽松模式的能力。禁用此功能通常需要重新编译Linux内核，但SELinux策略开发人员也考虑了另一种不允许用户切换SELinux状态的方法。用户切换到宽松模式所需的权限是有条件的，系统管理员可以轻松切换此条件来禁用从强制模式切换回宽松模式的操作。这个条件是通过名为`secure_mode_policyload`的SELinux布尔值实现的，默认值为`off`（意味着允许切换SELinux状态）。
- en: '`on` or `off`, although `true`/`false` and `1`/`0` are valid values as well)
    and manipulate parts of the active SELinux policy. The value of the conditionals
    can be persisted (meaning they survive reboots) or be kept only during the current
    boot session. We can persist the value across reboots by adding `-P` to the `setsebool`
    command, as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`on`或`off`（虽然`true`/`false`和`1`/`0`也是有效值），并操作活动的SELinux策略的部分。条件的值可以被持久化（意味着它们在重启后依然有效）或仅在当前启动会话期间有效。我们可以通过在`setsebool`命令中添加`-P`来使值在重启后持久化，如下所示：'
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: SELinux Booleans are covered in more depth in [*Chapter 12*](B16276_12_Final_VK.xhtml#_idTextAnchor312),
    *Tuning SELinux Policies*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux布尔值将在[*第12章*](B16276_12_Final_VK.xhtml#_idTextAnchor312)，*调优SELinux策略*中详细介绍。
- en: The use of the `secure_mode_policyload` SELinux Boolean allows administrators
    to restrict switching from enforcing mode back to permissive mode. This does not
    disable SELinux completely, but only toggles whether it will act upon its policies
    or not.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`secure_mode_policyload` SELinux布尔值允许管理员限制从强制模式切换回宽松模式。这并不会完全禁用SELinux，只是切换它是否会执行其策略。
- en: 'Switching from a disabled state to a running state is not supported. However,
    the reverse is possible, but only under the following condition: if the Linux
    kernel is built with the `SECURITY_SELINUX_DISABLE` kernel configuration parameter,
    then services such as `init` can effectively disable SELinux at runtime, but only
    if no SELinux policy is loaded yet. This functionality, however, is not recommended
    to be actively used, and was only introduced for platforms where boot options
    are hard to use. The feature is marked as deprecated in recent kernels as such
    platforms are few in number.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 从禁用状态切换到运行状态是不被支持的。然而，反向操作是可能的，但只有在以下条件下：如果 Linux 内核是使用 `SECURITY_SELINUX_DISABLE`
    内核配置参数构建的，那么像 `init` 这样的服务可以有效地在运行时禁用 SELinux，但前提是尚未加载 SELinux 策略。然而，这个功能并不推荐主动使用，它只为那些启动选项难以使用的平台引入。最近的内核将此功能标记为已弃用，因为此类平台数量很少。
- en: Using kernel boot parameters
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用内核启动参数
- en: Using the `setenforce` command makes sense when we want to switch to permissive
    or enforcing mode at a point in time when we have interactive access to the system.
    But what if we need this on system boot? If the system refuses to boot properly
    due to SELinux access controls, we cannot edit the `/etc/selinux/config` file.
    Luckily, we can change the SELinux state through other means as well.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `setenforce` 命令是有意义的，当我们希望在与系统交互时切换到宽松或强制模式。但如果我们需要在系统启动时设置呢？如果由于 SELinux
    访问控制系统无法正常启动，我们就无法编辑 `/etc/selinux/config` 文件。幸运的是，我们还可以通过其他方式更改 SELinux 状态。
- en: 'The solution is to use kernel boot parameters. We can boot a Linux system with
    one or two parameters that take precedence over the `/etc/selinux/config` setting,
    as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是使用内核启动参数。我们可以使用一个或两个启动参数来启动 Linux 系统，这些参数会优先于 `/etc/selinux/config` 设置，如下所示：
- en: '`selinux=0`: This informs the system to disable SELinux completely, and has
    the same effect as setting `SELINUX=disabled` in the configuration file. When
    set, the other parameter (`enforcing`) is not consulted. Please remember that
    booting a system with SELinux disabled means that to enable it again, we need
    to relabel all files and resources on the filesystem. The `selinux=` parameter
    is supported through the `CONFIG_SECURITY_SELINUX_BOOTPARAM` kernel configuration.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selinux=0`：这通知系统完全禁用 SELinux，其效果与在配置文件中设置`SELINUX=disabled`相同。设置后，不会考虑其他参数（如`enforcing`）。请记住，启动一个禁用
    SELinux 的系统意味着要再次启用它时，我们需要重新标记文件系统上的所有文件和资源。`selinux=` 参数通过 `CONFIG_SECURITY_SELINUX_BOOTPARAM`
    内核配置得到支持。'
- en: '`enforcing=0`: This informs the system to run SELinux in permissive mode, and
    has the same effect as setting `SELINUX=permissive` in the configuration file.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enforcing=0`：这通知系统以宽松模式运行 SELinux，其效果与在配置文件中设置`SELINUX=permissive`相同。'
- en: '`enforcing=1`: This informs the system to run SELinux in enforcing mode, and
    has the same effect as setting `SELINUX=enforcing` in the configuration file.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enforcing=1`：这通知系统以强制模式运行 SELinux，其效果与在配置文件中设置`SELINUX=enforcing`相同。'
- en: 'Consider a Linux system that uses GRUB2 as its boot loader, and we want to
    add `enforcing=0` to the boot entry. To accomplish this, we execute the following
    steps:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个使用 GRUB2 作为引导加载程序的 Linux 系统，我们希望将 `enforcing=0` 添加到启动项中。为此，我们执行以下步骤：
- en: Reboot the system until the GRUB2 boot screen comes up.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重启系统，直到 GRUB2 启动屏幕出现。
- en: Navigate with the arrow keys to the boot entry for which the SELinux state must
    be altered. This is usually the default boot entry and should be already selected.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用箭头键导航到需要更改 SELinux 状态的启动项。这通常是默认的启动项，应该已经被选中。
- en: Press the *E* key to edit the boot entry line. Do this before the GRUB2 timer
    reaches zero; otherwise, the system will continue to boot.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按 *E* 键编辑启动项行。在 GRUB2 倒计时归零之前进行此操作；否则，系统将继续启动。
- en: Use the arrow keys to go to the end of the line that starts with `options`.
    If no such line exists, go to the end of the line that starts with `linux`, `linux16`,
    or `linuxefi`.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用箭头键移动到以`options`开头的行的末尾。如果没有这样的行，请转到以`linux`、`linux16`或`linuxefi`开头的行的末尾。
- en: Add `enforcing=0` to the end of this line.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `enforcing=0` 添加到该行的末尾。
- en: Press *Ctrl* + *X* or *F10* to boot the entry.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按 *Ctrl* + *X* 或 *F10* 启动该项。
- en: Other boot loaders have similar approaches to changing the boot line without
    persisting it for every reboot. Consult your distribution documentation for more
    details.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 其他引导加载程序有类似的方式来更改启动行，但不会在每次重启时保持更改。有关更多详细信息，请参考您的发行版文档。
- en: 'Alongside the SELinux-specific parameters, there are a few **Linux Security
    Module** (**LSM**)-related boot parameters that can be useful to know, especially
    when you are combining multiple LSM modules on the same system. These are detailed
    as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 除了SELinux特定的参数外，还有一些与**Linux安全模块**（**LSM**）相关的启动参数，尤其是在将多个LSM模块组合到同一系统中时，这些参数非常有用。它们的详细信息如下：
- en: The `lsm.debug` boot parameter enables LSM initialization debugging output,
    showing which LSM modules it effectively enables or ignores, and which LSM modules
    are considered as exclusive.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lsm.debug`启动参数启用LSM初始化调试输出，显示实际启用或忽略了哪些LSM模块，以及哪些LSM模块被认为是排他的。'
- en: The `lsm=lsm1,…,lsmN` option chooses the order of LSM initialization. For instance,
    to initialize SELinux before lockdown, use `lsm=selinux,lockdown`.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lsm=lsm1,…,lsmN`选项选择LSM初始化的顺序。例如，要在锁定之前初始化SELinux，可以使用`lsm=selinux,lockdown`。'
- en: The `security=` boot parameter enables selection of the active, major/exclusive
    LSM module. This parameter, however, is deprecated, favoring the `lsm=` parameter.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`security=`启动参数启用选择活动的主要/独占LSM模块。然而，这个参数已经被弃用，推荐使用`lsm=`参数。'
- en: When using SELinux in production, it might be wise to properly protect the boot
    menu—for instance, by password-protecting the menu and regularly verifying the
    integrity of the boot menu files.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中使用SELinux时，可能需要妥善保护启动菜单——例如，通过密码保护菜单并定期验证启动菜单文件的完整性。
- en: Disabling SELinux protections for a single service
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 禁用单个服务的SELinux保护
- en: 'Since policy version 23 (which came with Linux 2.6.26), SELinux also supports
    a more granular approach to switching between permissive and enforcing mode: the
    use of permissive domains. As mentioned before, a domain is a term that SELinux
    uses for types (labels) assigned to processes. With **permissive domains**, we
    can mark one or more domains as permissive (and, as such, not enforced by SELinux
    rules), even though the rest of the system is still running in enforcing mode.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本23（随Linux 2.6.26发布）开始，SELinux还支持在宽松模式和强制模式之间更细粒度的切换方法：使用宽松领域。如前所述，域是SELinux用于指派给进程的类型（标签）的术语。通过**宽松领域**，我们可以将一个或多个领域标记为宽松（因此不受SELinux规则的强制执行），即使系统的其他部分仍在强制模式下运行。
- en: 'To make a domain permissive, we use the `semanage` command, as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要使某个领域变为宽松，可以使用`semanage`命令，方法如下：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With the same `semanage` command, we can list the currently defined permissive
    domains, like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的`semanage`命令，我们可以列出当前定义的宽松领域，如下所示：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the previous example, you will notice that there is also room for *built-in*
    permissive types. These are domains that have been marked as permissive by the
    policy developers of the Linux distribution itself. Some distributions opt to
    introduce new application policies in permissive mode first, allowing users to
    test out the policies before enforcing them. When that is the case, you can find
    these permissive domains under `Builtin Permissive Types`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，你会注意到也有为*内建*的宽松类型留有空间。这些是由Linux发行版的政策开发者标记为宽松的领域。有些发行版选择首先以宽松模式引入新的应用政策，允许用户在强制执行之前测试这些政策。当这种情况发生时，你可以在`Builtin
    Permissive Types`下找到这些宽松领域。
- en: 'Another method for listing the custom permissive types (those not marked as
    permissive through the distribution) is to use the `semodule` command. In the
    previous chapter, we briefly touched on this command when talking about SELinux
    policy modules. We can use it to list the SELinux policy modules that have `permissive_`
    in their name because the `semanage permissive` command generates a small SELinux
    policy module to mark the domain as permissive, as illustrated in the following
    code snippet:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 列出自定义宽松类型（那些没有通过发行版标记为宽松的类型）的另一种方法是使用`semodule`命令。在前一章中，我们在讨论SELinux政策模块时简要提到过该命令。我们可以使用它列出名称中包含`permissive_`的SELinux政策模块，因为`semanage
    permissive`命令会生成一个小的SELinux政策模块，将域标记为宽松，下面的代码片段展示了这一过程：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To remove the permissive mode from the domain, pass the `-d` argument to the
    `semanage` command. This is only possible for domains that the system administrator
    marked as permissive, though—distribution-provided permissive domains cannot be
    switched to enforcing mode through this approach. This is illustrated in the following
    code snippet:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要从领域中移除宽松模式，可以将`-d`参数传递给`semanage`命令。不过，这只有在系统管理员将该领域标记为宽松时才可行——通过这种方式，无法将发行版提供的宽松领域切换为强制模式。下面的代码片段展示了这一点：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When a domain is marked as permissive, the application should behave as if SELinux
    is not enabled on the system (SELinux will not be enforcing anything that particular
    application/domain does), making it easier for us to discover whether SELinux
    is really causing a permission issue. Note, though, that other domains (including
    those that interact with a permissive domain) are themselves still governed and
    enforced through the SELinux access controls.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个域被标记为宽松模式时，应用程序的行为应该就像系统上没有启用SELinux一样（SELinux不会强制执行该特定应用程序/域的任何操作），这使得我们更容易发现SELinux是否真的引发了权限问题。不过，请注意，其他域（包括与宽松域交互的域）仍然受到SELinux访问控制的管理和强制执行。
- en: Understanding SELinux-aware applications
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解SELinux感知应用程序
- en: Most applications themselves do not have knowledge that they are running on
    an SELinux-enabled system. Without this knowledge, permissive mode truly means
    that the application behaves as if SELinux were not enabled to begin with. However,
    some applications actively rely on the SELinux policy to make access control decisions,
    or interact with SELinux for further information gathering. We call these applications
    **SELinux-aware** because they change their behavior based on the SELinux-related
    information available.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序本身并不知道它们正在运行在启用了SELinux的系统上。没有这一信息，宽松模式实际上意味着应用程序的行为就像最初没有启用SELinux一样。然而，一些应用程序积极依赖SELinux策略来做出访问控制决策，或与SELinux交互以获取更多信息。我们将这些应用程序称为**SELinux感知**应用程序，因为它们会根据可用的SELinux相关信息改变其行为。
- en: Sadly, many of these SELinux-aware applications do not properly validate whether
    they are running in permissive mode or not. As a result, running these applications
    in a permissive domain (or the entire system in permissive mode) will generally
    not result in the application running as if SELinux were not active.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 可惜的是，许多这些SELinux感知的应用程序并没有正确验证它们是否在宽松模式下运行。因此，在宽松域中运行这些应用程序（或整个系统处于宽松模式）通常不会导致应用程序的行为像SELinux没有启用一样。
- en: Examples of such applications are the `init` system, and some cron daemons,
    as well as several core Linux utilities (such as `ls` and `id`). They might show
    permission failures or different behavior based on the SELinux policy, even if
    SELinux is not in enforcing mode.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这类应用程序的示例包括`init`系统、一些cron守护进程以及几个核心Linux实用程序（如`ls`和`id`）。即使SELinux没有处于强制模式，它们也可能会根据SELinux策略显示权限失败或不同的行为。
- en: 'We can find out whether an application is SELinux-aware by checking whether
    the application is dynamically linked with the `libselinux` library. Such checks
    are possible with `readelf`, `ldd`, or `objdump`, as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过检查应用程序是否动态链接`libselinux`库来判断它是否是SELinux感知的。可以使用`readelf`、`ldd`或`objdump`进行此类检查，如下所示：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Knowing whether an application is SELinux-aware or not can help in troubleshooting
    failures, as the application's behavior might still be different between a disabled
    SELinux state and a permissive SELinux state.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 知道一个应用程序是否是SELinux感知的，有助于故障排除，因为应用程序的行为在SELinux被禁用状态和宽松SELinux状态下可能仍然不同。
- en: Up until now, we've focused on enabling or disabling SELinux, and thus on a
    granular or coarse-grained matter. Once it is enabled though, its interaction
    with the administrator will be through policy enforcement and logging. So, let's
    look at how SELinux handles logging.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 直到现在，我们一直关注启用或禁用SELinux，从而关注的是细粒度或粗粒度的设置。但一旦启用SELinux，它与管理员的交互将通过策略执行和日志记录来进行。那么，接下来让我们看看SELinux如何处理日志记录。
- en: SELinux logging and auditing
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SELinux日志记录和审计
- en: SELinux developers understand that a security-oriented subsystem such as SELinux
    can only succeed if it is capable of enhanced logging and—even—debugging. Every
    action that SELinux takes, as part of the LSM hooks that it implements, should
    be auditable. Denials (actions that SELinux prevents) should always be logged
    so that administrators can take due action. SELinux tuning and changes, such as
    loading new policies or altering SELinux Booleans, should always result in an
    audit event.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux开发人员明白，像SELinux这样的面向安全的子系统只有在具备增强的日志记录甚至调试能力时才能成功。SELinux所执行的每个动作，作为它实现的LSM钩子的一部分，都应该是可审计的。拒绝（SELinux阻止的操作）应始终记录下来，以便管理员采取相应的措施。SELinux的调优和更改，例如加载新策略或更改SELinux布尔值，应该始终触发一个审计事件。
- en: Following audit events
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跟踪审计事件
- en: By default, SELinux will send its messages to the Linux audit subsystem (assuming
    the Linux kernel is configured with the audit subsystem enabled through the `CONFIG_AUDIT`
    kernel configuration). There, the messages are picked up by the Linux audit daemon
    (`auditd`) and logged in the `/var/log/audit/audit.log` file. Distributions and
    administrators can define additional handling rules by configuring the audit dispatcher
    process (`audisp`), which picks up audit events and dispatches them to one or
    more separate processes. The SELinux troubleshooting daemon (`setroubleshootd`),
    an optional service to provide help with troubleshooting SELinux events, uses
    this to get access to audit events.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，SELinux会将其消息发送到Linux审计子系统（假设Linux内核已配置为启用审计子系统，且通过`CONFIG_AUDIT`内核配置启用）。在那里，消息将被Linux审计守护进程（`auditd`）接收并记录在`/var/log/audit/audit.log`文件中。发行版和管理员可以通过配置审计调度进程（`audisp`）来定义额外的处理规则，该进程负责接收审计事件并将它们分发给一个或多个单独的进程。SELinux故障排除守护进程（`setroubleshootd`），一个用于帮助故障排除SELinux事件的可选服务，通过此方式获取审计事件。
- en: 'The audit event flow is shown in this diagram:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 审计事件流在该图中展示：
- en: '![Figure 2.1 – Flow of audit events generated by SELinux ](img/B16276_02_001.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1 – SELinux生成的审计事件流](img/B16276_02_001.jpg)'
- en: Figure 2.1 – Flow of audit events generated by SELinux
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – SELinux生成的审计事件流
- en: With SELinux enabled, (almost) every permission check that results in a denial
    is logged. When Linux auditing is enabled, these denials are logged by the audit
    daemon in the `audit.log` file by default. If the audit daemon is unavailable,
    the events are stored in the Linux kernel message buffer, which we can consult
    using the `dmesg` command. The events in the kernel message buffer are also often
    captured through the system logger.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 启用SELinux后，（几乎）每个导致拒绝的权限检查都会被记录。当启用Linux审计时，这些拒绝将默认通过审计守护进程记录在`audit.log`文件中。如果审计守护进程不可用，事件将存储在Linux内核消息缓冲区中，我们可以通过`dmesg`命令查看。内核消息缓冲区中的事件也常常通过系统日志记录器捕获。
- en: If the SELinux troubleshooting daemon is installed, then the audit daemon will,
    alongside its logging, also dispatch the events through the audit dispatch system
    toward the `sedispatch` command. This command will further handle the event and
    send it through D-Bus (a system bus implementation popular on Linux systems) to
    the SELinux troubleshooting daemon. This daemon will analyze the event and might
    suggest one or more fixes to the administrator. We will cover the SELinux troubleshooting
    daemon in the *Getting help with denials* section.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果安装了SELinux故障排除守护进程，则审计守护进程除了记录日志外，还会通过审计调度系统将事件分发到`sedispatch`命令。该命令将进一步处理事件，并通过D-Bus（Linux系统上流行的系统总线实现）将其发送到SELinux故障排除守护进程。该守护进程将分析事件，并可能向管理员建议一个或多个修复方案。我们将在*获取拒绝帮助*部分中介绍SELinux故障排除守护进程。
- en: 'Whenever SELinux verifies a particular access, it does not always go over the
    entire policy. Instead, it has an **access vector cache** (**AVC**), in which
    it stores the results of previous access attempts. This cache ensures that SELinux
    can quickly react to activities without having a huge impact on performance. We
    notice the abbreviation of this cache as the message type for most SELinux events,
    as shown at the beginning of the following example:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 每当SELinux验证特定的访问时，它并不总是遍历整个策略。相反，它有一个**访问向量缓存**（**AVC**），在其中存储之前访问尝试的结果。这个缓存确保SELinux能够快速响应活动，同时对性能的影响很小。我们注意到这个缓存的缩写作为大多数SELinux事件的消息类型，如以下示例开始时所示：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When the Linux kernel checks a permission request, this request is represented
    as an *access vector*, and the cache is then consulted to quickly find the appropriate
    response. If the cache has the right access vector, then the decision is taken
    from the cache; otherwise, the SELinux subsystem consults the policy itself and
    updates the cache. Of course, SELinux invalidates the cache when a new policy
    is loaded or the policy is dynamically adjusted. This ensures that all permission
    checks are in line with the active policy.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当Linux内核检查权限请求时，这个请求被表示为*访问向量*，然后会查询缓存以快速找到合适的响应。如果缓存中有正确的访问向量，则决策来自缓存；否则，SELinux子系统会查阅策略并更新缓存。当然，当加载新的策略或动态调整策略时，SELinux会使缓存无效。这确保了所有的权限检查都符合活动的策略。
- en: This inner working of SELinux is less relevant to most administrators, but at
    least now we know where the term *AVC* comes from.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux的内部工作原理与大多数管理员关系不大，但至少现在我们知道了术语*AVC*的来源。
- en: Tuning the AVC
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整AVC
- en: The AVC can be slightly tuned, by setting the size of the cache or its related
    tables.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过设置缓存或相关表的大小来稍微调整 AVC。
- en: 'We can configure the cache size itself through the `/sys/fs/selinux/avc/cache_threshold`
    pseudo-file (available if the `CONFIG_SECURITY_SELINUX_AVC_STATS` kernel configuration
    is set). For instance, to increase the cache size to 768 entries (the default
    is 512), the following command would be used:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 `/sys/fs/selinux/avc/cache_threshold` 伪文件（如果设置了 `CONFIG_SECURITY_SELINUX_AVC_STATS`
    内核配置）来配置缓存大小。例如，要将缓存大小增加到 768 条目（默认值为 512），可以使用以下命令：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To confirm the cache threshold, read the file, as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要确认缓存阈值，请读取文件，如下所示：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The AVC hash statistics are available through the `hash_stats` pseudo-file,
    as illustrated in the following code snippet:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: AVC 哈希统计信息可以通过 `hash_stats` 伪文件访问，如以下代码片段所示：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If you suspect that lower system performance is due to SELinux, then we advise
    you to look at the `longest chain` output in `hash_stats`. If it is longer than
    10, then some performance impact can be expected, and updating the cache size
    might help.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你怀疑系统性能下降是由于 SELinux，建议你查看 `hash_stats` 中的 `longest chain` 输出。如果它大于 10，则可能会影响性能，更新缓存大小可能有助于解决问题。
- en: 'The `avcstat` command shows the evolution of the cache over time (the first
    number is the total since boot). When the number of cache misses is high or volatile,
    or the number of reclaims (obsoleting oldest cache entries and reusing them for
    new ones) is volatile, then the cache size might need to be increased. The command
    is illustrated in the following code snippet:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`avcstat` 命令显示缓存随时间变化的情况（第一个数字是自启动以来的总数）。当缓存未命中次数很高或波动，或者回收次数（淘汰最旧的缓存条目并将其重新用于新条目）波动时，可能需要增加缓存大小。命令如以下代码片段所示：'
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Recent kernels also allow the number of buckets used through a kernel configuration
    parameter to be set (`CONFIG_SECURITY_SELINUX_SIDTAB_HASH_BITS`), and its cache
    statistics can be viewed through the `/sys/fs/selinux/ss/sidtab_hash_stats` pseudo-file,
    as illustrated in the following code snippet:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最近的内核还允许通过内核配置参数设置使用的桶数（`CONFIG_SECURITY_SELINUX_SIDTAB_HASH_BITS`），其缓存统计信息可以通过
    `/sys/fs/selinux/ss/sidtab_hash_stats` 伪文件查看，如以下代码片段所示：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Another performance parameter is the size of the internal `CONFIG_SECURITY_SELINUX_SID2STR_CACHE_SIZE`
    setting.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个性能参数是内部 `CONFIG_SECURITY_SELINUX_SID2STR_CACHE_SIZE` 设置的大小。
- en: Uncovering more logging
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开启更多日志记录
- en: There is an important SELinux policy directive that provides control over what
    is (not) audited, and that is `dontaudit`. A `dontaudit` rule in the SELinux policy
    tells SELinux that an access denial should not be logged. This is the only example
    where SELinux won't log a denial—the SELinux policy writer has explicitly disabled
    the auditing of events. This is usually done to remove clutter from the logs and
    hide cosmetic denials that have no influence on the security of the system.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个重要的 SELinux 策略指令可以控制哪些操作被（不）审计，那就是 `dontaudit`。SELinux 策略中的 `dontaudit` 规则告诉
    SELinux 访问拒绝不应该被记录。这是唯一一个 SELinux 不会记录拒绝的例子——SELinux 策略编写者明确禁用了事件的审计。这通常是为了减少日志的杂乱，隐藏那些对系统安全没有影响的外观性拒绝。
- en: 'The `seinfo` utility can tell us how many of these rules, as well as its sibling
    rule `auditallow` (log events, even though they are allowed by the policy), are
    currently active, as illustrated in the following code snippet:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`seinfo` 工具可以告诉我们当前有多少条这些规则，以及其兄弟规则 `auditallow`（即使政策允许，也记录事件），如以下代码片段所示：'
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Luckily, we can disable these `dontaudit` rules at will. Through the following
    `semodule` command, these rules are removed from the active policy:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以随意禁用这些 `dontaudit` 规则。通过以下 `semodule` 命令，这些规则将从活动策略中移除：
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The arguments can also be abbreviated to `-D` and `-B`, respectively. To re-enable
    the `dontaudit` rules, just rebuild the policy like so:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这些参数也可以分别缩写为 `-D` 和 `-B`。要重新启用 `dontaudit` 规则，只需像下面这样重新构建策略：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Disabling the `dontaudit` rules can sometimes help in troubleshooting failures
    that do not result in any useful audit event. Generally speaking, though, audit
    events that policy writers mark as cosmetic are not the cause of a failure.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 禁用 `dontaudit` 规则有时有助于排查那些没有产生有用审计事件的故障。然而，通常情况下，策略编写者标记为外观性的审计事件并不是故障的原因。
- en: Configuring Linux auditing
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 Linux 审计
- en: SELinux will try to use the audit subsystem when available and will fall back
    to regular system logging when it isn't. This can either be because the Linux
    kernel audit subsystem is not configured or because the Linux audit daemon itself
    is not running.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当Linux内核审计子系统未配置或Linux审计守护程序未运行时，SELinux将尝试使用审计子系统并退回到常规系统日志记录。
- en: 'For a Linux audit, we usually do not need to configure anything as SELinux
    AVC denials are logged by default. You will find the denials in the audit log
    file (`/var/log/audit/audit.log`), usually together with the system call and other
    event messages related to the same action, as illustrated in the following code
    snippet:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Linux审计，通常不需要配置任何东西，因为SELinux AVC拒绝默认会被记录。您会在审计日志文件（`/var/log/audit/audit.log`）中找到这些拒绝信息，通常与同一操作相关的系统调用和其他事件消息一起记录，如下面的代码片段所示：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: To configure the target log file for the audit system, use the `log_file` parameter
    in `/etc/audit/auditd.conf`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置审计系统的目标日志文件，请在`/etc/audit/auditd.conf`中使用`log_file`参数。
- en: To enable remote audit logging (to centralize audit events from multiple hosts
    on a single system), you have the option of either enabling syslog forwarding
    or enabling the `audisp-remote` plugin.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用远程审计日志记录（将多个主机的审计事件集中到单个系统上），您可以选择启用Syslog转发或启用`audisp-remote`插件。
- en: With syslog forwarding, the audit dispatch daemon is configured to send audit
    events to the local system logger as well. It is then up to the administrator
    to configure the local system logger to pass on events toward a remote system.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Syslog转发时，配置审计调度守护程序将审计事件发送到本地系统记录器。然后，管理员需要配置本地系统记录器以向远程系统传递事件。
- en: Informational note
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 信息提示
- en: The use of syslog forwarding has the advantage that no additional software deployments
    and daemons are needed on the servers to centralize their log events. The setup
    is hence also reusable in case hardened appliances are introduced to the environment.
    Of course, other log management solutions exist that can watch for log events
    and send those to the central server. These, however, require more configuration,
    and introduce an additional software agent to install.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Syslog转发的优点是在服务器上集中其日志事件时不需要额外的软件部署和守护程序。因此，即使在环境中引入了硬化设备，该设置也可以重复使用。当然，还存在其他可以监视日志事件并将其发送到中央服务器的日志管理解决方案。但是，这些解决方案需要更多的配置，并引入额外的软件代理进行安装。
- en: 'Edit the `/etc/audit/plugins.d/syslog.conf` file and set `active` to `yes`,
    as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`/etc/audit/plugins.d/syslog.conf`文件，并将`active`设置为`yes`，如下所示：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Using the system logger to centralize audit events might not be the best option
    though, as system loggers generally use unencrypted—and often not even guaranteed—data
    delivery. With the `audisp-remote` plugin, we can even use an encrypted channel
    to send the audit events, and provide guaranteed delivery to a remote `auditd`
    server.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使用系统记录器来集中审计事件可能不是最佳选择，因为系统记录器通常使用未加密的——甚至未保证——数据传递。通过`audisp-remote`插件，我们甚至可以使用加密通道发送审计事件，并向远程的`auditd`服务器提供保证的传递。
- en: 'First, configure the audit daemon on the target (log) server to accept audit
    logs from remote hosts by enabling the audit daemon to listen on port `60`. We
    also change the event formatting to an enriched value and add hostnames to the
    events so that we can distinguish events from multiple hosts, as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在目标（日志）服务器上配置审计守护程序，使其能够通过在端口`60`上启用审计守护程序来接收来自远程主机的审计日志。我们还将事件格式设置为丰富值，并向事件添加主机名，以便区分来自多个主机的事件，如下所示：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, enable the `audisp-remote` plugin, as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，启用`audisp-remote`插件，如下所示：
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Don't forget to restart the audit daemon so that the changes take effect.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记重新启动审计守护程序，以使更改生效。
- en: 'We can only recommend you always use the Linux audit subsystem. Not only does
    it integrate nicely with troubleshooting utilities; it also allows administrators
    to use the audit tools to query the audit logs or even generate reports, such
    as with `aureport`, as illustrated in the following code snippet:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强烈建议您始终使用Linux审计子系统。它不仅与故障排除实用工具很好地集成；管理员还可以使用审计工具查询审计日志，甚至生成报告，例如使用`aureport`，如下面的代码片段所示：
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The Linux audit system is an important aide for Linux administrators, and not
    just for SELinux troubleshooting. But next to the Linux audit system, events can
    also be directed toward the local system logger, as explained next.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Linux审计系统是Linux管理员的重要助手，不仅限于SELinux故障排除。除了Linux审计系统之外，事件还可以被定向到本地系统日志记录器，下面将进一步解释。
- en: Configuring the local system logger
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置本地系统日志记录器
- en: When auditing is not enabled, or the Linux audit daemon is not running, then
    the system logger is responsible for capturing SELinux events. The system logger
    will log these events through the kernel logging facility (`kern.*`). Most system
    loggers will save these kernel log events in a general log file, such as `/var/log/messages`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当审计未启用，或Linux审计守护进程未运行时，系统日志记录器负责捕获SELinux事件。系统日志记录器将通过内核日志设施（`kern.*`）记录这些事件。大多数系统日志记录器会将这些内核日志事件保存到一个通用日志文件中，例如`/var/log/messages`。
- en: 'We can configure the system logger to direct SELinux AVC messages into its
    own log file, such as `/var/log/avc.log`. For instance, for the `rsyslog` system
    logger, we can add in a configuration entry under `/etc/rsyslog.d` named `99-selinux.conf`,
    with the following content:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以配置系统日志记录器，将SELinux AVC消息定向到它自己的日志文件，例如`/var/log/avc.log`。例如，对于`rsyslog`系统日志记录器，我们可以在`/etc/rsyslog.d`目录下添加一个名为`99-selinux.conf`的配置条目，内容如下：
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: After restarting the system logger, the AVC-related messages will show up in
    the `/var/log/avc.log` file.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 重启系统日志记录器后，关于AVC的相关信息将会出现在`/var/log/avc.log`文件中。
- en: 'When the local system logger handles SELinux logging, an easy method to quickly
    obtain the latest AVC denials (or other messages) is through the `dmesg` command,
    as illustrated in the following code snippet:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当本地系统日志记录器处理SELinux日志时，快速获取最新的AVC拒绝信息（或其他信息）的一种简单方法是通过`dmesg`命令，如下所示的代码片段所示：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Be aware, though, that unlike the audit logs, many systems allow the `dmesg`
    content to be read by regular users. This might result in some information leakage
    to untrusted users. For this reason, some SELinux policies do not allow regular
    users to access the kernel ring buffer (and, as such, use `dmesg`) unless the
    `user_dmesg` SELinux Boolean is set to `on`, as illustrated in the following code
    snippet:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 但是要注意，与审计日志不同，许多系统允许普通用户读取`dmesg`内容。这可能导致一些信息泄漏给不受信任的用户。因此，一些SELinux策略不允许普通用户访问内核环形缓冲区（因此也无法使用`dmesg`），除非`user_dmesg`
    SELinux布尔值设置为`on`，如下所示的代码片段所示：
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `user_dmesg` SELinux Boolean is not available on CentOS, though. There,
    only the standard unconfined user type and the administrative user type have access
    to the kernel ring buffer. To prevent other users from reading this information,
    you need to map these users to non-administrative SELinux users, such as `user_u`
    or `(x)guest_u`, which is something described further on in this book.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`user_dmesg` SELinux布尔值在CentOS上不可用。在CentOS中，只有标准的非限制用户类型和管理员用户类型可以访问内核环形缓冲区。为了防止其他用户读取这些信息，您需要将这些用户映射到非管理员的SELinux用户，例如`user_u`或`(x)guest_u`，这将在本书后续部分进一步描述。
- en: Reading SELinux denials
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阅读SELinux拒绝信息
- en: 'The one thing every one of us will have to do several times with SELinux systems
    is to read and interpret SELinux denial information. When SELinux prohibits access
    and there is no `dontaudit` rule in place to hide it, SELinux will log it. If
    nothing is logged, it was probably not SELinux that was responsible for the failure.
    Remember: SELinux comes after Linux **discretionary access control** (**DAC**)
    checks, so if a regular permission doesn''t allow a certain activity then SELinux
    is never consulted.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 每个人在使用SELinux系统时，都会多次读取和解释SELinux拒绝信息。当SELinux禁止访问并且没有`dontaudit`规则来隐藏它时，SELinux会记录该信息。如果没有任何记录，可能不是SELinux导致了失败。请记住：SELinux在Linux**自愿访问控制**（**DAC**）检查之后执行，因此如果常规权限不允许某项活动，SELinux就不会被咨询。
- en: 'SELinux denial messages are logged the moment SELinux prevents some access
    from occurring. When SELinux is in enforcing mode, the application usually returns
    a **Permission denied** error, although sometimes it might be a bit more obscure.
    An example of this can be seen in the following code snippet:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当SELinux阻止某些访问发生时，SELinux拒绝信息会被记录。处于强制模式时，应用程序通常会返回**权限被拒绝**的错误，尽管有时可能会更加模糊。以下代码片段展示了一个例子：
- en: '[PRE28]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'So, what does a denial message look like? The following command output shows
    a denial from the audit subsystem, which we can query through the `ausearch` command:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，拒绝信息是什么样子的呢？以下命令输出展示了来自审计子系统的拒绝信息，我们可以通过`ausearch`命令进行查询：
- en: '[PRE29]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s break up this denial into its individual components. The following list
    gives more information about each part of the preceding denials. As an administrator,
    knowing how to read denials is extremely important, so take enough time for this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个拒绝日志分解成各个组成部分。以下列表提供了关于每个部分的更多信息。作为管理员，学会如何阅读拒绝日志非常重要，所以要花足够的时间学习：
- en: '`enforcing` mode. This is usually `denied`, although some actions are explicitly
    marked to be audited as well and would result in `granted`. Example: `denied`'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enforcing` 模式。通常是 `denied`，尽管某些操作会明确标记为审计操作，也会导致 `granted`。例如：`denied`'
- en: '`{ read }`'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{ read }`'
- en: '`pid=12569`'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pid=12569`'
- en: '`comm="dmesg"`'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`comm="dmesg"`'
- en: '`name="xterm-256color"`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name="xterm-256color"`'
- en: '`dev="sdb2"`'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dev="sdb2"`'
- en: '`ino=131523`'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ino=131523`'
- en: '`scontext=sysadm_u:sysadm_r:dmesg_t:s0-s0:c0.c1023`'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scontext=sysadm_u:sysadm_r:dmesg_t:s0-s0:c0.c1023`'
- en: '`tcontext=system_u:object_r:etc_t:s0`'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tcontext=system_u:object_r:etc_t:s0`'
- en: '`tclass=file`'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tclass=file`'
- en: '`0`, then SELinux was in enforcing mode; otherwise, it was permissive (either
    for the system or for the given domain).Example: `permissive=0`'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`，表示 SELinux 处于强制模式；否则，它处于宽容模式（无论是对系统还是对特定域）。例如：`permissive=0`'
- en: 'We can interpret the previous denial like so: SELinux has denied the `dmesg`
    command to read a file named "`xterm-256color`". The file has inode number `131523`
    on device `/dev/sdb2` and is labeled as `etc_t`. The `dmesg` command has PID `12569`
    and is labeled as `dmesg_t`. The `dmesg_t` domain was not in permissive mode.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样解读前面的拒绝：SELinux 拒绝了 `dmesg` 命令读取名为 "`xterm-256color`" 的文件。该文件在设备 `/dev/sdb2`
    上的 inode 编号是 `131523`，并被标记为 `etc_t`。`dmesg` 命令的 PID 是 `12569`，并被标记为 `dmesg_t`。`dmesg_t`
    域并未处于宽容模式。
- en: 'Depending on the action and the target class, SELinux uses different fields
    to give all the information we need to troubleshoot a problem. Consider the following
    denial:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 根据操作和目标类别，SELinux 使用不同的字段提供我们解决问题所需的所有信息。考虑以下拒绝：
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The preceding denial came up because the nginx web server was configured to
    listen on a non-default port (89 instead of the default 80).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的拒绝发生是因为 nginx web 服务器被配置为监听非默认端口（使用 89 而不是默认的 80）。
- en: Identifying the problem is a matter of understanding how the operations work
    and properly reading the denials. The denial logs give us enough to get us started,
    giving a clear idea of what was denied.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 识别问题是理解操作方式并正确阅读拒绝日志的问题。拒绝日志给了我们足够的信息，可以帮助我们入手，并清楚地了解被拒绝的内容。
- en: 'Administrators might want to update the SELinux policy to allow a specific
    action (by adding an `allow` rule to the SELinux policy, as described further
    on in this book). This is, however, not always the right approach because other
    options exist and are usually better, such as these:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 管理员可能希望更新 SELinux 策略以允许特定操作（通过向 SELinux 策略中添加 `allow` 规则，如本书后面所述）。然而，这并不总是正确的做法，因为还有其他选项，通常更好，例如：
- en: Providing the right label on the target resource (usually the case when the
    target is a non-default port, non-default location, and so on)
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为目标资源提供正确的标签（通常当目标是非默认端口、非默认位置等时会出现）
- en: Switching Booleans (flags that manipulate the SELinux policy) to allow additional
    privileges
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切换布尔值（标志，用于操作 SELinux 策略）以允许额外的权限
- en: Providing the right label on the source process (often the case when the acting
    application is not installed by the distribution package manager)
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为源进程提供正确的标签（通常当操作的应用程序不是通过发行版包管理器安装时会出现）
- en: Using the application as intended instead of through other means (as SELinux
    only allows expected behavior), such as starting a daemon through a service (`init`
    script or systemd unit) instead of through a command-line operation
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按预期使用应用程序，而不是通过其他方式使用（因为 SELinux 只允许预期行为），例如通过服务启动守护进程（`init` 脚本或 systemd 单元），而不是通过命令行操作
- en: If the preceding nginx example were a wanted configuration (using a non-default
    port), then we should label this port as a `httpd_t` domain to bind on (many)
    other ports.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前面的 nginx 示例是想要的配置（使用非默认端口），那么我们应该将该端口标记为 `httpd_t` 域，以便绑定到（许多）其他端口。
- en: Other SELinux-related event types
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他与 SELinux 相关的事件类型
- en: Although most SELinux log events are AVC-related, they aren't the sole event
    types an administrator will have to deal with. Most audit events will show SELinux
    information as part of the event, even though SELinux has little to do with the
    event itself, but a few audit event types are directly concerned with SELinux.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然大多数 SELinux 日志事件与 AVC 相关，但它们并不是管理员必须处理的唯一事件类型。大多数审计事件会将 SELinux 信息作为事件的一部分显示，尽管
    SELinux 与事件本身关系不大，但一些审计事件类型与 SELinux 直接相关。
- en: Tip
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: A full list of all possible audit events is available in the `linux/audit.h`
    header file, located in `/usr/include`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 所有可能的审计事件的完整列表可以在`linux/audit.h`头文件中找到，该文件位于`/usr/include`目录下。
- en: USER_AVC
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: USER_AVC
- en: A `USER_AVC` event resembles regular AVC audit events, but now the source is
    a user space object manager. These are applications that use SELinux policy rules,
    but they enforce these rules themselves rather than through the kernel.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`USER_AVC`事件类似于常规的AVC审计事件，但源头是一个用户空间对象管理器。这些是使用SELinux策略规则的应用程序，但它们自己执行这些规则，而不是通过内核。'
- en: 'The following example is such an event, generated by D-Bus:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例是由D-Bus生成的这样的事件：
- en: '[PRE31]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The event has two parts. Everything up to the `msg=` string is information about
    the user space object manager that generated the event, and is the first part
    of the event. The true event itself (which is the second part) is stored within
    the `msg=` part and includes similar fields, as we already know from regular AVCs.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 该事件有两个部分。直到`msg=`字符串之前的所有内容都是关于生成该事件的用户空间对象管理器的信息，是事件的第一部分。实际事件本身（即第二部分）存储在`msg=`部分，其中包括与常规AVC类似的字段。
- en: SELINUX_ERR
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SELINUX_ERR
- en: 'An `SELINUX_ERR` event comes up when SELinux detects a general policy violation
    rather than an access control violation. It cannot be resolved by SELinux policy
    writers by just allowing the operation. These events usually point to a misuse
    of applications and services that the policy is not tailored to accomplish, and
    an example is shown in the following code snippet:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当SELinux检测到一般的策略违规而不是访问控制违规时，会产生一个`SELINUX_ERR`事件。仅通过允许操作，SELinux策略编写者无法解决此问题。这些事件通常指向应用程序和服务的误用，而这些应用程序和服务并非根据策略来完成的，以下代码片段展示了一个示例：
- en: '[PRE32]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding example, a user (running in the `sysadm_t` domain) was executing
    `rpc.nfsd` (with `nfsd_exec_t` as the label), and the policy wanted to transition
    to the `nfsd_t` domain. However, that resulted in a full context of `sysadm_u:sysadm_r:nfsd_t:s0-s0:c0.c1023`,
    which is not a valid context. The `sysadm_r` SELinux role does not support the
    `nfsd_t` domain.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，一个用户（运行在`sysadm_t`域中）正在执行`rpc.nfsd`（标签为`nfsd_exec_t`），而策略希望过渡到`nfsd_t`域。然而，这导致了一个完整的上下文`sysadm_u:sysadm_r:nfsd_t:s0-s0:c0.c1023`，这是一个无效的上下文。`sysadm_r`
    SELinux角色不支持`nfsd_t`域。
- en: MAC_POLICY_LOAD
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MAC_POLICY_LOAD
- en: 'A `MAC_POLICY_LOAD` event occurs whenever the system loads a new SELinux policy
    in memory. This occurs when the administrator loads a new or updated SELinux policy
    module, rebuilds the policy with the `dontaudit` rules disabled, or toggles an
    SELinux Boolean that the administrator wants to persist across reboots. Such an
    event is illustrated in the following code snippet:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 每当系统将新的SELinux策略加载到内存中时，都会发生`MAC_POLICY_LOAD`事件。这通常发生在管理员加载新的或更新的SELinux策略模块、重新构建策略并禁用`dontaudit`规则，或切换管理员希望在重启后持续生效的SELinux布尔值时。这样的事件如下代码片段所示：
- en: '[PRE33]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When a `MAC_POLICY_LOAD` event occurs, you might notice a subsequent `USER_MAC_POLICY_LOAD`
    event. This occurs when a user space object manager detects an update on the SELinux
    policy and takes action. Note that not all user space object managers will send
    out this event: some object managers will query the live policy and, as such,
    do not need to act when a new policy loads.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生`MAC_POLICY_LOAD`事件时，您可能会注意到随后会有一个`USER_MAC_POLICY_LOAD`事件。这发生在用户空间对象管理器检测到SELinux策略更新并采取行动时。请注意，并非所有用户空间对象管理器都会发送此事件：某些对象管理器会查询实时策略，因此，在加载新策略时不需要采取任何行动。
- en: MAC_CONFIG_CHANGE
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MAC_CONFIG_CHANGE
- en: 'When an SELinux Boolean changes but doesn''t persist, then a `MAC_CONFIG_CHANGE`
    event will be dispatched. This tells the administrator that the active policy
    has been instructed to change its behavior slightly, but within the bounds of
    the existing loaded policy. Such an event is illustrated in the following code
    snippet:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当SELinux布尔值发生变化但未保持时，会触发`MAC_CONFIG_CHANGE`事件。这告诉管理员，活动策略已被指示稍微改变其行为，但仍在现有加载策略的范围内。这样的事件如下代码片段所示：
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the preceding example, the `virt_use_nfs` SELinux Boolean was changed from
    the value 1 (on) to 0 (off).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，`virt_use_nfs` SELinux布尔值从1（开启）更改为0（关闭）。
- en: MAC_STATUS
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MAC_STATUS
- en: 'A `MAC_STATUS` event shows up when the SELinux enforcement state has been changed.
    For instance, when an administrator uses `setenforce 0` to put SELinux in permissive
    mode, then the following event occurs:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当SELinux执行状态发生变化时，会出现`MAC_STATUS`事件。例如，当管理员使用`setenforce 0`将SELinux置于宽容模式时，就会发生以下事件：
- en: '[PRE35]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`MAC_STATUS` is also used to inform administrators when the SELinux state itself
    (enabled or disabled) is altered.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`MAC_STATUS`还用于通知管理员，当SELinux状态本身（启用或禁用）发生变化时。'
- en: NetLabel events
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NetLabel事件
- en: NetLabel is a Linux kernel project to support labeled network packets, allowing
    security contexts such as SELinux contexts to be passed on between hosts. One
    of the protocols that the NetLabel implementation supports in Linux is **Common
    IP Security Option** (**CIPSO**) labeling, which we will cover in [*Chapter 5*](B16276_05_Final_VK.xhtml#_idTextAnchor138),
    *Controlling Network Communications*.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: NetLabel是一个Linux内核项目，旨在支持标记的网络数据包，允许诸如SELinux上下文之类的安全上下文在主机之间传递。Linux中NetLabel实现支持的协议之一是**公共IP安全选项**（**CIPSO**）标记，我们将在[*第5章*](B16276_05_Final_VK.xhtml#_idTextAnchor138)中详细讲解，*控制网络通信*。
- en: 'The following audit events are related to the NetLabel capability:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下审计事件与NetLabel功能相关：
- en: '`MAC_UNLBL_STCADD` and `MAC_UNLBL_STCDEL` events are triggered when a static
    label is added or removed. Static labeling means that if a packet is received
    or sent and it does not have a label, then this "default" static label is assigned.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MAC_UNLBL_STCADD`和`MAC_UNLBL_STCDEL`事件在添加或删除静态标签时触发。静态标签意味着，如果数据包被接收或发送时没有标签，则会分配这个“默认”静态标签。'
- en: '`MAC_MAP_ADD` and `MAC_MAP_DEL` events are triggered when a mapping between
    a labeling protocol (such as CIPSO) and its parameters against an LSM (SELinux)
    domain is added or removed from the configuration.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MAC_MAP_ADD`和`MAC_MAP_DEL`事件在将标记协议（如CIPSO）与其针对LSM（SELinux）域的参数之间的映射添加或从配置中删除时触发。'
- en: '`MAC_CIPSOV4_ADD` and `MAC_CIPSOV4_DEL` events are triggered when a CIPSO (IPv4)
    configuration is added or removed.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MAC_CIPSOV4_ADD`和`MAC_CIPSOV4_DEL`事件在添加或删除CIPSO（IPv4）配置时触发。'
- en: Labeled IPsec events
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标记的IPsec事件
- en: Another labeled network protocol that Linux supports is **labeled IPsec**, where
    **IPsec** is short for **Information Protocol Security**. Through this, the SELinux
    context of the source process (which is communicating over the IPsec tunnel toward
    a target resource) is known by the IPsec daemons at both ends of the tunnel. Furthermore,
    SELinux will contain rules about which domains can communicate over an IPsec tunnel
    and which domains can communicate with each other network-wise.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Linux支持的另一个标记网络协议是**标记的IPsec**，其中**IPsec**是**信息协议安全**的缩写。通过这个协议，源进程的SELinux上下文（通过IPsec隧道与目标资源通信）会被IPsec守护进程在隧道的两端所知晓。此外，SELinux将包含关于哪些域可以通过IPsec隧道进行通信，哪些域可以在网络上互相通信的规则。
- en: 'The following audit events are related to IPsec:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 以下审计事件与IPsec相关：
- en: '`MAC_IPSEC_ADDSA` and `MAC_IPSEC_DELSA` events are used when a security association
    is added or removed (new IPsec tunnels are defined or deleted).'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MAC_IPSEC_ADDSA`和`MAC_IPSEC_DELSA`事件在添加或删除安全关联时使用（定义或删除新的IPsec隧道）。'
- en: '`MAC_IPSEC_ADDSPD` and `MAC_IPSEC_DELSPD` events are used when a security policy
    definition is added or removed. Security policies generally describe whether network
    packets need to be handled by IPsec and, if so, through which security association.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MAC_IPSEC_ADDSPD`和`MAC_IPSEC_DELSPD`事件在添加或删除安全策略定义时使用。安全策略通常描述网络数据包是否需要通过IPsec进行处理，如果是的话，通过哪个安全关联进行处理。'
- en: A `MAC_IPSEC_EVENT` event is a generic event for IPsec audit messages.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MAC_IPSEC_EVENT`事件是IPsec审计消息的通用事件。'
- en: SELinux support for labeled IPsec is described further on in this book.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 本书后续将进一步描述SELinux对标记的IPsec的支持。
- en: Using ausearch
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用ausearch
- en: The `ausearch` command, part of the Linux audit framework, is a frequently used
    command for querying audit events stored on the system. We already briefly covered
    it when taking a first look at an AVC denial, but only briefly mentioning it won't
    do it justice.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`ausearch`命令是Linux审计框架的一部分，是查询存储在系统上的审计事件的常用命令。在我们第一次查看AVC拒绝时已简要介绍过它，但简单提及并不能充分体现它的作用。'
- en: 'With `ausearch`, we can search for events that originated during or after a
    selected time period. We used the `-ts recent` (time start) option in the past,
    which displays events that occurred during the past 10 minutes. The argument can
    also be a timestamp. Other supported shorthand values are listed as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ausearch`，我们可以搜索在选定时间段内或之后发生的事件。我们过去使用了`-ts recent`（时间起始）选项，它显示过去10分钟内发生的事件。该参数也可以是时间戳。其他支持的简写值如下：
- en: '`today`, meaning starting at 1 second past midnight on the current day'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`today`，表示从当天午夜1秒钟开始'
- en: '`yesterday`, meaning starting at 1 second past midnight the previous day'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yesterday`，表示从前一天午夜1秒钟开始'
- en: '`this-week`, `this-month`, or `this-year`, meaning starting at 1 second past
    midnight on the first day of the current week, current month, or current year'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`this-week`，`this-month`，或`this-year`，意味着从当前周、当前月或当前年第一天的午夜1秒开始'
- en: '`checkpoint`, which uses the timestamp mentioned in a checkpoint file created
    in a previous run'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`checkpoint`，使用在前一次运行时创建的检查点文件中的时间戳'
- en: '`boot`, which implies only events since the system booted should be shown'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boot`，意味着只显示自系统启动以来的事件'
- en: '`week-ago`, meaning starting at 1 second after midnight exactly 7 days ago'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`week-ago`，意味着从正好7天前的午夜1秒开始'
- en: 'The use of `checkpoint` is particularly useful when troubleshooting SELinux
    issues as it allows us to show denials (and other SELinux events) since the last
    invocation of the `ausearch` command. This is illustrated in the following code
    snippet:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`checkpoint`尤其在排查SELinux问题时非常有用，因为它允许我们显示自上次调用`ausearch`命令以来的拒绝事件（及其他SELinux事件）。下面的代码片段中进行了说明：
- en: '[PRE36]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This allows administrators to perform minor tweaks and reproduce the problem
    and only see the events since then, instead of going through all events over and
    over again.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得管理员能够进行小范围的调整并重现问题，只查看从那时起发生的事件，而不是一次又一次地查看所有事件。
- en: By default, the `ausearch` command displays all events stored in the audit log.
    On busy systems, this can be very verbose and may result in unwanted events being
    displayed as well. Luckily, users can limit the type of events queried through
    the `ausearch` command.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`ausearch`命令会显示存储在审计日志中的所有事件。在繁忙的系统中，这可能会导致显示过于冗长的信息，并且可能会出现不需要的事件。幸运的是，用户可以通过`ausearch`命令限制查询事件的类型。
- en: 'For SELinux troubleshooting, using `avc,user_avc,selinux_err` limits the events
    nicely to those needed for the job, as illustrated in the following code snippet:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 对于SELinux故障排除，使用`avc,user_avc,selinux_err`可以将事件精确地限制在处理工作所需的范围内，如下面的代码片段所示：
- en: '[PRE37]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If the numeric display of fields such as user IDs and timestamps is too confusing,
    then it is possible for `ausearch` to look up and translate user IDs to usernames
    and timestamps to formatted time fields. Add the `-i` option to `ausearch` to
    have it interpret these fields and display the interpreted values instead.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字段如用户ID和时间戳的数字显示过于混乱，那么`ausearch`可以查找并转换用户ID为用户名，时间戳为格式化的时间字段。添加`-i`选项到`ausearch`命令，它将解释这些字段并显示已解释的值。
- en: In this section, we've seen how SELinux notifies the system about its actions
    through log events, and where these log events are stored. In the next section,
    we'll look at how to act upon these events.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已了解SELinux如何通过日志事件通知系统其操作，以及这些日志事件存储的位置。在下一节中，我们将探讨如何处理这些事件。
- en: Getting help with denials
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取关于拒绝的帮助
- en: On some distributions, additional support tools are available that help us identify
    the cause of a denial. These tools have some knowledge of common mistakes (for
    instance, setting the right context on files to allow the web server to read them).
    Other distributions require us to use our experience to make proper decisions,
    supporting us through the distribution mailing lists, bug tracking sites, and
    other cooperation locations—for example, **Internet Relay Chat** (**IRC**).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些发行版中，提供了额外的支持工具，帮助我们识别拒绝的原因。这些工具具有一些常见错误的知识（例如，设置文件的正确上下文以允许Web服务器读取它们）。其他发行版则要求我们凭借经验做出正确的决定，通过发行版的邮件列表、错误跟踪网站以及其他合作渠道（例如**Internet
    Relay Chat**（**IRC**））提供支持。
- en: Troubleshooting with setroubleshoot
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用setroubleshoot进行故障排除
- en: In CentOS (and other **Red Hat Enterprise Linux** (**RHEL**)-related distributions
    such as Fedora), additional tools are present that help us troubleshoot denials.
    The tools work together to catch a denial, look for a plausible solution, and
    inform the administrator about the denial and its suggested resolutions.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在CentOS（以及其他**Red Hat Enterprise Linux**（**RHEL**）相关发行版，如Fedora）中，提供了额外的工具，帮助我们排除拒绝问题。这些工具协同工作，捕捉拒绝事件，寻找合理的解决方案，并向管理员报告拒绝及其建议的解决方法。
- en: When used on a graphical workstation, denials can even result in popups that
    ask the administrator to review them immediately. Install the `setroubleshoot`
    package to get this support. On servers without a graphical environment, administrators
    can see the information in the system logs or can even configure the system to
    send out SELinux denial messages via email. Install the `setroubleshoot-server`
    package to get this support.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在图形工作站上使用时，拒绝事件甚至会弹出提示，要求管理员立即查看。安装`setroubleshoot`包以获得此支持。在没有图形环境的服务器上，管理员可以在系统日志中查看信息，或者甚至可以配置系统通过电子邮件发送
    SELinux 拒绝消息。安装`setroubleshoot-server`包以获得此支持。
- en: Under the hood, it is the audit daemon that triggers its audit event dispatcher
    application (`audispd`). This application supports plugins, something the SELinux
    folks gratefully implemented. They built an application called `sedispatch` that
    will act as a plugin for `audispd`. The `sedispatch` application checks whether
    the audit event is an SELinux denial and, if so, forwards the events to D-Bus.
    D-Bus then forwards the events to the `setroubleshootd` application (or launches
    the application if it isn't running yet), which analyzes the denial and prepares
    feedback for the administrator.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在后台，触发审计事件调度程序应用程序（`audispd`）的是审计守护进程。这个应用程序支持插件功能，SELinux 团队十分感激地实现了这一点。他们构建了一个名为`sedispatch`的应用程序，它将作为`audispd`的插件。`sedispatch`应用程序会检查审计事件是否为
    SELinux 拒绝事件，如果是，它会将事件转发到 D-Bus。D-Bus 然后将事件转发给`setroubleshootd`应用程序（如果该应用程序尚未运行，则启动它），该应用程序分析拒绝事件并为管理员提供反馈。
- en: 'When running on a workstation, `seapplet` is triggered to show a popup on the
    administrator workstation. The administrator can then select **Show** to view
    more details. Administrators don''t need a graphical user interface to be informed
    about SELinux issues, though. You can find analyzed feedback on the filesystem,
    and in the system logs you can read how to easily reach this information, as illustrated
    in the following code snippet:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在工作站上运行时，会触发`seapplet`，在管理员的工作站上显示弹出窗口。管理员可以选择**显示**以查看更多详情。不过，管理员无需图形用户界面也能得知
    SELinux 问题。你可以在文件系统中找到已分析的反馈，并且在系统日志中可以阅读如何轻松访问这些信息，如下面的代码片段所示：
- en: '[PRE38]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can look at a complete explanation through the `sealert` command (as mentioned
    in the log), as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`sealert`命令（如日志中所提到的）查看完整的解释，如下所示：
- en: '[PRE39]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `sealert` application is a command-line application that parses the information
    stored by the `setroubleshoot` daemon (in `/var/lib/setroubleshoot`).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`sealert`应用程序是一个命令行应用程序，它解析`setroubleshoot`守护进程存储的信息（存储在`/var/lib/setroubleshoot`目录下）。'
- en: This will provide us with a set of options to resolve the denial. In the case
    of the Apache-related denial shown earlier, `sealert` gives us one option with
    a certain confidence score. Depending on the problem, this tool might show multiple
    options, each with its own confidence figure (that is, how certain `sealert` is
    that this is the right resolution).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为我们提供一组选项来解决拒绝问题。在之前展示的与 Apache 相关的拒绝事件中，`sealert`给出了一个选项，并附有一定的信心分数。根据问题的不同，这个工具可能会显示多个选项，每个选项都有其自己的信心值（即，`sealert`对这是正确解决方法的确定程度）。
- en: As we can see from this example, the `setroubleshoot` application itself uses
    plugins to analyze denials. These plugins (offered through the `setroubleshoot-plugins`
    package) look at a denial to check whether they match a particular, well-known
    use case (for example, when to change an SELinux Boolean or when a target resource
    has a wrong context) and give feedback to `setroubleshoot` about how certain the
    plugin is so that this denial can be resolved through its recommended method.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从这个例子中看到的，`setroubleshoot`应用程序本身使用插件来分析拒绝事件。这些插件（通过`setroubleshoot-plugins`包提供）会查看拒绝事件，检查它们是否与某个特定的、已知的用例匹配（例如，何时更改
    SELinux 布尔值或何时目标资源具有错误的上下文），并向`setroubleshoot`提供反馈，表明插件对此的确定性，以便通过推荐的方法解决此拒绝事件。
- en: Sending emails when SELinux denials occur
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当 SELinux 拒绝发生时发送电子邮件
- en: Once a system is fine-tuned and denials no longer occur regularly, administrators
    can opt to have `setroubleshootd` send emails whenever a new denial comes up.
    This truly brings SELinux's host intrusion detection/prevention capabilities on
    top, as administrators do not need to constantly watch their logs for information.
    However, keep in mind that this could lead to a sudden burst in emails, which
    might result in **Denial of Service** (**DoS**)-like behavior, if many denials
    are triggered. Administrators should only implement this if their email infrastructure
    has rate limiting or other **Quality of Service** (**QoS**) controls in place.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦系统进行了微调且拒绝不再频繁发生，管理员可以选择让`setroubleshootd`在出现新拒绝时发送电子邮件。这真正增强了SELinux的主机入侵检测/防止能力，因为管理员不需要不断查看日志来获取信息。然而，请记住，这可能会导致电子邮件的突然激增，从而可能引发**拒绝服务**（**DoS**）-
    类似的行为，如果触发了许多拒绝。管理员应该只有在其邮件基础设施具备速率限制或其他**服务质量**（**QoS**）控制时才实施此功能。
- en: 'Open `/etc/setroubleshoot/setroubleshoot.conf` in a text editor and locate
    the `[email]` section. Update the parameters to match the local mailing infrastructure,
    as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在文本编辑器中打开`/etc/setroubleshoot/setroubleshoot.conf`文件，找到`[email]`部分。更新参数以匹配本地邮件基础设施，如下所示：
- en: '[PRE40]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Next, edit the `email_alert_recipients` file (as referenced through the `recipients_filepath`
    variable), and add the email addresses that need to be notified when an SELinux
    alert comes up.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，编辑`email_alert_recipients`文件（通过`recipients_filepath`变量引用），并添加需要在SELinux警报出现时通知的电子邮件地址。
- en: 'Finally, restart the D-Bus daemon, as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，重新启动D-Bus守护进程，如下所示：
- en: '[PRE41]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'When working on a non-systemd system, use the following command instead:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在非systemd系统上工作时，请使用以下命令：
- en: '[PRE42]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The D-Bus restart is needed as D-Bus manages the `setroubleshootd` daemon.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 需要重新启动D-Bus，因为D-Bus管理`setroubleshootd`守护进程。
- en: Using audit2why
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用audit2why
- en: If `setroubleshoot` and `sealert` are not available in the Linux distribution,
    we can still get some information about a denial. Although it isn't as extensive
    as the plugins offered by `setroubleshoot`, the `audit2why` utility (which is
    short for `audit2allow -w`) does provide some feedback on a denial. Sadly, it
    isn't always right in its deduction.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`setroubleshoot`和`sealert`在Linux发行版中不可用，我们仍然可以获得一些关于拒绝的信息。尽管它不像`setroubleshoot`提供的插件那样详细，但`audit2why`工具（即`audit2allow
    -w`的简称）确实提供了一些拒绝的反馈。遗憾的是，它并不总是能够正确推断。
- en: 'Let''s try it out against the same denial for which we used `sealert`, as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们针对之前使用`sealert`的相同拒绝尝试一下，如下所示：
- en: '[PRE43]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `audit2why` utility here didn't consider that the context of the target
    location was wrong, and it suggests that the policy be updated to allow the web
    server to bind to the `unreserved_port_t` type, unlike the information provided
    by `setroubleshoot`, which was more accurate, recommending that the target port
    be relabeled instead.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`audit2why`工具没有考虑到目标位置的上下文是错误的，并建议更新策略，允许 Web 服务器绑定到`unreserved_port_t`类型，这与`setroubleshoot`提供的信息不同，后者更准确，推荐重新标记目标端口。
- en: As the output of the command mentions, another tool exists called `audit2allow`,
    which can convert a denial into an SELinux policy. We will cover `audit2allow`
    in [*Chapter 12*](B16276_12_Final_VK.xhtml#_idTextAnchor312), *Tuning SELinux
    Policies*.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 正如命令输出所提到的，还有一个叫做`audit2allow`的工具，可以将拒绝转换为SELinux策略。我们将在[*第12章*](B16276_12_Final_VK.xhtml#_idTextAnchor312)，“调优SELinux策略”中介绍`audit2allow`。
- en: Interacting with systemd-journal
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与systemd-journal交互
- en: Alongside the Linux audit system, which is used for most SELinux logging and
    events, we can also gather information through other logging systems. systemd's
    journal, for instance, captures SELinux context information with the events and
    allows administrators to use this information while querying the journal.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 除了用于大多数SELinux日志记录和事件的Linux审计系统外，我们还可以通过其他日志系统收集信息。例如，systemd的日志捕获SELinux上下文信息并与事件一起存储，允许管理员在查询日志时使用这些信息。
- en: 'For instance, to see the events in `systemd-journal` that are generated by
    an application associated with the `system_u:system_r:sssd_t:s0` context, the
    following command can be used:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要查看由与`system_u:system_r:sssd_t:s0`上下文相关的应用程序生成的`systemd-journal`中的事件，可以使用以下命令：
- en: '[PRE44]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Because `systemd-journal` adds the SELinux context of the originating application,
    it is harder for malicious applications to generate fake events. Whereas regular
    system loggers just capture string events, `systemd-journal` retrieves the SELinux
    context from the system. Using the SELinux context, it is easy to group events
    across different but strongly related applications and have a higher guarantee
    that events come from a particular application.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`systemd-journal`添加了来源应用程序的SELinux上下文，因此恶意应用程序更难生成虚假事件。而常规的系统日志记录器只捕获字符串事件，`systemd-journal`从系统中检索SELinux上下文。使用SELinux上下文，可以轻松地跨不同但强相关的应用程序分组事件，并更高保证事件来自特定应用程序。
- en: 'When the `bash-completion` package is installed, we can even use it to see
    which SELinux contexts are present in the `systemd-journal` logs, which makes
    querying the journal logs much easier, as follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 安装`bash-completion`包后，我们甚至可以使用它查看`systemd-journal`日志中存在的SELinux上下文，这使得查询日志变得更加容易，如下所示：
- en: '[PRE45]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To find messages related to nginx, use the embedded `grep` filter, as follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找与nginx相关的消息，请使用嵌入的`grep`过滤器，如下所示：
- en: '[PRE46]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The benefit of the embedded `grep` filter is that `journalctl` will still show
    the multiline messages, whereas actually redirecting the `journalctl` output through
    `grep` would only show the individual lines that match the expression.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入的`grep`过滤器的好处在于，`journalctl`仍将显示多行消息，而实际通过`grep`重定向`journalctl`输出只会显示符合表达式的各个行。
- en: Using common sense
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用常识
- en: Common sense is not easy to document, but reading a denial often leads to the
    right solution when we have some experience with file labels (and what they are
    used for). If we get a denial about a web server failing to read its files, and
    the context of the file is (for instance) `user_home_t`, then that should ring
    a bell. End user home files, for instance, use the `user_home_t` context, which
    is not suitable for system files that the web server reads.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 常识并不容易记录，但是当我们对文件标签（及其用途）有一些经验时，阅读拒绝通常会导致正确的解决方案。例如，如果我们收到有关Web服务器无法读取其文件的拒绝，并且文件的上下文是（例如）`user_home_t`，那么这应该是一个警示。最终用户的主文件，例如，使用`user_home_t`上下文，这对Web服务器读取的系统文件不合适。
- en: 'One way to make sure that the context of the target resource is correct is
    to verify it with `matchpathcon`. This utility returns the context as it should
    be according to the SELinux policy, as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 确保目标资源的上下文正确的一个方法是使用`matchpathcon`进行验证。该实用程序根据SELinux策略返回应有的上下文，如下所示：
- en: '[PRE47]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Performing this for denials related to files and directories might help in finding
    a proper solution quickly.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 对于与文件和目录相关的拒绝，进行此操作可能有助于快速找到合适的解决方案。
- en: 'Furthermore, many domains have specific manual pages that inform the reader
    about types commonly used for each domain, as well as how to deal with the domain
    in more detail (for example, the available booleans, common mistakes made, and
    so on). These manual pages start with the main service and are suffixed with `_selinux`,
    as illustrated here:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，许多域都有特定的手册页面，告知读者每个域常用的类型，以及如何更详细地处理该域（例如，可用的布尔值、常见错误等）。这些手册页面以主要服务开头，并以`_selinux`为后缀，如下所示：
- en: '[PRE48]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In most cases, the approach to handling denials can be best described as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，处理拒绝的方法最好描述如下：
- en: Is the target resource label (such as the file label) the right one? Verify
    this with `matchpathcon`, or compare with labels of working (accessible) resources.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标资源标签（如文件标签）是否正确？可以使用`matchpathcon`进行验证，或与工作（可访问）资源的标签进行比较。
- en: Is the source label (the domain) the expected one? An SSH daemon should run
    in the `sshd_t` domain, not the `init_t` domain. If this is not the case, make
    sure that the labels of the application itself (such as its executable binary)
    are correct (again, use `matchpathcon` for this).
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源标签（域）是否符合预期？SSH守护进程应在`sshd_t`域中运行，而不是`init_t`域中。如果不是这种情况，请确保应用程序本身的标签（例如其可执行二进制文件）正确（再次使用`matchpathcon`进行验证）。
- en: Is the denial one that might be covered by an SELinux boolean? In that case,
    the policy might already have the appropriate rules in place, only requiring a
    change in an SELinux boolean value. `setroubleshootd` will report this if it is
    the case. Usually, the manual page of the domain (such as `httpd_selinux`) will
    also cover the available SELinux Booleans. We explain how to query and adjust
    SELinux Booleans in [*Chapter 12*](B16276_12_Final_VK.xhtml#_idTextAnchor312)*,
    Tuning SELinux Policies*.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该拒绝是否可能由SELinux布尔值覆盖？如果是这样，策略可能已经具备了适当的规则，只需要更改SELinux布尔值即可。`setroubleshootd`会报告这种情况。通常，域的手册页（如`httpd_selinux`）也会覆盖可用的SELinux布尔值。我们将在[*第12章*](B16276_12_Final_VK.xhtml#_idTextAnchor312)《调整SELinux策略》中解释如何查询和调整SELinux布尔值。
- en: Changing file labels will be discussed in [*Chapter 4*](B16276_04_Final_VK.xhtml#_idTextAnchor095)*,
    Using File Contexts and Process Domains*.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 更改文件标签将在[*第4章*](B16276_04_Final_VK.xhtml#_idTextAnchor095)《使用文件上下文和进程域》中讨论。
- en: To close off this section, common sense will be your most prolific approach
    to managing SELinux denials, but the aforementioned tools will be of assistance
    to begin with.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本节之前，常识将是管理SELinux拒绝的最有效方法，但前面提到的工具将是开始时的有力助手。
- en: Summary
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we saw how to enable and disable SELinux, both on a complete
    system level as well as a per-service level using various methods: kernel boot
    options, an SELinux configuration file, or plain commands. One such command is
    `semanage permissive`, which can disable SELinux protections for a single service.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何启用和禁用SELinux，既可以在整个系统级别操作，也可以通过各种方法在单个服务级别进行操作：内核启动选项、SELinux配置文件或普通命令。其中一个命令是`semanage
    permissive`，它可以禁用单个服务的SELinux保护。
- en: Next, we saw where SELinux logs its events and how to interpret them, which
    is one of the most common tasks an administrator has to undertake when dealing
    with SELinux. To assist us with this interpretation, we can use tools such as
    `setroubleshoot`, `sealert`, and `audit2why`. We also touched upon several utilities
    related to Linux auditing to help us sift through various events.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们了解了SELinux如何记录事件及其解释方法，这也是管理员在处理SELinux时最常见的任务之一。为了帮助我们解释这些事件，我们可以使用`setroubleshoot`、`sealert`和`audit2why`等工具。我们还简要介绍了与Linux审计相关的几个工具，以帮助我们筛选各种事件。
- en: 'In the next chapter, we will look at the first administrative task on SELinux
    systems: managing user accounts, their associated SELinux roles, and security
    clearances for the resources on the system.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论SELinux系统中的第一个管理任务：管理用户账户、关联的SELinux角色，以及系统资源的安全权限。
- en: Questions
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What should administrators try before disabling SELinux?
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在禁用SELinux之前，管理员应该尝试什么？
- en: Where can administrators find SELinux logs by default?
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 管理员默认可以在哪里找到SELinux日志？
- en: How do we know whether an application is SELinux-aware?
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何知道一个应用程序是否支持SELinux？
- en: What is the purpose of the AVC?
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: AVC的目的是什么？
- en: Are AVC events the only type of events for SELinux?
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: AVC事件是SELinux的唯一事件类型吗？
