- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing Users and Permissions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we set up our very own Ubuntu Server installation,
    and we can now learn how to maintain it, starting with a look at managing who
    is able to use our server.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: As administrators of Ubuntu servers, users can be your greatest asset and also
    your biggest headache. During your career, you’ll add countless new users, manage
    their passwords, remove their accounts when they leave the company, and grant
    or remove access to resources across the network. Even on servers on which you’re
    the only user, you’ll still find yourself managing user accounts, since even system
    processes run as users. To be successful at managing Linux servers, you’ll also
    need to know how to manage permissions, create password policies, and limit who
    can execute administrative commands on the machine. In this chapter, we’ll work
    through these concepts so that you have a clear idea of how to manage users and
    their resources.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, we will cover:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the purpose of users and groups
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding when to use `root`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and removing users
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the `/etc/passwd` and `/etc/shadow` files
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distributing default configuration files with `/etc/skel`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Switching between users
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing groups
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing passwords and password policies
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring administrator access with `sudo`
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting permissions on files and directories
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the first section, we will have a quick discussion about the nature of managing
    users.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the purpose of users and groups
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to a server, users are very important—without users to serve,
    then there’s no real need for a server in the first place. The subject of user
    management itself within the world of IT is in and of itself quite vast. Entire
    books have been written on individual methods of authentication, and entire technologies
    (such as **Lightweight Directory Access Protocol**, or **LDAP**) exist around
    it. In this chapter, we’ll look at managing users that exist locally on our server,
    and the groups that help define what they are able to do.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Since Ubuntu Server is a distribution of Linux, it adopts the Unix style of
    managing user accounts, groups, and permissions. Although our focus is on Ubuntu,
    many of the same commands around user management that you’ll learn in this chapter
    will apply to other platforms as well. There are commands that allow you to add,
    remove, and change users, as well as commands that allow you to alter permissions.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Users in the context of a server refer to who (or what) is able to use the server.
    For example, you may have an accountant named Susan, or an IT administrator named
    Haneef, who both need to access the server. Perhaps Susan only needs access to
    a file share directory for accounting-related files, and Haneef might have more
    access to the server as a system administrator. The user accounts we create on
    our server will represent the actual people that will use it.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Groups allow us to segregate access to specific files and directories. As we’ll
    learn later, files and directories have user and group assignments. When combined
    with permissions, we’ll be able to manage what our users are able to do with our
    server.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Users aren’t always people, though. We also have system users on our server
    that applications and running processes might use for background or automated
    tasks. An example of this might be a backup job, and you may have a backup user
    that runs a task in the background to facilitate some sort of file copy task that
    copies important files to another place. You don’t have to worry about system-related
    users for now, just know that they exist. You’ll see more examples of this as
    we go through the book.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: More advanced organizations may have a central login server, such as **Active
    Directory** (**AD**) or standard LDAP. There are others aside from those, as well.
    In this book, we won’t cover those technologies, but just keep in mind that central
    authentication servers are a possibility for your organization, should you choose
    to explore them.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: The most powerful user of all, though, is `root`. This special user gives us
    the most control, but as you’ll see in the next section, that comes with risks.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Understanding when to use root
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we set up our very own Ubuntu Server installation. During
    the installation process, we were instructed to create a user account to act as
    a system administrator. So, at this point, we should have at least two users on
    our server. We have the aforementioned administrative user, as well as `root`.
    We can certainly create additional user accounts with varying levels of access
    (and we will do so in this chapter), but before we get to that, some discussion
    is in order regarding the administrator account you created, as well as the `root`
    user that was created for you.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'The `root` user account exists on all Linux distributions and is the most powerful
    user account on the planet. The `root` user account can be used to do anything
    within your server, and I do mean *anything*. Want to create files and directories
    virtually anywhere on the filesystem? Want to install software? These processes
    are easily performed with `root`. The `root` account can even be used to destroy
    your entire installation with one typo or ill-conceived command: if you instruct
    `root` to delete all the files on your entire hard disk, it won’t hesitate to
    do so. It’s always assumed on a Linux system that if you are using `root`, you
    are doing so because you know what you are doing. So, there’s often not so much
    as a confirmation prompt while executing any command as `root`. It will simply
    do as instructed, for better or worse.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: It’s for this reason that every Linux distribution I’ve ever used has stated,
    or at least highly recommended, that you create a standard user during the installation
    process. It’s generally recommended in the Linux community for an administrator
    to have their own account and then switch to `root` whenever a task comes up that
    requires `root` privileges to complete. This approach is less likely to destroy
    your server with an accidental typo or bad command. Some administrators will strictly
    use `root` at all times without any issue, but again, it’s recommended to use
    `root` only when you have to.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Most distributions ask you to create a `root` password during installation in
    order to protect that account. Even Debian (on which Ubuntu is based) has you
    set a `root` password during installation. Ubuntu just decides to do things a
    little bit differently. The reason for this is that, unlike many other distributions,
    Ubuntu defaults to locking out the `root` account altogether. There’s nothing
    stopping you from enabling `root`, or switching to the `root` user after you log
    in. Being disabled by default just means the `root` account isn’t as easily accessible
    as it normally would be. I’ll cover how to enable this account later in this chapter,
    should you feel the need to do so.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: An exception to this rule is that some VPS providers, such as Linode, will enable
    the `root` account even on their Ubuntu servers. Sometimes, the `root` password
    will be randomly generated and emailed to you. However, you should still create
    a user for yourself with administrative access regardless.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Instead of using `root` outright, Ubuntu (as well as its server version) recommends
    the use of `sudo`. Specifically, `sudo` enables you to run individual commands
    with elevated privileges instead of being logged in as `root` all the time.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Using sudo to run privileged commands
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I’ll go over how to manage `sudo` later on in this chapter, but for now, just
    keep in mind that the purpose of `sudo` is to enable you to use your user account
    to do things that normally only `root` would be able to do. For example, as a
    normal user, you cannot issue a command such as the following to install a software
    package (don’t worry about the `apt` command for now, as we’ll cover that in *Chapter
    3*, *Managing Software Packages*):'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Instead, you’ll receive an error:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'But if you prefix the command with `sudo` (assuming your user account has access
    to it), the command will work just fine:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When you use `sudo`, you’ll be asked for your user’s password for confirmation,
    and then the command will execute. Subsequent commands prefixed with `sudo` may
    not prompt for your password, as it will cache your password for a short period
    of time until it times out or the terminal is closed. Understanding this should
    clarify the usefulness of the user account you created during installation. I
    referred to this user as an administrative account earlier, but it’s really just
    a user account that is able to utilize `sudo`. Ubuntu Server automatically gives
    the first user account you create during installation access to `sudo`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: The intent is that you’ll use that account to administer the system, rather
    than `root`. When you create additional user accounts, they will not have access
    to `sudo` by default, unless you explicitly grant it to them.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Creating and removing users
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating users in Ubuntu can be done with one of two commands: `adduser` and
    `useradd`. This can be a little confusing at first, because both of these commands
    do the same thing (in different ways) and are named very similarly. I’ll go over
    the `useradd` command first and then I’ll explain how `adduser` differs. You may
    even prefer the latter, but we’ll get to that in a moment.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Using useradd
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, here’s an example of the `useradd` command in action:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With this command, I created a user named `jdoe`. With the `-d` option, I’m
    clarifying that I would like a home directory created for this user, and following
    that, I called out `/home/jdoe` as the user’s home directory. The `-m` flag tells
    the system that I would like the home directory to be created during the process;
    otherwise, I would’ve had to create the directory myself. Finally, I called out
    the username for my new user (in this case, `jdoe`).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: As we go along in this book, there will be commands that require `root` privileges
    in order to execute. The preceding command was an example of this. For commands
    that require such permissions, I’ll prefix the commands with `sudo`. When you
    see these, it just means that `root` privileges are required to run the command.
    For these, you can also log in as `root` (if `root` is enabled) or switch to `root`
    to execute these commands as well. However, as I mentioned before, using `sudo`
    instead of using the `root` account is strongly encouraged.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, list the storage of `/home` using the following command:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You should see a folder listed there for our new user:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18425_02_01.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: Listing the contents of /home after our first user was created'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'What about creating our user’s password? We may have been asked for our current
    user’s password due to using `sudo`, but we weren’t asked for a password for the
    new user. To create a password for the user, we can use the `passwd` command.
    The `passwd` command defaults to allowing you to change the password for the user
    you’re currently logged in as, but it also allows you to set a password for any
    other user if you run it as `root` or with `sudo`. If you enter `passwd` by itself,
    the command will first ask you for your current password, then your new password,
    and then it will ask you to confirm your new password again. If you prefix the
    command with `sudo` and then specify a different user account, you can set the
    password for any user you wish. An example of the output of this process is as
    follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18425_02_02.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: Changing the password of a user'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the previous screenshot, you won’t see any asterisks or any
    kind of output when you type a password using the `passwd` command. This is normal.
    Although you won’t see any visual indication of input, your input is being recognized.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Now we have a new user and we were able to set a password for that user. The
    `jdoe` user will now be able to access the system with the password we’ve chosen.
    This user won’t have access to `sudo` by default, but we’ll cover how to change
    this later on in the chapter.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Using adduser
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Earlier, I mentioned the `adduser` command as another way of creating a user.
    The difference (and convenience) of this command should become apparent immediately
    once you’ve used it. Go ahead and give it a try; execute `adduser` along with
    a username for a user you wish to create. An example run of this process is as
    follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18425_02_03.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.3: Creating a user with the adduser command'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding process, I executed `sudo adduser dscully` (commands that
    modify users require `sudo` or `root`) and then I was asked a series of questions
    regarding how I wanted the user to be created. I was asked for the password (twice),
    `Full Name`, `Room Number`, `Work Phone`, and `Home Phone`. In the `Other` field,
    I entered the comment `Trust no one`, which is a great mindset to adopt while
    managing users. The latter prompts prior to the final confirmation were all optional:
    I didn’t have to enter `Full Name`, `Room Number`, and so on. I could’ve pressed
    *Enter* to skip those prompts if I wanted to. The only things that are really
    required are the username and the password.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: From the output, we can see that the `adduser` command performed quite a bit
    of work for us. The command defaulted to using `/home/dscully` as the home directory
    for the user, the account was given the next available **User ID** (**UID**) and
    **Group ID** (**GID**) of `1002`, and it also copied files from `/etc/skel` into
    our new user’s `home` directory. In fact, both the `adduser` and `useradd` commands
    copy files from `/etc/skel`, but `adduser` is more verbose regarding the actions
    it performs.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Don’t worry if you don’t understand what `UID`, `GID`, and `/etc/skel` are yet.
    We’ll work through those concepts soon.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: In a nutshell, the `adduser` command is much more convenient in the sense that
    it prompts you for various options while it creates the user without requiring
    that you memorize command-line options. It also gives you detailed information
    about what it has done. At this point, you may be wondering why someone would
    want to use `useradd` at all, considering how much more convenient `adduser` seems
    to be. Unfortunately, `adduser` is not available on all distributions of Linux.
    It’s best to familiarize yourself with `useradd` in case you find yourself on
    a Linux system that’s not Ubuntu.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'It may be interesting for you to see what exactly the `adduser` command is.
    It’s not even a binary program—it’s a **shell script**. A shell script is simply
    a text file that can be executed as a program. You don’t have to worry too much
    about scripting now, as we will cover it in *Chapter 6*, *Boosting Your Command-line
    Efficiency*. In the case of `adduser`, it’s a script written in **Perl**, which
    is a programming language that is sometimes used for administrative tasks. Since
    it’s not binary, you can even open it in a text editor in order to view all the
    code that it executes behind the scenes. However, make sure you don’t open the
    file in a text editor with `root` privileges, to ensure that you don’t accidentally
    save changes to the file and break the script. The following command will open
    `adduser` in a text editor on an Ubuntu Server system:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Use your up/down arrows as well as the *Page Up* and *Page Down* keys to scroll
    through the file. When you’re finished, press *Ctrl* + *x* on your keyboard to
    exit the text editor. If the editor prompts you to save changes, don’t do so.
    Anyway, those of you with keen eyes will likely notice that the `adduser` script
    is calling `useradd` to perform its actual work. So either way, you’re either
    directly or indirectly using `useradd`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to create users, it will be useful to understand how to
    remove them as well.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Removing users
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Removing or disabling an account is very important when a user no longer needs
    to access a system, as unmanaged accounts often become a security risk. To remove
    a user account, we’ll use the `userdel` command.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Before removing an account, though, there is one very important question you
    should ask yourself. Will you (or another person) need access to the user’s files?
    Most companies have retention policies in place that detail what should happen
    to a user’s data when they leave the organization. Sometimes, these files are
    copied into an archive for long-term storage. Often, a manager, coworker, or new
    hire will need access to the former user’s files, perhaps to continue working
    on a project where they left off. It’s important to understand this policy ahead
    of managing users. If you don’t have a policy in place that outlines retention
    requirements for files when users resign, you should probably work with your management
    team and create one.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在删除账户之前，你应该问自己一个非常重要的问题：你（或其他人）是否需要访问该用户的文件？大多数公司都有文件保留政策，详细说明了当员工离职时应该如何处理用户的数据。有时，这些文件会被复制到存档中进行长期存储。通常，经理、同事或新员工可能需要访问前用户的文件，或许是为了继续完成某个项目。理解这一政策对管理用户非常重要。如果你没有明确规定离职用户文件的保留要求，最好与管理团队合作制定一项政策。
- en: 'By default, the `userdel` command does not remove the contents of the user’s
    `home` directory. Here, we use the following command to remove `dscully` from
    the system:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`userdel`命令不会删除用户的`home`目录的内容。在这里，我们使用以下命令将`dscully`从系统中删除：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can see that the files for the `dscully` user still exist by entering the
    following command:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过输入以下命令来查看`dscully`用户的文件是否仍然存在：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding commands will result in the following outputs:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将会产生以下输出：
- en: '![](img/B18425_02_04.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18425_02_04.png)'
- en: 'Figure 2.4: The home directory for the user dscully still exists, even though
    we removed the user'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4：尽管我们已经删除了用户，但`dscully`的主目录仍然存在。
- en: 'With the `/home` directory for `dscully` still existing, we’re able to move
    the contents of this directory anywhere we would like to. If we had a directory
    called `/store/file_archive`, for example, we could easily move the files there:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`dscully`的`/home`目录仍然存在，我们可以将该目录的内容移动到任何我们想要的地方。例如，如果我们有一个名为`/store/file_archive`的目录，我们可以轻松地将文件移动到那里：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Of course, it’s up to you to create the directory where your long-term storage
    will ultimately be, but you get the idea.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，最终存储的目录由你决定，但你明白我的意思。
- en: 'If you weren’t already aware, you can create a new directory with the `mkdir`
    command. You can create a directory within any other directory that your logged-in
    user has access to. The following command will create the `file_archive` directory
    I mentioned in the preceding example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还不知道，你可以使用`mkdir`命令来创建一个新目录。你可以在任何你的登录用户有权限访问的目录中创建一个目录。以下命令将创建我在前面示例中提到的`file_archive`目录：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `-p` flag simply creates the parent directory if it didn’t already exist.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`-p`标志只是会在父目录不存在时创建父目录。'
- en: 'If you do actually want to remove a user’s home directory at the same time
    that you remove an account, just add the `-r` option. This will eliminate the
    user and their data in one shot:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确实希望在删除账户时同时删除用户的主目录，只需添加`-r`选项。这样可以一并删除该用户及其数据：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To remove the `/home` directory for the user after the account was already
    removed (if you didn’t use the `-r` parameter the first time), use the `rm -r`
    command to get rid of it, as you would any other directory:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在账户删除后仍需要删除`/home`目录（如果你第一次没有使用`-r`参数），可以使用`rm -r`命令像删除任何其他目录一样删除它：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'It probably goes without saying, but the `rm` command can be extremely dangerous.
    If you’re logged in as `root` or using `sudo` while using `rm`, you can easily
    destroy your entire installed system if you’re not careful. *DO NOT run this command*,
    but as a hypothetical example, the following command (while seemingly innocent
    at first glance) will likely completely destroy your entire filesystem:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 可能不言而喻，但`rm`命令可能非常危险。如果你以`root`身份登录或在使用`rm`时使用了`sudo`，如果不小心，可能会轻易摧毁你整个已安装的系统。*不要运行此命令*，但作为一个假设性的示例，以下命令（乍一看似乎无害）很可能会完全摧毁你整个文件系统：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Notice the typo: I accidentally typed a space after the first forward slash.
    I literally accidentally told my system to remove the contents of the entire filesystem.
    If that command were executed, the server probably wouldn’t even boot the next
    time we attempted to start it. All user and program data would be wiped out. If
    there was ever any single reason for us to be protective over the `root` account,
    the `rm` command is most certainly it!'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we understand how to add and remove users. In the next section,
    we’ll look deeper into passwords.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the /etc/passwd and /etc/shadow files
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we know how to create (and delete) user accounts on our server, we
    are well on our way to being able to manage our users. But where exactly is this
    information stored? We know that users store their personal files in `/home`,
    but is there some kind of database somewhere that keeps track of which user accounts
    are on our system? Actually, user account information is stored in two special
    text files:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '`/etc/passwd`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/etc/shadow`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can display the contents of each of those two files with the following
    commands. Note that any user can look at the contents of `/etc/passwd`, while
    only `root` has access to `/etc/shadow`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Go ahead and take a look at these two files (just don’t make any changes), and
    I will help you understand them.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the /etc/passwd file
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let’s go over the `/etc/passwd` file. What follows is some example output
    from this file on my test server. For brevity, I have limited the output to the
    last eight lines:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18425_02_05.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.5: Example /etc/passwd file'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Each line within this file corresponds to a user account on the system. Entries
    are split into columns, separated by a colon (`:`). The username is in the first
    column, so you can see that I’ve created users `jay` and `jdoe`. The next column
    on each is simply an `x`. I’ll go over what that means a bit later. For now, let’s
    skip to the third and fourth columns, which reference the UID and GID respectively.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: On a Linux system, user accounts and groups are actually referenced by their
    IDs. While it’s easier for you and I to manage users by their names, usernames
    and group names are nothing more than a label placed on the UID and GID in order
    to help us identify them more easily.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: For example, it may be frustrating to try to remember that `jdoe` is UID `1001`
    on our server each time we want to manage this account. Managing it by referring
    to the account as `jdoe` is easier for humans, since we don’t remember numbers
    as well as we do names. But to Linux, each time we reference user `jdoe`, we’re
    actually just referencing UID `1001`. When a user is created, the system (by default)
    automatically assigns the next available UID to the account. If you manage multiple
    Ubuntu servers, note that the UIDs will not match from one system to another,
    so keep in mind that UIDs don’t synchronize between installations.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: In my case (as shown in *Figure 2.5*), the UID of each user is the same as their
    GID. This is just a coincidence on my system and it isn’t always that way in practice.
    While I’ll discuss creating groups later in this chapter, understand that creating
    groups works in a similar way to creating users, in the sense that the group is
    assigned the next available GID in much the same way as new user accounts are
    assigned the next available UID. When you create a user, the user’s primary group
    is the same as their username (unless you request otherwise). For example, when
    I created `jdoe`, the system also automatically created a `jdoe` group as well.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: This is what you’re actually seeing here—the UID for the user, as well as the
    GID for the user’s primary group. Again, we’ll get to groups in more detail later.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: You probably also noticed that the `/etc/passwd` file on your system contains
    entries for many more users than the ones we’ve created ourselves. This is perfectly
    normal, as Linux uses user accounts for various processes and services that run
    in the background. You’ll likely never interact with the default accounts at all,
    though you may someday create your own system user for a process to run as. For
    example, perhaps you’ll create a data processor account for an automated data-processing
    script to run under.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Anyway, back to our `/etc/passwd` file. The fifth column is designated for user
    info, most commonly the user’s first and last names. In my example, the fifth
    field is blank for `jdoe`, as I created `jdoe` with the `useradd` command, which
    didn’t prompt me for the first and last names. This field is also nicknamed the
    `GECOS` field, and you may see it referred to as such when you read the documentation.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: In the sixth column, the home directory for each user is shown. In the case
    of `jdoe`, it’s set as `/home/jdoe`. Finally, we designate the user’s shell as
    `/bin/bash`. This field refers to the default shell the user will use, which defaults
    to `/bin/bash` when an account is created with the `adduser` command, and `/bin/sh`
    when created with the `useradd` command. (If you have no preference, `/bin/bash`
    is the best choice for most.) If we want the user to use a different shell, we
    can clarify that here (though shells other than `/bin/bash` aren’t covered in
    this book). If we wanted, we could change the user’s shell to something invalid
    to prevent them from logging in at all. This is useful for when a security issue
    requires us to disable an account quickly.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the /etc/shadow file
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With that out of the way, let’s take a look at the `/etc/shadow` file. We can
    use `cat` to display the contents like any other text file, but unlike `/etc/passwd`,
    we need `root` privileges in order to view it. So, go ahead and display the contents
    of this file, and I’ll walk you through it:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This will display the following output:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18425_02_06.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.6: Example /etc/shadow file'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot, *Figure 2.6*, shows the last four lines of this file
    on my server. First, we have the username in the first column—no surprises there.
    Note that the output is not showing the UID for each user in this file. The system
    knows which username matches which UID based on the `/etc/passwd` file, so there’s
    no need to repeat that here. In the second column, we have what appears to be
    gobbledygook. Actually, that’s the most important part of this entire file. That’s
    the actual hash for the user’s password.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: A password hash is a conversion of the actual password to a different string
    that represents the original password. This is a one-way conversion, so you cannot
    find the actual password by reverse-engineering the hash. In the `/etc/passwd`
    file, the hash of the password is stored rather than the actual password, for
    security purposes.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: If you recall, in the `/etc/passwd` file, each user listing had an `x` for the
    second column, and I mentioned I would explain that later. What the `x` refers
    to is the fact that the user’s password is encrypted and simply not stored in
    `/etc/passwd` and is instead stored in `/etc/shadow`. After all, the `/etc/passwd`
    file is viewable by everyone, so it would compromise security quite a bit if anyone
    could just open up the file and see what everyone’s passwords were.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: In the days of old, you could actually store a user’s password in `/etc/passwd`,
    but it’s never done that way anymore. Whenever you create a user account on a
    modern Linux system, the user’s password is encrypted (an `x` is placed in the
    second column of `/etc/passwd` for the user), and the actual password hash is
    stored in the second column of `/etc/shadow` to keep it away from prying eyes.
    Hopefully, now the relationship between these two files has become apparent.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember earlier I mentioned that the `root` user account is locked out by
    default? Well, let’s actually see that in action. Execute the following command
    to see the `root` user account entry in `/etc/shadow`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'On my system, I get the following output:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18425_02_07.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.7: Example /etc/shadow file'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: You should notice right away that the `root` user account doesn’t have a password
    hash at all. Instead, there’s an asterisk where the password hash would’ve been.
    In practice, placing an asterisk or exclamation point here is one way to lock
    an account. Even easier, you can use the `passwd -l` command against an account
    to lock it without having to edit a file. But either way, we can still switch
    to the `root` account anytime (which I’ll show you how to do later on in this
    chapter). Entering an asterisk or exclamation mark in the second field creates
    the restriction that we can’t directly log in as that user from the shell or over
    the network. We have to log in to the system as a normal user account first, and
    then we can still switch to that user if we want to.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'With the discussion of password hashes out of the way, there are a few more
    fields within `/etc/shadow` entries that we should probably understand. Here’s
    a contrived example line:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Continuing on with the third column, we can see the number of days since the
    **Unix epoch** that the password was last changed. For those that don’t know,
    the Unix epoch is January 1, 1970\. Therefore, we can read that column as the
    password having last been changed 16,809 days after the Unix epoch.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'Personally, I like to use the following command to show more easily when the
    password was last changed:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This will result in an output that looks something like the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18425_02_08.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.8: Checking the date of the last password change for a user'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: By executing this command, you can view information about any account on your
    system. The first column is obviously the username. The second has to do with
    the status of the password, which in this case is `L`, which refers to the fact
    that the user has a password that is locked. It would show `P` if the password
    was set and usable, or `NP` if the user didn’t have a password at all.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: The third column of this command’s output gives you the actual date of the last
    password change for the user. The fourth column tells us how many days are required
    to pass before the user will be able to change their password again. In this example,
    `jdoe` can change the password any time because the minimum number of days is
    set to `0`. We’ll talk about how to set the minimum number of days later on in
    this chapter, but I’ll give you a brief explanation of what this refers to. At
    first, it may seem silly to require a user to wait a certain number of days to
    be able to change their password. However, never underestimate the ability of
    your users to be oppositional. It’s quite common for a user, when required to
    change their password, to change their password to satisfy history requirements,
    only to then just change it back to what it was originally. By setting a minimum
    number of days, you’re forcing a waiting period in between password changes, making
    it less convenient for your users to cycle back through to their original password.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: The fifth column, as you can probably guess, is the maximum number of days that
    can pass between password changes. If you require your users to change their passwords
    every certain number of days, you’ll see that in this column. By default, this
    is set to `99999` days. That number of days is way beyond the human lifespan,
    so it may as well be infinite.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Continuing with the sixth column, we have the number of days that will elapse
    before the expiration date on which the user is warned that they will soon be
    required to change their password. In the seventh column, we set how many days
    can pass after the password expires, in which case the account will be disabled.
    With our example user, this is not set. Finally, with the eighth column (which
    is not visible), we can see the number of days since the Unix epoch that will
    elapse before the account is disabled (in our case, there’s nothing here, so there
    is no disabled day set).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: We’ll go over setting these fields later, but for now, hopefully you understand
    the contents of the `/etc/shadow` file better.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'If at any time you’d like additional clarification, feel free to check out
    the Ubuntu man pages. A man page (short for manual page) can give you quite a
    bit more information about commands as well as files. For example, the following
    command shows you the man page for the `ls` command:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'More specific to this section, you can retrieve man pages for the `/etc/shadow`
    files as well:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Press *q* on your keyboard to exit out of a man page. Feel free to check out
    the man pages for any command in this book to learn more as you go along.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Now that we fully understand how to manage our users, we can also look at how
    to provide them with default files in their home directory.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Distributing default configuration files with /etc/skel
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a typical organization, there are usually some defaults that are recommended
    for users in terms of files and configuration.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: For example, in a company that performs software development, there are likely
    recommended settings for text editors and version control systems. Files that
    are contained within `/etc/skel` are copied into the home directory for all new
    users when you create them (assuming you’ve chosen to create a home directory
    while setting up the user).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, you can see this for yourself right now. Execute the following command:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, you should be able to view the contents of the `/etc/skel` directory:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18425_02_09.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.9: Default /etc/skel files'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: You probably already know how to list files within a directory, but I added
    the `-a` option because I wanted to view hidden files as well. The files included
    in `/etc/skel` by default are hidden (their filenames begin with a period). I
    threw in the `-l` parameter solely because it shows a long list, which I think
    is easier to read.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Each time you create a new user and request a home directory to be created as
    well, these three files, shown in *Figure 2.9*, will be copied into their home
    directory, along with any other files you create here. You can verify this by
    listing the storage of the home directories for the users you’ve created so far.
    The `.bashrc` file in one user’s home directory should be the same as any other,
    unless they’ve made changes to it.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Armed with this knowledge, it should be extremely easy to create default files
    for new users that you create. For example, you could create a file named `welcome`
    with your favorite text editor and place it in `/etc/skel`. Perhaps you may create
    this file to contain helpful phone numbers and information for new hires in your
    company. The file would then be automatically copied to the new user’s home directory
    when you create the account. The user, after logging in, would see this file in
    their home directory and see the information. More practically, if your company
    has specific editor settings that are favored for writing code, you can include
    those files in `/etc/skel` as well to help ensure your users are compliant. In
    fact, you can include default configuration files for any application your company
    uses.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and give it a try. Feel free to create some random text files and then
    create a new user afterward, and you’ll see that these files will propagate into
    the home directories of the new user accounts that you add to your system.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have multiple users and have also seen how to manage their default
    files, we can take a look at how to switch from one user to another.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Switching users
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have several users on our system, we need to know how to switch
    between them. Of course, you can always just log in to the server as one of the
    users, but you can actually switch to any user account at any time, provided you
    either know that user’s password or have `sudo` access.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: The command you will use to switch from one user to another is the `su` command.
    If you enter `su` with no options, it will assume that you want to switch to `root`
    and will ask you for the `root` password. As I mentioned earlier, Ubuntu locks
    the `root` account by default, so at this point you may not have a `root` password.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Even though Ubuntu doesn’t create a password for `root` by default, some **Virtual
    Private Server** (**VPS**) providers unlock the `root` password and actually have
    you log in as the `root` user. Having an unlocked `root` account is not a standard
    Ubuntu practice, and is a customization specific to some cloud providers.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlocking the `root` account is actually really simple; all you have to do
    is create a `root` password. To do that, you can execute the following command
    as any user with `sudo` access:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The command will ask you to create and confirm your `root` password. From this
    point on, you will be able to use the `root` account as any other account. You
    can log in as `root` or switch to `root`—it’s fully available now. However, you
    really don’t have to unlock the `root` account in order to use it. You certainly
    can, but there are ways to switch to `root` without unlocking it, and it’s typically
    better to leave the `root` account locked unless you have a very specific reason
    to unlock it. The following command will allow you to switch to `root` from a
    user account that has `sudo` access:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now you’ll be logged in as `root` and will be able to execute any command you
    want with no restrictions whatsoever. To return to your previously logged-in account,
    simply type `exit`. You can tell which user you’re logged in as by the value at
    the beginning of your `bash` prompt.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'What if you want to switch to an account other than `root`? Of course, you
    can simply log out and then log in as that user. But you really don’t have to
    do that. The following command will do the job, providing you know the password
    for the account:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The shell will ask for that user’s password and then you’ll be logged in as
    that user. Again, type `exit` when you’re done using the account, which will return
    you to the one you were using before you switched.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: That command is all well and good if you know the user’s password, but you often
    won’t. Typically, in an enterprise, you’ll create an account, force the user to
    change their password at first login, and then you will no longer know that user’s
    password.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'Since you have `root` and `sudo` access, you could always change their password
    and then log in as them. But they’ll know something is amiss if their password
    suddenly stops working—you’re not eavesdropping, are you? Armed with `sudo` access,
    you can use `sudo` to change to any user you want to, even if you don’t know their
    password. Just prefix our previous command with `sudo` and you’ll only need to
    enter the password for your user account, instead of theirs:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Switching to another user account is often very helpful for support (especially
    while troubleshooting permissions). As an example, say that a user comes to you
    complaining that they cannot access the contents of a specific directory, or they
    are unable to run a command. In that case, you can log in to the server, switch
    to their user account, and try to reproduce their problem. That way, you can not
    only see their problem yourself, but you can also test out whether or not your
    fix has solved their issue before you report back to them.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Now we have a full understanding of user accounts, and even how to switch between
    them. In the next section, we’ll look into groups, which allow us to categorize
    our users.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Managing groups
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we understand how to create, manage, and switch between user accounts,
    we’ll need to understand how to manage **groups** as well. The concept of groups
    in Linux is not very different from other platforms and pretty much serves the
    exact same purpose. With groups, you can more efficiently control a user’s access
    to resources on your server. By assigning a group to a resource (a file, a directory,
    and so on), you can allow and disallow access to users by simply adding them or
    removing them from the group.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'The way this works in Linux is that every file or directory has both a user
    and a group that takes ownership of it. This is contrary to platforms such as
    Windows, which can have multiple groups assigned to a single resource. With Linux,
    it’s just one-to-one ownership: just one user and just one group assigned to each
    file or directory. If you list the contents of a directory on a Linux system,
    you can see this for yourself:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The following is a sample line of output from a directory on one of my servers:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this case, we can see that `root` owns the file and that the group `bind`
    is also assigned to it. Ignore the other fields for now; I’ll explain them later
    when we get to the section of this chapter dedicated to permissions. For now,
    just keep in mind that one user and one group are assigned to each file or directory.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: While each file or directory can only have one group assignment, any user account
    can be a member of any number of groups. Entering the `groups` command by itself
    with no options will tell you what groups your logged-in user is currently a member
    of. If you add a username to the `groups` command, you’ll see which groups that
    user is a member of. Go ahead and give the `groups` command a try with and without
    providing a username to get the idea.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: On the Ubuntu Server platform, you’ll likely see that each of your user accounts
    is a member of a group that’s named the same as your username. As I mentioned
    earlier, when you create a user account, you’re also creating a group with the
    same name as the user. On some Linux distributions, though, a user’s primary group
    will default to a group called `users` instead. If you were to execute the `groups`
    command as a user on the Ubuntu desktop platform, you would likely see additional
    groups. This is due to the fact that distributions of Linux that cater to being
    a server platform are often more stripped down and users on desktop platforms
    need access to more objects such as printers, audio cards, and so on. Some packages
    that can be installed also add additional system users to the server.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'If you were curious as to which groups exist on your server, all you would
    need to do is `cat` the contents of the `/etc/group` file. Similar to the `/etc/passwd`
    file we covered earlier, the `/etc/group` file contains information regarding
    the groups that have been created on your system. Go ahead and take a look at
    this file on your system:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following is sample output from this file on one of my servers:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18425_02_10.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.10: Sample output from the /etc/group file'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Like before, the columns in this file are separated by colons, though each line
    is only four columns long. In the first column, we have the name of the group.
    No surprise there. In the second, we are able to store a password for the group,
    but this is not used often as it’s actually a security risk to do so. In the third
    column, we have the GID, which is similar in concept to the UID from when we were
    discussing users. Finally, in the last column, we (would) see a comma-separated
    list of each user that is a member of each of the groups.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Several entries don’t show any group memberships at all. Each user is indeed
    a member of their own group, so this is implied even though it doesn’t explicitly
    call that out in this file. If you take a look at the `/etc/passwd` entries for
    your users, you will see that their primary group (shown as the third column in
    the form of a GID) references a group contained in the `/etc/group` file.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Creating new groups on your system is easy to do and is a great idea for categorizing
    your users and what they are able to do. Perhaps you create an `accounting` group
    for your accountants, an `admins` group for those in your IT department, and a
    `sales` group for your salespeople. The `groupadd` command allows you to create
    new groups.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wanted to, you could just edit the `/etc/group` file and add a new line
    with your group information manually, although, in my opinion, using `groupadd`
    saves you some work and ensures that group entries are created properly. Editing
    group and user files directly is typically frowned upon (and a typo can cause
    serious problems). Anyway, what follows is an example of creating a new group
    with the `groupadd` command:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If you take a look at the `/etc/group` file again after adding a new group,
    you’ll see that a new line was created in the file and a `GID` was chosen for
    you (the first one that hadn’t been used yet). Removing a group is just as easy.
    Just issue the `groupdel` command followed by the name of the group you wish to
    remove:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, we’ll take a look at the `usermod` command, which will allow you to actually
    associate users with groups. The `usermod` command is more or less a Swiss Army
    knife; there are several things you can do with that command (adding a user to
    a group is just one of its abilities). If we wanted to add a user to our `admins`
    group, we would issue the following command:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In that example, we’re supplying the `-a` option, which means append, and immediately
    following that, we’re using `-G`, which means we would like to modify secondary
    group membership. I put the two options together with a single dash (`-aG`), but
    you could also issue them separately (`-a -G`). The example I gave only adds the
    user to additional groups; it doesn’t replace their primary group.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Be careful not to miss the `-a` option here, as by doing so, you will instead
    replace all current group memberships with the new one, which is usually not what
    you want. The `-a` option means append, or to add the existing list of group memberships
    for that user.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wanted to change a user’s primary group, you would use the `-g` option
    instead (lowercase *g* instead of an uppercase *G* as we used earlier):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Feel free to check out the man pages for the `usermod` command, to see all
    the nifty things it allows you to manage relating to your users. You can peruse
    the man page for the `usermod` command with the following command:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'One additional example is changing a user’s `/home` directory. Suppose that
    one of your users has undergone a name change, so you’d like to change their username,
    as well as moving their previous `home` directory (and their files) to a new one.
    The following commands will take care of that:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In that example, we’re moving the home directory for `jdoe` to `/home/jsmith`,
    and then in the second example, we’re changing the username from `jdoe` to `jsmith`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wish to remove a user from a group, you can use the `gpasswd` command
    to do so. `gpasswd -d` will do the trick:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In fact, `gpasswd` can also be used in place of `usermod` to add a user to
    a group:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: So, now you know how to manage groups. With the efficient management of groups,
    you’ll be able to manage the resources on your server better. Of course, groups
    are relatively useless without some explanation of how to manage permissions (otherwise,
    nothing would actually allow a member of a group access to a resource). Later
    on in this chapter, we’ll cover permissions so that you have a complete understanding
    of how to manage user access.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Managing passwords and password policies
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ve already covered a bit of password management, since I’ve
    given you a few examples of the `passwd` command. If you recall, the `passwd`
    command allows us to change the password of the currently logged-in user. In addition,
    using `passwd` as `root` (and supplying a username) allows us to change the password
    for any user account on our system. But that’s not all this command can do.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Locking and unlocking user accounts
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One thing I’ve neglected to mention regarding the `passwd` command is the fact
    that you can use it to lock and unlock a user’s account. There are many reasons
    why you may want to do this. For instance, if a user is going on vacation or extended
    leave, perhaps you’d want to lock their account so that it cannot be used while
    they are away. After all, the fewer active accounts, the smaller your attack surface.
    To lock an account, use the `-l` option:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'And to unlock it, use the `-u` option:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: However, locking an account will not prevent the user from logging in if they
    have access to the server via SSH while utilizing public key authentication. In
    that case, you’d want to remove their ability to use SSH as well. One common way
    of doing this is to limit SSH access to users who are members of a specific group.
    When you lock an account, simply remove them from the group. Don’t worry so much
    about the SSH portion of this discussion if this is new to you. We will discuss
    securing your SSH server in *Chapter 21*, *Securing Your Server*. For now, just
    keep in mind that you can use `passwd` to lock or unlock accounts, and if you
    utilize SSH, you’ll want to lock your users out of that to prevent them from logging
    in.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: However, there’s more to password management than the `passwd` command, as we
    can also implement our own policies, such as viewing or adjusting password expiration
    details.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Setting password expiration information
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Earlier, I mentioned that you can set an expiration date on a user’s password
    (during our discussion on the `/etc/shadow` file). In this section, we’ll go through
    how to actually do that. Specifically, the `chage` command gives us this ability.
    We can use `chage` to alter the expiration period of a user’s password, but it’s
    also a more convenient way of viewing current expiration information than viewing
    the `/etc/shadow` file. With the `-l` option of `chage`, along with providing
    a username, we can see the relevant info:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Using `sudo` or `root` is not required to run `chage`. You’re able to view expiration
    information for your own username without needing to escalate permissions. However,
    if you want to view information via `chage` for any user account other than your
    own, you will need to use `sudo`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'In the example that follows, we can see the output of this command from a sample
    user account:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18425_02_11.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.11: Output from the chage command'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: In the output, we can see values for the date of expiration, the maximum number
    of days between password changes, and so on. Basically, it’s the same information
    stored in `/etc/shadow` but it’s much easier to read.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: If you would like to change this information, `chage` will again be the tool
    of choice. The first example I’ll provide is a very common one. When creating
    user accounts, you’ll certainly want them to change their password when they first
    log in.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, not everyone will be keen on doing so. The `chage` command allows
    you to force a password change for a user when they first log in. Basically, you
    can set their number of days to expiry to `0` as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You can see the results of this command immediately if you run `chage -l` again
    against the user account you just modified:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The output will display information regarding the password change:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18425_02_12.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.12: The chage command listing a user that has a required password
    change period set'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'To set a user account to require a password change after a certain period of
    days, the following will do the trick:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In that example, I’m setting the user account to expire and require a password
    change in 90 days. When the impending date reaches 7 days before the password
    is to be changed, the user will see a warning message when they log in.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'As I mentioned earlier, users will often do whatever they can to cheat password
    requirements and may try to change their password back to what it was originally
    after satisfying the initially required password change. You can set the minimum
    number of days with the `-m` flag, as you can see in the next example where we
    set it to 5 days:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The trick with setting a minimum password age is to set it so that it will be
    inconvenient for the user to change their password to the original one, but you
    still want a user to be able to change their password when they feel the need
    to (so don’t set it too long, either). If a user wants to change their password
    before the minimum number of days elapses (for example, if your user feels that
    their account may have been compromised), they can always have you change it for
    them. However, if you make your password requirements too much of an inconvenience
    for your users, it can also work against you.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Setting a password policy
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we should discuss setting a password policy. After all, forcing your users
    to change their passwords does little good if they change it to something simple,
    such as `abc123`. A password policy allows you to force requirements on your users
    for things such as length, complexity, and so on.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: To facilitate this, we have **Pluggable Authentication Module** (**PAM**) at
    our disposal. PAM gives us additional functionality and control over the process
    of authentication, and also provides additional plugins we can use to extend authentication
    and add additional features. Although a full walkthrough of PAM isn’t covered
    in this book, I recommend keeping it fresh in your mind in case you want to add
    additional features later.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'Specific to the subject of setting up a password policy, we can install a PAM
    module to enable this, which involves installing a new package:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Next, let’s take a look at the following file, which is provided with Ubuntu.
    Feel free to open it with a text editor, such as `nano`, as we’ll need to edit
    it:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: An extremely important tip while modifying configuration files related to authentication
    (such as password requirements, `sudo` access, SSH, and so on) is to always keep
    a `root` shell open at all times while you make changes, and in another shell,
    test those changes. Do not log out of your initial `root` window until you are
    100% certain that your changes have been thoroughly tested. While testing a policy,
    make sure that not only can your users log in, but your admins too. Otherwise,
    you may remove your ability to log in to a server and make changes.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable a history requirement for your passwords (meaning the system remembers
    the last several passwords a user has used, preventing them from reusing them),
    we can add the following line to the file:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In the example `config` line, I’m using `remember=99`, which (as you can probably
    guess) will cause our system to remember the last 99 passwords for each user and
    prevent them from using those passwords again. If you’ve configured a minimum
    password age earlier, for example, 5 days, it would take the user 495 days to
    cycle back to their original password if you take into account that the user changes
    their password once every 5 days, 99 times. That pretty much makes it impossible
    for the user to utilize their old passwords.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Another field worth mentioning within the `/etc/pam.d/common-password` file
    is the section that reads `difok=3`. This configuration mandates that at least
    three characters have to be different before the password is considered acceptable.
    Otherwise, the password would be deemed too similar to the old one and refused.
    You can change this value to whatever you like; the default is normally `5` but
    Ubuntu defaults it to `3` in their implementation of this config file. In addition,
    you’ll also see `obscure` mentioned in the file as well, which prevents simple
    passwords from being used (such as common dictionary words and so on).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Setting a password policy is a great practice to increase the security of your
    server. However, it’s also important to not get carried away. In order to strike
    a balance between security and user frustration, the challenge is always to create
    enough restrictions to increase your security, while trying to minimize the frustration
    of your users. Of course, the mere mention of the word “password” to a typical
    user is enough to frustrate them, so you can’t please everyone. But in terms of
    overall system security, I’m sure your users will appreciate the fact that they
    can be reasonably sure that you as an administrator have taken the necessary precautions
    to keep their (and your company’s) data safe. When it comes down to it, use your
    best judgment.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Since we’re on the subject of security, we should also take a look at configuring
    `sudo` itself, which we’ll take care of in the next section.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Configuring administrator access with sudo
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, we’ve already used `sudo` quite a few times in this book. At this point,
    you should already be aware of the fact that `sudo` allows you to execute commands
    as if you were logged in as another user, with `root` being the default. However,
    we haven’t had any formal discussion about it yet, nor have we discussed how to
    actually modify which of your user accounts are able to utilize `sudo`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: On all Linux systems, you should protect your `root` account with a strong password
    and limit it to being used by as few people as possible. On Ubuntu, the `root`
    account is locked anyway, so unless you unlocked it by setting a password (or
    you’re using a version of Ubuntu supplied by a VPS provider), it cannot be used
    to log in to the system. Using `sudo` is an alternative to logging in as `root`
    to execute commands directly, so you can give your administrators access to perform
    tasks that require `root` privileges with `sudo` without actually giving them
    your `root` password or unlocking the `root` account. In fact, `sudo` allows you
    to be a bit more granular. Using `root` directly is basically all or nothing—if
    someone knows the `root` password and the `root` account is enabled, that person
    is not limited and can do whatever they want. With `sudo`, that can also be true,
    but you can actually restrict some users to use only particular commands and therefore
    limit the scope of what they are able to do on the system. For example, you could
    give an admin access to install software updates but not allow them to reboot
    the server.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, members of the `sudo` group are able to use `sudo` without any
    restrictions. Basically, members of this group can do anything `root` can do (which
    is everything). During installation, the user account you created was made a member
    of `sudo`. To give additional users access to `sudo`, all you would need to do
    is add them to the `sudo` group:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Not all distributions utilize the `sudo` group by default, or even automatically
    install `sudo`. Other distributions require you to install `sudo` manually and
    may use another group (such as `wheel`) to govern access to `sudo`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: But again, that gives those users access to everything, and that may or may
    not be what you want. To actually configure `sudo`, we use the `visudo` command.
    This command assists you with editing `/etc/sudoers`, which is the configuration
    file that governs `sudo` access. Although you can edit `/etc/sudoers` yourself
    with a text editor, configuring `sudo` in that way is strongly discouraged. The
    `visudo` command checks to make sure your changes follow the correct syntax and
    helps prevent you from accidentally destroying the file. This is a very good approach,
    because if you did make any errors in the `/etc/sudoers` file, you may wind up
    in a situation where no one is able to gain administrative control over the server.
    And while there are ways to recover from such a mistake, it’s certainly not a
    very pleasant situation to find yourself in! So, the takeaway here is never to
    edit the `/etc/sudoers` file directly; always use `visudo` to do so.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of the type of warning the `visudo` command shows when you
    make a mistake:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18425_02_13.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.13: The visudo command showing an error'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: If you do see this error, press *e* to return to edit the file, and then correct
    the mistake.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: The way this works is when you run `visudo` from your shell, you are brought
    into a text editor with the `/etc/sudoers` file opened up. You can then make changes
    to the file and save it like you would any other text file. By default, Ubuntu
    opens up the `nano` text editor when you use `visudo`. With `nano`, you can save
    changes using *Ctrl* + *w*, and you can exit the text editor with *Ctrl* + *x*.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'So `visudo` allows you to make changes to who is able to access `sudo`. But
    how do you actually make these changes? Go ahead and scroll through the `/etc/sudoers`
    file that `visudo` opens and you should see a line similar to the following:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This is the line of configuration that enables `sudo` access to anyone who is
    a member of the `sudo` group. You can change the group name to any that you’d
    like, for example, perhaps you’d like to create a group called `admins` instead.
    If you do change this, make sure that you actually create that group and add yourself
    and your staff to be members of it before you edit the `/etc/sudoers` file or
    log off; it would be rather embarrassing if you found yourself locked out of administrator
    access to the server.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, you don’t have to enable access by group. You can actually call
    out a username instead. With the `/etc/sudoers` file, groups are preceded by `%`,
    while users are not. As an example of this, we also have the following line in
    the file:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Here, we’re calling out a username (in this case, `root`), but the rest of the
    line is the same as the one I pointed out before. While you can certainly copy
    this line and paste it one or more times (substituting `root` for a different
    username) to grant access to others, using the group approach is really the best
    way. It’s easier to add and remove users from a group (such as the `sudo` group)
    than it is to use `visudo` each time.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: So, at this point, you’re probably wondering what the options on `/etc/sudoers`
    configuration lines actually mean. So far, both examples used `ALL=(ALL:ALL) All`.
    In order to fully understand `sudo`, understanding the other fields is extremely
    important, so let’s go through them (using the `root` line again as an example).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: The first `ALL` means that `root` is able to use `sudo` from any terminal. The
    second `ALL` means that `root` can use `sudo` to impersonate any other user. The
    third `ALL` means that `root` can impersonate any other group. Finally, the last
    `ALL` refers to what commands this user is able to use; in this case, any command
    they wish.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 'To help drive this home, I’ll give some additional examples. Here’s a hypothetical
    example:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Here, we’re allowing user `charlie` to execute the `reboot` and `shutdown`
    commands. If user `charlie` tries to do something else (such as install a package),
    they will receive an error message:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'However, if `charlie` wants to use the `reboot` or `shutdown` commands on the
    server, they will be able to do so because we explicitly called out those commands
    while setting up this user’s `sudo` access. We can limit this further by changing
    the first `ALL` to a machine name, in this case, `ubuntu`, to reference the host
    name of the server I’m using for my examples. I’ve also changed the command that
    `charlie` is allowed to run:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: It’s always a good idea to use full paths to commands when editing `sudo` permissions,
    rather than the shortened versions. For example, we used `/usr/bin/apt` here,
    instead of just `apt`. This is important, as the user could create a script named
    `apt` to do mischievous things that we normally wouldn’t allow them to do. By
    using the full path, we’re limiting the user to the binary stored at that path.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Now, `charlie` is only able to use `apt`. They can use `apt update`, `apt dist-upgrade`,
    and any other sub-command of `apt`. But if they try to reboot the server, remove
    protected files, add users, or anything else we haven’t explicitly set, they will
    be prevented from doing so.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'We have another problem, though. We’re allowing `charlie` to impersonate other
    users. This may not be completely terrible given the context of installing packages
    (impersonating another user would be useless unless that user also has access
    to install packages), but it’s bad form to allow this unless we really need to.
    In this case, we could just remove the `(ALL:ALL)` from the line altogether to
    prevent `charlie` from using the `-u` option of `sudo` to run commands as other
    users:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'On the other hand, if we actually do want `charlie` to be able to impersonate
    other users (but only specific users), we can call out the username and group
    that `charlie` is allowed to act on behalf of by setting those values:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In that example, `charlie` is able to run commands on behalf of the user `dscully`
    and the group `admins`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Of course, there is much more to `sudo` than what I’ve mentioned in this section.
    Entire books could be written about `sudo` (and have been), but 99% of what you
    will need for your daily management of this tool involves how to add access to
    users while being specific about what each user is able to do. As a best practice,
    use groups when you can (for example, you could have an `apt` group, a `reboot`
    group, and so on) and be as specific as you can regarding who is able to do what.
    This way, you’re not only able to keep the `root` account private (or even better,
    disabled), but you also have more accountability on your servers.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve explored granting access to `sudo`, we will next take a look
    at permissions, which give us even more control over what our users are able to
    access.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Setting permissions on files and directories
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, all the user management we’ve done in this chapter so far all
    comes together. We’ve learned how to add accounts, manage accounts, and secure
    them, but we haven’t actually done any work regarding managing the resources as
    far as who is able to access them. In this section, I’ll give you a brief overview
    of how permissions work in Ubuntu Server and then I’ll provide some examples for
    customizing them.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Viewing permissions
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I’m sure by now that you understand how to list the contents of a directory
    with the `ls` command. When it comes to viewing permissions, the `-l` flag is
    especially handy, as the output that the long listing provides allows us to view
    the permissions of an object:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The following are some example, hypothetical file listings:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In each line, we see several fields of information. The first column is our
    permission string for the object (for example, `-rw-r—r--`), which we’ll cover
    in more detail shortly. We also see the link count for the object (second column).
    Links are beyond the scope of this chapter but will be discussed in *Chapter 5*,
    *Managing Files and Directories*. Continuing on, the user that owns the file is
    displayed in the third column, the group that owns the file is in the fourth column,
    the size in bytes is in the fifth, the last date the file was modified is in the
    sixth, and finally there is the name of the file.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that depending on how your shell is configured, your output may
    look different and the fields may be in different places. For the sake of our
    discussion on permissions, what we’re really concerned with is the permissions
    string, as well as the owning user and group. In this case, we can see that the
    first file (named `welcome`) is owned by a user named `doctor`. The second file
    is named `profile` and is owned by `root`. Finally, we have a file named `exterminate`
    owned by a user named `dalek`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'With these files, we have the permission strings of `-rw-rw-rw-`, `-rw-r--r--`,
    and `-rwxr-xr-x` respectively. If you haven’t worked with permissions before,
    these may seem strange, but it’s actually quite easy when you break them down.
    Each permission string can be broken down into four groups, as I’ll show you in
    the following table:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '| **Object type** | **User** | **Group** | **World** |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
- en: '| - | `rw-` | `rw-` | `rw-` |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
- en: '| - | `rw-` | `r--` | `r--` |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
- en: '| - | `rwx` | `rwx` | `r-x` |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
- en: I’ve broken down each of the three example permission strings into four groups.
    Basically, I split them each at the first character and then again every third.
    The first section of a permission string is just one character. In each of these
    examples, it’s just a single hyphen. This refers to what type the object is. Is
    it a directory? A file? A link? In our case, each of these permission strings
    is a file, because the first positions of the permission strings are all hyphens.
    If the object were a directory, the first character would’ve been a `d` instead
    of a `-`. If the object were a link, this field would’ve been `l` (lowercase *L*)
    instead.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next section, in the second column of each object, we have three characters,
    `rw-`, `rw-`, and `rwx` respectively. This refers to the permissions that apply
    to the user that owns the file. For example, here is the first permission string
    again:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The third section of the preceding code output shows us that `doctor` is the
    user that owns the file. Therefore, referring back to the table, the second column
    of the permission string (`rw-`) applies specifically to the user `doctor`. Moving
    on, the third column of permissions is also three characters; in this case, `rw-`
    again. This section of the permissions string refers to the group that owns the
    file. In this case, the group is also named `doctor`, as you can see in column
    four of the preceding code output. Finally, the last section of the permission
    string, visualized in the table (`rw-` yet again, in this case), refers to `world`,
    also known as *other*. This basically refers to anyone else other than the owning
    user and owning group. Therefore, literally everyone else gets at least `rw-`
    permissions on the object.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Individually, `r` stands for *read* and `w` stands for *write*. Therefore, we
    can read the second column (`rw-`), indicating that the user (`doctor`) has access
    to read and write to this file. The third column (`rw-` again) tells us the `doctor`
    group also has read and write access to this file. The fourth column of the permission
    string is the same, so anyone else would also have read and write permissions
    to the file as well.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: 'The third permission string I gave as an example looks a bit different. Here
    it is again:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Here, we see the `x` attribute set. The `x` attribute refers to the ability
    to execute the file as a script. So, with that in mind, we know that this file
    is likely a script and is executable by users, groups, and others. Given the filename
    of `exterminate`, this is rather suspicious, and if it were a real file, we’d
    probably want to look into it.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: 'If a permission is not set, it will simply be a single hyphen where there would
    normally be `r`, `w`, or `x`. This is the same as indicating that a permission
    is disabled. Here are some examples:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '`rwx`: Object has read, write, and execute permissions set for this field'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`r-x`: Object has read enabled, write disabled, and execute enabled for this
    field'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`r--`: Object has read enabled, write disabled, and execute disabled for this
    field'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`---`: Object has no permissions enabled for this field'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bringing this discussion all the way home, here are a few more permission strings:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: For the first of these examples, we see that `sue` is the owning user of `budget.txt`
    and that this file is assigned an accounting group. This object is readable and
    writable by `sue` and readable by everyone else (`group` and `world`). This is
    probably bad, considering this is a budget file and is probably confidential.
    We’ll change it later.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: 'The `annual_projects` object is a directory, which we can tell from the `d`
    in the first column. This directory is owned by the `bob` user and the `sales`
    group. However, since this is a directory, each of the permission bits has different
    meanings. In the following two tables, I’ll outline the meanings of these bits
    for files and again for directories:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: 'Files:'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **Bit** | **Meaning** |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
- en: '| `r` | The file can be read |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
- en: '| `w` | The file can be written to |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
- en: '| `x` | The file can be executed as a program |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
- en: 'Directories:'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **Bit** | **Meaning** |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
- en: '| `r` | The contents of the directory can be viewed |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
- en: '| `w` | The contents of the directory can be altered |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
- en: '| `x` | The user or group can use `cd` to go inside the directory |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
- en: 'As you can see, permissions are read differently depending on their context:
    whether they apply to a file or a directory. In the example of the `annual_projects`
    directory, `bob` has `rwx` permissions to the directory. This means that the user
    `bob` can do everything (view the contents, add or remove contents, and use `cd`
    to move the current directory of his shell into the directory). Regarding a group,
    members of the `sales` group are able to view the contents of this directory and
    `cd` into it. However, no one in the `sales` group can add or remove items to
    or from the directory. On this object, *other* has no permissions set at all.
    This means that no one else can do anything at all with this object, not even
    view its contents.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Changing permissions
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, now we understand how to read permissions on files and directories. That’s
    great, but how do we alter them? As I mentioned earlier, the `budget.txt` file
    is readable by everyone (*other*). This is not good because the file is confidential.
    To change permissions on an object, we will use the `chmod` command. This command
    allows us to alter the permissions of files and directories in a few different
    ways.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we can simply remove read access from the `sue` user’s budget file by
    removing the read bit from the other field. We can do that with the following
    example:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'If we are currently not in the directory where the file resides, we need to
    give a full path:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: If you’re using the `chmod` command against files other than those you own yourself,
    you’ll need to use `sudo`.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: 'But either way, you probably get the idea. With this example, we’re removing
    the `r` bit from *other* (`o-r`). If we wanted to add this bit instead, we would
    simply use `+` instead of `-`. Here are some additional examples of `chmod` in
    action:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '`chmod u+rw <filename>`: The object gets `rw` added to the `user` column'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chmod g+r <filename>`: The owning group is given read access'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chmod o-rw <filename>`: *Other* is stripped of the `rw` bits'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition, you can also use octal point values to manage and modify permissions.
    This is actually the most common method of altering permissions. I like to think
    of this as a scoring system. That’s not what it is, but it makes it a lot easier
    to understand to think of each type of access as having its own value. Basically,
    each of the permission bits (`r`, `w`, and `x`) has its own octal equivalent,
    as follows:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: 'Read: `4`'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Write: `2`'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Execute: `1`'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With this style, there are only a few possibilities for numbers you can achieve
    when combining these octal values (each can only be used once). Therefore, we
    can get `0`, `1`, `2`, `3`, `4`, `5`, `6`, and `7` by adding (or not adding) these
    numbers in different combinations. Some of them you’ll almost never see, such
    as an object having write access but not read. For the most part, you’ll see `0`,
    `4`, `5`, `6`, and `7` used with `chmod` most often. For example, if we add `Read`
    and `Write`, we get `6`. If we add `Read` and `Execute`, we get `5`. If we add
    all three, we get `7`. If we add no permissions, we get `0`. We repeat this for
    each column (`User`, `Group`, and `Other`) to come up with a string of three numbers.
    Here are some examples:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '`600`: `User` has read and write (4+2). No other permissions are set.'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is the same as `-rw-------`.
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`740`: `User` has read, write, and execute. `Group` has read. `Other` has nothing.'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is the same as `-rwxr-----`.
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`770`: Both `User` and `Group` have full access (read, write, and execute).
    `Other` has nothing.'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is the same as `-rwxrwx---`.
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`777`: Everyone has everything.'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is the same as `-rwxrwxrwx`.
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Going back to `chmod`, we can use this numbering system in practice:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '`chmod 600 filename.txt`'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chmod 740 filename.txt`'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chmod 770 filename.txt`'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hopefully you get the idea. If you wanted to change the permissions of a directory,
    the `-R` option may be helpful to you. This makes the changes recursive, meaning
    that you’ll not only make the changes to the directory but also to all files and
    directories underneath it in one shot:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'While using `-R` with `chmod` can save you some time, it can also cause trouble
    if you have a mix of directories and files underneath the directory you’re changing
    permissions on. The previous example gives permissions `770` to `mydir` and all
    of its contents. If there are files inside, they are now given executable permissions
    to the user and group, since `7` includes the execute bit (value of `1`). This
    may not be what you want. We can use the `find` command to differentiate these.
    While `find` is out of the scope of this chapter, it should be relatively simple
    to see what the following commands are doing and how they may be useful:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Basically, in the first example, the `find` command is locating all files (`-type
    f`) in `/path/to/dir/` and everything it finds, it executes `chmod 644` against.
    The second example is locating all directories in this same path and changing
    them all to permission `755`. The `find` command isn’t covered in detail here
    because it easily deserves a chapter of its own, but I’m including it here because
    hopefully these examples are useful and will be handy for you to include in your
    own list of useful commands.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: Changing the ownership of objects
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, we’ll need to know how to change the ownership of files and directories.
    It’s often the case that a particular user needs to gain access to an object,
    or perhaps we need to change the owning group as well. We can change user and
    group ownership of a file or directory with the `chown` command. As an example,
    if we wanted to change the owner of a file to `sue`, we could do the following:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'In the case of a directory, we can also use the `-R` flag to change the ownership
    of the directory itself, as well as all the files and directories it may contain:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'If we would like to change the group assignment to the object, we would follow
    the following syntax:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Notice the colon separating the user and the group. With that command, we established
    that we would like the `sue` user and the `sales` group to own this resource.
    Again, we could use `-R` if the object were a directory and we wanted to make
    the changes recursive.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: 'Another command worth knowing is the `chgrp` command, which allows you to directly
    change the group ownership of a file. To use it, you can execute the `chgrp` command
    along with the group you’d like to own the file, followed by the filename. For
    example, our previous `chown` command can be simplified to the following, since
    we were only modifying the group assignment of that file:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Just like the `chown` command, we can use the `-R` option with `chgrp` to make
    our changes recursively, in the case of a directory.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: Well, there you have it. You should now be able to manage permissions of the
    files and directories on your server. If you haven’t worked through permissions
    on a Linux system before, it may take a few tries before you get the hang of it.
    The best thing for you to do is to practice. Create some files and directories
    (as well as users) and manage their permissions. Try to remove a user’s access
    to a resource and then try to access that resource as that user anyway and see
    what errors you get. Fix those errors and work through more examples. With practice,
    you should be able to get a handle on this very quickly.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Linux administration and related fields, managing users and permissions is
    something you’ll find yourself doing quite a bit. New users will join your organization,
    while others will leave, so this is something that will become ingrained in your
    mental toolset. Even if you’re the only person using your servers, you’ll find
    yourself managing permissions for applications as well, given the fact that processes
    cannot function if they don’t have access to their required resources.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we took a lengthy dive into managing users, groups, and permissions.
    We worked through creating and removing users, assigning permissions, and managing
    administrative access with `sudo`. Practice these concepts on your server. When
    you get the hang of it, I’ll see you in our next chapter, where we’ll discuss
    all things related to package management. It’s going to be epic.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: Relevant videos
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Linux Crash Course – Managing Users (LearnLinuxTV): [https://linux.video/lcc-users](https://linux.video/lcc-users)'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Linux Crash Course – Understanding File & Directory Permissions (LearnLinuxTV):
    [https://linux.video/lcc-perm](https://linux.video/lcc-perm)'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Linux Crash Course – usermod (LearnLinuxTV): [https://linux.video/lcc-usermod](https://linux.video/lcc-usermod)'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Linux Crash Course – sudo (LearnLinuxTV): [https://linux.video/lcc-sudo](https://linux.video/lcc-sudo)'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Linux Crash Course – User Account & Password Expiration (LearnLinuxTV): [https://linux.video/lcc-userexp](https://linux.video/lcc-userexp)'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Linux Crash Course – Managing Groups (LearnLinuxTV): [https://linux.video/lcc-groups](https://linux.video/lcc-groups)'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-391
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'File permissions (Ubuntu community wiki): [https://learnlinux.link/ubuntu-perms](https://learnlinux.link/ubuntu-perms)'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'User management (Ubuntu documentation): [https://learnlinux.link/sec-users](https://learnlinux.link/sec-users)'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join our community on Discord
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/LWaZ0](https://packt.link/LWaZ0)'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code50046724-1955875156.png)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
