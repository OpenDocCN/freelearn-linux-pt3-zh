- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: The Linux Filesystem
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux 文件系统
- en: Files and filesystems are the topics of discussion in this chapter. The Unix
    ethos of *everything is a file* carries on in Linux, and while that’s not true
    100% of the time, most resources in Linux are actually files.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的主题是文件和文件系统。Unix 的 *一切皆文件* 理念在 Linux 中延续，尽管这并非 100% 成立，但大多数 Linux 资源实际上是文件。
- en: In this chapter, we will first define several relevant concepts. Then we will
    investigate Linux’s implementation of the *everything is a file* concept. We will
    then cover the specialized filesystems the kernel makes use of to report data
    about running processes or attached hardware. We will then move on to normal files
    and filesystems, things you would typically associate with documents, data, and
    applications. Finally, we will explore standard filesystem operations and provide
    comparisons with other available alternatives. It is very important to know what
    limitations has each filesystem type in order for you to take the best decisions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先定义几个相关的概念。接着，我们将探讨 Linux 如何实现 *一切皆文件* 的概念。然后，我们将介绍内核用于报告正在运行的进程或连接的硬件的专用文件系统。接下来，我们将讨论普通文件和文件系统，这些通常与文档、数据和应用程序相关联。最后，我们将探讨标准的文件系统操作，并提供与其他可用替代方案的比较。了解每种文件系统类型的限制非常重要，这样你才能做出最佳决策。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The types of filesystems available and the differences between them
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用文件系统类型及其之间的差异
- en: The directory trees and standard directories
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目录树和标准目录
- en: How to mount/unmount filesystems
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何挂载/卸载文件系统
- en: What is a filesystem?
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是文件系统？
- en: A filesystem (or sometimes *file system*) governs the storage and retrieval
    of data in computers. Without a filesystem, all the data saved on a computer’s
    hard drive would be jumbled together, making it impossible to find certain files.
    Instead, with a filesystem, data is easily isolated and identified by breaking
    it up into pieces and giving each piece a name. Each collection of data is referred
    to as a *file*, a name that originally came from information systems that use
    paper storage. A *filesystem* is a name for the organizational framework and logical
    principles used to handle the names and groups of bits of data.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统（有时也称为 *文件系统*）负责计算机中数据的存储和检索。如果没有文件系统，计算机硬盘上保存的所有数据将被混在一起，无法找到特定的文件。相反，使用文件系统后，数据被轻松分隔并通过为每一部分命名来标识。每一组数据被称为
    *文件*，这个名字最初来自于使用纸质存储的信息系统。*文件系统* 是指用于处理数据名称和数据块组的组织框架和逻辑原则的名称。
- en: In fact, there are a variety of filesystems available for Linux; if you’re unsure
    which one to use, we’ll present a thorough list of the filesystems that Linux
    supports.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，Linux 提供了多种文件系统；如果你不确定该使用哪个文件系统，我们将提供一个详尽的 Linux 支持文件系统的列表。
- en: '*What types of Linux filesystems* *are there?*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*Linux 文件系统有哪些类型*？'
- en: 'Linux has a variety of filesystems to choose from, including the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 有多种文件系统可以选择，包括以下几种：
- en: '**ext**: The first filesystem constructed expressly for Linux was called *ext*,
    which is an acronym for *extended filesystem*, and was released in 1992\. The
    primary objective of ext’s developers was to increase the maximum size of editable
    files, which at the time was limited to 64 MB. The maximum file size grew to 2
    GB as a result of the new metadata structure that was created. The maximum length
    of filenames was also increased at the same time to 255 bytes.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ext**：专门为 Linux 构建的第一个文件系统叫做 *ext*，它是 *扩展文件系统*（extended filesystem）的缩写，发布于
    1992 年。ext 开发者的主要目标是增加可编辑文件的最大大小，当时的限制为 64 MB。通过新创建的元数据结构，最大文件大小增大到了 2 GB。文件名的最大长度也同时增加到
    255 字节。'
- en: '**ext2**: This is also known as the *second expanded system*. ext2 was developed
    by Remy Card, just like the first one, and was intended to replace Linux’s original
    extension system. It introduced innovations in fields such as storage capacity
    and overall performance. The maximum file size was notably increased to 2 TB,
    as opposed to the previous version’s 2 GB. Still, filenames remained limited to
    255 bytes long.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ext2**：这也被称为 *第二扩展系统*。ext2 由 Remy Card 开发，就像第一个文件系统一样，旨在取代 Linux 原始的扩展系统。它在存储容量和整体性能等方面引入了创新。最大文件大小显著增加到
    2 TB，相较于上一版本的 2 GB。然而，文件名仍然保持为最多 255 字节。'
- en: '**ext3**: ext3 is an upgraded version of ext2 and was first developed in 2001\.
    The 2-TB maximum file size did not change, but ext3 was superior to ext2 in that
    it is a journaling filesystem. The 2-TB maximum file size does not change. This
    means that if the computer, hard drive(s), or both crash for any reason or encounter
    some type of power outage, the files can be repaired and restored upon rebooting
    using a separate log that contains the changes performed before the crash.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ext3**：ext3 是 ext2 的升级版，首次开发于 2001 年。2 TB 的最大文件大小没有变化，但 ext3 优于 ext2，因为它是一个日志记录文件系统。2
    TB 的最大文件大小保持不变。这意味着如果计算机、硬盘或两者因为某种原因崩溃，或遇到断电等情况，文件可以通过重启后使用一个单独的日志进行修复和恢复，该日志包含崩溃前所做的更改。'
- en: 'ext3 supports three levels of journaling:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: ext3 支持三种日志记录级别：
- en: '**Journal**: In the event of a power outage, the filesystem ensures effective
    filesystem recovery by writing both user data and metadata to the journal. Of
    the three ext3 journaling modes, this is the slowest. This journaling mode reduces
    the likelihood that any changes to any file in an ext3 filesystem will be lost.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志**：在发生断电的情况下，文件系统通过将用户数据和元数据写入日志来确保有效的文件系统恢复。在三种 ext3 日志记录模式中，这是最慢的。这种日志模式降低了在
    ext3 文件系统中对任何文件所做的更改丢失的可能性。'
- en: '`data=writeback` mode, only metadata updates are logged in the journal. Data
    updates, on the other hand, are written directly to their respective locations
    on the disk without being logged in the journal first. This approach can provide
    better performance for write-intensive workloads because it reduces the overhead
    of journaling data.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data=writeback` 模式下，仅元数据更新会被记录到日志中。数据更新则直接写入磁盘上的相应位置，而不先写入日志。由于减少了日志记录数据的开销，这种方法能为写密集型工作负载提供更好的性能。'
- en: '**Pros**:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**优点**：'
- en: Improved performance for write-heavy workloads since data is written directly
    to disk without the extra overhead of journaling
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于写密集型工作负载，性能得到提升，因为数据直接写入磁盘，避免了额外的日志记录开销。
- en: Lower write latency as data doesn’t need to be written twice (to the journal
    and then to the filesystem)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入延迟较低，因为数据无需写入两次（一次到日志，再次到文件系统）。
- en: '**Cons**:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**缺点**：'
- en: Reduced data consistency during a system crash or power failure. Since data
    updates are not journaled, there’s a possibility of data loss or inconsistency
    in case of a crash.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统崩溃或断电时数据一致性降低。由于数据更新未被记录在日志中，崩溃时可能会发生数据丢失或不一致。
- en: In scenarios where data integrity is critical (for example, databases), the
    `writeback` mode may not be the best choice because it prioritizes performance
    over data consistency.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数据完整性至关重要的场景中（例如数据库），`writeback` 模式可能不是最佳选择，因为它优先考虑性能而非数据一致性。
- en: '**Ordered**: This mode does not update related filesystem metadata; instead,
    it flushes changes from file data to disk before updating the associated filesystem
    metadata. This is ext3’s default journaling mode. Only the files that were in
    the process of being written to the disk *disappear* in the event of a power outage.
    The architecture of the filesystem is undamaged.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有序**：该模式不会更新相关的文件系统元数据，而是先将文件数据的更改刷新到磁盘，然后再更新相关的文件系统元数据。这是 ext3 的默认日志记录模式。只有在断电时，正在写入磁盘的文件会*消失*，文件系统的架构不会受到损害。'
- en: '**ext4**: The *fourth extended system*, often known as ext4, was launched in
    2008\. This filesystem is commonly used as the default filesystem for the majority
    of Linux distributions since it overcomes a number of shortcomings that the third
    extended system had. Ext4 supports significantly larger filesystems and individual
    file sizes compared to Ext3\. It can handle filesystems up to 1 exabyte (1 EB)
    and individual files up to 16 terabytes (16 TB). Additionally, a directory in
    ext4 can have up to 64,000 subdirectories (as opposed to 32,000 in ext3).'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ext4**：*第四扩展文件系统*，通常称为 ext4，发布于 2008 年。由于它克服了 ext3 存在的一些缺点，ext4 成为了大多数 Linux
    发行版的默认文件系统。相比 ext3，ext4 支持显著更大的文件系统和单个文件大小。它可以处理最大 1 exabyte（1 EB）的文件系统和最大 16
    terabytes（16 TB）的单个文件。此外，ext4 中的目录最多可以包含 64,000 个子目录（相比之下，ext3 为 32,000 个）。'
- en: Extents have replaced fixed blocks as the primary method of data allocation
    in ext4\. An extent’s beginning and end locations on the hard disk serve as a
    description of it. The number of pointers needed to represent the location of
    all the data in larger files can be greatly reduced because of the ability to
    express extremely long, physically contiguous files in a single inode pointer
    entry.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ext4 中，范围（Extent）取代了固定块，成为数据分配的主要方法。范围在硬盘上的起始和结束位置用于描述该范围。由于能够用单个 inode 指针条目表示非常长的物理连续文件，因此表示大文件中所有数据位置所需的指针数量可以大大减少。
- en: '**JFS**: JFS stands for *Journaled File System*. It is a 64-bit filesystem
    developed by IBM. In 1990, the first version of JFS (also known as *JFS1*) was
    introduced for use with IBM’s AIX operating system.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JFS**：JFS 代表 *日志文件系统*。它是由 IBM 开发的64位文件系统。1990年，JFS的第一个版本（也称为 *JFS1*）推出，用于IBM的
    AIX 操作系统。'
- en: Data recovery after a power outage is simple and reliable. Additionally, compared
    to other filesystems, JFS requires less CPU power.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 电源中断后的数据恢复简单且可靠。此外，与其他文件系统相比，JFS需要更少的CPU功率。
- en: '**XFS**: SGI began working on XFS in the early 1990s with the intention of
    using it as the filesystem for their IRIX operating system. To tackle the most
    difficult computing challenges, XFS was designed as a high-performance 64-bit
    journaling filesystem. Large file manipulation and high-end hardware performance
    are strengths of XFS. In SUSE Linux Enterprise Server, XFS is the default filesystem
    for data partitions.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**XFS**：SGI 从1990年代初期开始开发 XFS，旨在将其作为其 IRIX 操作系统的文件系统。为了应对最具挑战性的计算难题，XFS 被设计为一种高性能的64位日志式文件系统。XFS
    在大文件操作和高端硬件性能方面具有优势。在 SUSE Linux Enterprise Server 中，XFS 是数据分区的默认文件系统。'
- en: '**Btrfs**: Chris Mason created the **copy-on-write** (**COW**) filesystem known
    as Btrfs. It is based on Ohad Rodeh’s COW-friendly B-trees. Btrfs is a logging-style
    filesystem that links the change after writing the block modifications in a new
    area as opposed to journaling them. New changes are not committed until the last
    write.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Btrfs**：Chris Mason 创建了名为 Btrfs 的 **写时复制**（**COW**）文件系统。它基于 Ohad Rodeh 的适用于写时复制的
    B 树。Btrfs 是一种日志式文件系统，它通过将修改后的块写入新的区域而不是将其记录在日志中，来链接更改。新的更改在最后一次写入之前不会被提交。'
- en: '**Swap**: When the amount of memory available to the computer begins to run
    low, the system will use a file known as a swap file to generate temporary storage
    space on a solid-state drive or hard disk. The file replaces a section of memory
    in the RAM storage of a paused program with a new part, making memory available
    for use by other processes.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交换**：当计算机的可用内存开始变低时，系统会使用一个被称为交换文件的文件，在固态硬盘或硬盘上生成临时存储空间。该文件会用一个新的部分替代暂停程序中的一部分内存，从而释放内存供其他进程使用。'
- en: The computer is able to utilize more RAM than is physically installed by using
    a swap file. In other words, it is capable of running more programs than it would
    be able to execute if it relied solely on the limited resources provided by the
    RAM that was physically installed.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机通过使用交换文件可以利用比物理安装的更多的内存。换句话说，它能够运行比单纯依赖物理内存所提供的有限资源更多的程序。
- en: Because swap files are not kept in the computer’s actual RAM, we can consider
    them to be a form of virtual memory. When a computer uses a swap file, its operating
    system essentially tricks itself into thinking that it has more RAM than it actually
    does.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于交换文件并不保存在计算机的实际内存中，我们可以将其视为一种虚拟内存。当计算机使用交换文件时，操作系统实际上是在自欺欺人，认为它拥有比实际更多的内存。
- en: Linux is compatible with a wide variety of filesystems, including the FAT and
    NTFS filesystems that are standard to other operating systems such as Windows.
    It’s possible that embedded developers will support those, although in most cases,
    a Linux filesystem such as ext4, XFS, or Btrfs will be used for storage partitions.
    A better understanding of the benefits of the available alternatives will help
    you to choose the appropriate filesystem for a certain application.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 兼容多种文件系统，包括 FAT 和 NTFS 文件系统，这些文件系统是其他操作系统（如 Windows）的标准。嵌入式开发者可能会支持这些文件系统，尽管在大多数情况下，会使用
    Linux 文件系统，如 ext4、XFS 或 Btrfs，来作为存储分区。更好地理解现有替代方案的优点，将有助于你为特定应用选择合适的文件系统。
- en: High scalability
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高可扩展性
- en: By leveraging allocation groups, XFS provides excellent scalability.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用分配组，XFS 提供了卓越的可扩展性。
- en: The block device that supports the XFS filesystem is split into eight or more
    linear regions that are all the same size at the moment the filesystem is created.
    They are referred to as allocation groups. Each allocation group controls its
    own free disk space and inodes. The kernel can address multiple allocation groups
    at once since they are relatively independent of one another. The high scalability
    of XFS is made possible by this feature. These autonomous allocation groups naturally
    meet the requirements of multiprocessor systems.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 支持 XFS 文件系统的块设备在创建文件系统时被划分为八个或更多相同大小的线性区域，它们被称为分配组。每个分配组控制其自身的空闲磁盘空间和 inode。由于分配组之间相对独立，内核可以同时处理多个分配组。这一特点使得
    XFS 具备了高度的可扩展性。这些自治的分配组自然满足了多处理器系统的需求。
- en: High performance
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高性能
- en: XFS provides high performance by effectively managing disk space.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: XFS 通过有效管理磁盘空间来提供高性能。
- en: Within the allocation groups, B+ trees manage free space and inodes. The effectiveness
    and scalability of XFS are considerably enhanced by the usage of B+ trees. XFS
    manages allocation in a delayed manner by dividing the allocation procedure into
    two steps. Pending transactions are kept in the RAM and the necessary amount of
    space is set aside. The precise location (in filesystem blocks) of the data’s
    storage is still left up to XFS. This choice is postponed until the very last
    second. If it is outdated when XFS selects where to save it, certain short-lived
    temporary data may never reach the disk. XFS improves write performance and lessens
    filesystem fragmentation in this way. Data loss after a crash during a write operation
    is likely to be more severe in a delayed-allocation filesystem than in other filesystems.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在分配组内，B+树管理着空闲空间和 inode。通过使用 B+树，XFS 的效率和可扩展性得到了显著提升。XFS 通过将分配过程分为两步来延迟管理分配。待处理的事务保存在
    RAM 中，并预留了必要的空间。数据存储的精确位置（以文件系统块为单位）仍然由 XFS 来决定。这个选择会被推迟到最后一刻。如果在 XFS 选择存储位置时数据已过时，某些短暂的临时数据可能永远无法写入磁盘。XFS
    通过这种方式提高了写入性能并减少了文件系统的碎片化。在写入操作发生崩溃时，延迟分配文件系统比其他文件系统更可能遭遇数据丢失。
- en: What filesystem does my system use?
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我的系统使用哪种文件系统？
- en: If you aren’t sure which filesystem your distribution ships with, or if you
    just want to know which one you have installed, you can use some clever commands
    at the Terminal to find out.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不确定你的发行版使用的是哪种文件系统，或者你只是想知道自己安装的是哪种文件系统，可以在终端使用一些巧妙的命令来查找。
- en: There are other ways to accomplish this, but we’ll demonstrate the simplest
    one here using the `df -``T` command.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他方法可以完成这一任务，但我们将在这里展示最简单的一种，使用 `df -T` 命令。
- en: '![Figure 3.1 – A command used to determine what type of filesystem is in use](img/Figure_3.1_B18575.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1 – 用于确定正在使用的文件系统类型的命令](img/Figure_3.1_B18575.jpg)'
- en: Figure 3.1 – A command used to determine what type of filesystem is in use
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – 用于确定正在使用的文件系统类型的命令
- en: In the second column, labeled `Type`, you can see the descriptions of the filesystem
    formats. At this point, you should be able to tell which filesystem is mounted
    on your Linux installation.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二列标为 `Type` 的部分，你可以看到文件系统格式的描述。这时，你应该能够判断出你在 Linux 系统上挂载的是什么文件系统。
- en: FUSE filesystem
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FUSE 文件系统
- en: As a user, you shouldn’t have to worry too much about the underlying implementation
    when interacting with files and directories in user space. It is common practice
    for processes to make use of system calls to the kernel in order to read or write
    to a mounted filesystem. However, you do have access to data from the filesystem
    that doesn’t seem to belong in the user’s domain. The `stat()` system call in
    particular returns inode numbers and link counts.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 作为用户，在与用户空间中的文件和目录交互时，你不需要过多担心底层的实现。通常，进程通过系统调用与内核交互，从而读取或写入已挂载的文件系统。然而，你确实可以访问一些看起来不属于用户领域的数据，特别是
    `stat()` 系统调用，它返回 inode 号和链接计数。
- en: Do you have to worry about inode numbers, link counts, and other implementation
    details even when you’re not maintaining a filesystem? No (in most cases). This
    information is made available to user-mode programs for the primary purpose of
    maintaining backward compatibility. In addition, these filesystem internals aren’t
    present in every Linux filesystem because they’re not standardized. The VFS interface
    layer is responsible for ensuring that system calls always return inode numbers
    and link counts; however, the values of these numbers may or may not indicate
    anything.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在你不维护文件系统时，是否需要担心 inode 编号、链接计数和其他实现细节？不需要（在大多数情况下）。这些信息提供给用户模式程序的主要目的是为了保持向后兼容。此外，这些文件系统内部细节并非每个
    Linux 文件系统都有，因为它们并没有标准化。VFS 接口层负责确保系统调用始终返回 inode 编号和链接计数；然而，这些数字的值可能代表某些意义，也可能不代表任何意义。
- en: On non-traditional filesystems, it’s possible that you won’t be able to carry
    out operations that are typical of the Unix filesystem. For instance, you cannot
    use the `ln` command to create a hard link on a mounted VFAT filesystem because
    that filesystem’s directory entry structure does not support the concept of hard
    links. Because of the high level of abstraction provided by the system calls available
    in user space, working with files on Linux systems does not require any prior
    knowledge of the underlying implementation. Additionally, the format of filenames
    is flexible, and the use of mixed-case filenames is supported; both of these features
    make it simple to support other hierarchical-style filesystems.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在非传统文件系统上，您可能无法执行典型的 Unix 文件系统操作。例如，您无法在挂载的 VFAT 文件系统上使用`ln`命令创建硬链接，因为该文件系统的目录条目结构不支持硬链接的概念。由于用户空间提供的系统调用具有高度抽象，因此在
    Linux 系统上操作文件无需了解底层实现的任何知识。此外，文件名的格式灵活，并且支持使用大小写混合的文件名；这两个特点使得支持其他层次结构样式的文件系统变得简单。
- en: Note
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注
- en: Keep in mind that the support for a particular filesystem does not necessarily
    need to be included in the kernel. To give one illustration, the role of the kernel
    in user-space filesystems is limited to that of a conduit for system calls.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，特定文件系统的支持不一定需要包含在内核中。举一个例子，内核在用户空间文件系统中的作用仅限于作为系统调用的传导者。
- en: The directory tree and standard directories
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 目录树和标准目录
- en: 'To see the main structure of the root folder, just use the following command:
    `tree -``L 1`.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看根目录的主要结构，只需使用以下命令：`tree -L 1`。
- en: '![Figure 3.2 – The command to see a directory structure tree](img/Figure_3.2_B18575.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2 – 查看目录结构树的命令](img/Figure_3.2_B18575.jpg)'
- en: Figure 3.2 – The command to see a directory structure tree
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – 查看目录结构树的命令
- en: 'To better grasp how the Linux filesystem functions in general, let’s examine
    what each folder’s purpose is with reference to the Linux filesystem diagram shown
    in *Figure 3**.2*. Not all of the folders mentioned here nor in the preceding
    examples will be found in every Linux distribution, but the vast majority of them
    will:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解 Linux 文件系统的运作方式，让我们参考 *图 3.2* 中显示的 Linux 文件系统图，看看每个文件夹的作用。并非所有这里提到的文件夹或前面示例中的文件夹都会出现在每个
    Linux 发行版中，但绝大多数都会：
- en: '`/bin`: The majority of your binary files are kept in this location, which
    is pronounced *bin,* and is often used by Linux Terminal commands and essential
    utilities such as `cd` (change directory), `pwd` (print working directory), `mv`
    (move), and others.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/bin`：大多数二进制文件保存在此位置，这个位置发音为*bin*，并且常常被 Linux 终端命令和一些基本实用工具使用，例如`cd`（切换目录）、`pwd`（打印当前目录）、`mv`（移动）等。'
- en: '`/boot`: All of the boot files for Linux can be found in this folder. The majority
    of people, including myself, save this directory on a separate partition of their
    hard drive, especially if they plan to use dual-booting. Remember that even if
    `/boot` is physically located on a different partition, Linux still believes it
    to be at `/boot`.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/boot`：所有与 Linux 启动相关的文件都可以在此文件夹中找到。大多数人（包括我）将此目录保存在硬盘的单独分区上，特别是如果他们计划使用双启动。记住，即使
    `/boot` 物理上位于不同的分区，Linux 仍然认为它位于 `/boot`。'
- en: '`/dev`: Your physical devices, such as hard drives, USB drives, and optical
    media, are mounted here. Additionally, your drive may have different partitions,
    in which case you’ll see `/dev/sda1`, `/dev/sda2`, and so forth.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/dev`：你的物理设备，例如硬盘、USB 驱动器和光盘，在这里挂载。此外，您的磁盘可能会有不同的分区，在这种情况下，您将看到`/dev/sda1`、`/dev/sda2`，以此类推。'
- en: '`/etc`: This directory stores configuration files. Users can keep configuration
    files in their own `/home` folder, which affects only the given user, whereas
    configurations placed in `/etc` usually affect all users on the system.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/home`: Because this directory contains all of your personal information,
    you’ll spend most of your time here. The `/home/username` directory contains the
    `Desktop`, `Documents`, `Downloads`, `Photos`, and `Videos` directories.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/lib`: Here is where you’ll find all the library buildings. There are always
    extra libraries that start with lib-something that get downloaded when you install
    a Linux distribution. The operation of your Linux program depends on these files.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/media`: This is where external devices such as USB drives and CD-ROMs are
    mounted. This varies between Linux distributions.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/mnt`: This directory basically serves as a mounting point for other folders
    or drives. This can be used for anything, although it is typically used for network
    locations.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/opt`: This directory contains supplementary software for your computer that
    is not already managed by the package management tool that comes with your distribution.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/proc`: The *processes* folder contains a variety of files holding system
    data (remember, everything is a file). In essence, it gives the Linux kernel—the
    heart of the operating system—a mechanism to communicate with the numerous processes
    that are active within the Linux environment.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/root`: This is the equivalent of the `/home` folder for the root user, commonly
    known as the superuser. You should only touch anything in this directory if you
    are really sure you know what you’re doing.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/sbin`: This is comparable to the `/bin` directory, with the exception that
    it contains instructions that can only be executed by the *root* user, sometimes
    known as the *superuser*.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/tmp`: Temporary files are kept here and are often erased when the computer
    shuts down, so you don’t have to manually remove them as you would in Windows.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/usr`: This directory contains files and utilities that are shared between
    users.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/var`: The files used by the system to store information as it runs are often
    located in the `/var` subfolder of the root directory in Linux and other Unix-like
    operating systems.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We’ve now covered the root directory, but many of the subdirectories also lead
    to additional files and folders. You can get a general concept of what the basic
    filesystem tree looks like from the following diagram:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Basic filesystem structure (Source: https://en.wikipedia.org/wiki/Unix_filesystem)](img/Figure_3.3_B18575.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.3 – Basic filesystem structure (Source: [https://en.wikipedia.org/wiki/Unix_filesystem](https://en.wikipedia.org/wiki/Unix_filesystem))'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Having an understanding of the root directory structure will make your life
    much easier in the Linux world.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Links (hard and symbolic)
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two alternative ways to refer to a file on the hard drive: hard links
    and symbolic links. The filesystem, which organizes which file belongs where and
    how, includes several approaches such as symbolic link and hard link. A hard link
    basically refers to the inode of a file and is a synchronized carbon copy of that
    file. On the other hand, symbolic links point directly to the file, which in turn
    points to the inode, a shortcut. We need to next discuss inodes in order to comprehend
    how symbolic and hard links function.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种替代方式来引用硬盘上的文件：硬链接和符号链接。文件系统通过不同的方式组织文件的位置，包括符号链接和硬链接。硬链接基本上指向文件的 inode，是该文件的同步副本。另一方面，符号链接直接指向文件，而文件再指向
    inode，形成一个快捷方式。我们需要接下来讨论 inode，才能理解符号链接和硬链接是如何工作的。
- en: What is an inode?
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是 inode？
- en: A Unix-style filesystem uses a data structure called an inode to describe filesystem
    objects such as files and directories. The properties and disk block locations
    of an object’s data are stored in each inode. Attributes of filesystem objects
    can include metadata, owner information, and permission information.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Unix 风格的文件系统使用一种称为 inode 的数据结构来描述文件系统对象，如文件和目录。对象的数据属性和磁盘块位置存储在每个 inode 中。文件系统对象的属性可以包括元数据、所有者信息和权限信息。
- en: Inodes are essentially a whole address’s numerical equivalent. The operating
    system can obtain details about a file, including permission privileges and the
    precise location of the data on the hard drive, using an inode.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: inode 本质上是一个地址的数字等价物。操作系统可以通过 inode 获取有关文件的详细信息，包括权限、特权以及数据在硬盘上的精确位置。
- en: What is a hard link?
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是硬链接？
- en: On a computer system, a hard link is a special kind of link that points directly
    to a specific file by its name. A hard link will continue to point to the original
    file even if the file’s name is changed, unlike a soft link.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机系统中，硬链接是一种特殊的链接，通过文件名直接指向特定的文件。即使文件名发生更改，硬链接仍然会继续指向原始文件，这与软链接不同。
- en: When comparing the two methods of linking a directory entry or file to the same
    memory region, hard links are more reliable. As opposed to symbolic links, hard
    links prevent files from being deleted or moved. The *alias effect*, in which
    a file has numerous identifiers, can occur when multiple hard links point to the
    same file. Experts agree that all links, whether hard or soft, are pointers; nonetheless,
    hard links are distinguished as being more permanent than soft connections.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在将目录项或文件链接到相同内存区域的两种方法进行比较时，硬链接更加可靠。与符号链接不同，硬链接防止文件被删除或移动。当多个硬链接指向同一个文件时，*别名效应*
    可能会发生，文件会有多个标识符。专家一致认为，所有链接，无论是硬链接还是软链接，都是指针；然而，硬链接被认为比软链接更加永久。
- en: What are symbolic links?
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是符号链接？
- en: Symbolic links are essentially shortcuts that refer to a file rather than the
    inode value of the file they point to. This method can be applied to directories
    and can be used to make references to data that is located on a variety of hard
    discs and volumes. A symbolic link will be broken or leave a dangling link if
    the original file is moved to a different folder. This is due to the fact that
    symbolic links refer to the original file and not the inode value of the file.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 符号链接本质上是快捷方式，指向的是文件，而不是文件的 inode 值。此方法可以应用于目录，也可以用来引用位于不同硬盘和磁盘卷上的数据。如果原始文件被移动到其他文件夹，符号链接会被破坏或变成悬挂链接。这是因为符号链接指向的是原始文件，而不是文件的
    inode 值。
- en: Because a symbolic link points to the original file, any changes you make to
    the symbolic link should result in corresponding changes being made to the actual
    file.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 因为符号链接指向原始文件，所以你对符号链接所做的任何更改，都应导致对实际文件的相应更改。
- en: Mounting and unmounting filesystems
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挂载和卸载文件系统
- en: In order for the computer to access files, the filesystem must be mounted. The
    `mount` command will show you what is mounted (usable) on your system at the moment.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让计算机访问文件，文件系统必须被挂载。`mount` 命令将显示当前在系统上挂载（可用）的内容。
- en: 'I created my own `/data` folder and mounted a new HDD into it:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建了自己的 `/data` 文件夹，并将一个新的硬盘挂载到该文件夹：
- en: '![Figure 3.4 – A command showing what filesystem is mounted on /data](img/Figure_3.4_B18575.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4 – 显示挂载在 /data 上的文件系统的命令](img/Figure_3.4_B18575.jpg)'
- en: Figure 3.4 – A command showing what filesystem is mounted on /data
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – 显示挂载在 /data 上的文件系统的命令
- en: 'To mount your filesystem with a command, just run the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过命令挂载文件系统，只需运行以下命令：
- en: '[PRE0]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In order to have it automatically mounted on reboot, you have to define this
    entry in `/etc/fstab`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to mount a CD-ROM, just run the following command:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: For more detailed information, consult the `mount` man page or run `mount` with
    the `-h` flag to get assistance.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: The `cd` command can be used to traverse the newly accessible filesystem through
    the mount point you just created after mounting.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: How to unmount the filesystem
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using the `umount` command and specifying the mount point or device, you can
    unmount (detach) the filesystem from your computer.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command, for instance, would unmount a CD-ROM:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Pseudo-filesystems
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A process information pseudo-filesystem is another name for the `proc` filesystem.
    It contains runtime system information rather than *actual* files (for example,
    system memory, devices mounted, hardware configuration, and so on). It can therefore
    be viewed as the kernel’s command and information hub. This directory (`/proc`)
    is accessed by many system utilities. The `lsmod` command lists the modules loaded
    by the kernel, and the `lspci` command displays the devices attached to the PCI
    bus. Both of these commands are functionally equivalent to `cat /proc/modules`
    and `cat /proc/pci`, respectively. Common examples of pseudo filesystems in Unix-like
    operating systems (for example, Linux) include the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Processes, the most prominent use
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kernel information and parameters
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System metrics, such as CPU usage
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processes
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All the information about each running process can be found in the `/proc/pid`
    file. Here’s an illustration of a few PIDs in action right now:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – A command to see running processes](img/Figure_3.5_B18575.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – A command to see running processes
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take, for example, PID `1031` and see what is inside:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – A command to see what is inside of the process with PID 1031](img/Figure_3.6_B18575.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – A command to see what is inside of the process with PID 1031
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a synthetic filesystem is a filesystem that provides a tree-like interface
    to non-file objects, making them look like regular files in a disk-based or long-term
    storage filesystem. This type of filesystem is also known as a faux filesystem.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Kernel and system information
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Numerous folders under `/proc` contain a wealth of knowledge about the kernel
    and the operating system. There are too many of them to include here, but we will
    cover a few along with a brief description of what they contain:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '`/proc/cpuinfo`: Information about the CPU'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/proc/meminfo`: Information about the physical memory'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/proc/vmstats`: Information about the virtual memory'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/proc/mounts`: Information about the mounts'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/proc/filesystems`: Information about filesystems that have been compiled
    into the kernel and whose kernel modules are currently loaded'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/proc/uptime`: This shows the current system uptime'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/proc/cmdline`: The kernel command line'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CPU usage
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When evaluating a system’s overall performance, it is crucial to have a firm
    grasp of how much CPU time is being used. Knowing how to monitor CPU utilization
    in Linux via the command line is essential knowledge for everyone working with
    Linux, from enthusiasts to system administrators.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most common commands used for this purpose is `top`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – Output of top command](img/Figure_3.7_B18575.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – Output of top command
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: The system’s response should be a comprehensive rundown of all active tasks
    where users, processes, CPU usage, and memory consumption can all be viewed.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored files and filesystems in Linux. Filesystems are
    a powerful and versatile approach to organize access to information in a hierarchical
    fashion. In Linux, filesystems are the focus of numerous technologies and ongoing
    efforts. Some are open source, but there is also a spectrum of commercial options.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will talk about processes and process control.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
