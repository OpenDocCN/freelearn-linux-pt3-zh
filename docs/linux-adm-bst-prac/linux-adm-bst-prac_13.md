# *第十章*：用户与访问管理策略

在**Linux**世界中，我们很容易忘记我们依然有用户，而这些用户仍然需要我们在**Windows**或**macOS**世界中期望的所有监督、安全和管理。在基于 Linux 的操作系统中，用户通常是被忽视的，因为这些系统常常被视为黑盒服务器工作负载或奇怪的设备，最终用户不需要关心。这当然并不正确。用户在任何 Linux 系统中都很重要，就像在其他任何系统中一样。

在本章中，我们将讨论服务器和最终用户设备的用户及用户访问管理。我们将研究在 Windows 世界中常见的方法，以及在 UNIX 世界中常见的方法，并且我们还会谈到一些在行业中开始出现的替代方法。

我们还将讨论 Linux 的远程访问——即支持或从我们的系统进行远程工作。当然，所有这一切都将在安全的背景下进行，因为用户管理本质上是一个安全话题。

在本章中，我们将学习以下内容：

+   本地用户与远程用户

+   用户管理机制

+   远程访问方法

+   SSH、密钥管理和跳转服务器

+   替代的远程访问方法

+   终端服务器和虚拟桌面基础架构（VDI）

# 本地用户与远程用户

从最高层次来看，任何系统上的用户账户有两种基本的思考方式。第一种是本地账户，存在于本地系统上并被使用。第二种是用户账户，存储在某种远程服务器上，本地系统通过网络进行引用。当然，也有将这些技术以各种方式结合的混合方法。

我们应该首先谈论这两种方法的明显好处。对于本地管理的用户账户，我们可以迅速访问账户信息，并且不依赖于网络。这带来了明显的性能优势、更好的安全性，并且防止了其他服务的故障影响到我们的本地系统。本地用户是稳健且简单的，快速且易用。直到 1990 年代，甚至很少有人考虑其他可能性。

*远程管理的用户*今天占据了绝大多数的情况，因为这种模式使得不同组织之间的用户可以有一个*单一的真理来源*，有时候甚至可以跨组织使用！这有许多好处，比如允许用户创建一个复杂的密码，他们有可能记住并在多个地方使用，修改一次密码就能在所有地方生效，同时也使得支持团队（这可能是我们这些系统管理员）可以轻松重置、锁定或禁用账户。

在现代企业中，假设只有远程用户账户是可行的已经成为常见做法，但本地账户依然完全可用且可行，对于各种规模的组织来说，仍然是一个不错的选择。不要仅仅因为你的规模或现代化程度而认为某种方式适合你的使用场景。当然，几乎所有现有组织都已经在他们将要使用的架构上进行了大量投资，改变架构是一个非常庞大的工作。我们很少能有机会在一片空白的环境中实施类似用户管理的项目，但偶尔也会遇到这种情况。

本地用户管理需要的网络带宽更少，但今天这基本上已经不是一个问题。更为重要的是安全性和可用性问题。如今，大多数网络非常快，用户管理所需的资源也很少；这导致供应商将用户管理提供为一种服务，通过托管服务商通过互联网提供集中式用户账户。如果互联网能够为这些服务提供足够的带宽，那么基于局域网的版本应该也不会有问题。

安全性成为问题的原因是，多个地方共享同一个账户意味着有一个账户会成为攻击的目标，而如果这个账户被攻破，实际上将无限制地访问所有使用该账户的地方。如果我们使用本地用户账户，并且在不同地方重复使用相同的密码，那么这就模拟了这个问题，因此在很多情况下，除非我们遇到一种情况，用户在不同位置使用不同的凭证，否则这个问题并不成立。对于传统的终端用户来说，这种情况不太可能发生。对于系统管理员来说，这可能相对容易做到。经过培训并理解凭证重要性的高安全性用户，可能很容易利用本地账户的灵活性。你必须了解你的用户及其参与意愿，才能真正评估这种情况中的安全潜力。

围绕安全性的更大问题是支持远程账户的具体机制，它们可以单独受到攻击，而与其支持的账户是分开的。无论你选择哪种机制，都必须通过网络进行通信，以便这些账户能够集中化。在几乎所有情况下，还会有某种形式的本地回退机制——例如凭证缓存——它也可能成为攻击的目标，因此远程存在的账户几乎从未能完全消除本地账户及某种机制的需求。如果缺乏这样的机制，那么就有现成的方法可以通过攻击网络访问来中断登录。

远程用户管理的优势在于拥有一个中央存储库，这个存储库可以接收更专注的安全关注，并且能够更轻松地防止物理暴露给攻击者。终端设备通常最多只会缓存少数的用户账户或紧急访问账户，而不是整个用户列表，从而减少了盗窃笔记本电脑或桌面被攻击时，影响超出设备上缓存的账户列表的风险。

这两种方法都不能算作最佳实践。两者都是完全可行的，并且应当在组织层面以及工作负载层面进行评估。企业选择使用不同的方法来满足不同需求并不罕见。通常没有必要实行单一机制，因为大多数组织足够庞大，拥有多样化的需求，且可以合理地在组织内部实施多个机制。通常，这种混合方式效果最佳，因为集中账户对于大多数终端用户最有利，而本地账户则更适合 IT 和其他技术部门。

在我们掌握了这些基础知识后，我们准备好讨论可以管理这些用户的机制，无论我们选择在哪里实现它们。

# 用户管理机制

在现实世界中，有许多用户管理机制的实现方式需要考虑。有些是 UNIX 或 Linux 原生的，有些在 Windows 世界中常见，有些是新兴的，还有些则是通用且中立的。

需要说明的是，任何探讨用户管理机制的旅程，首先要研究的就是 Linux 用户系统本身。简单而通用，每个值得一提的 Linux 系统都会自带此系统。当然，这个系统是可以被替代的，但实际上它几乎从未被替换。这个系统有着巨大的优势：它始终内置、速度非常快、安全性高，且为每个 UNIX 管理员所熟知。系统中几乎没有出错的地方，也没有复杂的设计。虽然有一些过时的组件可能会因为早期的遗留而存在，如果有必要进行手动配置，可能会让人感到有些困惑，但如今几乎没有人手动操作这些系统（尽管了解如何手动操作总是有备无患）。本地用户通常可以通过自定义脚本、现有工具或状态机等方式非常轻松地自动化。

## 使用自动化将本地用户转化为远程用户

这正是我们无法区分本地用户和远程用户之间差异的一个典型案例。对本地用户管理的一种重要方法是将主用户列表存储在其他地方。这个列表可能是一个简单的文本文件，我们对其运行脚本，或者更可能是一个配置文件，在基础设施即代码的实现中作为状态管理系统的一部分。

在这个例子中，我们的中央管理系统可以用于将用户账户、权限和细节从中央配置系统推送到我们网络中的每台主机上。系统可能会将所有用户推送到所有机器上，或者只将分配给这些机器的用户推送上去。这些决策在实施过程中完全由你来决定。

在这个例子中，是的，我们仍然在每台计算机上使用本地用户机制，并且在任何给定时刻都不需要通过网络进行登录，然而账户仍然是以一种几乎完全模仿像 Active Directory 这样的系统的方式进行中央控制的。我们可以集中执行密码规则，可以集中创建或撤销账户，可以集中控制哪些机器可以或不可以登录，等等。我们本质上有一个中央用户系统，而不是本地系统。

关键的区别在于，像 Active Directory 这样的真正中央用户目录中，用户活动会被导向中央系统，只有在系统离线或处于某种降级状态时，才会可选地触发本地缓存。当可能时，网络活动会支持登录过程。我们所描述的机制中，所有的登录都是通过本地资源进行的——也就是说，*非网络化*的资源，而中央系统仅用于更新本地登录列表和细节。虽然“本地账户”和“本地缓存账户”之间存在精确的语义差异，但这两者的行为确实是不同的。这是一个非常有趣的思维实验。假设本地维护的账户必须在每台设备上包含所有用户，但实际上有许多方法可以将其限制为仅几个用户，甚至有时仅一个用户，同时假设没有用户或只有少数用户会从远程用户管理系统缓存到本地设备，但在某些情况下，整个用户列表可能会被缓存到本地。这里的区别在于用户列表是如何本地创建的，了解这种机制在你案例中的工作原理，再加上了解系统的使用方式，就能告诉你两种方法对你的暴露程度。

然而，这种自动化本质上提供了一个相当重要的机会，让我们重新思考关于本地用户限制的假设。在这种情况下，我们或许能够仅通过本地用户重新创建许多或所有通常被认为仅由更重、更脆弱的远程用户系统提供的期望功能。在现代环境中，应用程序通常不会对操作系统认证系统的扩展进行身份验证，这种方法可能会非常奏效，尤其是在基于 Linux 的操作系统上，在这种系统上，这种集成并不常见。如果你的网络架构采用共享认证方法，例如通过 Active Directory 提供的方式来允许访问网络资源，那么这种方法将无法提供与这些模型通常所具有的平滑、集成体验。依赖这些共享认证过程的网络资源设计模型在如今的主流方法中正逐渐失去其地位，因为随着居家办公的增加、用户的流动性增强以及安全问题的关注，用户体验的格局开始发生变化。

在超越本地用户之后，实际上只有默认机制可用时，我们开始看到各种遗留的和更现代的用户管理选项，随着这一领域的升温，未来肯定会有更多选项出现，因为新的基础设施需求正在推动许多企业对用户管理优先级的转变。

在 UNIX 环境中，当然包括 Linux，传统的用户集中管理服务是**网络信息服务**，最初称为 YellowPages，后来简化为**NIS**。NIS 由**SUN Microsystems**于 1985 年推出，并迅速在 UNIX 世界中普及，改变了人们对跨系统用户的思考方式。NIS 是推动 1990 年代 IT 发展运动的先锋，当时目录服务成为那个时代的热门战略技术。NIS 可能不是第一个目录服务（尽管也许是），但它无疑是第一个广泛应用并且从根本上改变了行业的用户管理范式的服务。

NIS 非常基础，但灵活且易于管理，几乎没有现代所需的所有安全性——这些特性在当时使其非常有效。NIS 几乎在所有 UNIX 系统上都普遍可用，包括 Solaris 和 AIX 等商业产品，以及 BSD 和基于 Linux 的开源操作系统。学习 NIS 意味着你可以轻松跨操作系统进行工作，NIS 还提供了不同 UNIX 版本之间的互操作性。

考虑到 NIS 的巨大历史以及它在安全性和可扩展性方面的不足，似乎 NIS 早已过时，成为人们围坐篝火旁给老一辈讲述的故事，但事实并非如此。NIS 至今仍在使用，尤其是在一些历史悠久的大型企业中，NIS 的实现可能早在 1990 年代就已开始使用，那时它仍是关键技术。新的部署可能早在十多年前几乎就消失了，但旧的实现仍然存在。事实上，在撰写本文时，每个主要的基于 Linux 的操作系统仍然包括 NIS 的包和支持，既可以使系统作为 NIS 客户端使用，也可以创建新的 NIS 服务器！有人提出 RHEL 将在未来几年弃用 NIS，但目前这仍然只是一个提议，离实际发生还有一段时间。NIS 为自己创造了相当深远的影响。

NIS 存在许多不足，特别是在安全性和可扩展性方面，以至于它的设计者在仅仅七年后就尝试用 1992 年推出的 NIS+来替代它（我告诉过你，1990 年代是目录服务的黄金时代）。然而，NIS+并不是 NIS 的直接升级，并且管理起来非常困难，从 NIS 到 NIS+的升级过程也并不顺利。NIS+从未获得足够强大的支持，未能成为主流技术，实际上 NIS 在现实世界的使用和软件支持方面超越了 NIS+。制造 NIS 和 NIS+的 SUN 公司宣布 NIS+将在 2002 年停止使用，虽然它在几年后仍然得到官方支持，但已经逐渐衰退。毫无疑问，NIS+推动了集中式用户管理技术的发展，但它本身从未成为关键技术。它的黄金时代是在 1990 年代中期，但由于当时涌现了大量的技术，NIS+在来自各方的竞争中逐渐被遗忘——包括来自 Novell 和 Microsoft 等新兴厂商的竞争。

为了避免深入讨论 1980 年代和 1990 年代那些复杂且大多被遗忘的目录服务历史，我们只需关注 1993 年推出的一项主导技术——LDAP（轻量级目录访问协议）。LDAP 在许多方面改变了游戏规则。首先，它是厂商中立的，允许任何系统自由实现。其次，它具备许多先进的数据库、协议和安全特性，既能够灵活使用，又能保证安全，同时具备良好的可扩展性。虽然当时也存在其他技术，但到了 1997 年 LDAPv3 发布时，其他目录服务几乎不再成为新闻头条。LDAP 被视为局域网目录市场的明确胜者和未来。

LDAP 在 1990 年代开始取代 UNIX 世界中的 NIS 和 NIS+，包括在基于 Linux 的操作系统中，尽管当时可用的实现复杂且尚未广为人知。LDAP 真正取得突破是在 2000 年，Microsoft 宣布他们将用名为 Active Directory 的 LDAP 实现来取代传统的安全账户管理器（SAM）系统（该系统以有主备域控制器（PDC 和 BDC）而闻名）。Active Directory 被证明是一个制作精良且易于管理的 LDAP 实现，它完全主导了市场，并且超越了 LDAP，甚至到了今天，很少有人意识到 Active Directory 本质上只是市场上众多 LDAP 实现之一。

基于 Linux 的操作系统几乎可以使用任何 LDAP 服务器作为目录服务源，甚至可以使用 Active Directory 本身，后者是一个 LDAP 服务器，但除了 LDAP 系统部分外，还有像 Kerberos 这样的高级要求，赋予了它比普通 LDAP 更强的功能和安全性。自 1990 年代末以来，LDAP（以某种形式）一直是 Linux 系统需要认证到基于局域网的目录服务时的通用标准。今天，有多种 LDAP 服务器实现可以在 Linux 上运行。甚至还有用于 Linux 的 SAM 和 Active Directory 实现，可以作为服务器运行！

如果选择使用本地目录服务器作为方法，那么在基于 Linux 的操作系统中，几乎可以肯定实现 LDAP 的方式是唯一合理的选择。如果目的是与其他系统（如 Windows 或 macOS）进行集成，那么带有额外*特殊功能*的 Active Directory 版本的 LDAP 几乎可以肯定是必需的选项——无论是直接来自 Microsoft 的版本，还是可以在几乎任何 Linux 上运行的开源 Samba 实现。如果是为了实现全 UNIX 设备的集成，那么更传统的 LDAP 服务器产品更可能是合适的选择，例如 OpenLDAP 或 389 目录服务器。

一般认为 LDAP 不适合暴露给公共网络（如互联网），通常被认为是局域网中心化的，这意味着它至少部分依赖于网络防火墙来提供一个安全的操作空间，以便它能够执行其工作。暴露 LDAP（即使假设通过升级版 LDAPS 协议支持 SSL/TLS）也有一定的风险。一些公司仍然这样做，虽然它可以工作，但需要大量的规划和对暴露范围的理解。许多公司通过第三方代理不小心暴露了 LDAP 组件，导致了无意的暴露（也突显了局域网中心化安全方法的围墙花园理论的风险）。

## 著名的 RDP 暴露风险

在 Linux 或 UNIX 圈子里，RDP 暴露风险的例子并不像在 Windows 世界中那样广为人知，因为通过微软的**远程桌面协议**（**RDP**）远程访问系统是非常常见的。然而，RDP 通常相关的概念和问题，如容易受到暴力破解攻击和对潜在攻击者的高可见性，实际上与 Windows 本身无关，而是与架构设计有关。

问题在于，将 RDP 暴露在一个公开可访问的 IP 地址上被认为是非常高风险的。然而，RDP 协议的安全性与 SSH 相似，SSH 通常被认为是可以公开暴露的（在合理范围内）。为什么这两种用途和安全性相似的协议会导致两种如此不同的安全态势？

秘密在于，Windows 世界中的一个惯例是普遍使用 Active Directory（一个 LDAP 实现），或者是微软标准的多用户 RDP 环境**RDS**（**远程桌面服务**）要求 Active Directory。提到 RDP 时，Active Directory 几乎成为了一个不言而喻的结论，但使用 SSH 时，通常假设不会使用 Active Directory 或某种形式的 LDAP（至少不是作为外部认证方法）。

为什么底层的安全方法会产生不同的效果，而 Active Directory 和 LDAP 本身都是高度安全的，RDP 也是一个非常安全的协议？答案在于，RDP 以一种与其在内部局域网中的使用方式截然不同的方式强制暴露了对 Active Directory 的访问。

在局域网内，我们基本上有一个自动白名单，它包含了我们局域网中的设备。在许多环境中，这个白名单会被 VLAN 进一步限制，将不必要的设备（手机、物联网设备等）隔离在终端用户设备之外。在更大的环境中，网络访问控制可能进一步限制潜在的暴露，从而为我们的 Active Directory 提供一个非常安全的环境。此外，Active Directory 本身通常通过限制对任何给定账户的登录尝试来保护自己，在允许进一步尝试之前，会将账户锁定一段时间。远程攻击局域网中的 Active Directory 通常是相当困难的。

当我们将 RDP 开放到互联网时，所有这些控制都会完全消失。当然，可以通过 IP 白名单、VPN 封装或其他技术来限制这一点，但标准部署将会大范围地暴露我们的系统（如果没有这样做，暴露它的目的通常就会丧失）。通常被忽视的是，*在一定数量的失败尝试后锁定*机制，这对于确保 Active Directory 的安全至关重要，但它也为对我们的用户发动拒绝服务（DoS）攻击提供了手段（也就是说，外部用户可以轻易地阻止我们的用户登录）。为了减轻这种攻击风险，我们必须禁用 RDP 的此机制，从而允许来自公共空间的无限攻击！两种选择都不完全可行，因此，尽管 RDP 和 Active Directory 在各自的领域内都相当安全，但在传统方式下使用 RDP 仍然具有很高的风险。

SSH 和其他机制通常与中央用户账户系统（如 LDAP 和 Active Directory）解耦使用，使它们能够保持一个完全独立的安全机制和姿态，相较于其他用户认证方法。RDP 当然也可以这样使用，但由于 Active Directory 的存在，通常假设它具有中央用户账户访问功能，这使得将其视为解耦服务变得困难，因为我们组织中的许多人会期望它与 Active Directory 有即时的集成。

今天，我们生活在一个后 LAN 和通常是后 LDAP 的世界里。即使是 LDAP 的最大支持者微软，也在尽可能避免使用它，并且可能比其他任何公司都在投资 LDAP 替代方案，主要是他们自己的 Azure AD 服务，这个服务令人困惑地保留了“Active Directory”这个名字，尽管它与 Active Directory 完全不相关（但可以与之连接以扩展它）。

对行业公认的认证系统的最大变化是，大多数系统是托管产品，而不是企业需要自行部署和维护的软件；而且大多数现代系统都是基于互联网的，允许用户几乎位于任何地方，只要他们有互联网连接，就能连接到认证机制。

这些新的机制来自许多不同的供应商和供应商类型，以不断增加的多样化形式出现。在完全不涉及服务器、仅限桌面的 Chromebook 世界中，Google 自身拥有一个独特的认证机制，并且今天代表了基于 Linux 的最终用户市场的一个非常重要的部分。

## 操作系统登录在现代世界中还有意义吗？

作为一本关于 Linux 管理的书，我们无可避免地要讨论操作系统级别的用户管理，并且我们必须（按照最佳实践）质疑这个概念今天是否仍然重要（或从历史角度来看是否重要），或者登录操作系统是否很快就会成为过去式。说实话，这个问题并不容易回答。直觉的反应是得出结论，操作系统用户是极其相关的，并且是所有安全的基础。但它们真的是吗？

首先，我想先说：是的，通常来说，操作系统的登录和用户管理今天仍然很重要，而且一直以来都是如此。

然而，我们对用户登录的思考方式发生了巨大的变化。今天的用户环境与一到两十年前大不相同。让我们从一点历史开始。

在 1990 年之前的时代，即*古老的*计算机世界，极少有系统使用用户身份验证机制，至少在操作系统级别没有。像 UNIX 和 VMS 这样的系统是特殊案例，是被视为先进和令人印象深刻的大型企业系统。大多数用户接触到的，甚至是使用像 Mac、Amiga 或 MS-DOS 这样的系统，都是单用户、没有身份验证的系统。直到 2001 年，微软的 Windows **Millenium Edition**（**ME**）发布时仍不支持真正的多用户（因为它仍然只是 MS-DOS 上的图形化外壳）。总的来说，操作系统需要管理多个用户的想法曾是一个陌生的概念。

在 1990 年代，随着网络的普及、互联网逐渐成熟，用户对更高级功能的需求显著增加，用户安全性和访问控制的转变非常重要。如果说 1990 年代有什么特征的话，那就是用户管理的时代（我们之前提到过）。突然间，每个人都开始关心如何处理多个用户共享同一设备，如何在多个设备之间使用户体验变得可移植。系统管理几乎被完全颠覆。

到了 2000 年代，操作系统级别的用户体验期望已经深深扎根，用户管理从竞争优势转变为商品化功能。最后那些没有支持原生多用户功能的操作系统逐渐消失，即便是面向娱乐用户的普通终端产品也开始鼓励用户管理和安全性。

当智能手机首次进入市场时，它们是对 1980 年代无用户系统的回顾。设备的持有者被假定为其普遍且未命名的唯一用户。即使是手机也已经至少转变为一个以用户和安全为中心的设备，即使它们仍然聚焦于单个用户，但也会考虑访问控制和用户身份。

在服务器端，用户管理在过去几十年里确实失去了光彩。在 1990 年代的巅峰时期，Linux 及其 UNIX 亲戚系统曾风靡一时，直接的终端用户登录和服务器上的用户管理占据了系统管理员大部分的工作时间。这个趋势逐渐消退，如今，终端用户需要在操作系统级别上访问服务器的账户或登录的想法，最多也只是显得过时。例外情况总是存在，但它们少之又少，并且越来越罕见。

即便在其巅峰时期，所有管理员必须使用单独的用户账户登录这一必要性也从未得到普遍接受。或许所有管理员共享单一账户从未真正成为常态，但也从未真正罕见过。共享 root 账户（默认的管理员用户账户）访问一直是一个普遍的做法，尽管很少有人愿意承认自己见过，它在 Linux、Windows，甚至可能在所有其他环境中都很常见。这种做法（并且肯定仍然存在）如此广泛，以至于通过外部机制管理用户访问单一账户的技术和工具甚至有点流行（比如登录到一个第三方控制台，按需访问多个服务器上的 root 账户！）

由于我们这本书是关于最佳实践的，我想花一点时间指出，作为系统管理员，维护用户身份和访问控制在我们的服务器上绝对是最佳实践，而且共享账户即使管理得当并且安全，通常也不是一个好主意。为了维持更安全和可审计的系统所需的努力并不大，我们完全没有理由去避免它。尽管如此，共享账户的访问并不一定像听起来那么危险，因为即使在这种情况下，仍然存在审计控制和访问控制的潜力，而虽然我真的怀疑是否存在实际正当的使用案例来支持这么做，但确实可以让共享访问变得*足够安全*，以便有效运作。

更重要的是，对于服务器（以及终端用户工作站的管理功能），现代设计技术如状态机、基础设施即代码、应用封装（如应用容器）、**MDM**（**移动设备管理**）甚至**RMM**（**远程监控和管理**）工具，可能完全消除了登录的需求，从而使整个用户管理讨论变得不再重要。如果我们从不登录，如果我们从不创建用户，那么我们就不需要考虑用户账户访问安全的问题，无论是远程的还是本地的。

因此，值得考虑的是，从服务器的角度来看，用户的需求可能不过是一个过时的时尚，或是那些无法保持最新技术的商店所依赖的备用支撑。这些当然是管理用户，但这长期以来一直是服务器上唯一预期存在的用户。

在终端用户设备上，用户的概念也开始发生剧烈变化，但原因完全不同。传统上，终端用户设备上的工作主要集中在本地安装的应用程序上，这些应用程序本身没有用户控制，而只是运行在操作系统提供的安全控制环境下。这可以是任何类型的应用程序，从文字处理、图像编辑到视频游戏。这个环境主要由可访问的本地存储位置来定义。对许多用户，尤其是家庭用户而言，这几乎已经完全改变。

如今，大多数应用程序是 Web 应用程序，即在浏览器中运行而不是完全安装的应用程序。用户可能会登录到应用程序，但这几乎总是与任何操作系统登录分开。即使是本地安装的应用程序，也开始通过互联网连接进行身份验证，越来越多地依赖于服务。

随着这一变化的发生，操作系统用户作为定义安全访问上下文的主要组成部分的概念正在迅速消退，用户需要在应用程序级别存在的想法已经成为常态。随着这一过程的推进，我们必须开始考虑操作系统用户账户的功能不再是精细的访问控制机制或用户管理的终极方式，而只是为了尝试确保一个安全、受保护的环境，从中我们可以启动我们的 Web 或网络应用程序，并在应用程序层面进行登录，在那里用户和访问控制才是更加相关的。将用户访问控制转移到应用程序层面至关重要，因为数据智能就存在于此，在这一层面可以进行更细粒度的控制，而不是在整个应用程序层面授予访问权限。

随着操作系统在用户管理中的传统角色逐渐消失，强大的用户管理和控制系统的优势也开始削弱。这不仅仅是因为行业和软件成熟导致了用户访问控制从操作系统上移到应用程序中的变化。还有其他因素在起作用。曾几何时，计算机被期望大量使用打印机，但这种情况已经不再普遍。打印机现在只是一个事后考虑的设备，如果它们存在的话，而不再是计算机的主要功能。同样，现代应用程序也不像过去那样使用操作系统管理的存储，严格管理本地存储和映射远程存储资源的需求已经减少。

即使是在十年前，用户管理系统，比如 Active Directory，首先用于协调打印和映射驱动器资源给终端用户。今天，随着应用现代化、工作力量的流动性和计算的普及，这些功能已经成为遗留功能。在家工作的笔记本用户可能完全不需要映射驱动器或打印机，而为了让移动用户能够以这种方式工作，办公室内的工作人员也不得不做出相应的适应。访问控制机制的趋势正在远离传统的操作系统级用户使用方式。

总结来说，用户仍然很重要，但他们的相关性已经不像过去那样强烈，未来看起来是一个用户价值将继续减弱的趋势。

知道哪些远程访问方法最适合你，需要的不仅仅是理解这些系统是如何工作的，了解它们的实现如何适应你的环境只是确定应该为你的组织选择哪种机制的第一步。了解市场上目前有哪些产品，它们的当前功能、局限性、定价和其他商业因素都是必要的。用户管理迅速发展成为一个市场，在这个市场中，我们更多的是需要了解现有的产品供应，而不再是自己来实施。

在接下来的章节中，我们将超越用户身份验证，深入探讨如何为这些用户提供远程访问他们所需系统的方式。

# 远程访问方法

假设我们没有采用基于状态机技术的*无访问*方法，我们有几种常见的途径可以用来访问我们的 Linux 系统。在大多数基于 Linux 的操作系统中，我们将讨论系统管理员，像你我一样，如何能够登录并交互使用操作系统，但我们所使用的任何典型方法，最终也将成为终端用户的选择。终端用户的需求通常与系统管理员的需求截然不同，但我们能使用的工具通常会有所重叠。

对于我们这些系统管理员来说，访问通常需要非常快速地设置，使用时也非常临时，重点是确保系统具有高度的可访问性并以命令行驱动。对于终端用户，我们则会期待相反的需求。管理员通常需要登录到多个不同的操作系统，可能是一个接一个地登录，也可能是同时登录多个系统。访问过程过长可能会显著妨碍我们发挥作用。

传统上，终端用户通常只会登录到单一系统，并在整个工作期间（通常是一个工作日或类似时间段）保持连接。虽然他们可能需要花更多时间进行一次登录，但优先考虑的是提供更稳定的终端用户体验。由于需求差异，远程访问技术可能是分开的，实际上没有必要强求将它们合并。

远程访问有两种主要类型。一种是直接连接，即我们暴露端口并使用像 SSH、RDP 或 RFB（VNC）这样的协议，通过软件客户端连接到我们的系统。这是最为人熟知的技术类型，也是最直接的管理方式。它不需要复杂的配置，且易于理解。在这种方法中，我们在目标虚拟机上（或者可能是在虚拟化管理程序上，但结果大致相同）运行传统服务，外部客户端*访问*该系统。

另一种访问方法是间接访问，其中使用访问服务器来管理操作系统和客户端的访问。该方法需要一个公开托管的服务器（通常是以服务形式提供，但也可以自托管），终端用户和客户端都作为客户端连接到它，从而确保只有访问服务器需要对外暴露。

两种解决方案的优点非常明确。直接连接较为简单，出错的可能性较低。间接连接则需要更多的基础设施，但能减少潜在的暴露点，整合连接，并隐藏网络的存在，使得基于远程访问发布的网络更难被发现和攻击。

出于多种原因，普通终端用户倾向于使用直接连接技术，如 RDP 和 RFB（VNC），而系统管理员则倾向于使用间接连接技术，如 MeshCentral、ConnectWise 和 LogMeIn。对于终端用户而言，直接连接技术通常能提供最稳定的体验，仿佛他们直接操作硬件，就像它就在面前一样。对于系统管理员而言，增强的安全性和对跨多个物理位置系统的访问整合是非常有益的。

然而，需要注意的是，我们在所有情况下都在说*趋向*。这里没有硬性规则，只有强烈的趋势。然而，由于我们正在处理 Linux，我们还需要考虑其他因素。例如，RDP 在 Linux 上的管理通常比在 Windows 上更为复杂，而间接访问方法可能更容易实施，但理解程度较低。此外，我们的用户群体可能有不同的固有期望——例如，Windows 用户可能期望使用 Windows 原生工具，而基于 Linux 的操作系统用户可能对不太熟悉的访问选项持更加开放的态度。

和许多 IT 领域的事情一样，理解基础技术只是第一步。在接下来的部分中，我们将讨论如何使 SSH（一种直接连接技术）变得更加灵活和强大，并从某些角度来看，我们将通过直接连接模拟间接连接。它们之间的差异并不大。

即便是经验法则在这种情况下也很难适用，远程访问的讨论通常会依赖于许多因素，例如如何使用这种访问，这些基础设施是否会与最终用户共享，可能存在的安全需求，是否还有其他访问方式如 VPN，是否有价值创建一个与其他技术或平台共享的统一连接过程？

然后，我们还需要考虑使用多种访问方式的可能性。为了确保即使一种方法失败，仍然能保持可用，使用不止一种方法是很常见的。某一种可能是方便但脆弱的访问方式，而备份方法则可能是高度安全、操作繁琐，但作为关键备份，能在其他方式都失败时派上用场。

## 我如何处理远程访问

在这样一个缺乏明确指导的主题下，我觉得花时间分享我自己常用的访问选择是有价值的。我这么做并不是要建议我的方法是理想的，而是希望为大家提供一些现实世界决策过程的洞察。

在我负责管理 Linux 服务器的系统行政工作时，我们通常需要远程访问正在运行的系统，而不是完全依赖于状态机或基础设施即代码的方式，通常会选择一种双重方法，一个是直接访问，另一个是间接访问。

对于间接访问，我们使用 MeshCentral，它本身是开源软件，运行在我们自己托管的 Linux 操作系统上。这使我们在与大多数解决方案相比，具有广泛的灵活性和成本节省，并且因为我们能够在与内部和客户部署相同的操作系统上运行它，我们能够利用其他地方已在使用的流程、工具和技能，从而最大化效率。像许多间接远程访问解决方案一样，使用 MeshCentral，我们可以进行远程终端访问、如果服务器上安装了 GUI，还可以进行远程图形桌面访问，并且有许多工具用于监控、文件传输和远程命令执行。

通过这种间接访问，系统管理员几乎可以立即访问我们所维护的所有服务器，跨越高度不同的技术栈和物理位置。一些服务器被隔离在局域网内，无法进行端口转发，一些有公共 IP，一些有图形桌面，大多数只有命令行接口。不管它们的地点、使用场景或配置如何，MeshCentral 都能为我们提供所需的访问权限，帮助我们管理系统。

对于主要涉及紧急访问的情况，我们还保持对几乎所有系统的直接 SSH 访问。这一点非常重要，因为当间接访问方式失败时，重新配置、打补丁或重启系统的能力通常至关重要。这种访问几乎总是会限制为仅从直接托管工作负载的本地 LAN 上进行访问，甚至可能在该网络范围内进一步限制，使得 SSH 只能从某些特定工作站或其他指定为高度安全远程访问用途的服务器访问。在某些情况下，SSH 服务可能甚至默认不会运行，只有通过更改状态机设置或通过某种带外管理方式手动开启；或者它也可能通过某种自动化方式启用。`SSH` 对某些自动化任务也可能非常有用。

拥有两种截然不同的访问方式，并且配备深度安全控制，为我们提供了访问性、保护性和安全性的最佳平衡。你必须意识到，每增加一种访问方式，意味着恶意攻击者的攻击途径也会增多，因此增加不必要的访问方式通常不是一个好选择。你需要确保可靠的访问同时又不危及系统安全。

在这类讨论中常常被忽视的一点是，有些直接远程访问工具的工作方式往往是我们没有预料到的，比如基于网页的直接访问工具。这些工具包括 **Cockpit** 或 **WebMin** 等产品，它们为我们的系统提供基于网页的界面。这些工具可能允许通过网页界面配置系统，甚至可能允许通过网页界面进行交互式控制台访问，从而使我们能够以完全不同的方式发布和确保远程访问。

在 Linux 世界里，跨越房间或跨越全球访问计算机最常见且假定的方法就是广泛使用的 SSH 协议。接下来，我们将探讨一些方法，让 SSH 比原生更强大。

# SSH、密钥管理和跳板机

使用 SSH 进行 Linux 操作系统的远程管理是如此普遍，以至于它值得特别关注。单独使用 SSH 是高效且非常安全的，但它是一个广为人知的工具，通常会暴露出如此强大的功能，因此常常成为有针对性的攻击目标。我们在使用 SSH 时不能掉以轻心，尤其是当它暴露在互联网上时，风险实在是太高了。

使用 SSH 时，我们几乎有一长串的方式可以保障其安全。我们将探讨其中几种方式，以及它们如何协同工作，使得 SSH 极其难以被攻破。在 Linux 上，SSH 通过 OpenSSH 提供，它是一个成熟且经过实战检验的工具，接受的审查比几乎所有软件包都要严格。大多数角度来看，SSH 从一开始就是一个非常坚固的软件包。

我们确保 SSH 安全的第一个工具是完全取消基于密码的访问，而改为使用密钥。密钥快速高效，允许管理员比使用密码更快速、更安全地访问服务器。密钥还支持密码短语，作为一种两步验证的形式。如果根据安全需求，这对于你的组织是可行的，那么这就要求某人同时知道加密密码并拥有私钥，才能尝试通过这一通道攻击系统。密钥在远程访问认证中已经使用了很长时间，但它们并没有得到应有的普及。许多公司采取了*如果你愿意，可以为自己设置密钥*的做法，导致太多管理员根本不愿意利用密钥所提供的效率和安全性。

我们的第二个工具是来自失败尝试的帐户锁定。基于 Linux 的操作系统中用于此的标准工具是 Fail2Ban。Fail2Ban 处理 SSH 和其他具有标准登录模块的服务，与它们一起检测针对我们系统的可疑恶意尝试，并自动化我们本地的（即 Linux 基础操作系统上的防火墙）防火墙，阻止来自受影响 IP 地址的流量一段预定时间，通常是三到十五分钟。这种方法是我们对抗暴力破解攻击最有效的工具。

## 你是否仍然需要同时拥有网络边缘防火墙和操作系统防火墙？

你可能会对这个问题出现的频率感到震惊。让这个问题如此令人惊讶的是它总是出现在什么样的背景下。

首先，了解一些技术。在现实世界中，出于多种实际原因，所有路由器实际上也是防火墙。所以，没有硬件防火墙的网络边缘环境几乎是不可能的。在某些情况下，例如安装 VPS 或云服务时，我们可能默认一个完全开放的防火墙，但至少防火墙还是存在的。我们必须从一个假设出发，即所有操作系统实例通常都位于网络防火墙之后，而这个防火墙可能非常无效。

其次，稍微了解一下历史。由于性能影响，操作系统防火墙在 1990 年代末期之前极为罕见。它们也不太重要，因为在那之前，计算机网络化的程度远远较低。即使网络防火墙已经是普遍的假设，操作系统防火墙还是被引入了，因为它们能提供更细粒度和自动化的功能，例如我们在 Fail2Ban 中所得到的功能，而且它们保护的是已经突破网络防火墙或更可能的是来自局域网内部的攻击。

考虑到背景、技术限制和历史，认为两个防火墙不需要的想法显得荒谬。如果我们有能力绕过网络防火墙，理论上是可以做到的，但在这一层跳过安全性是没有意义的；虽然我们可以选择不使用操作系统防火墙，但这样会带来无法通过其他方法缓解的风险。操作系统防火墙在抵御本地和远程威胁方面具有独特的能力，而网络防火墙只能防御远程威胁。虽然没有什么比同时拥有两个防火墙更好的，但从安全角度来看，我们最关心的是操作系统防火墙。我们主要关心网络防火墙的原因是为了减轻操作系统防火墙的负担。

重要的是，今天的基本防火墙功能并不会产生任何可测量的系统开销。这曾是使用防火墙的缺点（大约二十五年前）。如今，使用防火墙没有有效的限制条件。

最佳实践非常明确且极其重要：网络防火墙和操作系统防火墙是绝对需要的。没有任何情况是可以移除或禁用其中一个防火墙的。

操作系统防火墙常常被禁用，因为系统管理员不愿意花时间了解网络需求或正确地保护工作负载。这从来不是一个有效的借口。我们都曾感到懒惰，也都希望避免在系统中维护另一个支持点，但这涉及到基础的安全性，能够正确地支持生产环境中的系统就要求我们具备启用并配置防火墙所需的所有知识。任何认为禁用防火墙有价值的情况（当然不包括故障排除）都应该被视为一个巨大的警告信号，提示我们需要解决某些问题。

在 `SSH` 的安全性方面，继基于密钥的认证和账户锁定后，我们的第三种工具是网络限制，通常以限制连接到 SSH 的请求来源 IP 地址的形式存在。这可以通过多种方式实现。通常，我们会在 Linux 系统上的防火墙上实现这一点，但它也可以由网络边缘的硬件防火墙或云服务提供商的网络防火墙等提供。

IP 限制通常最好通过白名单来设置，尽可能的话。白名单允许我们将 SSH 流量限制到一个单一的 IP 或一小组我们认为是已知且安全的 IP 地址，例如管理员的家庭、信任的数据中心或办公室的 IP 地址。这大大减少了我们系统的攻击面，使它们在第一时间难以被发现。

然而，对于某些人来说，白名单可能不可行，或者至少不太现实。在这种情况下，黑名单可以用来屏蔽那些肯定不需要访问的 IP 范围，依然能提高安全性。在这种情况下，系统管理员可以使用国家 IP 范围来阻止来自某些国家和地区的流量，这种做法是可行的。我从不推荐在面向客户的系统中使用这种做法，因为你可能会无意中阻止客户或商业伙伴，从而招致反弹（记住，对于试图从黑名单所在地点使用服务的人来说，他们并不会认为自己被阻止，而是认为服务失败了或离线了），但对于系统管理访问来说，管理员的位置应该大致已知，并且应始终有备选的沟通渠道，安全性更为关键，这种做法是非常有意义的。

第四，使用`sudo`要求在执行提升权限的命令之前进行额外验证是非常有用的。通过`sudo`，我们可以在已有的密钥或更好的密钥加密码的基础上增加更多的保护。如果我们使用拥有`sudo`权限的用户账户登录 root 超级用户账户，那么我们在成为普通用户之前已经证明了一个或两个认证因素。使用`sudo`时，我们可以选择要求该用户输入另一个独立的密码，以便获得提升权限的权限。这提供了很多潜在的保护。`Sudo`还帮助我们避免了直接以 root 用户身份运行时可能发生的危险错误，通常是由于打字错误。`Sudo`更可能保护我们免于自身的错误，而不是来自外部的攻击。它是一个非常有用的工具。

第五，由于上面提到的`sudo`的强大功能，我们可以完全禁用通过`SSH`登录的 root 用户，将最著名、也是目前风险最大账户完全排除在风险之外。当我们拥有`sudo`机制来保护 root 用户，并且在其被访问时进行日志记录时，就没有必要将 root 用户暴露在外了。

## 更改 SSH 默认端口有效吗？

你会发现许多人和文章告诉你应该始终更改 SSH 的默认端口，或任何访问协议的默认端口，以便使攻击者更难发现。这种做法通常被认为是一种“安全性通过模糊化”手段，但这种方式一般被认为根本没有安全性。

但实际上，这两种做法都有些被夸大。更改默认端口对于实际安全并没有什么作用，因为任何具有一定复杂性或力度的真实攻击都可以在几秒钟内发现一个非标准端口，而攻击者甚至可能不会意识到你试图通过更改地址来阻止攻击。就像你把家门移到房子的侧面，大多数闯入的小偷甚至不会注意到门的位置变得奇怪。门还是那扇门，非常明显。

认为使用非标准端口作为安全措施是错误的。充其量，它在名义上改善了安全姿态，最糟糕的情况可能是暗示你通过混淆来进行安全防护，并可能成为更有针对性攻击的良好目标。非标准端口潜在的好处在于减少了击中我们端口的流量量，使得存储和过滤日志变得更容易。

当然，通过减少日志混乱可以增强安全性，因为这样可以更快地发现或诊断令人担忧的攻击，并且减少存储需求总是一个不错的好处。因此，更改 SSH 端口可能是有益的，但应保持在适当的背景下考虑其益处。

除了 SSH 的所有这些最佳实践安全方法外，还有许多其他标准的加固选项可以使用，但我认为，除了这些，我们很难再定义更多作为最佳实践而不是强烈推荐或值得考虑的选项。稍作调整，SSH 对几乎任何组织需求都可以极其安全。

要提升 SSH 安全性的另一种方法是通过工具如 Google Authenticator 应用一次性密码进行多因素身份验证，这非常简单。还存在许多第三方安全增强措施，SSH 可以像你想要的那样安全。

## SSH 密钥管理

一般认为，如果我们要使用 SSH，则需要使用密钥来保护对其的访问。如前所述，它们快速且非常安全。没有理由不使用它们。然而，并不仅仅是*简单地使用*它们。当我们选择使用密钥时，我们必须确定如何管理这些密钥。这如何才会有意义主要取决于我们组织的规模，或者至少取决于我们的系统管理团队的规模，以及使用这些密钥访问的系统数量。

在其最简单的形式下，SSH 密钥管理可以由个人自行管理。如果用户已经可以登录操作系统，则可以自由创建和管理自己的密钥。对于较小的组织或仅与少数系统管理员合作的情况，这可能是有意义的。

使用 SSH 密钥时，管理涵盖了两个组成部分，即公钥和私钥。通常用户会管理自己的私钥，确保安全，而公钥可以采用几乎任何方式管理。

对于希望改进密钥管理而基础设施较少的小型组织，最简单的方法可以是将用户（包括系统管理员）的公钥存储在维基或其他简单文档系统中，以便根据需要轻松获取。单单这一步就能极大地简化密钥的使用。

密钥也可以存储在类似管理服务器或工作站的文件系统中，并通过简单的自动化推送出去，比如通过 SSH 远程执行的脚本，将密钥复制到指定位置。脚本也可以从网页、文件共享中提取公钥，或者使用像 GIT 或 Subversion 这样的工具从仓库中获取密钥。密钥本质上是文本文件，因此管理它们非常灵活。

在更高级的设置中，可以使用状态机和基础设施即代码的方法，通过与其他自动化工具相同的工具来自动化密钥部署。密钥可以仅仅作为一组文件处理，并不需要特别对待。像状态机和基础设施即代码这样的 DevOps 流程是简化 SSH 密钥管理的极好机制。

然而，所有这些实际上几乎不值得考虑。一旦你在任何规模上使用密钥，并且你的系统管理中出现了密钥管理的问题，那么可能是时候考虑使用**公钥基础设施**（**PKI**）系统来管理证书，而不是密钥了。SSH 使用 TLS，这是与 HTTPS 以及无数其他安全协议相同的机制，因此它可以使用与网站相同的 PKI 系统。

当然，在几乎所有情况下，使用公共托管的 PKI 证书系统对于我们 Linux 基础设施中的几乎所有私有和内部主机来说都会是一个问题。因此，我们需要运行自己的证书授权机构，称为 CA，但这是一个标准的做法，成本和开销极低，虽然这种技能并不广泛存在，但它是可以轻松掌握的。使用 SSH 证书*而不是*SSH 密钥（这里的“而不是”是因为证书包含了密钥，密钥始终隐藏在背后）为我们提供了一个机制，能够快速扩展许多管理员和可能的许多最终用户的 SSH 密钥安全性。

我不会过于夸张地说运行自己的证书授权机构并建立 PKI 基础设施是最佳实践，但对于那些不仅仅是几个用户连接到几个 SSH 主机的组织来说，这是一条不错的经验法则。许多用户连接到不同操作系统实例的网络效应，可能导致 SSH 密钥数量激增，如果不采取措施，可能会无人管理。例如，十个管理员、二十个开发人员、十个测试人员和一百个虚拟机，光是这些就可能需要监控四千个 SSH 密钥组合！

随着几乎所有操作系统今天都支持 SSH，强大的 SSH 安全策略的好处更加显著。SSH 越容易安全地使用，就越有可能被采用，取代其他技术。

## 跳板机

跳跃盒子是一个重要的安全和管理工具，可以简化系统管理的许多方面。作为一个概念，它们非常常见，但作为一个术语，即使是经验丰富的系统管理员也可能不熟悉。跳跃盒子是一个系统，系统管理员（或普通用户，但通常只供技术支持人员使用，因为其设计较为繁琐）通过远程访问该系统，并授予访问权限到要管理的其他系统。

它被称为跳跃盒子，因为你在*跳跃*到另一个系统之前，首先登录到它。它是你任务的起点。跳跃盒子不仅用于访问，还常常作为工具的中央存储库、临时存储位置，或者运行自动化脚本的公共位置。

跳跃盒子通常用于提供一个中央访问点，以便直接访问系统，获取类似于间接远程访问技术和传统直接访问之间的混合特性。从技术上讲，跳跃盒子只是一个两阶段的直接访问系统，但它非常有用，可以避免使用像 VPN 或复杂代理这样的网络路由器来实现访问整合。

通过访问整合，我们可以更实际地保护我们的第一道访问防线。跳跃盒子通常会收到最复杂的 IP 过滤、严格的 Fail2Ban 规则、详细的日志记录、双因素认证、快速修补等，以紧密保护最脆弱的进入点。以这种方式，系统管理员可能会通过登录到他们的跳跃盒子开始一天的工作，然后快速轻松地从该点连接到他们管理的系统。

由于其设计，跳跃盒子通常容易存在于局域网内，托管在共置数据中心，甚至可以是云托管的。它们可以被放置在任何实际需要的地方，并可以在任何地方访问资源。它们可以被加固、监控，并通过直接访问协议，甚至 VPN 或多个 VPN 连接到系统和网站，根据需要进行访问。

由于跳跃盒子是一个单一系统，因此管理的系统可以允许从它的单一 IP 地址连接，即使使用直接访问技术时也能保持良好的安全性。

基于 Linux 的操作系统的跳跃盒子通常用于 SSH，因此它们可能被构建为精简的服务器。没有图形界面的 Linux 跳跃盒子可以运行在最小的虚拟机上，这些虚拟机几乎不占用任何资源，使得它们非常容易在需要的地方部署且成本低廉。

跳跃盒子还可以处理其他协议，通常是 X 或 RDP 协议。例如，这在 Linux 系统管理中并不常见，因为图形界面通常对我们来说只是负担，而当使用跳跃盒子时，提供中央图形界面源的资源需求和复杂性通常会让我们重新考虑是否提供图形界面。

跳板机不是最佳实践，但它是一个常见的安全和管理工具，在需要直接访问以加快、简化和提高安全性时非常有用。

# 替代性远程访问方法

至少从我们通常的理解来看，传统远程访问完全是围绕终端用户的需求设计的，用户需要通过远程会话来替代他们的本地桌面。作为系统管理员，能够在合适的场景下使用这些工具对我们来说是非常有帮助的，并且我们必须理解这些工具，因为它们通常是由我们来管理的组成部分，但就我们自身使用而言，这些工具可能不是最实用的。

当然，我们可以将大多数间接远程访问技术归类为替代性远程访问方法，但它们本质上只是经过调整的传统访问方式，以使其更适合我们的使用场景。作为管理员，我们希望减少与远程机器的登录或交互式会话，期望最终完全消除这种访问，至少在理想状态下是这样。

为此，我们今天有了其他方法来在我们的服务器上运行命令。这些方法并不会在所有情况下取代我们现有的方式，但它们可能是帮助我们从当前状态向未来目标过渡的一项过渡性技术。

使我们大多数系统访问方法看起来*传统*的原因，实际上是它们涉及完全的交互性。这意味着无论我们使用 RDP、Splashtop 还是 SSH 会话，我们都假设正在与需要管理的系统建立完全连接，包括用户级别的环境设置，并在一个持续的输入和输出过程中进行工作。这种假设已经深入人心，许多应用程序或工具实际上也假设使用这种方法，可能需要一些不合逻辑或不合适的会话环境变量。

除非像我们之前讨论的那样完全移除访问——即通过基础设施即代码的方式——否则我们的过渡性访问步骤是远程命令执行或使用非交互式命令。这与我们其他访问方法一样有效，但没有交互能力。远程命令执行使我们能更轻松地从手动任务过渡到自动化，并且非常适用于审计、安全性和可扩展性。

从最简单的角度看，远程命令执行可以通过 SSH 处理，使用与交互式会话相同的基础设施。SSH 设计得能够优雅地处理这两种方法，并且由于它是透明地执行的，它可以是从一种方法平稳过渡到另一种方法的便捷工具。这些方法可以根据情况混合使用，或者一位管理员使用一种方法，另一位使用另一种方法。

使用远程命令执行，我们可以获得所有命令都在源系统上执行的好处，因此可以被记录。非常适合像跳板机或管理服务器这样的工具，可以记录所有执行的操作。然而，交互式会话，即使是从跳板机启动的，也会将所有重要的会话信息记录到最终的操作系统中，跳板机只会知道远程会话已启动——对于到底执行了哪些命令及其响应的详细信息，将会丧失在中央日志平台的可见性。

在许多方面，远程命令执行是系统管理员在软件开发世界中的函数式编程类比。交互式会话更像是过程式编程，其中动作被视为一系列事件。远程命令执行则是使用单一远程函数来执行任务。如果你不熟悉这些编程范式，这个类比可能难以应用，但对于那些使用过这些范式的人来说，我认为这个例子是有价值的。

SSH 可能是悄然引入远程命令执行的理想方式，并且本质上始终可供系统管理员使用。即使在高度严格、结构化和正式的流程驱动环境中，政策法令通常也不太可能不允许管理员在允许传统交互式 SSH 会话的情况下，随时随地使用这种方法。

其他工具，尤其是越来越流行的工具，今天也允许远程命令执行。这已成为大多数间接远程访问工具的标准选项，从大型商业软件服务产品到小型开源自托管产品几乎总是包含某种形式的远程命令执行。在某些情况下，还具备扩展功能，如能够同时对一组或列表中的多个系统运行相同的命令或命令集。

远程管理工具（RMM）通常以相同方式构建远程命令执行系统。这比创建自定义交互式会话机制要容易得多，并且可以被吹捧为更先进的选项，同时实现起来也更简单。

在我看来，最有趣的远程命令执行应用场景是状态机系统。正如 SSH 可以被视为具有远程命令执行作为可选策略，远离交互式会话，逐步过渡到一种稍微不那么熟悉的方式，状态机也可以并且确实将远程命令执行作为一种方式，保持在更传统的操作模式中，为系统管理员提供在状态定义过于复杂或耗时时的备用方法。

从状态机进行远程命令执行也是一种测试状态机访问或功能的方法，尤其是在开发状态文件时。状态是通过在被管理的系统上运行命令来维持的，不管是哪种方式。在某些情况下，命令是通过一个远程代理来执行的，而远程命令虽然被执行，但具体的命令并不是由状态管理中心系统发送的。在其他系统中，命令可能直接按照管理系统上输入的内容发送，状态机只是作为执行助手。

远程访问，尽管一开始看起来很简单，并不是“一刀切”的解决方案，我们甚至可以在同一个组织内使用不同的解决方案。考虑跳出固有思维，尝试新的或不同的方法来提升工作流程的安全性、稳定性和效率。

现在我们已经准备好从各种方法中获取系统管理员访问和安全性的概念，我们应该讨论一些更适用于终端用户访问系统的技术：终端服务器和虚拟桌面基础设施。

# 终端服务器和虚拟桌面基础设施（VDI）

与 Windows 世界不同，在基于 Linux 的操作系统中，远程 GUI 访问相对较少。这只是因为 Linux 并不将此视为其核心功能，在这种自我实现的情况下，客户没有需求，所以供应商也没有在此方面做专门化，导致客户觉得这方面的可用性很低，从而形成了一个循环。然而，这并不是说终端服务和**VDI**（即**虚拟桌面基础设施**，但它通常更为人熟知并直接以缩写形式使用）选项在 Linux 系统中不存在，它们当然存在。

## 概念上理解终端服务和 VDI

终端服务器和 VDI 架构交织在一起并不罕见，这主要是由于市场营销部门试图在不适用的场景中推销 VDI，并且因为常常使用重叠的技术。VDI 被作为一种新的热门技术来推广，好像它并非一直存在一样，这也加剧了混淆。而作为该领域领导者的微软，将其核心产品从**终端服务器**重命名为**远程桌面服务器**（**RDS**），也没有起到任何帮助。这导致了一个问题，即许多 Windows 管理员，更不用说用户，常常将 RDP（远程桌面协议）与 RDS（微软的终端服务器产品）混淆。一个是由多种不同产品实现并使用的通信协议；另一个是一个具体的产品和许可工具，必须从微软购买，可能会使用 RDP，也可能不会。

所以我们必须从定义这些技术开始。两者都涉及远程访问计算机。两者都可以使用相同的一套潜在协议来实现这一“魔法”。两者的基本目的是相同的，但实现方式有所不同。

终端服务器一直意味着一个*单一服务器*（即：一个*单一操作系统实例*），可以被多个远程用户同时访问。在最初的时代，这通过使用串行连接到哑终端来远程显示文本来实现。后来出现了诸如 telnet、RSH，最终是今天我们使用的 SSH 等技术。这些技术推进了安全性和可访问性的状态，但从根本上讲，远程访问仍然是一个类似于原始串行物理终端的命令行活动。几十年前，图形桌面环境的远程使用成为终端用户的常态，新的协议如 RDP、RFB、X 和 NX 变得流行，但本质上没有什么根本变化。许多用户仍然连接到一个单一的操作系统实例，并共享其资源。只有一个操作系统需要修补，所有人共享相同的内核和应用程序。终端服务器采用的是*多对一*架构。

VDI（虚拟桌面基础设施）是一种替代方法，用户可以远程访问仅为他们存在的虚拟化操作系统实例。在 VDI 中，每个用户的操作系统实例可以完全不同，具有不同的补丁级别，甚至可能是完全不同的操作系统。一个用户可能使用**Windows 11**，另一个用户使用 Windows XP，另一个用户使用 Ubuntu。VDI 意味着*一对一*架构。

在大多数情况下，这两种方法之间的概念和区别几乎完全是出于管理微软软件许可限制的需要。在 Linux 世界中，终端服务器或 VDI 部署之间的区别纯粹是根据系统在访问时如何使用*即时*决定的。每个 Linux 设备本身已经是多用户的。Linux 缺乏 Windows 生态系统中始终存在的*一次只有一个用户*的框架。这些概念在非 Windows 环境中往往会被忽视或造成混淆。对于 Linux 管理员来说，任何 VDI 系统其实就是多个轻度使用的终端服务器。在 Windows 世界中，许可规则以非常复杂的方式支配了这个方程式的各个方面。

在 Windows 世界中，Windows 7、10 或 11 的最终用户工作站许可证总是单用户许可证，没有例外。远程访问总是允许的，但只允许单一用户使用，绝不允许替代或附加用户。一个用户坐在控制台前，或者该用户远程访问，但一次只能有一个用户使用。即使是 Windows Server 许可证也只允许一个用户同时使用（另有一个额外许可证仅供系统管理用途），除非购买了 RDS 许可证以支持额外用户。RDS 只能作为附加许可证用于 Windows Server。由于这些许可证规则，Windows 世界中什么是服务器，什么是最终用户工作站，界限非常明确且显而易见。

当然，在 Linux 中并不存在这样的许可证限制。任何工作站都可以作为服务器使用，任何服务器都可以作为桌面或供多个用户使用。任何机器都可以灵活地在任何时间以任何方式使用。诸如终端服务器和 VDI 之类的术语仅指我们打算如何使用系统或系统在任何特定时刻的使用方式，但对于大多数非 Linux 管理员来说，它是一个固定、石沉大海、昂贵的、以许可证为驱动的设计和决策过程，因此我们必须能够理解这些术语和概念如何影响那些处于我们自由灵活的环境之外的人们的认知。

当然，还有一个显而易见的第三种选择，它没有名称。终端服务并不考虑系统是物理的（也就是说，直接安装在裸机硬件上）还是虚拟化的，在这两种情况下它都是一个终端服务器，虚拟化是无关紧要的。对于 VDI，虚拟化是名称的一部分，因此我们只有在系统没有明显理由进行虚拟化时，才会将其视为 VDI。如果我们在裸机操作系统安装上做与 VDI 相同的逻辑架构，那么这个架构没有名称，至少没有一个广为人知的名称。没有虚拟化的一对一远程访问实际上是最常见的远程访问基础方式，甚至以至于大多数人都不会将其视为一种架构。它基本上不需要规划或协调，通常用于各种目的。这个没有名称的设计在任何操作系统中都很常见，无论是 Linux、Windows、macOS 还是其他。

基于 Linux 的操作系统将支持我们所需的任何远程访问架构，甚至支持通常与其他操作系统相关的协议：即来自 Windows 生态系统的 RDP。在 Windows 生态系统中，RDS 技术上与 Active Directory 绑定，导致用户管理与远程访问策略紧密耦合。在 Linux 中，我们没有这样的约束。部署基于 RDP 的终端服务器可以使用我们想要的任何用户管理系统。

像终端服务器和 VDI 这样的工具，更有可能被终端用户使用，从办公室工作人员到开发者，而非系统管理员，但这并不是唯一的情况。在我当前的部署中，我们同时维护这两者，专门供系统管理使用。我将以此为示例场景，展示这些技术如何在管理方面有效地使用。

有时，系统管理员可能会从拥有图形会话中受益。这可能是因为图形工具，如记事本、截图、网页界面等，使工作更高效，或者在某些情况下，工具本身需要图形会话。不幸的是，许多系统，虽然 Linux 本身不常见，但常常是为 Linux 系统管理员所需的系统，只提供基于 Web 的 GUI 界面，或者更糟的是，像 Java 应用程序界面或甚至原生应用程序。我们在主信任数据中心内部，拥有一个专为多用户 RDP 支持构建的 Linux 终端服务器，并且具有静态 IP 地址，这使得我们的管理团队可以随时随地为所有团队成员提供访问权限，在受信任的位置打开图形会话，执行任何必要的工作。

拥有图形界面在进行文档编写、通过屏幕共享进行培训或类似任务时，往往会非常有益。

终端服务器非常适合，特别是在基于 Linux 的操作系统中，提供一个干净、标准的共享环境。VDI 提供了一种竞争的方式，我们和许多公司一样，使用 VDI 提供高度定制化的环境，满足个别系统管理员的需求，例如替代操作系统或桌面环境，这些在共享服务器环境中实施时可能会与其他用户发生冲突。VDI 在某些情况下也更适合，个别系统管理员可能需要成为自己环境的管理员，通常是为了测试，但在共享环境中，这从安全角度来看可能不明智或不可行。

无论是图形界面还是仅命令行的终端服务器和 VDI，都可以作为跳板、管理站、远程执行环境等平台使用。当然，我们还可以将它们用作向终端用户提供基于 Linux 的桌面环境。简单来说，完全没有理由在概念上将这些技术仅限于 Windows，Linux 在这里也能大放异彩，而且在许多情况下，表现得更为出色。

# 摘要

Linux 操作系统上的用户和用户访问是一个复杂的话题，主要因为 Linux 给我们提供了极大的灵活性。我们可以从多个角度探讨用户的存在位置、如何创建用户、如何管理用户、我们信息的来源以及用户如何以多种方式访问他们的系统。我们有古老的技术，也有极其现代的技术。我们几乎可以使用任何机制，来自任何时代、任何生态系统，我们甚至可以自己构建并且是独一无二的。我们可以遵循传统的流程，也可以轻松地构建自己的流程，并以独特的方式工作。

在 Linux 上没有简单的最佳用户管理实践。相反，我们的最佳实践通常是，我们需要理解技术的各种可能性，了解不同的风险和利益如何适应我们独特的组织，了解市场上现有的产品——从开源到商业，从软件到服务，并从各个方面评估这些需求，以确定适合我们组织的解决方案。没有预设假设。使用本地用户帐户并不错误，即使是在非常大规模的情况下。使用远程用户并不错误，即使是在非常小的规模下。我们不必为安全性维护和运行自己的基础设施，但也不必依赖第三方供应商来为我们做这件事。天空才是极限——大多数方法都有其优点，但所有方法都有其局限性，因此它们都值得彻底调查。

总是有一种倾向，认为任何系统都需要过度复杂化。我们被教导复杂就是好，因为它显得先进，而且感觉是对的。但最终，简单通常能提供最低的总体拥有成本，同时承载最少的风险。使用简单的系统和设计，部件更少，出错的机会也更少，这通常会取得成功。

我希望通过这些信息，你能拥有知识和勇气，从不同的角度来看待用户管理。太多的用户管理解决方案是因为误解了行业趋势应该驱动决策，或者认为常见的解决方案比实际更加安全。最好的解决方案永远是最适合你情况的，而适合你的是很少是适合别人（你所比较的对象）的，只有在极少数情况下，任何你所比较的对象都花时间真正评估过他们自己的需求，因此，允许他人的决策过度影响我们往往是非常危险的。

在我们的下一章节中，我们将要讨论一个极其复杂且常常令人困惑的话题——故障排除。
