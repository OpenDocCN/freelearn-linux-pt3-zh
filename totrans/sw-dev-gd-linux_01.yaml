- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: How the Command Line Works
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令行是如何工作的
- en: Before we dive into practical Linux commands, you need to have a basic understanding
    of how the command line works. This chapter will give you that understanding.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入学习实际的 Linux 命令之前，你需要对命令行的工作原理有一个基本的理解。本章将为你提供这样的理解。
- en: For new developers, we’ll explore the initial skills that you need to get started
    on the Linux command line. For those with a little more experience, there are
    still some nuances to discover, such as the difference between “shell” and “command
    line.” It pays to know the difference!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '对于新手开发者，我们将探讨你开始使用 Linux 命令行所需的基本技能。对于有一些经验的人来说，仍然有一些细微的差别需要了解，比如“shell”和“命令行”之间的区别。了解这些差异很有价值！ '
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The basic idea of a command-line interface, or CLI
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令行界面（CLI）的基本概念
- en: The form that commands take
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令的格式
- en: How command arguments work and how they look when you’re typing commands and
    when you’re looking up documentation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令参数是如何工作的，当你输入命令以及查阅文档时，它们是什么样子的。
- en: An introduction to “the shell,” and how it differs from the “command line”
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍“shell”及其与“命令行”的区别
- en: The core rules that the shell uses to look up commands
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: shell 用来查找命令的核心规则
- en: To begin with, we’ll start off with the basic idea of a command-line interface.
    We will get ourselves up to speed with how a CLI works and run through a quick
    example.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将从命令行界面的基本概念开始。我们将快速掌握 CLI 的工作原理，并通过一个简单的例子来加以演练。
- en: In the beginning…was the REPL
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一开始……是 REPL
- en: 'What is a **command-line interface** (**CLI**)? It’s a text-based environment
    for interacting with your computer that:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是 **命令行界面**（**CLI**）？它是一个基于文本的计算机交互环境：
- en: Reads some input from you,
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从你那里读取一些输入，
- en: Evaluates (or processes) that input,
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 评估（或处理）输入，
- en: Prints some output to the screen in response, and then
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 响应并打印一些输出到屏幕，然后
- en: Loops back to the beginning to repeat that process.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环回到开始，重复该过程。
- en: Let’s look at what happens at each step, on a practical level, with the `ls`
    (list) command, which you’ll see in a few pages. For now, it’s enough to know
    that the `ls` command lists the contents of a directory.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实际看看每一步发生了什么，以 `ls`（列出目录内容）命令为例，稍后你会在几页后看到它。现在，了解 `ls` 命令列出目录内容就足够了。
- en: '| **Step** | **What it means** |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| **步骤** | **含义** |'
- en: '| 1\. Read input | You type the `ls` command and press *Enter*. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 1\. 读取输入 | 你输入 `ls` 命令并按 *Enter* 键。 |'
- en: '| 2.Evaluate command | The shell looks up the `ls` binary, finds it, and tells
    the machine to execute it. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 2\. 评估命令 | shell 查找 `ls` 二进制文件，找到它后指示机器执行该命令。 |'
- en: '| 3\. Print output | The `ls` command emits some text – the names of all files
    and directories it found – and the shell prints that output to your terminal window.
    |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 3\. 打印输出 | `ls` 命令会输出一些文本——它找到的所有文件和目录的名称——然后 shell 会将这些输出打印到你的终端窗口。 |'
- en: '| 4\. Loop back to 1 (repeat the process) | Once the programs called by the
    command have exited, repeat the process by accepting more user input. |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 4\. 循环回到第1步（重复该过程） | 当命令调用的程序退出后，通过接受更多的用户输入来重复该过程。 |'
- en: If you read steps 1-4 again, you’ll notice that the first letter of each step
    spells “REPL”, which is a common way of referring to this kind of Read-Eval-Print
    Loop in the languages that invented and refined this workflow, such as Lisp.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次阅读步骤1-4，你会注意到每个步骤的第一个字母拼出了“REPL”，这是在那些发明并完善了这种工作流的语言（如 Lisp）中，常用来指代这种读取-评估-打印循环的方式。
- en: 'To put this into programming terms, you can translate the REPL instructions
    above into code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 用编程术语来说，你可以将上面的 REPL 指令翻译成代码：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Indeed, you can create a REPL capable of doing basic calculations with just
    a few lines of code in most programming languages. Here’s a one-liner “shell”
    program written in Perl:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你可以使用大多数编程语言的几行代码创建一个能够进行基本计算的 REPL。以下是用 Perl 编写的单行“shell”程序：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we write the code as a parameter, printing the output of the evaluation
    as long as there is input to read from. At the end, we append a new line and exit.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将代码写作一个参数，只要有输入可以读取，就会打印出评估后的输出。最后，我们添加一个新行并退出。
- en: This program is tiny, but it’s enough to implement an interactive Read-Eval-Print
    Loop in a command-line environment – a **shell**. The shells you’ll use in Linux
    and Unix are significantly more complex than this Perl mini-shell, but the principles
    are the same.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序很小，但足够在命令行环境中实现一个交互式读评打印循环——一个**shell**。你在 Linux 和 Unix 中使用的 shell 比这个 Perl
    小 shell 要复杂得多，但原理是相同的。
- en: 'The point is simple: as a developer, you might already be using REPLs without
    realizing it, because almost all modern scripting languages come with one. In
    essence, the Linux (or macOS, or other Unix) command line functions like the “interactive
    shells” that interpreted languages give you. So even if you’re not familiar with
    the Lisp REPL, the Perl snippet above should remind you of a very basic Ruby or
    Python shell.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 重点很简单：作为开发者，你可能已经在不自觉中使用 REPL，因为几乎所有现代脚本语言都会带有一个。实际上，Linux（或者 macOS、或其他 Unix
    系统）命令行就像解释型语言提供的“交互式 shell”一样。所以即使你不熟悉 Lisp REPL，前面的 Perl 代码片段也应该会让你想起一个非常基础的
    Ruby 或 Python shell。
- en: Now that you understand the basic mechanics of the command-line interfaces you’ll
    be using in Linux, you’re ready to try out your first commands. To do that, you’ll
    need to know the correct command-line syntax to use.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了将要在 Linux 中使用的命令行接口的基本机制，你准备好尝试你的第一个命令了。为此，你需要了解正确的命令行语法。
- en: Command-line syntax (read)
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令行语法（阅读）
- en: 'All REPLs start by reading some input. On the Linux command line, commands
    that the shell reads in need to have the correct syntax. Commands take this basic
    form:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的 REPL 都是通过读取一些输入来开始的。在 Linux 命令行中，shell 读取的命令需要具有正确的语法。命令的基本格式如下：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In programming terms, you can think of the command name as a function name,
    and the options as any number of arguments that will be passed to that function.
    This is important, because there is no single fixed syntax for all the options
    – each command defines which parameters it will accept. Because of this, the shell
    can do very little to validate a command’s correctness beyond checking that the
    command maps to an executable.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程术语中，你可以把命令名看作函数名，把选项看作传递给该函数的任意数量的参数。这一点很重要，因为并没有统一的语法来处理所有选项——每个命令都定义了它将接受哪些参数。正因如此，shell
    对命令的正确性验证非常有限，除了检查命令是否映射到一个可执行文件。
- en: '**Note**'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The terms “program” and “command” are used interchangeably in this chapter.
    There’s a very slight difference because some shell builtins are defined in the
    shell’s code and are therefore not technically separate programs of their own,
    but you don’t need to worry about it – leave that distinction to the Unix greybeards.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，“程序”和“命令”这两个术语可以互换使用。它们之间有一个非常细微的差别，因为一些 shell 内建命令是定义在 shell 代码中的，因此从技术上讲，它们并不是独立的程序，但你不需要担心这个区别——把这点留给
    Unix 老手们去琢磨吧。
- en: 'Let’s dive into more complex variations on this “command [options]” syntax,
    which you’ll see frequently:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨这个“命令 [选项]”语法的更复杂变体，你将会经常看到：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is the conventional format you’ll see used in help documentation such
    as the program manual pages (manpages) included in most Linux environments, and
    it’s fairly simple:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你在大多数 Linux 环境中看到的帮助文档中的常见格式，例如程序手册页（manpages），它相当简单：
- en: '`command` is the program you’re running'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`command` 是你正在运行的程序'
- en: Items in brackets are optional, and brackets with ellipses (`[xyz ...]`) tell
    you that you can pass zero or more arguments here
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方括号中的项是可选的，带省略号的方括号（`[xyz ...]`）表示你可以在此传递零个或多个参数
- en: '`-flags` means any valid option (“flag,” in Unix-speak) for that program, e.g.
    `-debug or -foobar`'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-flags` 表示该程序的任何有效选项（在 Unix 中称为“标志”），例如 `-debug 或 -foobar`'
- en: 'Some programs will also accept short and long versions of a parameter, usually
    denoted by single- vs. double-hyphenation: so `-l` and `--long` might do the same
    thing. It’s not consistent across commands, though; this kind of behavior requires
    that the command’s creator implemented short and long arguments that set the same
    parameter.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 有些程序还会接受参数的短版本和长版本，通常通过单短划线和双短划线来区分：例如 `-l` 和 `--long` 可能会执行相同的操作。然而，这种行为在命令之间并不一致；这种行为要求命令的创建者实现了短版本和长版本的参数，以设置相同的参数。
- en: Not all commands will implement all these ways of passing configuration when
    invoking them, but these represent the most common forms you’ll see.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 不是所有命令都会在调用时实现所有这些配置传递方式，但这些是你最常见的几种形式。
- en: By default, a space denotes the end of an argument, so just like in most programming
    languages, an argument string that includes spaces must be single- or double-quoted.
    You’ll read more about this in *Chapter 12*, *Automating Tasks with Shell Scripts*.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，空格表示参数的结束，所以像大多数编程语言一样，包含空格的参数字符串必须使用单引号或双引号。你将在*第 12 章*《使用 Shell 脚本自动化任务》中阅读更多相关内容。
- en: 'In just a moment, we’ll follow the process of how the shell interprets a command
    that you issue using this syntax, but first we want to clearly define the difference
    between two sometimes-interchangeable terms we’ve been using in this chapter:
    “command line” and “shell.”'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的内容中，我们将跟随这一过程，了解 shell 如何解释你使用这种语法输入的命令，但首先，我们需要清楚地定义一下本章中我们使用的两个有时可以互换的术语：“命令行”和“shell”。
- en: Command line vs. shell
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令行与 shell
- en: In this book, we refer to a “command-line environment.” We define this as any
    text-based environment that acts as a kind of REPL, specifically for interacting
    with the operating system, programming language interpreter, database, etc. A
    “command-line” environment or interface describes the general idea of how you’re
    interacting with a system.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们提到的“命令行环境”是指任何作为 REPL 一种形式的文本环境，专门用于与操作系统、编程语言解释器、数据库等进行交互。“命令行”环境或界面描述了你与系统交互的一般方式。
- en: 'But there’s a more specific term which we’ll use here: shell.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 但这里有一个更具体的术语，我们将在这里使用：shell。
- en: 'A shell is a specific program that implements this command-line environment
    and lets you give it text commands. Technically, there are lots of different shells
    which provide the same kind of REPL-based command-line environment, often for
    wildly different things:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: shell 是一个特定的程序，它实现了这个命令行环境，并让你可以输入文本命令。技术上讲，有很多不同的 shell 提供相同类型的基于 REPL 的命令行环境，通常用于截然不同的目的：
- en: Bash is a common shell environment for interacting with Linux and Unix operating
    systems.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bash 是一个常见的 shell 环境，用于与 Linux 和 Unix 操作系统交互。
- en: Popular databases like Postgres, MySQL, and Redis all provide a shell for developers
    to interact with and run commands in.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流行的数据库，如 Postgres、MySQL 和 Redis，都提供了 shell 供开发者与之交互并执行命令。
- en: Most interpreted languages provide a shell environment to speed up development.
    In these, valid commands are simply programming language statements. See `irb`
    for Ruby, the interactive Python shell, etc.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数解释型语言都提供 shell 环境，以加快开发速度。在这些环境中，有效的命令只是编程语言的语句。比如 Ruby 的 `irb`，Python 的交互式
    shell 等。
- en: Zsh (the Z shell) is an alternative operating system shell (like Bash), which
    you might see on some developers’ laptops if they’ve customized their environments.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Zsh（Z shell）是另一种操作系统 shell（类似 Bash），你可能会在一些开发者的笔记本上看到它，尤其是当他们自定义了环境设置时。
- en: When we talk about a *shell* in this book, we’re referring to a Unix shell (generally
    Bash), which is a command-line interface specifically designed to let you interact
    with the underlying Linux or Unix operating system.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在本书中提到 *shell* 时，我们指的是 Unix shell（通常是 Bash），它是一个专门设计用来让你与底层 Linux 或 Unix
    操作系统进行交互的命令行界面。
- en: How does the shell know what to run? (evaluate)
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Shell 如何知道该运行什么？（评估）
- en: After *reading* in a command, the shell needs to *evaluate* it, by executing
    a program, fetching some information, or doing something else that’s actually
    useful to you.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在*读取*命令后，shell 需要对其进行*评估*，通过执行程序、获取一些信息或做其他对你实际有用的事情。
- en: '**Note**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Such a detailed description of how shells work may seem tedious at first, but
    we promise that this knowledge will come in handy when you have to troubleshoot
    an issue with a missing or incorrectly permissioned program.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这样详细描述 shell 工作原理可能一开始会显得冗长，但我们保证，当你需要解决因缺少或权限不正确的程序而产生的问题时，这些知识将派上用场。
- en: 'When you type a command like `foobar -option1 test.txt` in a shell like Bash
    and press *Enter*, a few things happen:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在像 Bash 这样的 shell 中输入类似 `foobar -option1 test.txt` 的命令并按下 *Enter* 键时，以下几件事会发生：
- en: 'If the command has a path specified, it will be used. This can take various
    forms:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果命令中指定了路径，它将被使用。路径可以有多种形式：
- en: A full path, like `/usr/bin/foobar` in the command `/usr/bin/foobar -option1
    test.txt`.
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个完整的路径，比如命令 `/usr/bin/foobar -option1 test.txt` 中的 `/usr/bin/foobar`。
- en: A relative path, like the current working directory in the command `./foobar-option1
    test.txt` (the `.` denotes the current directory, which we’ll cover in the *Absolute
    vs. Relative Filepaths* section below; this command essentially says “please execute
    the “foobar” file that’s in my current directory”).
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相对路径，例如在命令`./foobar-option1 test.txt`中的当前工作目录（`.`表示当前目录，我们将在*绝对路径与相对路径*部分中讨论；此命令基本上表示“请执行我的当前目录中的“foobar”文件”）。
- en: 'The path may be based on variables and symbols either in:'
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路径可能基于变量和符号，也可能是：
- en: The shell’s environment (env vars) like `$HOME/foobar`, or
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shell的环境（env vars）如`$HOME/foobar`，或者
- en: Provided by the shell, like `~/foobar` (the `~` character means “this user’s
    home directory”)
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由shell提供，例如`~/foobar`（`~`字符表示“这个用户的主目录”）
- en: 'If not, the shell checks to see whether it knows what `foobar` means:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有，shell将检查是否知道`foobar`的含义：
- en: It could be a built-in shell command.
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能是一个内置的shell命令。
- en: It could be an *alias*, which is a way to set up macros or shortcuts for commands.
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能是一个*别名*，用于设置命令的宏或快捷方式。
- en: 'If not, the shell generally looks at the `$PATH` environment variable, which
    contains a few different locations to check for commands: `/bin`, `/usr/bin`,
    `/sbin`, etc. Users can add locations to this `$PATH` list, and various software
    will modify your `$PATH`: version managers for scripting languages, Python’s virtual
    environments, and many other programs make heavy use of this mechanism. The shell
    tries those places specified in your `$PATH`, in the order it finds them in the
    `$PATH` variable, to see if any of them contain an executable with the name `foobar`.'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有，shell通常会查看`$PATH`环境变量，该变量包含几个不同的位置用于检查命令：`/bin`、`/usr/bin`、`/sbin`等。用户可以向`$PATH`列表添加位置，各种软件将修改您的`$PATH`：脚本语言的版本管理器、Python的虚拟环境以及许多其他程序大量使用这种机制。Shell会按照`$PATH`变量中找到的顺序尝试这些指定的位置，以查看是否有包含名为`foobar`的可执行文件。
- en: 'If the shell still hasn’t found anything, it’ll return an error like `bash:
    foobar: command not found:`.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '如果shell仍然找不到任何内容，它将返回一个错误，例如`bash: foobar: command not found:`。'
- en: On the other hand, if at any point the shell indeed finds an executable file
    named `foobar`, it executes that file and passes `-option1` and `test.txt` (in
    that order) as arguments.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果在任何时候shell确实找到名为`foobar`的可执行文件，它将执行该文件并将`-option1`和`test.txt`（按照顺序）作为参数传递。
- en: At this point, the shell knows what program to use to evaluate the command,
    and it does so. As the command is evaluated, any output is printed to the user,
    completing the third step of the REPL process. Now all that’s left to do is to
    loop back to the beginning and start the process over again, accepting another
    command as input from the user.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，shell知道要使用什么程序来评估命令，并执行。在评估命令时，将任何输出打印给用户，完成REPL过程的第三步。现在唯一剩下的就是回到开始并重新启动过程，接受用户的另一个命令作为输入。
- en: 'The shell tries its best to guess which program the user wants to run, using
    the general process we outlined above to resolve ambiguity. However, ambiguity
    can be a bad thing and lead to misunderstandings or bugs. During troubleshooting,
    you’ll often want to find out which command is really being run. To accomplish
    this, you can use the command `which <command>`, which will print the full path
    (or the alias or script being run) and will let you know whether that command
    is a shell builtin. Depending on the system, `which` might not be available. In
    these situations, you can use `command –v` instead. This is the POSIX equivalent,
    which we’ll learn about next:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Shell尽最大努力猜测用户想要运行的程序，使用我们上面概述的一般过程来解决歧义。然而，歧义可能是一个坏事，会导致误解或错误。在故障排除过程中，您经常会想要找出实际运行的命令。为此，您可以使用命令`which
    <command>`，它将打印完整路径（或正在运行的别名或脚本），并告诉您该命令是否是shell内置的。在某些系统上，可能无法使用`which`命令。在这些情况下，您可以改用`command
    –v`。这是POSIX的等效命令，我们将在下面学习它：
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: A quick definition of POSIX
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: POSIX的简单定义
- en: Wikipedia tells us that “the **Portable Operating System Interface** (**POSIX**)
    is a family of standards specified by the IEEE Computer Society for maintaining
    compatibility between operating systems.” Practically speaking, it’s an attempt
    at defining some common standards between Unix systems, which can otherwise have
    wildly different sets of basic commands available.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 维基百科告诉我们，“**可移植操作系统接口**（**POSIX**）是IEEE计算机学会指定的一系列标准，用于在操作系统之间保持兼容性。”从实际角度来看，它试图在Unix系统之间定义一些共同的标准，否则这些系统可能具有完全不同的基本命令集。
- en: POSIX basically says things like, “every POSIX-compatible OS should have a list
    command called `ls`"; in this case, “every POSIX-compatible OS should have a way
    to check to see if a matching executable exists for a given command name.”
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX 基本上是这样说的：“每个符合 POSIX 的操作系统应该有一个叫做 `ls` 的列表命令”；在这个例子中，“每个符合 POSIX 的操作系统应该有一种方法来检查是否存在与给定命令名匹配的可执行文件。”
- en: If your scripts need to be portable across Unix operating systems, restricting
    yourself to POSIX commands is a good thing to do. However, it’s still not a guarantee
    – many extremely popular Linux distributions divert from POSIX in numerous ways,
    most of which you won’t notice until they bite you.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的脚本需要在不同的 Unix 操作系统间移植，限制自己只使用 POSIX 命令是一个好方法。然而，这仍然不能完全保证成功——许多非常流行的 Linux
    发行版在多个方面偏离了 POSIX 大多数情况下，直到遇到问题时你才会意识到这些差异。
- en: 'Understanding POSIX is the last brick in the foundation you need before getting
    started with the practical job of working on the command line. We’ve covered a
    lot of ground so far:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 POSIX 是你开始进行命令行实际操作之前需要打下的最后一块基石。到目前为止，我们已经覆盖了很多内容：
- en: You learned about REPLs and saw how this basic process maps to how all modern
    shells work
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你已经了解了 REPL（读取-求值-输出循环），并看到这一基本过程如何映射到所有现代 shell 的工作方式。
- en: We explored the basic command syntax you’ll be using while working with Linux
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们探讨了你在使用 Linux 时将会用到的基本命令语法。
- en: 'You saw how your shell decides how to take your command input and “evaluate”
    it correctly. You learned important terminology that you’ll come across frequently:
    shell, command-line interface, POSIX, and a few more terms that will pay dividends
    if you learn them now. Armed with this knowledge, you’re ready to move from theory
    to practice. In the next section, we’ll talk about the Linux-specific context
    that you’ll be in while running commands. You’ll learn the absolute basics of
    the Linux filesystem and how different kinds of paths work. After that, the rest
    of the chapter is all about running Linux commands!'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你了解了 shell 如何决定如何正确处理你的命令输入并“评估”它。你学到了许多重要的术语，你会经常遇到这些术语：shell、命令行界面、POSIX，以及一些如果现在学习了将会带来好处的术语。有了这些知识，你已经准备好从理论进入实践。在接下来的部分，我们将讨论你在执行命令时所处的
    Linux 特定环境。你将学习 Linux 文件系统的基本知识，以及不同类型路径的工作方式。之后，本章的其余部分将专注于运行 Linux 命令！
- en: Basic command-line skills
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本命令行技能
- en: 'To work effectively with Linux, you need to know the absolute basics: how the
    system is structured, how to look and move around on the system, and how to read
    and edit files. In this section, we’ll cover all of that, and get you comfortable
    with the very basics of navigating a Linux system.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要高效使用 Linux，你需要知道一些最基本的知识：系统的结构、如何在系统中查找和移动、以及如何读取和编辑文件。在本节中，我们将涵盖这些内容，并帮助你熟悉
    Linux 系统的基本导航。
- en: Throughout the rest of this book, we’ll dive deeper into each of these topics
    and commands, but we want to make sure you have a minimal, functioning set of
    skills by the time you get to the end of this chapter.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的其余部分，我们将深入探讨每一个主题和命令，但我们希望确保你在本章结束时掌握一套最基本、能正常运作的技能。
- en: Unix filesystem basics
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Unix 文件系统基础
- en: In graphical user interfaces, **directories** (called *folders* in macOS) are
    represented by icons. Perhaps you’re used to seeing neat little rows of these
    in your home directory - Desktop, Documents, Videos, and so on. Double-clicking
    on a directory icon opens a new window with a new view from inside that directory.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在图形用户界面中，**目录**（在 macOS 中称为 *文件夹*）通过图标表示。也许你习惯了在你的主目录中看到这些小小整齐排列的图标——桌面、文档、视频等等。双击目录图标会打开一个新窗口，显示该目录内部的内容。
- en: When we use the term “filesystem,” we mean exactly this – a collection of directories
    and files that organizes all data on the system. The underlying concept is exactly
    the same in a command-line environment, it just looks a bit different.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用“文件系统”这个术语时，我们指的正是这样——一个由目录和文件组成的集合，用来组织系统上的所有数据。在命令行环境中，底层的概念是完全相同的，只是它看起来有所不同。
- en: Instead of seeing lots of windows and icons, everything is represented as text,
    and the contents of directories are only shown when you ask for them. However,
    files and directories still work exactly the way that you’re used to.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你不会看到许多窗口和图标，一切都以文本的形式呈现，目录的内容只有在你请求时才会显示。然而，文件和目录依旧像你习惯的那样工作。
- en: Keeping the filesystem in your head as you navigate seems difficult at first,
    but once you get used to it, it’s often a more efficient way of dealing with a
    computer. After a few days of working this way, most people have no problem holding
    a detailed view of the filesystem in their heads as they work on a system and
    verify this view only occasionally.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在你浏览文件系统时，刚开始时似乎很难记住它，但一旦你习惯了，这通常是处理计算机的更高效方式。经过几天的工作后，大多数人都能毫不费力地在工作时保持文件系统的详细视图，并且只偶尔验证这个视图。
- en: Absolute vs. relative file paths
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绝对路径 vs. 相对路径
- en: 'When beginners work with Linux, they often get caught up on the difference
    between an **absolute path** and a **relative path**. This simple misunderstanding
    results in frustrating amounts of time wasted staring at errors like this one:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当初学者使用Linux时，他们常常被**绝对路径**和**相对路径**的区别所困扰。这个简单的误解导致了浪费大量时间盯着这样的错误：
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Because you need to understand paths as a prerequisite for almost every Linux
    command you run, we’ll cover them first.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你需要理解路径，作为你运行几乎每个Linux命令的前提条件，我们将首先讲解路径。
- en: An absolute path is the full path to any file on the filesystem, starting from
    the root directory. You can recognize this because it starts with a `/`, which
    references the root directory (the very top, or beginning, of the filesystem,
    which contains all other files and directories).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 绝对路径是指从根目录开始，到文件系统中任何文件的完整路径。你可以通过它以`/`开始来识别这个路径，`/`引用了根目录（文件系统的最顶部或开头，包含所有其他文件和目录）。
- en: 'Here are some examples of absolute paths:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些绝对路径的例子：
- en: '`/home/dave/Desktop`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/home/dave/Desktop`'
- en: '`/var/lib/floobkit/`'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/var/lib/floobkit/`'
- en: '`/usr/bin/sudo`'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/usr/bin/sudo`'
- en: These **absolute paths** are like a full set of driving directions, giving turn-by-turn
    instructions from a known starting point (your apartment, or in the case of a
    Unix system, the root directory).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这些**绝对路径**就像一整套驾车路线，从已知的起点（比如你的公寓，或者在Unix系统中是根目录）给出逐步指引。
- en: You can immediately recognize an absolute path by the fact that it starts with
    a “`/`" character. No matter where you are on the filesystem, absolute paths will
    work, since they are full, unique addresses for file objects.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过它以“`/`”字符开始立即识别出绝对路径。无论你在文件系统中的哪个位置，绝对路径都会起作用，因为它们是完整的、唯一的文件对象地址。
- en: A **relative path** is a partial path, and it’s assumed that it starts at *the
    current location* instead of at the root directory. You can recognize an absolute
    path by the fact that it *doesn’t* start with a `/` character.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**相对路径**是部分路径，默认假设它是从*当前目录*开始的，而不是从根目录开始的。你可以通过以下特点识别绝对路径：它*不*以`/`字符开始。'
- en: Relative paths are like driving directions that use your current location as
    the starting point. If you’ve pulled off the road because you’re lost and you
    need new directions, you want directions that start from your *current location*,
    not your home address. Relative paths give you exactly this.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 相对路径就像是使用当前位置作为起点的驾车路线。如果你迷路了，想要新的路线，你希望得到的是从*当前位置*出发的路线，而不是从你的家庭地址开始的路线。相对路径正是提供了这一点。
- en: 'As a result, relative paths are often more convenient to type: if you’re already
    sitting in your `/home/Desktop` directory, it’s easier to reference a file as
    `mydocument.txt` than as `/home/Desktop/mydocument.txt` (even though both ways
    are valid, given your location on the filesystem). The real difference comes when
    you change directories. When you move up a directory from `/home/Desktop` to `/home`,
    the absolute path will still reference the same file, while the relative path
    reference won’t (now, typing `mydocument.txt` would reference `/home/mydocument.txt`).'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，相对路径通常更方便输入：如果你已经在`/home/Desktop`目录下，引用文件时用`mydocument.txt`比用`/home/Desktop/mydocument.txt`要更简单（即使两种方式都是有效的，取决于你在文件系统中的位置）。真正的区别出现在你切换目录时。当你从`/home/Desktop`上移到`/home`时，绝对路径仍然引用相同的文件，而相对路径则不再引用（此时输入`mydocument.txt`会引用`/home/mydocument.txt`）。
- en: 'Imagine a partial directory structure like this – in our example, we’ll say
    this is a directory tree listing of `/home/dave/Desktop`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下这样的部分目录结构——在我们的例子中，我们假设这是`/home/dave/Desktop`的目录树列表：
- en: '[PRE6]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You’re sitting in this desktop directory; in other words, your current directory
    (which you can see by running the `pwd` command) is `/home/dave/Desktop`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在坐在这个桌面目录中；换句话说，你的当前目录（你可以通过运行`pwd`命令看到）是`/home/dave/Desktop`。
- en: 'Here are some example relative paths to files in this desktop directory:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些相对路径示例，指向该桌面目录中的文件：
- en: '`anotherfile`'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`anotherfile`'
- en: '`documents/contract.txt`'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`documents/contract.txt`'
- en: '`stuff/important`'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stuff/important`'
- en: 'Here are the absolute paths for those same files:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这些相同文件的绝对路径：
- en: '`/home/dave/Desktop/anotherfile`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/home/dave/Desktop/anotherfile`'
- en: '`/home/dave/Desktop/documents/contract.txt`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/home/dave/Desktop/documents/contract.txt`'
- en: '`/home/dave/Desktop/stuff/important`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/home/dave/Desktop/stuff/important`'
- en: You’ll notice that a relative path is just an absolute path with the path to
    the current working directory chopped off from the beginning.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，相对路径实际上只是一个绝对路径，去掉当前工作目录的路径部分。
- en: Absolute vs. relative pathname review
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绝对路径与相对路径复习
- en: 'Recall our example:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 回想我们的示例：
- en: '[PRE7]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now imagine that you’re in a shell environment and your current working directory
    is this `Desktop` directory. You want to list the `contract.txt` file. How do
    you reference that file? You’ve got two options:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设你在一个 shell 环境中，当前工作目录是 `Desktop` 目录。你想列出 `contract.txt` 文件。你该如何引用该文件？你有两个选项：
- en: '`ls /home/dave/Desktop/documents/contract.txt`: This is the absolute path,
    which works from everywhere.'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ls /home/dave/Desktop/documents/contract.txt`：这是绝对路径，可以在任何地方使用。'
- en: '`ls documents/contract.txt`: This is a relative path to that file, from your
    current directory.'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ls documents/contract.txt`：这是相对于当前目录的该文件的路径。'
- en: Opening a terminal
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 打开终端
- en: On Ubuntu Linux and macOS, you can get to a command-line prompt by opening the
    “Terminal” application.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ubuntu Linux 和 macOS 上，你可以通过打开“Terminal”应用程序进入命令行提示符。
- en: Looking around – command-line navigation
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 环顾四周 – 命令行导航
- en: As a beginner, the first thing you’ll want to do when you open a shell is to
    have a look around the system. In this section, we’ll cover the most important
    commands for navigating around and looking at a Linux environment through a shell
    window.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 作为初学者，当你打开一个 shell 时，你首先要做的就是浏览一下系统。在本节中，我们将介绍最重要的命令，用于在 shell 窗口中浏览和查看 Linux
    环境。
- en: That said, let’s dive into some basic Linux commands!
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们深入了解一些基本的 Linux 命令吧！
- en: pwd - print working directory
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: pwd - 打印当前工作目录
- en: '`pwd` stands for “print working directory,” and when you type it into your
    terminal, your shell will print out the directory that you’re currently sitting
    in. The Unix filesystem is often compared to a tree, but for now you can just
    think of it as a messy desktop with lots of directories inside. If each directory
    is like a room, `pwd` lets you see which room your command-line environment is
    currently visiting.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`pwd` 代表“打印工作目录”，当你在终端中输入它时，shell 会打印出你当前所在的目录。Unix 文件系统通常被比作一棵树，但现在你可以把它当作一个凌乱的桌面，里面有很多目录。如果每个目录都像一个房间，`pwd`
    让你看到当前命令行环境所在的房间。'
- en: 'New shell sessions will usually start in your home directory. If you’re following
    along on Linux, this will look something like:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 shell 会话通常从你的主目录开始。如果你在 Linux 上操作，它看起来可能是这样的：
- en: '[PRE8]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you’re running another flavor of Unix, it may look slightly different. Here’s
    what you’d see on macOS:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在运行其他版本的 Unix，它可能会稍有不同。以下是在 macOS 上你会看到的内容：
- en: '[PRE9]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Regardless of where you are on the filesystem, you can still reference files
    in all directories (see the *Absolute vs. relative file paths* section in this
    chapter), but sometimes moving around makes things easier. We’ll get into the
    details of filesystem structure in a later chapter.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你在文件系统中的位置如何，你仍然可以引用所有目录中的文件（请参阅本章中的 *绝对路径与相对路径* 部分），但有时四处移动会更容易些。我们将在后面的章节中详细介绍文件系统结构。
- en: ls - list
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ls - 列出
- en: '`ls` lets you “list” the files in a directory. If you run this command without
    any arguments, it’ll just list the files and directories in your current directory.
    If you pass it a path to a directory as an argument, it’ll try to see what’s in
    that directory and list it out for you:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`ls` 让你“列出”目录中的文件。如果你不带任何参数运行此命令，它将列出当前目录中的文件和目录。如果你传入一个目录的路径作为参数，它会尝试查看该目录中的内容并列出来：'
- en: '[PRE10]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: List will also take arguments (“flags”). There are many flags, but two commonly
    useful ones are `-l` (“long”) and `-h` (“human-readable”).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: List 也可以接受参数（“标志”）。有很多标志，但两个常用的标志是 `-l`（“长格式”）和 `-h`（“人类可读格式”）。
- en: '[PRE11]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'A long listing will produce the following output format:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 长列表将产生以下输出格式：
- en: '[PRE12]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let’s go through it, column by column:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐列查看：
- en: '`-rw-r--r--`: The filetype (the first character) and permissions (three groups
    of three bits that represent permissions for the owning user, the owning group,
    and everyone else on the system, respectively).'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-rw-r--r--`：文件类型（第一个字符）和权限（三个三位数，分别表示拥有用户、拥有组和系统中其他所有用户的权限）。'
- en: '`1`: The number of references (hardlinks) to this file.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1`：对该文件的引用次数（硬链接数量）。'
- en: '`dcohen`: The user who owns this file.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dcohen`：拥有此文件的用户。'
- en: '`wheel`: The group that owns this file.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wheel`：拥有此文件的组。'
- en: '`0`: The amount of disk space used by the file (this one is empty). The `-h`
    flag changes this output from the default, number of bytes to something “human-readable,”
    meaning it’ll show megabytes or gigabytes when appropriate.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`：文件所占用的磁盘空间（此文件为空）。`-h` 标志将默认的字节数输出改为“人类可读”的形式，即在适当情况下显示为兆字节或吉字节。'
- en: '`Jul 5 09:27`: File modification time.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Jul 5 09:27`：文件的修改时间。'
- en: '`foobar.txt`: The filename.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`foobar.txt`：文件名。'
- en: This shows you output that requires some knowledge that we haven’t covered yet
    (users, groups, and permissions). That’s okay – we’ll get there in *Chapter 7*,
    *Users and Groups*.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这会显示需要一些我们尚未涵盖的知识（用户、组和权限）的输出。没关系——我们会在*第7章*，“用户和组”中讲解。
- en: Moving around
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动位置
- en: Now that you’ve learned the most basic Linux commands for getting your bearings,
    let’s talk about navigating to where you want to go in a command line environment.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学习了最基本的 Linux 命令来帮助你定位自己，接下来我们来聊聊如何在命令行环境中导航到你想去的地方。
- en: cd – change directory
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: cd – 改变目录
- en: '`cd` lets you “change directory” to anywhere on the filesystem. Using the rooms
    metaphor from before, this is the equivalent of teleporting out of your current
    room and going into a different one.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`cd` 让你可以“改变目录”，前往文件系统中的任何地方。借用之前的房间隐喻，这就相当于从当前房间传送到另一个房间。'
- en: 'After you successfully change directory, the `pwd` command will show your new
    (updated) location:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 成功改变目录后，`pwd` 命令将显示你新的（更新后的）位置：
- en: '[PRE13]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: find – find files
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: find – 查找文件
- en: '`find` allows you to search for files. It is one of the few commands that does
    not follow the convention of long options (e.g., `--name`). Instead, its flags
    are specified with a single dash. Here is an example:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`find` 允许你搜索文件。它是少数几个不遵循长选项（例如`--name`）约定的命令之一。相反，它的标志是通过单个短划线指定的。以下是一个示例：'
- en: '[PRE14]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The above will search `/` (the whole system) for a directory (`-type d`) with
    the name `home`. Keep in mind that when you are not executing this as the all-powerful
    root (administrator) user, `find` will not have permissions to list the contents
    of many directories, so you will receive output like `find: ''/root'': Permission
    denied` in addition to what is being found.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '上述命令会在 `/`（整个系统）中搜索一个名为 `home` 的目录（`-type d`）。请记住，当你不是以拥有超级权限的 root（管理员）身份执行此操作时，`find`
    可能没有权限列出许多目录的内容，因此你将收到类似 `find: ''/root'': Permission denied` 的输出，除此之外还会列出找到的内容。'
- en: 'Another common use case is to execute commands based on the output of `find`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的用例是根据 `find` 输出执行命令：
- en: '[PRE15]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This will run the `echo` command with any found files in place of `{}`. The
    resulting output will be much like an invocation of `ls`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这将运行 `echo` 命令，并将找到的文件替换为 `{}`。结果输出将类似于运行 `ls` 命令。
- en: If, instead of running `echo` for each found file, we want to pass them as arguments
    to `echo`, we can replace `+` instead of `\`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望将每个找到的文件作为参数传递给`echo`，而不是为每个文件运行`echo`，可以用`+`代替`\`。
- en: '[PRE16]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`find` has many more flags. Which ones, exactly? That depends on the version
    of `find` your operating system ships with.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`find` 还有许多其他标志。具体哪些标志可用，取决于你的操作系统所提供的 `find` 版本。'
- en: 'Here are some typical use cases:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些典型的使用案例：
- en: '`find -iname foobar`: Searches for `foobar`, but be case-insensitive'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find -iname foobar`：搜索 `foobar`，忽略大小写'
- en: '`find -name "foobar*"`: Searches for files starting with `foobar`'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find -name "foobar*"`：搜索以 `foobar` 开头的文件'
- en: '`find -name "*foobar"`: Searches for files ending with `foobar`'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find -name "*foobar"`：搜索以 `foobar` 结尾的文件'
- en: Reading files
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阅读文件
- en: Now that you’ve learned how to find the files you’re looking for, let’s see
    how to actually read file content on the command line.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何找到你要的文件，接下来我们来看看如何在命令行中实际阅读文件内容。
- en: less – page through a file
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: less – 翻阅文件
- en: '`less` allows you to read a file, one “page” (based on the size of your terminal
    window) at a time.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`less` 允许你一次阅读文件的一“页”（基于你的终端窗口大小）。'
- en: '[PRE17]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Running `less` will open the file and allow you to scroll through it, one line
    (up/down arrow keys) or one page (spacebar) at a time.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `less` 会打开文件，并允许你逐行（上下箭头键）或逐页（空格键）滚动查看。
- en: To search inside the file, type `/`, followed by your search string, and hit
    *Enter*. Navigate matches with `n` (for next) and `SHIFT-n` (previous).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要在文件内搜索，输入 `/`，然后输入你的搜索字符串，按 *Enter* 键。用 `n`（下一个）和 `SHIFT-n`（上一个）来导航匹配项。
- en: To quit, type `q`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要退出，输入 `q`。
- en: Making changes
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改操作
- en: Now that you can find and read files, let’s look at how to change them or create
    new ones.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以查找和读取文件，接下来我们来看看如何修改文件或创建新文件。
- en: touch – create an empty file, or update modification time for an existing one
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: touch – 创建一个空文件，或者更新现有文件的修改时间
- en: '`touch` creates a file, and therefore requires a file path as your argument.
    If the path you give it doesn’t exist yet (and presuming you have permissions
    to do so), an empty file is created at that path.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`touch` 创建一个文件，因此需要一个文件路径作为参数。如果你提供的路径还不存在（并且假设你有权限），将在该路径下创建一个空文件。'
- en: If a file already exists at the specified path, its access and modification
    timestamps are updated to the current time. If you only want to update access-time
    OR modification-time, you can use the `-a` or `-m` flags, respectively.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指定路径下的文件已经存在，它的访问时间和修改时间将更新为当前时间。如果你只想更新访问时间或修改时间，可以分别使用 `-a` 或 `-m` 标志。
- en: mkdir – create a directory
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: mkdir – 创建目录
- en: '`mkdir` requires a file path argument and uses it to create (“make”) a directory:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`mkdir` 需要一个文件路径参数，并利用它来创建（“制作”）目录：'
- en: '[PRE18]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Optionally, you can feed it additional arguments if you want to create multiple
    directories:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，如果你想创建多个目录，可以提供额外的参数：
- en: '[PRE19]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If you want to create multiple directories nested inside of each other (or
    if you simply want to ensure that they all exist), you can use the `-p` flag:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想创建多个嵌套的目录（或者你只是想确保它们都存在），可以使用 `-p` 标志：
- en: '[PRE20]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Even if `/var/log/myapp` didn’t exist before, running `mkdir` with the `-p`
    flag would have ensured that `/var/log/myapp` was created, before creating `/var/log/myapp/error`
    inside of that. On the other hand, if a directory in the path you’re giving to
    `mkdir -p` *does* already exist, `-p` won’t hurt it in any way, so it’s safe to
    run multiple times in a row (“idempotent”). This makes the `-p` flag standard
    for scripting use.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 `/var/log/myapp` 之前不存在，使用 `mkdir` 和 `-p` 标志也会确保创建 `/var/log/myapp`，然后再在其中创建
    `/var/log/myapp/error`。另一方面，如果你给 `mkdir -p` 的路径中的某个目录已经存在，`-p` 不会对它造成任何影响，所以可以安全地多次运行（“幂等”）。这使得
    `-p` 标志成为脚本使用中的标准。
- en: rmdir – remove empty directories
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: rmdir – 删除空目录
- en: '`rmdir` removes empty directories. They have to be empty for this command to
    work, meaning it’s a relatively safe command to run. Most Linux users end up just
    using `rm` instead, because it can do the same thing.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`rmdir` 删除空目录。为了使此命令生效，目录必须为空，这意味着它是一个相对安全的命令。大多数 Linux 用户最终还是使用 `rm`，因为它可以完成相同的任务。'
- en: rm – remove files and directories
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: rm – 删除文件和目录
- en: 'To delete a file, use the `rm` command:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除一个文件，请使用 `rm` 命令：
- en: '[PRE21]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In practice, most people use `rm` to delete directories as well, because unlike
    `rmdir`, it works on directories that are *not* empty. You’ll need the `-r` flag
    to apply the command *recursively* (to all directories contained by the one you’re
    deleting), and the `-f` flag to “force” deletion without a confirmation for each
    file and directory:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，大多数人也使用 `rm` 来删除目录，因为与 `rmdir` 不同，它可以删除*非*空的目录。你需要使用 `-r` 标志来*递归*地应用命令（对你正在删除的目录包含的所有目录），并使用
    `-f` 标志来“强制”删除，而不需要每次确认每个文件和目录：
- en: '[PRE22]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '**Note**'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Be extremely careful when using `rm -rf` because Linux will let you delete directories
    that are critical to the operation of your system. For example, `rm -rf /` is
    telling `rm` that you’d like to delete the root directory, which contains everything
    on the system.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `rm -rf` 时要非常小心，因为 Linux 允许你删除对系统操作至关重要的目录。例如，`rm -rf /` 告诉 `rm` 你希望删除根目录，根目录包含系统上的所有内容。
- en: Some Linux distributions and Unix operating systems get around this in creative
    ways (Ubuntu ships with a version of the `rm` command that has a `--no-preserve-root`
    option as a way of asking “are you *sure* you want to do this?” and Solaris intentionally
    used a loose interpretation of what `rm` should do to avoid deleting the root
    directory). In practice, these safeguards are easily circumvented. Be careful
    when using `rm`, and take care when pasting commands into your shell from the
    Internet!
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Linux发行版和Unix操作系统通过创新的方式解决了这个问题（Ubuntu提供了一个带有`--no-preserve-root`选项的`rm`命令，作为一种询问“你*确定*要这样做吗？”的方式，而Solaris故意对`rm`的功能做了宽松解释，以避免删除根目录）。实际上，这些保护措施很容易绕过。在使用`rm`时要小心，并且在将命令从互联网上粘贴到你的shell中时要特别注意！
- en: mv – move or rename files and directories
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: mv – 移动或重命名文件和目录
- en: '`mv` is a clever one, because it can do two different things using the same
    syntax. Either it “moves” files from one directory to another, or – alternatively
    – it can rename a file, keeping it in the same directory.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`mv`是一个聪明的命令，因为它可以使用相同的语法做两种不同的事情。它可以将文件从一个目录“移动”到另一个目录，或者——另外——它可以重命名一个文件，并将其保留在同一目录下。'
- en: 'First, we’ll create a file using `touch`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用`touch`命令创建一个文件：
- en: '[PRE23]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, we’ll rename the file in place:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将在原地重命名文件：
- en: '[PRE24]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note that the command above would overwrite any existing file named `foobarbaz.txt`,
    if one existed, so be careful when renaming things.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，上述命令会覆盖任何已存在的名为`foobarbaz.txt`的文件，如果存在的话，所以在重命名时要小心。
- en: 'To move the file to a new directory, we’ll create a new directory and then
    move the file there:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要将文件移动到新目录，我们将创建一个新目录，然后将文件移到那里：
- en: '[PRE25]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can combine the operations, too. If you want to move a file to a different
    directory *and* rename it at the same time, you can:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将这些操作结合起来。如果你想将文件移动到另一个目录*同时*重命名它，可以这样做：
- en: '[PRE26]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Getting help
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取帮助
- en: All but the most minimal environments tend to come with manual pages (manpages),
    which are documentation that you can use to learn (or remember) how to use the
    command-line programs you have available to you.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 除了最基本的环境之外，大多数环境都会提供手册页（manpages），它们是你可以用来学习（或记住）如何使用你可用的命令行程序的文档。
- en: 'Use `man $COMMANDNAME` to get information on a command. For example, `man ls`
    will print something like this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`man $COMMANDNAME`来获取命令的信息。例如，`man ls`将打印出类似以下内容：
- en: '[PRE27]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Since manual pages are automatically opened in a pager application, scrolling,
    searching, and quitting works using the same shortcuts that you’re used to from
    the `less` command.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 由于手册页面会自动打开在一个分页程序中，滚动、搜索和退出都可以使用你习惯的`less`命令中的快捷键。
- en: Keep in mind that `man` is an old utility which tries to resemble an actual
    book, with different sections (chapters) that cover different topics. In the example
    above, the `(1)` in `ls(1)` denotes which manual section we’re being shown.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`man`是一个古老的工具，它尽力模仿一本实际的书籍，分为不同的章节，涵盖不同的主题。在上面的示例中，`ls(1)`中的`(1)`表示我们正在查看的手册章节。
- en: Sometimes a man page with the same name will exist in different sections. To
    specify a section, add a number before the command name. For example, to receive
    the same manual as above one might run `man 1 ls`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，具有相同名称的手册页可能会存在于不同的章节中。要指定某个章节，可以在命令名称前添加数字。例如，要查看与上述相同的手册，你可以运行`man 1 ls`。
- en: 'The sections on most Unix-like operating systems are as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数类Unix操作系统的手册章节如下：
- en: General commands, so commands that you typically run on the command line
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 常用命令，这些是你通常在命令行中运行的命令
- en: System calls
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统调用
- en: Library functions, covering the C standard library
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 库函数，涵盖C标准库
- en: Special files (usually devices, those found in `/dev`) and drivers
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 特殊文件（通常是设备文件，位于`/dev`目录下）和驱动程序
- en: File formats and conventions. This includes configuration files
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件格式和约定。这包括配置文件
- en: Games and screensavers
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 游戏和屏幕保护程序
- en: Miscellaneous
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 杂项
- en: System administration commands and daemons
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统管理命令和守护进程
- en: So, if you want to dig deeper into one of the topics we cover in this book,
    you’ll likely start by looking in manpage sections 1, 5, and 8.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果你想深入了解本书中涉及的某个主题，你很可能会从查看手册页的第1、5和8章开始。
- en: If you are unsure about what the name of the manual page you are looking for
    is, you can use `apropos <keyword>` or `man -k <keyword>` to find it. It will
    print a list of all manual pages containing the specified keyword.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不确定要查找的手册页面名称是什么，可以使用`apropos <keyword>`或`man -k <keyword>`来查找。它会打印出所有包含指定关键词的手册页面列表。
- en: Shell autocompletion
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Shell自动补全
- en: If you’re in an interactive shell session (i.e., not executing from a script
    or creating a Dockerfile), you can use **shell autocompletion**, also known as
    **tab-completion**, to construct commands with fewer keystrokes and a lower chance
    of typos.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个交互式Shell会话中（即，不是从脚本执行或创建Dockerfile），你可以使用**Shell自动补全**，也称为**Tab补全**，通过更少的按键和更低的拼写错误概率来构建命令。
- en: To make use of shell autocompletion, start typing a file or directory name and
    press *Tab*. The shell will progressively narrow your choices, displaying possible
    matches below the line you’re typing on. When there’s only one choice left based
    on what you’ve typed, the shell will autocomplete that command or argument and
    you can press *Enter*. Let’s walk through an example.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Shell自动补全，开始输入一个文件或目录名称并按*Tab*键。Shell将逐步缩小你的选择范围，显示你输入行下方的可能匹配项。当根据你输入的内容，只剩下一个选项时，Shell会自动完成该命令或参数，你可以按*Enter*键执行。让我们看一个示例。
- en: 'If you’re sitting in your home directory on a Linux desktop system, the view
    might look like this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在Linux桌面系统的主目录下，界面可能看起来像这样：
- en: '[PRE28]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If you want to move to the `Documents` directory, you’ll use the `cd` (change
    directory) command to do that:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想进入`Documents`目录，你可以使用`cd`（切换目录）命令来实现：
- en: '[PRE29]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'First, type `cd D` and hit *Tab*:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，输入`cd D`并按*Tab*键：
- en: '[PRE30]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You’ll see that the shell has narrowed the ten possible choices down to three.
    Type another letter and press *Tab* again. You’ll see that only two items match:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到，Shell已将十个可能的选项缩小为三个。再输入一个字母并按*Tab*键，你将看到只有两个匹配项：
- en: '[PRE31]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Typing another letter, `c`, will narrow the choices to just one and another
    *Tab* will autocomplete the directory name for you:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 输入另一个字母`c`，这将把选择范围缩小到只有一个选项，再按一次*Tab*键即可自动完成目录名称：
- en: '[PRE32]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As soon as you reach an autocompletion for a directory name, you can execute
    the command as usual with *Enter* or continue autocompleting inside of that directory.
    For example, pressing *Tab* again here will start the autocompletion process again
    inside of the `Documents` directory, leaving the `Documents/` prefix and autocompleting
    valid items to the right of the slash. Your shell’s current working directory
    won’t change until you have a valid path and press *Enter*.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成了目录名称的自动补全，你可以像平常一样按*Enter*键执行命令，或者继续在该目录内进行自动补全。例如，在这里按一次*Tab*键将重新开始在`Documents`目录内的自动补全过程，保留`Documents/`前缀，并自动完成斜杠右侧的有效项。直到你有一个有效路径并按下*Enter*键，Shell的当前工作目录才会改变。
- en: This small trick will save you a LOT of typing over the years. Start using it
    sooner rather than later!
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小技巧将为你节省大量的输入时间。越早开始使用它越好！
- en: Conclusion
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: In this chapter, you learned all the basic theory you need to know before working
    effectively on the command line. You saw practical examples of command-line syntax
    and learned the basics of how most commands accept arguments.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学习了在命令行上高效工作之前需要了解的所有基本理论。你看到了命令行语法的实际示例，并学习了大多数命令如何接受参数的基础知识。
- en: We also introduced the concept of shells and walked through how executables
    are looked up once you type a command and press the *Enter* key. Surprisingly,
    there are many advanced users who don’t fully understand these two concepts, and
    it hinders their ability to quickly and efficiently use command-line environments.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还介绍了Shell的概念，并演示了在你输入命令并按下*Enter*键后，如何查找可执行文件。令人惊讶的是，许多高级用户并不完全理解这两个概念，这会影响他们快速高效地使用命令行环境。
- en: Finally, you’ve learned the most important basic commands for getting around
    a system on the command line. You’ll use these commands almost every single time
    you work on a Linux system – they represent the absolute basics anyone needs to
    master before going further. You even learned your first time-saving trick, shell
    autocompletion.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你已经学会了在命令行系统中移动的最重要基本命令。你几乎每次操作Linux系统时都会使用这些命令——它们代表了任何人在进一步深入学习之前都必须掌握的绝对基础。你甚至学会了第一个省时技巧——Shell自动补全。
- en: If you’re following along and trying all of this on a real Linux system (and
    you *should* be!), make sure to practice what you’ve learned for a few minutes
    before moving on to the next chapter. We’ll build on that knowledge throughout
    the rest of this book.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在跟随并尝试在一个真实的Linux系统上操作（你*应该*这么做！），确保在进入下一章之前练习几分钟你所学到的内容。我们将在本书的其余部分建立在这些知识之上。
- en: Learn more on Discord
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Discord上了解更多
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入本书的 Discord 社区 —— 在这里你可以分享反馈、向作者提问，并了解新版本发布 —— 请扫描下面的二维码：
- en: '[https://packt.link/SecNet](https://packt.link/SecNet)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/SecNet](https://packt.link/SecNet)'
- en: '![](img/QR_Code17684224202100941871.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code17684224202100941871.png)'
