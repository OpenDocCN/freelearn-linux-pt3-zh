<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div id="_idContainer126" class="Basic-Text-Frame">
    <h1 class="chapterNumber"><a id="_idTextAnchor431"/>13</h1>
    <h1 id="_idParaDest-381" class="chapterTitle"><a id="_idTextAnchor432"/>Starting Up – The init Program</h1>
    <p class="normal">We looked at how the kernel boots up to the point where it launches the first program, <code class="inlineCode">init</code>, in <a href="Chapter_04.xhtml#_idTextAnchor096"><em class="italic">Chapter 4</em></a>. In <em class="italic">Chapters 5</em> and <em class="italic">6</em>, we looked at creating root filesystems of varying complexity, all of which contained an <code class="inlineCode">init</code> program. Now, it is time to look at the <code class="inlineCode">init</code> program itself in more detail and discover why it is so important to the rest of the system.</p>
    <p class="normal">There are many implementations of <code class="inlineCode">init</code>. In this chapter, I will describe the three main ones: BusyBox <code class="inlineCode">init</code>, System V <code class="inlineCode">init</code>, and <code class="inlineCode">systemd</code>. I will explain how they work and what types of systems are best suited for each. Part of this is balancing the tradeoff between size, complexity, and flexibility. We will learn how to launch a daemon using both BusyBox <code class="inlineCode">init</code> and System V <code class="inlineCode">init</code>. We will also learn how to add a service to <code class="inlineCode">systemd</code>.</p>
    <p class="normal">In this chapter, we will cover the following topics:</p>
    <ul>
      <li class="bulletList">After the kernel has booted</li>
      <li class="bulletList">Introducing the <code class="inlineCode">init</code> programs</li>
      <li class="bulletList">BusyBox <code class="inlineCode">init</code></li>
      <li class="bulletList">System V <code class="inlineCode">init</code></li>
      <li class="bulletList"><code class="inlineCode">systemd</code></li>
    </ul>
    <h1 id="_idParaDest-382" class="heading-1"><a id="_idTextAnchor433"/>Technical requirements</h1>
    <p class="normal">To follow along with the examples, make sure you have the following:</p>
    <ul>
      <li class="bulletList">An Ubuntu 24.04 or later LTS host system with at least 90 GB of free disk space</li>
      <li class="bulletList">Buildroot 2024.02.6 LTS release</li>
      <li class="bulletList">Yocto 5.0 (scarthgap) LTS release</li>
    </ul>
    <p class="normal">You should have already installed the 2024.02.6 LTS release of Buildroot for <a href="Chapter_04.xhtml#_idTextAnchor110"><em class="italic">Chapter 6</em></a>. If you have not, then refer to the <em class="italic">System requirements</em> section of <em class="italic">The Buildroot user manual</em> (<a href="https://buildroot.org/downloads/manual/manual.html)"><span class="url">https://buildroot.org/downloads/manual/manual.html)</span></a> before installing Buildroot on your Linux host according to the instructions from <a href="Chapter_04.xhtml#_idTextAnchor110"><em class="italic">Chapter 6</em></a>.</p>
    <p class="normal">You should have already built the 5.0 (scarthgap) LTS release of Yocto in <a href="Chapter_04.xhtml#_idTextAnchor110"><em class="italic">Chapter 6</em></a>. If you have not, then please refer to the <em class="italic">Compatible Linux Distribution</em> and <em class="italic">Build Host Packages</em> sections of the <em class="italic">Yocto Project Quick Build</em> guide (<a href="https://docs.yoctoproject.org/brief-yoctoprojectqs/"><span class="url">https://docs.yoctoproject.org/brief-yoctoprojectqs/</span></a>) before building Yocto on your Linux host according to the instructions in <a href="Chapter_04.xhtml#_idTextAnchor110"><em class="italic">Chapter 6</em></a>.</p>
    <p class="normal">The code used in this chapter can be found in the chapter folder in this book’s GitHub repository: <a href="https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development"><span class="url">https://github.com/PacktPublishing/Mastering-Embedded-Linux-Development</span></a>.</p>
    <h1 id="_idParaDest-383" class="heading-1"><a id="_idTextAnchor434"/>After the kernel has booted</h1>
    <p class="normal">In <a href="Chapter_04.xhtml#_idTextAnchor096"><em class="italic">Chapter 4</em></a>, we saw how the kernel <a id="_idIndexMarker940"/>bootstrap code looks for a root filesystem, either <code class="inlineCode">initramfs</code> or a filesystem specified by <code class="inlineCode">root=</code> on the kernel command line. The kernel bootstrap code then executes a <a id="_idIndexMarker941"/>program, which, by default, is <code class="inlineCode">/init</code> for <code class="inlineCode">initramfs</code> and <code class="inlineCode">/sbin/init</code> for a regular filesystem. The <code class="inlineCode">init</code> program has <code class="inlineCode">root</code> privilege, and since it is the first process to run, it has a <strong class="keyWord">process ID</strong> (<strong class="keyWord">PID</strong>) of 1. If, for some reason, <code class="inlineCode">init</code> cannot be started, the kernel will panic and the system will fail to boot.</p>
    <p class="normal">The <code class="inlineCode">init</code> program is the ancestor of all other processes, as shown here by the <code class="inlineCode">pstree</code> command running on a simple embedded Linux system:</p>
    <pre class="programlisting con"><code class="hljs-con"># pstree -gn
init(1)-+-syslogd(63)
        |-klogd(66)
        |-dropbear(99)
        `-sh(100)---pstree(109)
</code></pre>
    <p class="normal">The job of the <code class="inlineCode">init</code> program is to take control of the boot process in user space and set it running. It may be as simple as a shell command running a shell script—there is an example of this at the start of <a href="Chapter_05.xhtml#_idTextAnchor138"><em class="italic">Chapter 5</em></a>—but in most cases, you will use a dedicated <code class="inlineCode">init</code> daemon to perform the following tasks:</p>
    <ul>
      <li class="bulletList">Start other daemons and configure system parameters and other things needed to get the system into a working state.</li>
      <li class="bulletList">Optionally, launch a login daemon, such as <code class="inlineCode">getty</code>, on terminals that allow a login shell.</li>
      <li class="bulletList">Adopt processes that become orphaned due to their immediate parent terminating and there being no other processes in the thread group.</li>
      <li class="bulletList">Respond to any of its immediate children terminating by catching the <code class="inlineCode">SIGCHLD</code> signal and collecting the return value to prevent them from becoming zombie processes. I will talk more about zombies in <a href="Chapter_17.xhtml#_idTextAnchor542"><em class="italic">Chapter 17</em></a>.</li>
      <li class="bulletList">Optionally, restart other daemons that have terminated.</li>
      <li class="bulletList">Handle system shutdown.</li>
    </ul>
    <p class="normal">In other words, <code class="inlineCode">init</code> manages the life cycle of the system from bootup to shutdown. There is a school of thought that says <code class="inlineCode">init</code> is well placed to handle other runtime events such as new hardware and the loading and <a id="_idIndexMarker942"/>unloading of modules. This is what <code class="inlineCode">systemd</code> does.</p>
    <h1 id="_idParaDest-384" class="heading-1"><a id="_idTextAnchor435"/>Introducing the init programs</h1>
    <p class="normal">The three init programs you are most likely to encounter in embedded devices are BusyBox <code class="inlineCode">init</code>, System V <code class="inlineCode">init</code>, and <code class="inlineCode">systemd</code>. Buildroot<a id="_idIndexMarker943"/> offers all three with BusyBox <code class="inlineCode">init</code> as the default. The Yocto Project lets you choose between System V <code class="inlineCode">init</code> and <code class="inlineCode">systemd</code> with System V <code class="inlineCode">init</code> as the default. While Yocto’s tiny distribution ships with BusyBox <code class="inlineCode">init</code>, most other distro layers do not.</p>
    <p class="normal">The following table gives some metrics to compare the three:</p>
    <table id="table001-2" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Metric</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">BusyBox init</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">System V init</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">systemd</strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Complexity</p>
          </td>
          <td class="table-cell">
            <p class="normal">Low</p>
          </td>
          <td class="table-cell">
            <p class="normal">Medium</p>
          </td>
          <td class="table-cell">
            <p class="normal">High</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Bootup speed</p>
          </td>
          <td class="table-cell">
            <p class="normal">Fast</p>
          </td>
          <td class="table-cell">
            <p class="normal">Slow</p>
          </td>
          <td class="table-cell">
            <p class="normal">Medium</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Required shell</p>
          </td>
          <td class="table-cell">
            <p class="normal">ash</p>
          </td>
          <td class="table-cell">
            <p class="normal">dash or bash</p>
          </td>
          <td class="table-cell">
            <p class="normal">None</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Number of executables</p>
          </td>
          <td class="table-cell">
            <p class="normal">1(*)</p>
          </td>
          <td class="table-cell">
            <p class="normal">4</p>
          </td>
          <td class="table-cell">
            <p class="normal">50</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">libc</p>
          </td>
          <td class="table-cell">
            <p class="normal">Any</p>
          </td>
          <td class="table-cell">
            <p class="normal">Any</p>
          </td>
          <td class="table-cell">
            <p class="normal">glibc</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Size (MB)</p>
          </td>
          <td class="table-cell">
            <p class="normal">&lt; 0.1(*)</p>
          </td>
          <td class="table-cell">
            <p class="normal">0.1</p>
          </td>
          <td class="table-cell">
            <p class="normal">34(**)</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="packt_figref">Table 13.1 – Comparison of BusyBox init, System V init, and systemd</p>
    <p class="normal">(*) BusyBox <code class="inlineCode">init</code> is part of BusyBox’s single executable, which is optimized for size on disk.</p>
    <p class="normal">(**) Based on the Buildroot configuration of <code class="inlineCode">systemd</code>.</p>
    <p class="normal">Broadly speaking, there is an increase in flexibility and complexity as you go from BusyBox <code class="inlineCode">init</code> to <code class="inlineCode">systemd</code>.</p>
    <h1 id="_idParaDest-385" class="heading-1"><a id="_idTextAnchor436"/>BusyBox init</h1>
    <p class="normal">BusyBox has a minimal <code class="inlineCode">init</code> program that uses an <code class="inlineCode">/etc/inittab</code> configuration file to start programs at bootup and <a id="_idIndexMarker944"/>stop them at shutdown. The actual work is done by shell scripts, which, by convention, are placed in the <code class="inlineCode">/etc/init.d</code> directory.</p>
    <p class="normal"><code class="inlineCode">init</code> begins by reading <code class="inlineCode">/etc/inittab</code>. This file contains a list of programs to run, one per line, in this format:</p>
    <pre class="programlisting code"><code class="hljs-code">&lt;id&gt;::&lt;action&gt;:&lt;program&gt;
</code></pre>
    <p class="normal">The roles of these parameters are:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">id</code>: The controlling terminal for the command</li>
      <li class="bulletList"><code class="inlineCode">action</code>: When and how to run the program</li>
      <li class="bulletList"><code class="inlineCode">program</code>: The program to run along with all its command-line arguments</li>
    </ul>
    <p class="normal">The actions are:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">sysinit</code>: Runs the program when <code class="inlineCode">init</code> starts before any of the other types of actions.</li>
      <li class="bulletList"><code class="inlineCode">respawn</code>: Runs the program and restarts it if it terminates. It is used to run a program as a daemon.</li>
      <li class="bulletList"><code class="inlineCode">askfirst</code>: The same as <code class="inlineCode">respawn</code>, but it prints the message <strong class="screenText">Please press Enter to activate this console</strong> to the console and runs the program after <em class="italic">Enter</em> has been pressed. It is used to<a id="_idIndexMarker945"/> start an interactive shell on a terminal without prompting for a username or password.</li>
      <li class="bulletList"><code class="inlineCode">once</code>: Runs the program once but does not attempt to restart it if it terminates.</li>
      <li class="bulletList"><code class="inlineCode">wait</code>: Runs the program and waits for it to complete.</li>
      <li class="bulletList"><code class="inlineCode">restart</code>: Runs the program when <code class="inlineCode">init</code> receives the <code class="inlineCode">SIGHUP</code> signal, indicating that it should reload the <code class="inlineCode">inittab</code> file.</li>
      <li class="bulletList"><code class="inlineCode">ctrlaltdel</code>: Runs the program when <code class="inlineCode">init</code> receives the <code class="inlineCode">SIGINT</code> signal, usually as a result of pressing <em class="italic">Ctrl + Alt + Del</em> on the console.</li>
      <li class="bulletList"><code class="inlineCode">shutdown</code>: Runs the program when <code class="inlineCode">init</code> shuts down.</li>
    </ul>
    <p class="normal">Here is a small example that mounts <code class="inlineCode">proc</code> and <code class="inlineCode">sysfs</code> and then runs a shell on a serial interface:</p>
    <pre class="programlisting code"><code class="hljs-code">null::sysinit:/bin/mount -t proc proc /proc
null::sysinit:/bin/mount -t sysfs sysfs /sys
console::askfirst:-/bin/sh
</code></pre>
    <p class="normal">For simple projects in which you want to launch a small number of daemons and start a login shell on a serial terminal, it is easy to write the scripts manually. This is appropriate if you are creating a <strong class="keyWord">roll-your-own</strong> (<strong class="keyWord">RYO</strong>) embedded Linux. However, you will find that handwritten <code class="inlineCode">init</code> scripts rapidly become unmaintainable as the number of things to be configured increases. They are not very modular and need updating each time a new component is added or removed.</p>
    <h2 id="_idParaDest-386" class="heading-2"><a id="_idTextAnchor437"/>Buildroot init scripts</h2>
    <p class="normal">Buildroot has been making effective use of BusyBox <code class="inlineCode">init</code> for many years. Buildroot has two scripts in <code class="inlineCode">/etc/init.d/</code> named <code class="inlineCode">rcS</code> and <code class="inlineCode">rcK</code> (<code class="inlineCode">rc</code> stands for “run commands”). The <code class="inlineCode">rcS</code> script runs at bootup. It iterates over all the scripts in <code class="inlineCode">/etc/init.d/</code> with names that begin with a capital <code class="inlineCode">S</code> followed by two <a id="_idIndexMarker946"/>digits and runs them in numerical order. These are the start scripts. The <code class="inlineCode">rcK</code> script is run at shutdown. It iterates over all the scripts beginning with a capital <code class="inlineCode">K</code> followed by two digits and runs them in numerical order. These are the kill scripts.</p>
    <p class="normal">With this structure in place, it becomes easy for Buildroot packages to supply their own start and kill scripts so that the system becomes extensible. The two-digit number controls the order in which the <code class="inlineCode">init</code> scripts are run. If you are using Buildroot, this structure is transparent. If not, then you can use it as a model for writing your own BusyBox <code class="inlineCode">init</code> scripts.</p>
    <p class="normal">Like BusyBox <code class="inlineCode">init</code>, System V <code class="inlineCode">init</code> relies on shell scripts inside <code class="inlineCode">/etc/init.d</code> and an <code class="inlineCode">/etc/inittab</code> configuration file. While<a id="_idIndexMarker947"/> the two <code class="inlineCode">init</code> systems are similar in many ways, System V <code class="inlineCode">init</code> has more features and a much longer history.</p>
    <h1 id="_idParaDest-387" class="heading-1"><a id="_idTextAnchor438"/>System V init</h1>
    <p class="normal">This <code class="inlineCode">init</code> program was<a id="_idIndexMarker948"/> inspired by the one from Unix System V and dates back to the mid-1980s. The version most often found in Linux distributions was written initially by Miquel van Smoorenburg. Until recently, it was the <code class="inlineCode">init</code> daemon for almost all desktop and server distributions and a fair number of embedded systems as well. However, in recent years it has been replaced by <code class="inlineCode">systemd</code>, which we will describe in the next section.</p>
    <p class="normal">The BusyBox <code class="inlineCode">init</code> daemon is just a trimmed-down version of System V <code class="inlineCode">init</code>. System V <code class="inlineCode">init</code> has two advantages compared to BusyBox <code class="inlineCode">init</code>:</p>
    <ul>
      <li class="bulletList">Firstly, the boot scripts are written in a well-known modular format making it easy to add new packages at build time or runtime.</li>
      <li class="bulletList">Secondly, it has the concept of <strong class="keyWord">runlevels</strong>, which allow a collection of programs to be started or stopped in one go when switching from one runlevel to another.</li>
    </ul>
    <p class="normal">There are eight runlevels numbered from <code class="inlineCode">0</code> to <code class="inlineCode">6</code> plus <code class="inlineCode">S</code>:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">S</code>: Runs startup tasks</li>
      <li class="bulletList"><code class="inlineCode"><a id="_idTextAnchor439"/>0</code>: Halts the system</li>
      <li class="bulletList"><code class="inlineCode"><a id="_idTextAnchor440"/>1</code> to <code class="inlineCode">5</code>: Available for general use</li>
      <li class="bulletList"><code class="inlineCode"><a id="_idTextAnchor441"/>6</code>: Reboots the system</li>
    </ul>
    <p class="normal">Levels <code class="inlineCode">1</code> to <code class="inlineCode">5</code> can be used as desired. On most desktop Linux distributions, they are assigned as:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">1</code>: Single user</li>
      <li class="bulletList"><code class="inlineCode"><a id="_idTextAnchor442"/>2</code>: Multi-user without network configuration</li>
      <li class="bulletList"><code class="inlineCode"><a id="_idTextAnchor443"/>3</code>: Multi-user with network configuration</li>
      <li class="bulletList"><code class="inlineCode"><a id="_idTextAnchor444"/>4</code>: Not used</li>
      <li class="bulletList"><code class="inlineCode"><a id="_idTextAnchor445"/>5</code>: Multi-user with graphical login</li>
    </ul>
    <p class="normal">The <code class="inlineCode">init</code> program starts the default runlevel given by the <code class="inlineCode">initdefault</code> line in <code class="inlineCode">/etc/inittab</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">id:3:initdefault:
</code></pre>
    <p class="normal">You can change the runlevel at runtime using the <code class="inlineCode">telinit &lt;runlevel&gt;</code> command, which sends a message to <code class="inlineCode">init</code>. You can find the current runlevel and the previous one using the <code class="inlineCode">runlevel</code> command. Here is an example:</p>
    <pre class="programlisting con"><code class="hljs-con"># runlevel
N 5
# telinit 3
INIT: Switching to runlevel: 3
# runlevel
5 3
</code></pre>
    <p class="normal">The initial output from the <code class="inlineCode">runlevel</code> command is <code class="inlineCode">N 5</code>. An <code class="inlineCode">N</code> indicates that there is no previous runlevel because the runlevel has not changed since booting. The current runlevel is <code class="inlineCode">5</code>. After changing the runlevel, the output is <code class="inlineCode">5</code> <code class="inlineCode">3</code>, indicating that there has been a transition from <code class="inlineCode">5</code> to <code class="inlineCode">3</code>.</p>
    <p class="normal">The <code class="inlineCode">halt</code> and <code class="inlineCode">reboot</code> commands switch<a id="_idIndexMarker949"/> to runlevels <code class="inlineCode">0</code> and <code class="inlineCode">6</code>, respectively. You can override the default runlevel by giving a different one (a single digit from <code class="inlineCode">0</code> to <code class="inlineCode">6</code>) on the kernel command line. For example, to force the default runlevel to be single user, you append <code class="inlineCode">1</code> to the kernel command line like this:</p>
    <pre class="programlisting con"><code class="hljs-con">console=ttyAMA0 root=/dev/mmcblk1p2 1
</code></pre>
    <p class="normal">Each runlevel has a number of kill scripts that stop things, and another group of start scripts to get them going. When entering a new runlevel, <code class="inlineCode">init</code> first runs the kill scripts followed by the start scripts from the new level. Daemons that are currently running and have neither a start script nor a kill script in the new runlevel are sent a <code class="inlineCode">SIGTERM</code> signal. In other words, the default action when switching runlevels is to terminate daemons unless told otherwise.</p>
    <p class="normal">In truth, runlevels are not used much in embedded Linux. Most devices simply boot to the default runlevel and stay there. I have a feeling this is partly because most people are not aware of them.</p>
    <div class="packt_tip">
      <p class="normal"><strong class="keyWord">Tip</strong></p>
      <p class="normal">Runlevels are a simple and convenient way to switch between modes, for example, from production to maintenance mode.</p>
    </div>
    <p class="normal">System V <code class="inlineCode">init</code> is an option in Buildroot and The Yocto Project. In both cases, the <code class="inlineCode">init</code> scripts have been stripped of any <code class="inlineCode">bash</code> shell specifics, so they will work with the BusyBox <code class="inlineCode">ash</code> shell. However, Buildroot cheats somewhat by replacing the BusyBox <code class="inlineCode">init</code> program with System V <code class="inlineCode">init</code> and adding an <code class="inlineCode">inittab</code> that mimics the behavior of BusyBox. Buildroot does not implement runlevels except for <code class="inlineCode">0</code> and <code class="inlineCode">6</code>, which halt or reboot the system.</p>
    <p class="normal">Next, let’s look at some of the details. The following examples are taken from The Yocto Project 5.0 release. Other Linux distributions may implement <code class="inlineCode">init</code> scripts a little differently.</p>
    <h2 id="_idParaDest-388" class="heading-2"><a id="_idTextAnchor446"/>inittab</h2>
    <p class="normal">The <code class="inlineCode">init</code> program begins by reading <a id="_idIndexMarker950"/>entries that define what happens at each runlevel from an <code class="inlineCode">/etc/inittab</code> configuration file. The format is an extended version of the BusyBox <code class="inlineCode">inittab</code> described in the preceding section. This is no surprise since BusyBox borrowed it from System V in the first place.</p>
    <p class="normal">The format of each entry in the <code class="inlineCode">inittab</code> is:</p>
    <pre class="programlisting code"><code class="hljs-code">&lt;id&gt;:&lt;runlevels&gt;:&lt;action&gt;:&lt;process&gt;
</code></pre>
    <p class="normal">The fields are:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">id</code>: A unique identifier of up to four characters</li>
      <li class="bulletList"><code class="inlineCode">runlevels</code>: The runlevels this entry belongs to</li>
      <li class="bulletList"><code class="inlineCode">action</code>: When and how to run the command</li>
      <li class="bulletList"><code class="inlineCode">process</code>: The command to run</li>
    </ul>
    <p class="normal">The actions are the same as for BusyBox <code class="inlineCode">init</code>: <code class="inlineCode">sysinit</code>, <code class="inlineCode">respawn</code>, <code class="inlineCode">once</code>, <code class="inlineCode">wait</code>, <code class="inlineCode">restart</code>, <code class="inlineCode">ctrlaltdel</code>, and <code class="inlineCode">shutdown</code>. However, System V <code class="inlineCode">init</code> does not have <code class="inlineCode">askfirst</code>, which is specific to BusyBox.</p>
    <p class="normal">Here is the complete <code class="inlineCode">inittab</code> supplied by<a id="_idIndexMarker951"/> The Yocto Project when building <code class="inlineCode">core-image-minimal</code> for the <code class="inlineCode">qemuarm</code> machine:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># /etc/inittab: init(8) configuration.</span>
<span class="hljs-comment"># $Id: inittab,v 1.91 2002/01/25 13:35:21 miquels Exp $</span>
<span class="hljs-comment"># The default runlevel.</span>
<span class="hljs-built_in">id</span>:5:initdefault:
<span class="hljs-comment"># Boot-time system configuration/initialization script.</span>
<span class="hljs-comment"># This is run first except when booting in emergency (-b) mode.</span>
si::sysinit:/etc/init.d/rcS
<span class="hljs-comment"># What to do in single-user mode.</span>
~~:S:<span class="hljs-built_in">wait</span>:/sbin/sulogin
<span class="hljs-comment"># /etc/init.d executes the S and K scripts upon change</span>
<span class="hljs-comment"># of runlevel.</span>
<span class="hljs-comment">#</span>
<span class="hljs-comment"># Runlevel 0 is halt.</span>
<span class="hljs-comment"># Runlevel 1 is single-user.</span>
<span class="hljs-comment"># Runlevels 2-5 are multi-user.</span>
<span class="hljs-comment"># Runlevel 6 is reboot.</span>
l0:0:<span class="hljs-built_in">wait</span>:/etc/init.d/rc 0
l1:1:<span class="hljs-built_in">wait</span>:/etc/init.d/rc 1
l2:2:<span class="hljs-built_in">wait</span>:/etc/init.d/rc 2
l3:3:<span class="hljs-built_in">wait</span>:/etc/init.d/rc 3
l4:4:<span class="hljs-built_in">wait</span>:/etc/init.d/rc 4
l5:5:<span class="hljs-built_in">wait</span>:/etc/init.d/rc 5
l6:6:<span class="hljs-built_in">wait</span>:/etc/init.d/rc 6
<span class="hljs-comment"># Normally not reached, but fallthrough in case of emergency.</span>
z6:6:respawn:/sbin/sulogin
AMA0:12345:respawn:/sbin/getty 115200 ttyAMA0
<span class="hljs-comment"># /sbin/getty invocations for the runlevels</span>
<span class="hljs-comment">#</span>
<span class="hljs-comment"># The "id" field MUST be the same as the last</span>
<span class="hljs-comment"># characters of the device (after "tty").</span>
<span class="hljs-comment">#</span>
<span class="hljs-comment"># Format:</span>
<span class="hljs-comment"># &lt;id&gt;:&lt;runlevels&gt;:&lt;action&gt;:&lt;process&gt;</span>
<span class="hljs-comment">#</span>
1:2345:respawn:/sbin/getty 38400 tty1
</code></pre>
    <p class="normal">The first <code class="inlineCode">id:5:initdefault</code> entry sets the default runlevel to <code class="inlineCode">5</code>. The next <code class="inlineCode">si::sysinit</code> entry runs the <code class="inlineCode">/etc/init.d/rcS</code> script at <a id="_idIndexMarker952"/>bootup. All the <code class="inlineCode">rcS</code> script does is enter the <code class="inlineCode">S</code> runlevel:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">#!/bin/sh</span>
&lt;…&gt;
<span class="hljs-built_in">exec</span> /etc/init.d/rc S
</code></pre>
    <p class="normal">Hence, the first runlevel entered is <code class="inlineCode">S</code>, followed by the default runlevel of <code class="inlineCode">5</code>. Note that runlevel <code class="inlineCode">S</code> is not recorded and is never displayed as a prior runlevel by the <code class="inlineCode">runlevel</code> command.</p>
    <p class="normal">The seven entries beginning with <code class="inlineCode">l0</code> to <code class="inlineCode">l6</code> run the <code class="inlineCode">/etc/init.d/rc</code> script whenever there is a change to the runlevel. The <code class="inlineCode">rc</code> script is responsible for processing the start and kill scripts.</p>
    <p class="normal">Scan down a bit further for an entry that runs a <code class="inlineCode">getty</code> daemon:</p>
    <pre class="programlisting code"><code class="hljs-code">AMA0:12345:respawn:/sbin/getty 115200 ttyAMA0
</code></pre>
    <p class="normal">This entry generates a login prompt on <code class="inlineCode">/dev/ttyAMA0</code> when entering runlevels <code class="inlineCode">1</code> through <code class="inlineCode">5</code> allowing you to log in and get an interactive shell. The <code class="inlineCode">ttyAMA0</code> device is the serial console on the Arm Versatile board emulated by QEMU. The device name may be different for serial consoles on other development boards.</p>
    <p class="normal">The last entry runs another <code class="inlineCode">getty</code> daemon on <code class="inlineCode">/dev/tty1</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">1:2345:respawn:/sbin/getty 38400 tty1
</code></pre>
    <p class="normal">This entry is triggered when entering runlevels <code class="inlineCode">2</code> through <code class="inlineCode">5</code>. The <code class="inlineCode">tty1</code> device is a virtual console that is mapped to a graphical screen when you build your kernel with <code class="inlineCode">CONFIG_FRAMEBUFFER_CONSOLE</code> or <code class="inlineCode">VGA_CONSOLE</code>.</p>
    <p class="normal">Desktop Linux distributions usually spawn six <code class="inlineCode">getty</code> daemons on virtual terminals 1 to 6, with <code class="inlineCode">tty7</code> reserved for the graphical screen. Ubuntu and Arch Linux are notable exceptions since they use <code class="inlineCode">tty1</code> for graphics. You can switch between virtual terminals with key combinations <em class="italic">Ctrl + Alt + F1</em> through <em class="italic">Ctrl + Alt + F6</em>. Virtual terminals are seldom used on embedded devices.</p>
    <h2 id="_idParaDest-389" class="heading-2"><a id="_idTextAnchor447"/>The init.d scripts</h2>
    <p class="normal">Each component that needs to respond to a runlevel change has a script in <code class="inlineCode">/etc/init.d</code> to perform the change. The script<a id="_idIndexMarker953"/> should expect two parameters: <code class="inlineCode">start</code> and <code class="inlineCode">stop</code>. I will give an example of each in the <em class="italic">Adding a new daemon</em> section.</p>
    <p class="normal">The <code class="inlineCode">/etc/init.d/rc</code> runlevel-handling script takes the runlevel it is switching to as a parameter. There is a directory named <code class="inlineCode">rc&lt;runlevel&gt;.d</code> for each runlevel:</p>
    <pre class="programlisting con"><code class="hljs-con"># ls -d /etc/rc*
/etc/rc0.d  /etc/rc2.d  /etc/rc4.d  /etc/rc6.d
/etc/rc1.d  /etc/rc3.d  /etc/rc5.d  /etc/rcS.d
</code></pre>
    <p class="normal">There you will find a set of scripts beginning with a capital <code class="inlineCode">S</code> followed by two digits. You may also find scripts beginning with a capital <code class="inlineCode">K</code>. These are the start and kill scripts. Here is an example of the scripts for runlevel <code class="inlineCode">5</code>:</p>
    <pre class="programlisting con"><code class="hljs-con"># ls /etc/rc5.d
S01networking   S20hwclock.sh  S99rmnologin.sh  S99stop-bootlogd
S15mountnfs.sh  S20syslog
</code></pre>
    <p class="normal">These are, in fact, symbolic links back to their corresponding scripts in <code class="inlineCode">init.d</code>. The <code class="inlineCode">rc</code> script first runs all the scripts beginning with a <code class="inlineCode">K</code> passing in the <code class="inlineCode">stop</code> parameter. Then it runs all the scripts beginning with an <code class="inlineCode">S</code> passing in the <code class="inlineCode">start</code> parameter. Once again, the two-digit codes are there to impart the order in which to execute the scripts.</p>
    <h2 id="_idParaDest-390" class="heading-2"><a id="_idTextAnchor448"/>Adding a new daemon</h2>
    <p class="normal">Imagine that you have a program <a id="_idIndexMarker954"/>named <code class="inlineCode">simpleserver</code> that is written as a traditional Unix daemon; in other words, it forks and runs in the background. The code for this program is in <code class="inlineCode">MELD/Chapter13/simpleserver</code>. The corresponding <code class="inlineCode">init.d</code> script (see below) is in <code class="inlineCode">MELD/Chapter13/simpleserver-sysvinit/init.d</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">#! /bin/sh</span>
<span class="hljs-keyword">case</span> <span class="hljs-string">"</span><span class="hljs-variable">$1</span><span class="hljs-string">"</span> <span class="hljs-keyword">in</span>
   start)
<span class="hljs-built_in">     echo</span> <span class="hljs-string">"Starting simpelserver"</span>
     start-stop-daemon -S -n simpleserver -a /usr/bin/simpleserver
     ;;
   stop)
<span class="hljs-built_in">     echo</span> <span class="hljs-string">"Stopping simpleserver"</span>
     start-stop-daemon -K -n simpleserver
     ;;
   *)
<span class="hljs-built_in">     echo</span> <span class="hljs-string">"Usage: </span><span class="hljs-variable">$0</span><span class="hljs-string"> {start|stop}"</span>
<span class="hljs-built_in">     exit</span> 1
<span class="hljs-keyword">esac</span>
<span class="hljs-built_in">exit</span> 0
</code></pre>
    <p class="normal"><code class="inlineCode">start-stop-daemon</code> is a program that makes it easier to manipulate background processes. It originally came from the Debian installer package (<code class="inlineCode">dpkg</code>) but most embedded systems use the one from BusyBox. Running <code class="inlineCode">start-stop-daemon</code> with the <code class="inlineCode">-S</code> parameter starts the daemon, making sure that there is never more <a id="_idIndexMarker955"/>than one instance running at any one time. Running <code class="inlineCode">start-stop-daemon</code> with the <code class="inlineCode">-K</code> parameter stops the daemon by sending it a signal, <code class="inlineCode">SIGTERM</code> by default, to indicate to the daemon that it is time to terminate.</p>
    <p class="normal">To make <code class="inlineCode">simpleserver</code> operational, copy the <code class="inlineCode">init.d</code> script to <code class="inlineCode">/etc/init.d</code> and make it executable. Then, add links from each of the runlevels that you want to run this program from—in this case, only the default runlevel of <code class="inlineCode">5</code>:</p>
    <pre class="programlisting con"><code class="hljs-con"># cd /etc/init.d/rc5.d
# ln -s ../init.d/simpleserver S99simpleserver
</code></pre>
    <p class="normal">The number <code class="inlineCode">99</code> means that this will be one of the last programs to start.</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">Important note</strong></p>
      <p class="normal">Bear in mind that there may be other links beginning with <code class="inlineCode">S99</code>, in which case the <code class="inlineCode">rc</code> script will just run them in lexical order.</p>
    </div>
    <p class="normal">It is rare in embedded devices to have to worry too much about shutdown operations, but if there is something that needs to be done, add kill links to levels <code class="inlineCode">0</code> and <code class="inlineCode">6</code>:</p>
    <pre class="programlisting con"><code class="hljs-con"># cd /etc/init.d/rc0.d
# ln -s ../init.d/simpleserver K01simpleserver
# cd /etc/init.d/rc6.d
# ln -s ../init.d/simpleserver K01simpleserver
</code></pre>
    <p class="normal">We can circumvent runlevels and ordering for more immediate testing and debugging of <code class="inlineCode">init.d</code> scripts.</p>
    <h2 id="_idParaDest-391" class="heading-2"><a id="_idTextAnchor449"/>Starting and stopping services</h2>
    <p class="normal">You can interact with the <a id="_idIndexMarker956"/>scripts in <code class="inlineCode">/etc/init.d</code> by calling them directly. Here is an <a id="_idIndexMarker957"/>example using the <code class="inlineCode">syslog</code> script that controls the <code class="inlineCode">syslogd</code> and <code class="inlineCode">klogd</code> daemons:</p>
    <pre class="programlisting con"><code class="hljs-con"># /etc/init.d/syslog --help
Usage: syslog { start | stop | restart }
# /etc/init.d/syslog stop
Stopping syslogd/klogd: stopped syslogd (pid 198)
stopped klogd (pid 201)
done
# /etc/init.d/syslog start
Starting syslogd/klogd: done
</code></pre>
    <p class="normal">All scripts implement <code class="inlineCode">start</code> and <code class="inlineCode">stop</code>, and they should also implement <code class="inlineCode">help</code>. Some implement <code class="inlineCode">status</code> as well, which will tell you whether the service is running or not. Mainstream distributions that still use System V <code class="inlineCode">init</code> have a command named <code class="inlineCode">service</code> to start and stop services, which hides<a id="_idIndexMarker958"/> the details of calling the scripts directly.</p>
    <p class="normal">System V <code class="inlineCode">init</code> is a simple <code class="inlineCode">init</code> daemon that has served Linux admins for decades. While runlevels offer a greater <a id="_idIndexMarker959"/>degree of sophistication than BusyBox <code class="inlineCode">init</code>, System V <code class="inlineCode">init</code> still lacks the ability to monitor services and restart them if needed. As System V <code class="inlineCode">init</code> starts to show its age, most popular Linux distributions have moved on to <code class="inlineCode">systemd</code>.</p>
    <h1 id="_idParaDest-392" class="heading-1"><a id="_idTextAnchor450"/>systemd</h1>
    <p class="normal"><code class="inlineCode">systemd</code> (<a href="https://systemd.io/"><span class="url">https://systemd.io/</span></a>) defines itself as a <em class="italic">system and service manager</em>. The project was initiated in 2010 by Lennart <a id="_idIndexMarker960"/>Poettering and Kay Sievers to create an integrated set of tools for managing a Linux system based around an <code class="inlineCode">init</code> daemon. It also includes device management (<code class="inlineCode">udev</code>) and logging, among <a id="_idIndexMarker961"/>many other things. <code class="inlineCode">systemd</code> is state of the art and is still evolving rapidly. It is common on desktop and server Linux distributions and is becoming increasingly popular on embedded Linux systems. So, how is it better than System V <code class="inlineCode">init</code>?</p>
    <ul>
      <li class="bulletList">Configuration is simpler and more logical (once you understand it). Instead of convoluted shell scripts, <code class="inlineCode">systemd</code> has unit <a id="_idIndexMarker962"/>configuration files that are written in a well-defined format.</li>
      <li class="bulletList">There are explicit dependencies between services. This is a huge improvement over two-digit numbers that only control the order in which scripts are executed.</li>
      <li class="bulletList">It is easy to set the permissions and resource limits for each service in the interest of security.</li>
      <li class="bulletList">It can monitor services and restart them if needed.</li>
      <li class="bulletList">Services are started in parallel, reducing boot time.</li>
    </ul>
    <p class="normal">A complete description of <code class="inlineCode">systemd</code> is not possible here. As with System V <code class="inlineCode">init</code>, I will focus on the embedded use cases with examples based on The Yocto Project 5.0 release with <code class="inlineCode">systemd</code> version 255.</p>
    <h2 id="_idParaDest-393" class="heading-2"><a id="_idTextAnchor451"/>Building systemd with The Yocto Project and Buildroot</h2>
    <p class="normal">The default <code class="inlineCode">init</code> daemon<a id="_idIndexMarker963"/> in The Yocto Project is System V. To select <code class="inlineCode">systemd</code>, add this line to your <code class="inlineCode">conf/local.conf</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">INIT_MANAGER = <span class="hljs-string">"systemd"</span>
</code></pre>
    <p class="normal">Buildroot uses BusyBox <code class="inlineCode">init</code> by default. You can select <code class="inlineCode">systemd</code> through <code class="inlineCode">menuconfig</code> by looking in the <strong class="screenText">System configuration | Init system</strong> menu. You will also have to configure the toolchain to use <code class="inlineCode">glibc</code> for the C library since <code class="inlineCode">systemd</code> does not officially support <code class="inlineCode">uClibc-ng</code> or <code class="inlineCode">musl</code>. In addition, there are restrictions on the version and configuration of the kernel. There is a complete list of library and kernel dependencies in the <code class="inlineCode">README</code> file at the top level of the <code class="inlineCode">systemd</code> source code.</p>
    <h2 id="_idParaDest-394" class="heading-2"><a id="_idTextAnchor452"/>Introducing targets, services, and units</h2>
    <p class="normal">Before I describe how <code class="inlineCode">systemd</code> works, I need to introduce three key concepts:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Unit</strong>: A configuration<a id="_idIndexMarker964"/> file that describes a target, a service, or several other things. Units are text files that <a id="_idIndexMarker965"/>contain properties and values.</li>
      <li class="bulletList"><strong class="keyWord">Service</strong>: A daemon that <a id="_idIndexMarker966"/>can be started <a id="_idIndexMarker967"/>and stopped, much like a System V <code class="inlineCode">init</code> service.</li>
      <li class="bulletList"><strong class="keyWord">Target</strong>: A group of services, similar to <a id="_idIndexMarker968"/>a System V <code class="inlineCode">init</code> runlevel. There is a <a id="_idIndexMarker969"/>default target consisting of all the services that are started at boot time.</li>
    </ul>
    <p class="normal">You can change states and find out what is going on using the <code class="inlineCode">systemctl</code> command.</p>
    <h3 id="_idParaDest-395" class="heading-3"><a id="_idTextAnchor453"/>Units</h3>
    <p class="normal">The basic item of configuration<a id="_idIndexMarker970"/> is the <strong class="keyWord">unit</strong> file. Unit files are found in four different places:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">/etc/systemd/system</code>: Local configuration</li>
      <li class="bulletList"><code class="inlineCode">/run/systemd/system</code>: Runtime configuration</li>
      <li class="bulletList"><code class="inlineCode">/usr/lib/systemd/system:</code> Distribution-wide configuration (default location)</li>
      <li class="bulletList"><code class="inlineCode">/lib/systemd/system</code>: Distribution-wide configuration (legacy default location)</li>
    </ul>
    <p class="normal">When looking for a unit, <code class="inlineCode">systemd</code> searches <a id="_idIndexMarker971"/>these directories in the preceding order, stopping as soon as it finds a match. You can override the behavior of a distribution-wide unit by placing a unit of the same name in <code class="inlineCode">/etc/systemd/system</code>. You can also disable a unit completely by creating a local file that is empty or linked to <code class="inlineCode">/dev/null</code>.</p>
    <p class="normal">All unit files begin with a section marked <code class="inlineCode">[Unit]</code> that contains basic information and dependencies. For example, here is the <code class="inlineCode">Unit</code> section of the D-Bus service <code class="inlineCode">/lib/systemd/system/dbus.service</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">[Unit]
Description=D-Bus System Message Bus
Documentation=man:dbus-daemon(1)
Requires=dbus.socket
</code></pre>
    <p class="normal">In addition to the description and a reference to the documentation, there is a dependency on the <code class="inlineCode">dbus.socket</code> unit expressed through the <code class="inlineCode">Requires</code> keyword. This tells <code class="inlineCode">systemd</code> to create a local socket when the D-Bus service is started.</p>
    <p class="normal">Dependencies are expressed by the <code class="inlineCode">Requires</code>, <code class="inlineCode">Wants</code>, and <code class="inlineCode">Conflicts</code> keywords:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">Requires</code>: A list of units <a id="_idIndexMarker972"/>that this unit depends on; these are started when this unit is started.</li>
      <li class="bulletList"><code class="inlineCode">Wants</code>: A weaker form of <code class="inlineCode">Requires</code>; this unit continues even when any of these dependencies fails to start.</li>
      <li class="bulletList"><code class="inlineCode">Conflicts</code>: A negative dependency; these units are stopped when this one is started, and conversely, if one of them is subsequently restarted, then this one is stopped.</li>
    </ul>
    <p class="normal">These three keywords define <strong class="keyWord">outgoing dependencies</strong>. They are used to create dependencies between <em class="italic">targets</em>. There is another set of dependencies called <strong class="keyWord">incoming dependencies</strong>, which are used to create links between <em class="italic">services</em> and <em class="italic">targets</em>. In other words, outgoing dependencies are used to create the list of targets that need to be started as the system goes from one state to another, and incoming dependencies are used to determine the services that should be started or stopped when entering any state. Incoming dependencies are created by the <code class="inlineCode">WantedBy</code> keyword, which I will describe in the upcoming section, <em class="italic">Adding your own service</em>.</p>
    <p class="normal">Processing the dependencies produces a list of units that should be started or stopped. The <code class="inlineCode">Before</code> and <code class="inlineCode">After</code> keywords determine the order in which they are started. The stop order is simply the reverse of the <a id="_idIndexMarker973"/>start order:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">Before</code>: Start this unit before the units listed.</li>
      <li class="bulletList"><code class="inlineCode">After</code>: Start this unit after the units listed.</li>
    </ul>
    <p class="normal">For example, the <code class="inlineCode">After</code> directive ensures that the following web server is started after the network subsystem is started:</p>
    <pre class="programlisting code"><code class="hljs-code">[Unit]
Description=Lighttpd Web Server
After=network.target
</code></pre>
    <p class="normal">In the absence of a <code class="inlineCode">Before</code> or <code class="inlineCode">After</code> directive, the units are started or stopped in parallel with no ordering.</p>
    <h3 id="_idParaDest-396" class="heading-3"><a id="_idTextAnchor454"/>Services</h3>
    <p class="normal">A <strong class="keyWord">service</strong> is a daemon that <a id="_idIndexMarker974"/>can be started and stopped like a System V <code class="inlineCode">init</code> service. A service has a<a id="_idIndexMarker975"/> unit file with a name ending in <code class="inlineCode">.service</code>.</p>
    <p class="normal">A service unit has a <code class="inlineCode">[Service]</code> section that describes how the service should be run. Here is the <code class="inlineCode">[Service]</code> section from <code class="inlineCode">lighttpd.service</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">[Service]
ExecStart=/usr/sbin/lighttpd -f /etc/lighttpd/lighttpd.conf -D
ExecReload=/bin/kill -HUP $MAINPID
</code></pre>
    <p class="normal">These are the commands to run when starting and restarting the service. There are many more configuration points you can add here so refer to the manual page for <code class="inlineCode">systemd.service(5)</code>.</p>
    <h3 id="_idParaDest-397" class="heading-3"><a id="_idTextAnchor455"/>Targets</h3>
    <p class="normal">A <strong class="keyWord">target</strong> is a unit that <a id="_idIndexMarker976"/>groups services or other types of units together. A target is a metaservice in<a id="_idIndexMarker977"/> that respect and serves as a synchronization point. A target only has dependencies. Targets have names ending in <code class="inlineCode">.target</code> like <code class="inlineCode">multi-user.target</code>. A target is a desired state that performs the same role as System V <code class="inlineCode">init</code> runlevels. Here is the complete <code class="inlineCode">multi-user.target</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">[Unit]
Description=Multi-User System
Documentation=man:systemd.special(7)
Requires=basic.target
Conflicts=rescue.service rescue.target
After=basic.target rescue.service rescue.target
AllowIsolate=yes
</code></pre>
    <p class="normal">This says that the basic target must be started before the multi-user target. This also says that since it conflicts with the rescue target, starting the rescue target will cause the multi-user target to be stopped <a id="_idIndexMarker978"/>first. The rescue and multi-user targets cannot run simultaneously because the rescue target boots into single-user mode. Activating the rescue target only makes sense during system recovery.</p>
    <h2 id="_idParaDest-398" class="heading-2"><a id="_idTextAnchor456"/>How systemd boots the system</h2>
    <p class="normal">Let’s see how <code class="inlineCode">systemd</code> implements <a id="_idIndexMarker979"/>the bootstrap. The kernel starts <code class="inlineCode">systemd</code> because <code class="inlineCode">/sbin/init</code> is symbolically linked to <code class="inlineCode">/lib/systemd/systemd</code>. <code class="inlineCode">systemd</code> runs <code class="inlineCode">default.target</code>, which is always a link to the desired target: either <code class="inlineCode">multi-user.target</code> for a text login or <code class="inlineCode">graphical.target</code> for a graphical environment. If the default target is <code class="inlineCode">multi-user.target</code>, you will see this symbolic link:</p>
    <pre class="programlisting con"><code class="hljs-con">/etc/systemd/system/default.target -&gt; /lib/systemd/system/multi-user.target
</code></pre>
    <p class="normal">Override the default target by passing <code class="inlineCode">system.unit=&lt;new target&gt;</code> on the kernel command line.</p>
    <p class="normal">To discover the default target:</p>
    <pre class="programlisting con"><code class="hljs-con"># systemctl get-default
multi-user.target
</code></pre>
    <p class="normal">Starting a target like <code class="inlineCode">multi-user.target</code> creates a tree of dependencies that bring the system into a working state. In a typical system, <code class="inlineCode">multi-user.target</code> depends on <code class="inlineCode">basic.target</code>, which depends on <code class="inlineCode">sysinit.target</code>, which depends on the services that need to be started early.</p>
    <p class="normal">To print a text graph of system dependencies:</p>
    <pre class="programlisting con"><code class="hljs-con"># systemctl list-dependencies
</code></pre>
    <p class="normal">To list all services and their current states:</p>
    <pre class="programlisting con"><code class="hljs-con"># systemctl list-units --type service
</code></pre>
    <p class="normal">To list all targets:</p>
    <pre class="programlisting con"><code class="hljs-con"># systemctl list-units --type target
</code></pre>
    <p class="normal">Now that we’ve seen the dependency tree for the system, how do we insert an additional service?</p>
    <h2 id="_idParaDest-399" class="heading-2"><a id="_idTextAnchor457"/>Adding your own service</h2>
    <p class="normal">Here is a<a id="_idIndexMarker980"/> unit for our <code class="inlineCode">simpleserver</code> service:</p>
    <pre class="programlisting code"><code class="hljs-code">[Unit]
Description=Simple server
[Service]
Type=forking
ExecStart=/usr/bin/simpleserver
[Install]
WantedBy=multi-user.target
</code></pre>
    <p class="normal">You will find this <code class="inlineCode">simpleserver.service</code> file in <code class="inlineCode">MELD/Chapter13/simpleserver-systemd</code>.</p>
    <p class="normal">The <code class="inlineCode">[Unit]</code> section only contains a description that shows up under <code class="inlineCode">systemctl</code>. There are no dependencies since this service is very simple.</p>
    <p class="normal">The <code class="inlineCode">[Service]</code> section points to the executable and has a flag to indicate that it forks. If <code class="inlineCode">simpleserver</code> was even simpler and ran in the foreground, <code class="inlineCode">systemd</code> would do the daemonizing for us and <code class="inlineCode">Type=forking</code> would not be needed.</p>
    <p class="normal">The <code class="inlineCode">[Install]</code> section creates an incoming dependency on <code class="inlineCode">multi-user.target</code> so that our server is started when the system enters multi-user mode.</p>
    <p class="normal">Once you place the <code class="inlineCode">simpleserver.service</code> file in the <code class="inlineCode">/etc/systemd/system</code> directory, you can start and stop the service using the <code class="inlineCode">systemctl start simpleserver</code> and <code class="inlineCode">sytemctl stop simpleserver</code> commands. You can also use <code class="inlineCode">systemctl</code> to get its current status:</p>
    <pre class="programlisting con"><code class="hljs-con"># systemctl status simpleserver
simpleserver.service - Simple server
  Loaded: loaded (/etc/systemd/system/simpleserver.service; disabled)
  Active: active (running) since Thu 1970-01-01 02:20:50 UTC; 8s ago
Main PID: 180 (simpleserver)
  CGroup: /system.slice/simpleserver.service
          └─180 /usr/bin/simpleserver -n
Jan 01 02:20:50 qemuarm systemd[1]: Started Simple server.
</code></pre>
    <p class="normal">At this point, the service only starts and stops on command. To make it persistent, you need to add a permanent dependency to a target. The <code class="inlineCode">[Install]</code> section says that when this service is enabled, it becomes dependent on <code class="inlineCode">multi-user.target</code> so that it starts at boot time.</p>
    <p class="normal">To enable the service:</p>
    <pre class="programlisting con"><code class="hljs-con"># systemctl enable simpleserver
Created symlink from /etc/systemd/system/multiuser.target.wants/simpleserver.service to /etc/systemd/system/simpleserver.service.
</code></pre>
    <p class="normal">To update the <code class="inlineCode">systemd</code> dependency tree without rebooting:</p>
    <pre class="programlisting con"><code class="hljs-con"># systemctl daemon-reload
</code></pre>
    <p class="normal">You can also add <a id="_idIndexMarker981"/>dependencies to services without having to edit target unit files. A target can have a directory named <code class="inlineCode">&lt;target_name&gt;.target.wants</code> with links to services. Creating a link inside this directory is the same as adding a unit to the <code class="inlineCode">[Wants]</code> list in the target. The <code class="inlineCode">systemctl enable</code> <code class="inlineCode">simpleserver</code> command created the following link:</p>
    <pre class="programlisting con"><code class="hljs-con">/etc/systemd/system/multi-user.target.wants/simpleserver.service -&gt; /etc/systemd/system/simpleserver.service
</code></pre>
    <p class="normal">You might want to restart an important service if it crashes. To achieve that, add the following flag to the <code class="inlineCode">[Service]</code> section:</p>
    <pre class="programlisting code"><code class="hljs-code">Restart=on-abort
</code></pre>
    <p class="normal">The other <code class="inlineCode">Restart</code> options are <code class="inlineCode">on-success</code>, <code class="inlineCode">on-failure</code>, <code class="inlineCode">on-abnormal</code>, <code class="inlineCode">on-watchdog</code>, and <code class="inlineCode">always</code>.</p>
    <h2 id="_idParaDest-400" class="heading-2"><a id="_idTextAnchor458"/>Adding a watchdog</h2>
    <p class="normal">Many embedded systems require a <a id="_idIndexMarker982"/>watchdog: you need to act if a critical service stops. This usually means rebooting the system. Most embedded SoCs have a hardware watchdog that can be accessed via the <code class="inlineCode">/dev/watchdog</code> device node. The <strong class="keyWord">watchdog</strong> is initialized with a timeout at boot. If this timer is <a id="_idIndexMarker983"/>not reset within the timeout period, the watchdog is triggered and the system reboots. The interface with the watchdog driver is described in the kernel source under <code class="inlineCode">Documentation/watchdog/</code> and the code for the drivers is in <code class="inlineCode">drivers/watchdog/</code>.</p>
    <p class="normal">A problem arises when there are two or more critical services that need to be protected by a watchdog. <code class="inlineCode">systemd</code> has a useful feature that distributes the watchdog between multiple services. <code class="inlineCode">systemd</code> can be configured to expect a regular keepalive call from a service and act when no keepalive is received, creating a software watchdog. For this to work, you need to add code to the daemon to send the keepalive messages. The daemon reads the value of the <code class="inlineCode">WATCHDOG_USEC</code> environment variable and calls <code class="inlineCode">sd_notify(false, "WATCHDOG=1")</code> within this time period. The period <a id="_idIndexMarker984"/>should be set to about half the watchdog timeout. There are examples in the <code class="inlineCode">systemd</code> source code.</p>
    <p class="normal">To enable the software watchdog in a service unit, add something like this to the <code class="inlineCode">[Service]</code> section:</p>
    <pre class="programlisting code"><code class="hljs-code">WatchdogSec=30s
Restart=on-watchdog
StartLimitInterval=5min
StartLimitBurst=4
StartLimitAction=reboot-force
</code></pre>
    <p class="normal">In this example, the service expects a keepalive call every 30 seconds. If the keepalive fails to be delivered, the service is restarted, but if it is restarted more than four times in 5 minutes, <code class="inlineCode">systemd</code> immediately reboots the entire system. There is a full description of these settings in the <code class="inlineCode">systemd.service(5)</code> manual page.</p>
    <p class="normal">A software watchdog takes care of individual services, but what if <code class="inlineCode">systemd</code> itself fails, the kernel crashes, or the <a id="_idIndexMarker985"/>hardware locks up? In those cases, we need to tell <code class="inlineCode">systemd</code> to use the hardware watchdog. Add <code class="inlineCode">RuntimeWatchdogSec=&lt;N&gt;</code> to <code class="inlineCode">/etc/systemd/system.conf</code>. This will reset the watchdog within the given <code class="inlineCode">N</code> period so that the system reboots if <code class="inlineCode">systemd</code> fails for some reason. This will be an immediate hard reboot or “reset” of the system without any graceful shutdown.</p>
    <h2 id="_idParaDest-401" class="heading-2"><a id="_idTextAnchor459"/>Implications for embedded Linux</h2>
    <p class="normal"><code class="inlineCode">systemd</code> has a lot of<a id="_idIndexMarker986"/> features that are useful for embedded Linux. This chapter only mentions some of them. The others include resource control (described in the manual pages for <code class="inlineCode">systemd.slice(5)</code> and <code class="inlineCode">systemd.resource-control(5)</code>), device<a id="_idIndexMarker987"/> management (<code class="inlineCode">udev(7)</code>), system logging facilities (<code class="inlineCode">journald(5)</code>), mount units for auto-mounting filesystems, and timer units for <code class="inlineCode">cron</code> jobs.</p>
    <p class="normal">You need to balance these features with <code class="inlineCode">systemd</code>'s size. Even a minimal build of just the core components (<code class="inlineCode">systemd</code>, <code class="inlineCode">udevd</code>, and <code class="inlineCode">journald</code>) approaches 10 MB of storage including shared libraries.</p>
    <p class="normal">You also need to keep in mind that <code class="inlineCode">systemd</code> development follows the kernel and <code class="inlineCode">glibc</code> closely, so a <code class="inlineCode">systemd</code> release won’t work on a kernel and <code class="inlineCode">glibc</code> more than a year or two older than itself.</p>
    <h1 id="_idParaDest-402" class="heading-1"><a id="_idTextAnchor460"/>Summary</h1>
    <p class="normal">Every Linux device needs an <code class="inlineCode">init</code> program of some kind. If you are designing a system that only needs to launch a small number of daemons at startup, then BusyBox <code class="inlineCode">init</code> is sufficient. BusyBox <code class="inlineCode">init</code> is also usually a good choice if you are using Buildroot as your build system.</p>
    <p class="normal">On the other hand, if you have a system with complex dependencies between services at boot time or runtime, then <code class="inlineCode">systemd</code> is the best choice. Even without such complexity, <code class="inlineCode">systemd</code> has some useful features like watchdogs, remote logging, and so on. If you have the storage space, you should seriously consider <code class="inlineCode">systemd</code>.</p>
    <p class="normal">Meanwhile, System V <code class="inlineCode">init</code> lives on. It is well understood and there are already <code class="inlineCode">init</code> scripts for every component that is important to us. System V remains the default <code class="inlineCode">init</code> for The Yocto Project reference distribution (Poky). In terms of boot time, <code class="inlineCode">systemd</code> is faster for similar workloads. However, if you are looking for the fastest boot, neither beats simple BusyBox <code class="inlineCode">init</code> with minimal boot scripts.</p>
    <h1 id="_idParaDest-403" class="heading-1"><a id="_idTextAnchor461"/>Further study</h1>
    <ul>
      <li class="bulletList"><em class="italic">systemd System and Service Manager</em> – <a href="https://systemd.io/"><span class="url">https://systemd.io/</span></a></li>
    </ul>
  </div>
</div></div></body></html>