- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PowerShell and the Web – HTTP, REST, and JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until now, we’ve worked in a very small space – our client machine. It’s
    nice, but the world doesn’t work like that. Pretty much every device we use is
    connected to other machines and also, usually, the internet. Devices need to be
    able to interact with services provided over the web to download data, interact
    with cloud applications, and play games. In this, chapter we’re going to look
    at ways we can use PowerShell to work with objects in the world outside our box.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start out with a brief chat about web services and then look at the basic
    PowerShell tool for interacting with them; `Invoke-WebRequest`. We’ll go on to
    look at `Invoke-RestMethod`, we’ll look at some of the ways of exchanging information
    with web services using **JavaScript Object Notation** (**JSON**), and the tools
    we use to convert JSON data into PowerShell objects, and vice versa. Finally,
    we’ll tackle a short exercise.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will give us the basic techniques we’ll need for some of the work
    we’ll do in later chapters of the book and build on some of the work we did in
    the last chapter. We’ll see that those techniques apply to data on the web as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we are going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with HTTP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting to grips with APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with REST
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with JSON
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with HTTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The world we live in has a dominant philosophy, a set of concepts and practices
    that has largely defined information technology for the last 30 years; the client/server
    paradigm. There are alternatives; centralized computing with dumb terminals, such
    as mainframe computing, thin client computing with applications such as Citrix,
    or peer-to-peer computing such as we might see in BitTorrent or blockchain applications.
    Tim Berners-Lee envisaged the World Wide Web as a peer-to-peer network, but it
    hasn’t really stayed that way. The client/server model is prevalent. In general,
    the device on our desk or in our hands is the client, and it is connected to a
    remote server to receive or manipulate information. It differs from a dumb terminal
    in that some of the processing is carried out on the client, and some of it on
    the server.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’re going to look at how information is exchanged between
    clients and servers on the internet using the foundational protocol of the World
    Wide Web; **Hypertext Transfer Protocol** (**HTTP**). This is the protocol we
    use to browse websites.
  prefs: []
  type: TYPE_NORMAL
- en: The basic cmdlet for working with HTTP in PowerShell is `Invoke-WebRequest`,
    so let’s have a look at how we can use the `Invoke-WebRequest` cmdlet to work
    with data on the web.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Invoke-WebRequest` cmdlet is an incredibly versatile tool that allows
    us to create an HTTP request and submit it to a web service. Because the range
    of requests we might make is huge, the cmdlet is pretty complicated, with over
    thirty parameters. Let’s start with the simple stuff. Let’s get a list of hyperlinks
    to relevant news topics. In a web browser, go to this address: [https://neuters.de](https://neuters.de).
    This is a text-based website that aggregates the most recent Reuters news articles.
    It’s nice and simple.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open PowerShell and type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This will send a `GET` request to the address and store the response in the
    `$``News` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s see what we’ve got by calling the contents of `$News`. Type this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see something that looks like the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Invoke-WebRequest gets the HTTP response](img/B17600_07_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – Invoke-WebRequest gets the HTTP response
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s great, but it’s not pretty. If we look a little closer at our output,
    we can see that one of the sections is called `Links`. We can use that to just
    get the hyperlinks from the page by calling it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, they are all relative links, but we should turn them into absolute
    links by adding the root location, which we can do quite easily. If we pipe the
    output of `$News.Links` to `Get-Member`, we can see that it has a property called
    `href`, which just contains the link, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – href property](img/B17600_07_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – href property
  prefs: []
  type: TYPE_NORMAL
- en: 'We can concatenate that with the root domain. Type the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'And you should see a list of absolute links, like in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Scraping the neuters.de site for links](img/B17600_07_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – Scraping the neuters.de site for links
  prefs: []
  type: TYPE_NORMAL
- en: If you got something like that, congratulations, you have just **scraped** your
    first website with PowerShell. Scraping is the process of automating the retrieval
    of data from a website.
  prefs: []
  type: TYPE_NORMAL
- en: '`Invoke-WebRequest` has only one mandatory parameter; `-Uri`. It is positional,
    so any string following the cmdlet will be treated as an input for this parameter.
    The `–Uri` parameter accepts the URL of the source.'
  prefs: []
  type: TYPE_NORMAL
- en: URI versus URL
  prefs: []
  type: TYPE_NORMAL
- en: We are probably all familiar with the acronym `http:` and `https:`, so an absolute
    URL would be [https://neuters.de](https://neuters.de), containing both the scheme
    (`https:`) and the address (`neuters.de`) separated by a double slash (`//`).
  prefs: []
  type: TYPE_NORMAL
- en: What about URNs, though? A URN consists of the scheme (`urn:`), one or more
    `urn:ietf:rfc:1149`, which identifies my favorite protocol definition.
  prefs: []
  type: TYPE_NORMAL
- en: The twist is that the `-Uri` parameter only supports the `http:` and `https:`
    schemes, so can only accept URLs. However, according to the World Wide Web Consortium,
    the international standards authority for the web, URI is a more precise and technically
    correct term than URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a closer look at some of the parameters that we can use with `Invoke-WebRequest`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-Method` will accept any of the standard HTTP methods: `GET`, `PUT`, `POST`,
    `DELETE`, and a few others. If we omit it, then the default method is `GET`. If
    we need to use a custom method, then we can use the `-CustomMethod` parameter.
    We can’t use both `-Method` and `-CustomMethod` in the same cmdlet. This parameter
    allows us to send information to a web address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-OutFile` specifies a path and name to write the output to a file. Note this
    only writes the response HTML to the file, not things such as the response code.
    This parameter prevents the output from being placed in the pipeline. If we want
    the output to be available to the pipeline and to be written to a file, then we
    need to use the `-PassThru` parameter as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Headers` can be used to submit specific header information as part of the
    web request. The information must take the form of a hashtable or dictionary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Body` can submit specific body content, such as a query. We can’t use `-Body`
    and `-Form` in the same cmdlet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Form`. The `-Form` parameter is used to submit information to an HTML form
    at the target address. We can find lots of information on the web about how to
    use the `-Form` parameter to quickly and easily log in to websites using Windows
    PowerShell. Unfortunately, most of them don’t work with PowerShell 7 because the
    HTML is parsed differently. We’ll discover why shortly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Proxy` allows us to specify an alternative proxy server to the one set on
    our client. It is normally used with either the `-ProxyUseDefaultCredentials`
    parameter, which passes the current user credentials to the proxy, or with the
    `-ProxyCredentials` parameter, which allows us to specify alternative credentials.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-NoProxy` lets us bypass the client proxy altogether. We can’t use it in the
    same cmdlet as `-Proxy`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-SessionVariable` can be used when connecting to a stateful web service; we
    can use the `-SessionVariable` the first time we run `Invoke-WebRequest`, and
    then use the `-WebSession` parameter with the same value for each subsequent connection
    to ensure we persist the session state. This is useful if we need to log in to
    a web service before using it. Note that we supply a string to `-SessionVariable`,
    but then supply the string as a variable to `-Websession`, like so:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`-SkipHttpErrorCheck`: By default, if `Invoke-WebRequest` gets a HTTP error
    code as a response, it will report it as an error, in red, rather than as an output.
    If we want to capture the error response and process it, then we can use this
    parameter. For an example, see the following figure:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 7.4 – Using -SkipHttpErrorCheck](img/B17600_07_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – Using -SkipHttpErrorCheck
  prefs: []
  type: TYPE_NORMAL
- en: In the figure here, the first cmdlet, in the red box, doesn’t use the `-SkipHttpErrorCheck`
    parameter, so PowerShell treats the response as an error. In the second cmdlet,
    in the green box, we’ve used the parameter and we can see the actual HTTP response
    that the server sent.
  prefs: []
  type: TYPE_NORMAL
- en: There are another thirty parameters we can use with `Invoke-WebRequest` but
    these are the most commonly used ones. Let’s take a look at why the `-Form` parameter
    isn’t as useful in PowerShell 7.
  prefs: []
  type: TYPE_NORMAL
- en: Why don’t we see Forms information in PowerShell 7?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we mentioned, the `-Form` parameter doesn’t work as well in PowerShell 7
    as it does in Windows PowerShell. If we examine the objects returned by `Invoke-WebRequest`
    with `Get-Member`, we can’t see the `Forms` property in PowerShell 7 but we can
    in Windows PowerShell. It’s worth taking a closer look and understanding why.
    The `Invoke-WebRequest` cmdlet produces different types of objects in PowerShell
    7 and Windows PowerShell. We can see in the following figure the difference in
    output. In the upper blue frame, we can see that Windows PowerShell produces objects
    with a `TypeName` of `HtmlWebResponseObject`, and we can see the properties of
    this type include `Forms`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – Invoke-WebRequest in Windows PowerShell](img/B17600_07_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5 – Invoke-WebRequest in Windows PowerShell
  prefs: []
  type: TYPE_NORMAL
- en: 'In PowerShell 7, next, we can see that we get a `BasicHtmlWebResponseObject`,
    which doesn’t have a `Forms` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – Invoke-WebRequest in PowerShell 7](img/B17600_07_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.6 – Invoke-WebRequest in PowerShell 7
  prefs: []
  type: TYPE_NORMAL
- en: This is because PowerShell 7 uses basic parsing by default.
  prefs: []
  type: TYPE_NORMAL
- en: In Windows PowerShell, we can use the information held in the `Forms` property
    of the web page to create a variable with properties that match the fields on
    the form, and then submit the variable as part of our cmdlet, using the `-Form`
    parameter. Because the objects returned by `Invoke-WebRequest` don’t have a property
    called `Forms`, many of the instructions found on the internet for using the cmdlet
    this way won’t work in PowerShell 7.
  prefs: []
  type: TYPE_NORMAL
- en: That doesn’t mean we can’t use `Invoke-WebRequest` to fill in forms, however.
    We just need to understand what the form fields are beforehand; we will struggle
    to work it out with PowerShell 7 alone. We also need to be aware that many of
    the examples we see on the internet are written for the Windows PowerShell version
    of the `Invoke-WebRequest` cmdlet.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Many websites use some form of authentication, so authentication is a big part
    of `Invoke-WebRequest`. The first thing to do is to set the type of authentication
    in use. We can use the `-UseDefaultCredentials` parameter to try and authenticate
    with the current environment login, but if we’re using an external address, rather
    than something inside our organization, then we will probably need to supply site-specific
    information. The `-Authentication` parameter accepts the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`None`: This is the default. If the `-Authentication` parameter is not filled,
    then `Invoke-WebRequest` will not use any authentication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Basic`: This will send a Base64-encoded set of credentials. Hopefully, we’re
    connecting to an HTTPS URL, because Base64 encoding is not the same as encryption.
    This is not a very secure way of sending credentials. We will also need to use
    the `-Credential` parameter to supply the username and password.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Bearer`: This will require a Bearer token to be supplied as a secure string
    using the `-Token` parameter. A token is basically a long string that can be used
    to identify the sender of the request. Bearer authentication is an HTTP authentication
    scheme that was developed as part of OAuth 2.0 – the Open Authorization standard.
    Not all bearer authentication is OAuth, however. Because we are passing a token
    assigned by the remote server, it should only be used over HTTPS so that it is
    encrypted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Oauth`: This is an open standard for access delegation. It’s used by many
    big internet companies such as Amazon, Google, and Microsoft to provide authorization
    and authentication. Usually, it takes a bearer token, as mentioned previously.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s have a look at how this works. On my client, I’ve installed PowerShell
    Universal, a module from the good people at Ironman Software (https://blog.ironmansoftware.com/).
    This lets me run a lightweight server on my client and create endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t try to do this on your client
  prefs: []
  type: TYPE_NORMAL
- en: It takes quite a lot of configuration that we’re not going to cover in this
    book and requires a subscription to use the authentication functions. I’m including
    it here so that we can see how the process works.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ve created an endpoint at `http://localhost:5000/me` that requires an authentication
    token to access. I’ve created the token on the server, and stored it as a secure
    string as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The token isn’t really `<mytoken>`; it’s a very much longer random string.
    Now I can access the endpoint by providing the token using the `$``apptoken` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the following figure, without supplying authentication, I
    get a `401` error; I’m unauthorized. When I supply authentication in the second
    cmdlet, I get the content of the page, `Hello World`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7 – Providing authentication using the -Authentication and -Token
    parameters](img/B17600_07_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.7 – Providing authentication using the -Authentication and -Token parameters
  prefs: []
  type: TYPE_NORMAL
- en: 'Quite often, however, we will need to provide authentication via the `-Headers`
    parameter. This is a little more involved than using `-Authentication`. We need
    to provide the token as part of the web request but point it to the correct header.
    In the case of my local test endpoint, I can do it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that if we supply the token in the header, we must *not* encode it using
    the `ConvertTo-SecureString` cmdlet. I’ve saved the unencoded token as `$admtoken`,
    (not `$apptoken`) as we can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8 – Passing authentication data using the -Headers parameter](img/B17600_07_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.8 – Passing authentication data using the -Headers parameter
  prefs: []
  type: TYPE_NORMAL
- en: In the first line, I’m trying to pass the encoded token, stored in the `$apptoken`
    variable. In the second line, I’m passing the unencoded token store in the `$``admtoken`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the `SecureString` object type provides a *measure of security*,
    according to Microsoft. It’s not truly secure. Read more here: [https://learn.microsoft.com/en-us/dotnet/api/system.security.securestring](https://learn.microsoft.com/en-us/dotnet/api/system.security.securestring).'
  prefs: []
  type: TYPE_NORMAL
- en: Now we’ve covered making basic requests, let’s take a look at how we can interact
    with websites more programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: Getting to grips with APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most modern systems communicate between client and server using an API. This
    is a list of agreed requests and responses between the two components. This sounds
    complicated, but it is quite simple. If we put the [https://random.dog/woof.json](https://random.dog/woof.json)
    URL into a browser, we get back the URL of a random dog, from a database of dog
    images. We also get the size of the file, in bytes.
  prefs: []
  type: TYPE_NORMAL
- en: Our browser is the client, and it sends an HTTP `GET` request to an API endpoint
    (`/woof.json`) on the server at the [https://random.dog](https://random.dog) URL.
    In response to this request, the server sends a message containing a URL back
    to us, in the first frame in the following figure. We can look at the headers
    in the second frame below and see that the content type is **JSON**. We can then
    display the URL in a browser to see a picture of an adorable dog, below. Note
    that I’m using Firefox, here, which allows us to see the headers as well as the
    content. Other browsers will only show the JSON content.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9 – Dog via API](img/B17600_07_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.9 – Dog via API
  prefs: []
  type: TYPE_NORMAL
- en: The server isn’t sending a web page for the browser to display; it’s just sending
    data that contains a URL, and every time we request the page, it sends a different
    URL. We’ll take a good look at this data in the later section of this chapter
    entitled *Working with JSON*, so don’t worry about it too much now.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four common types of APIs in general use:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Remote Procedure Call** (**RPC**) APIs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SOAP APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: REST APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WebSocket APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They fall into two categories – **stateful**, where the connection between client
    and server is maintained over a number of requests, and **stateless**, where each
    request from a client is treated as a unique event and doesn’t persist any information
    over to the next request. Let’s take a closer look.
  prefs: []
  type: TYPE_NORMAL
- en: RPC APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RPC APIs call a function in software on a server – they tell a server to do
    something using a specific piece of code, and the server will return an output
    that may or may not contain data. They may not do this over HTTP; there is a separate
    protocol called, appropriately enough, RPC, which is often used over local networks.
    We are not going to concern ourselves with RPC APIs in this chapter, but they
    are undergoing a bit of a resurgence on the internet, particularly for blockchain
    applications. RPC APIs were historically stateful, but more modern implementations
    of this model are usually not.
  prefs: []
  type: TYPE_NORMAL
- en: SOAP APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**SOAP** APIs use the **Simple Object Access Protocol** to exchange messages
    using XML. We see these APIs most usually when working with Windows servers running
    Microsoft **Internet Information Server** (**IIS**) rather than Linux servers,
    which usually run Apache or NGINX software. As we have seen in [*Chapter 6*](B17600_06.xhtml#_idTextAnchor117),
    *PowerShell and Files – Reading, Writing, and Manipulating Data*, XML is not the
    easiest language to work with and Windows is a less common operating system than
    Linux for web servers, so SOAP APIs are not the most popular. SOAP is most commonly
    stateless.'
  prefs: []
  type: TYPE_NORMAL
- en: REST APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**REST** is a style of software architecture for client-server, machine-to-machine
    communication. A REST API conforms to this style. They are flexible and lightweight,
    most often based on the HTTP protocol. REST APIs are stateless and can receive
    output in many forms, including HTML and XML. JSON is the most common form of
    output, however. REST APIs are generally the simplest APIs to work with and certainly
    the most common on the internet.'
  prefs: []
  type: TYPE_NORMAL
- en: WebSocket APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: WebSocket APIs use JSON to move data between clients and servers. Like REST
    APIs, they are based on HTTP, but unlike REST APIs, WebSocket APIs also use their
    own protocol, called the WebSocket protocol, an extension of HTTP, which allows
    for a wider range of operations. They are stateful and bi-directional; the server
    may initiate communication with a connected client. This makes them extremely
    powerful, but also harder to use.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a closer look at how we can work with the most common API type –
    the REST API.
  prefs: []
  type: TYPE_NORMAL
- en: Working with REST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most common API we will work with is the REST API. We most frequently encounter
    REST APIs when we use **web applications**. A web application is usually a tiered
    client/server application. A typical application would consist of three tiers
    or layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A presentation layer** – the web browser or app on the client device'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**An application layer** – the web server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A storage layer** – usually a database running on the web server or a separate
    server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use REST APIs to communicate between the presentation layer (the browser)
    and the application layer (the web server); how the application layer communicates
    with the storage layer (the database) is up to the application developer, but
    it will often be Python or PHP.
  prefs: []
  type: TYPE_NORMAL
- en: REST APIs are usually implemented using HTTP, which means they use a familiar
    set of HTTP commands such as `GET`, `PUT`, and `POST`. Because of the way web
    applications are usually designed, REST APIs are frequently associated with database
    operations; **Create, Read, Update, and Delete** (**CRUD**). The following table
    summarizes how the commands map to operations.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Database operation** | **REST** **API request** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Create | `POST` | Create a new user |'
  prefs: []
  type: TYPE_TB
- en: '| Read | `GET` | Get a picture of a dog |'
  prefs: []
  type: TYPE_TB
- en: '| Update | `PUT` | Change an address |'
  prefs: []
  type: TYPE_TB
- en: '| Delete | `DELETE` | Delete a chatroom post |'
  prefs: []
  type: TYPE_TB
- en: Table 7.1 – How REST relates to CRUD
  prefs: []
  type: TYPE_NORMAL
- en: The websites we’ve looked at so far utilize APIs, and we’ve worked with them
    using `Invoke-WebRequest`. Let’s take a look at a different cmdlet we can use.
  prefs: []
  type: TYPE_NORMAL
- en: Invoke-RestMethod
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Invoke-RestMethod` cmdlet can be used to query a REST API endpoint, such
    as `http://random.dog/woof.json`. How does `Invoke-RestMethod` differ from `Invoke-WebRequest`?
    Let’s look at the `random.dog/woof.json` API endpoint with both to compare the
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.10 – Comparing Invoke-WebRequest and Invoke-RestMethod](img/B17600_07_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.10 – Comparing Invoke-WebRequest and Invoke-RestMethod
  prefs: []
  type: TYPE_NORMAL
- en: In the first example, in the red box, I’ve used `Invoke-WebRequest`. In the
    second example, in the green box, I’ve used `Invoke-RestMethod`. Both cmdlets
    parse the response correctly, but they are doing different things. `Invoke-WebRequest`
    is displaying the HTTP response from the endpoint, including the headers and content.
    `Invoke-RestMethod` is only looking at the content and is displaying it as a custom
    object with a set of properties corresponding to names in the dictionary included
    in the content. Wait, what? Where did the dictionary come from? Remember, `Invoke-RestMethod`
    works with REST API endpoints. A REST API provides output in JSON, or less frequently
    in XML. JSON and XML outputs usually consist of a collection of name-value pairs;
    a dictionary. If we use `Invoke-RestMethod` to interrogate an HTML page that doesn’t
    output in JSON or XML, then we get a single object, consisting of the raw HTML
    from the page. We will cover JSON in more detail in the next section of this chapter,
    *Working with JSON*. Let’s take a closer look at the output we get when we access
    an API endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we pipe `Invoke-RestMethod` to `Get-Member`, we can see that we have a `System.Management.Automation.PSCustomObject`
    with two properties; `fileSizeBytes` and `url`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The parameters for `Invoke-RestMethod` are quite similar to `Invoke-WebRequest`.
    We can summarize them in *Table 7.2*. As we can see, `Invoke-WebRequest` has the
    `-HttpVersion` parameter, which was introduced in PowerShell 7.3, while `Invoke-RestMethod`
    does not, and `Invoke-RestMethod` has parameters that deal with relative links
    (`-FollowRelLink` and `-MaximumFollowRelLink`) and `-StatusCodeVariable`, which
    can assign the HTTP response status code to a separate variable. This is useful
    when combined with the `-``SkipHttpErrorCheck` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Table_02_A.jpg)![](img/Table_02_B.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 7.2 – The parameters of Invoke-WebRequest and Invoke-RestMethod, compared
  prefs: []
  type: TYPE_NORMAL
- en: There are some minor differences in a couple of the parameters, for example,
    the `Invoke-RestMethod -Uri` parameter can also accept `file:` and `ftp:` schemes,
    as well as `http:` and `https:`.
  prefs: []
  type: TYPE_NORMAL
- en: To really get to grips with `Invoke-RestMethod` though, we need to understand
    the content that we are retrieving when we use it. To do that, let’s take a closer
    look at the most common data format, JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Working with JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What is JSON? First of all, it’s *not* a language; it’s a data format. While
    it has JavaScript in the name, it is used by many modern languages to generate,
    parse, and exchange data. It is also intended to be human-readable; we just have
    to know how to read it. JSON stores data in a dictionary-like format of key-value
    pairs. The first term is the key, and the second term is the value. The key is
    a string, and the value may be another string, a Boolean, a number, an array,
    or a JSON object. A JSON object consists of one or more key-value pairs, so because
    the value can be another object, JSON objects can be nested. Let’s type the cmdlet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Then, we get something like the following JSON response.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This consists of two key-value pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the first pair, `fileSizeBytes` is the key, and the value is `176601`, which
    is fairly obviously the file size, in bytes. The second pair has a key of `url`,
    and the value is the URL that follows. The key and the value are separated by
    a colon (`:`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Both pairs are enclosed in a single set of braces (`{}`). The braces tell us
    that this is a single object consisting of the enclosed pairs. The pairs in an
    object are separated by a comma (`,`). There is no comma after the last pair in
    an object. If we wanted to include an array, we would enclose it in square brackets.
    Let’s write one that describes a well-known television character. Open VS Code,
    create a new file, and save it as something appropriate, such as `C:\temp\poshbook\ch7\enterprise.json`.
    Then, type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The following figure shows how it should look in VS Code. It’s a valid JSON
    file and demonstrates the valid JSON data types and syntax.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.11 – To boldly demonstrate JSON](img/B17600_07_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.11 – To boldly demonstrate JSON
  prefs: []
  type: TYPE_NORMAL
- en: '`Name` and `Designation` contain string values, `Captain` contains another
    JSON object, and `BridgeCrew` contains an array of strings (but it could be an
    array of other valid data types, or even of more JSON objects). Obviously, it
    has no `JediName`, and it is definitely awesome.'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, VS Code can parse JSON and help us ensure our syntax is correct
    through color coding.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few other points to remember. First of all, whitespace between
    elements is ignored; `"Initial": "T"` is as valid as `"Initial": "T"`. Do everyone
    a favor by being consistent with how you use whitespace, though. Secondly, there
    is no particular number format. `240000000` is not an integer or a floating-point
    value; it’s just a number. Finally, there is no provision for comments within
    JSON; this should encourage us to write clear and descriptive code.'
  prefs: []
  type: TYPE_NORMAL
- en: Now we have a reasonable understanding of what JSON is, how can we use it in
    PowerShell? PowerShell doesn’t work with JSON the way it does with XML, so we
    need to be able to convert our JSON data into a custom PowerShell object and convert
    PowerShell objects into JSON. There are a pair of cmdlets that can do this for
    us, `ConvertFrom-Json` and `ConvertTo-Json`. Let’s look at `ConvertFrom-Json`
    first.
  prefs: []
  type: TYPE_NORMAL
- en: ConvertFrom-Json
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ConvertFrom-Json` will parse JSON content from a location and turn it into
    a custom PSObject. Let’s see how it works.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a PowerShell console and try getting the content using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see from the following figure, we can import the content fine, but
    if we use `Get-Member`, we can see we have imported that content as a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.12 – Importing JSON with Get-Content alone](img/B17600_07_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.12 – Importing JSON with Get-Content alone
  prefs: []
  type: TYPE_NORMAL
- en: 'Turning the data held in the JSON file into a string is going to make it difficult
    to use and manipulate. Now, let’s try using `ConvertFrom-Json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, we’ve imported it as a custom PSObject, which is much more useful.
    Doing it this way creates an object with properties corresponding to the key-value
    pairs contained in the JSON, which we can then access the same way as we can with
    the properties of any other PowerShell object, as in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.13 – Importing JSON with ConvertFrom-Json](img/B17600_07_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.13 – Importing JSON with ConvertFrom-Json
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a closer look at the `ConvertFrom-Json` cmdlet.
  prefs: []
  type: TYPE_NORMAL
- en: '`ConvertFrom-Json` is a simple cmdlet that hides a lot of complicated work.
    As we’ve seen, we can use it to convert a JSON string into a custom PSObject.
    We can also use it to create an ordered hashtable from a JSON string; this is
    necessary because JSON allows duplicate key names, where only the case of the
    string may be different. Because PowerShell is case-insensitive, only the last
    key-value pair would be converted; instead, `ConvertFrom-Json` throws an error.
    The other reason is that JSON allows keys that are empty strings; this would lead
    to a PSObject with a property name that is an empty string, which isn’t allowed.
    See the following figure for examples of these errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.14 – Reasons to use the -AsHashtable parameter](img/B17600_07_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.14 – Reasons to use the -AsHashtable parameter
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-AsHashtable` will convert the JSON string into an ordered hashtable, which
    preserves the ordering of the JSON keys. We looked at ordered hashtables in [*Chapter
    4*](B17600_04.xhtml#_idTextAnchor071), *PowerShell Variables and Data Structures*.
    While not as useful as a PSObject, ordered hashtables are easier to work with
    than strings, and in some circumstances are faster to process than a PSObject.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Depth` allows us to set the maximum depth of nesting that we will process;
    as we saw at the start of this section, JSON key-value pairs can contain JSON
    objects, which in turn can contain further JSON objects. The default value of
    `-Depth` is `1024`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-InputObject` only accepts strings; either the string itself, a variable that
    contains a string, or an expression that generates a string, as we saw in the
    `enterprise.json` example previously. We can’t pass a file to it directly; we
    need to get the file content first using `Get-Content`. Obviously, it accepts
    pipeline input.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-NoEnumerate` will read an array of strings as a single string, resulting
    in a single output object. Consider the example in the following figure:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 7.15 – Using the -NoEnumerate parameter](img/B17600_07_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.15 – Using the -NoEnumerate parameter
  prefs: []
  type: TYPE_NORMAL
- en: In the first cmdlet, we get three separate objects. When we include the `-NoEnumerate`
    parameter, we get a single object, `fish` `cat dog`.
  prefs: []
  type: TYPE_NORMAL
- en: Now we’ve seen how to convert JSON into a format that PowerShell can easily
    work with, let’s look at how we can convert PowerShell objects into JSON.
  prefs: []
  type: TYPE_NORMAL
- en: ConvertTo-Json
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ConvertTo-Json` will take any PowerShell object and convert it into a JSON-formatted
    string. It does this by converting the properties of the object into key-value
    pairs, where the property name is the key, and discarding any methods the object
    has. Let’s see it working. If you didn’t create the `$starship` variable as a
    PSObject previously, do so now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s say we’ve been in a battle, and need to update our photon torpedo
    count. We can type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This will update it on the PSObject, and then we use `ConvertTo-Json` to produce
    a JSON-formatted object to replace the original that we imported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If we open that in VS Code, we can see that it is a correctly formatted JSON
    file with the updated torpedo count:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.16 – After a Klingon attack](img/B17600_07_016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.16 – After a Klingon attack
  prefs: []
  type: TYPE_NORMAL
- en: We can see in line 16 that the torpedo count has changed. VS Code still sees
    this as valid JSON with no errors. We can see the formatting has changed from
    the original file; each element of the `BridgeCrew` array is on its own line because
    of the formatting rules that `ConvertTo-Json` uses, but other than that it’s the
    same as the original `enterprise.json` file. We could then feed this JSON string
    to an API to update the information on a server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like `ConvertFrom-Json`, `ConvertTo-Json` is a deceptively simple cmdlet that
    hides a lot of work behind a short list of parameters. Let’s take a look at them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-AsArray` will convert a PSObject into a JSON array unconditionally. Consider
    the following examples in the following figure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 7.17 – The -AsArray parameter](img/B17600_07_017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.17 – The -AsArray parameter
  prefs: []
  type: TYPE_NORMAL
- en: In the first line, I’m converting two strings into JSON. `ConvertTo-Json` automatically
    treats them as an array and puts them in square brackets because they are two
    separate objects. In the second line, I’m only feeding a single string into the
    pipeline, and `ConvertTo-Json` treats it as a single string. But what if I want
    it to be formatted as a single-member array? Then, I use the `-AsArray` parameter,
    and I get my square brackets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Compress` removes whitespace and indented formatting from the JSON output.
    The output will be on a single line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Depth` specifies how many levels of nested objects can be included in the
    JSON output. We can have between zero and one hundred levels of nesting, but the
    default is a miserly two levels, which can catch people out. We get a warning
    if our output has more than this level. Consider the JSON in the following figure:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 7.18 – nesting.json](img/B17600_07_018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.18 – nesting.json
  prefs: []
  type: TYPE_NORMAL
- en: 'If we ingest it into a variable, then convert it back into JSON, and then we
    get the warning in the following figure. Notice that the third level of nesting,
    on the line beginning with `"really?"`, is not converted into a JSON object, but
    into a string representing a hashtable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.19 – We need to increase -Depth](img/B17600_07_019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.19 – We need to increase -Depth
  prefs: []
  type: TYPE_NORMAL
- en: '`-EnumsAsStrings` will convert all the values of the `DayOfWeek` property of
    a `DateTime` object. When we type `(Get-Date).DayOfWeek`, it returns a string,
    `Saturday`, but the value is actually held as an integer between 1 and 7\. Have
    a look at the example in the following figure:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 7.20 - Using the -EnumAsStrings parameter](img/B17600_07_020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.20 - Using the -EnumAsStrings parameter
  prefs: []
  type: TYPE_NORMAL
- en: '`-EscapeHandling` controls how certain characters are escaped, such as the
    newline character (`` `n ``). There are three possible settings – `Default`, where
    only control characters are escaped, `EscapeNonAscii`, where all non-ASCII and
    control characters are escaped, and `EscapeHtml`, where special HTML characters
    such as `<`, `>`, `?`, `&`, `''`, and `"` are escaped.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-InputObject` accepts any type of PowerShell object explicitly or via the
    pipeline, as an expression, or as a variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of these parameters are formatting controls intended to make it easier
    to work with APIs, which may have different expectations of the input we give
    them. There is one more command that helps us get our data into a format that
    can be consumed by an API; `Test-Json`.
  prefs: []
  type: TYPE_NORMAL
- en: Test-Json
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Test-Json` cmdlet will test the validity of a string as a JSON object.
    This is extremely useful when writing scripts to work with APIs to make sure our
    data can be consumed correctly. It is especially useful when we consider that
    not everything we produce with `ConvertTo-Json` is necessarily good JSON. Consider
    the examples in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.21 – Getting things wrong with ConvertTo-Json](img/B17600_07_021.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.21 – Getting things wrong with ConvertTo-Json
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first line, we create a variable called `$date` and put the current
    date in it. This is an object of the `DateTime` type. Unsurprisingly, when we
    try the cmdlet in line 2, `Test-Json` is unhappy. In line 3, we convert the expression
    into JSON using `ConvertTo-Json`, and then test it again in line 4\. Horror! Although
    it has been converted successfully, it’s still not compliant JSON. In line 5,
    we can try testing just the string output from line 3, and we can see what the
    problem is. While `ConvertTo-Json` has taken the value from the `$date` variable,
    it hasn’t formatted it correctly as a string. When we correct the formatting in
    line 6, we can see that `Test-Json` is now happy. The clever way to do it, of
    course, is like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.22 – The right way to do it](img/B17600_07_022.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.22 – The right way to do it
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple of parameters with `Test-Json` that allow us to define custom
    JSON schemas if we need to produce specialized or custom JSON for particular systems,
    but we don’t need to go into them here. One interesting quirk of the cmdlet is
    that the `-InputObject` parameter found on almost all cmdlets is called `-Json`
    here, but functionally it is the same; it takes a string, either explicitly or
    via the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s have some fun – who is on the International Space Station?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since I was small, I have been fascinated by space. One of my earliest memories
    is sitting up with my mam and dad to watch an Apollo moon landing on a creaky
    old black and white television. It wasn’t Apollo 11\. I’m not quite that old.
    As an exercise, let’s see whether we can find out who is on the ISS, and present
    that data on a web page. We’ll need to refer to some of the stuff we learned about
    in the last chapter to accomplish this; [*Chapter 6*](B17600_06.xhtml#_idTextAnchor117),
    *PowerShell and Files – Reading, Writing, and Manipulating Data*, as well as what
    we’ve learned in this chapter. We’re not going to walk through it – try and accomplish
    this on your own. There are lots of ways to do this, and I’ve put my solution
    in the answers. Here are some hints though.
  prefs: []
  type: TYPE_NORMAL
- en: Activity
  prefs: []
  type: TYPE_NORMAL
- en: 'We can break this down into two tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Task 1 – use an API to find out who is on the ISS, right now
  prefs: []
  type: TYPE_NORMAL
- en: Task 2 – display this data in an HTML file
  prefs: []
  type: TYPE_NORMAL
- en: There is an API with the data we require at [http://api.open-notify.org/astros.json](http://api.open-notify.org/astros.json)
  prefs: []
  type: TYPE_NORMAL
- en: You could use `Invoke-WebRequest`, but it’s probably easier to use `Invoke-RestMethod`
  prefs: []
  type: TYPE_NORMAL
- en: You will probably want to use `ConvertTo-Html` to produce the web page. You
    may need to study the help file for this cmdlet to understand some of the formatting
    options.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s my finished attempt:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.23 – Just beautiful](img/B17600_07_023.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.23 – Just beautiful
  prefs: []
  type: TYPE_NORMAL
- en: This should stretch us a little bit, but we’ve got all the knowledge we need
    to get this done and have some fun along the way.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve come on a bit of a journey in this chapter and started to interact with
    the world outside our local machines. The techniques we covered will be used throughout
    the book, so we will get plenty of opportunity to become properly familiar with
    them.
  prefs: []
  type: TYPE_NORMAL
- en: We started out by looking at how we can work with HTML data over HTTP using
    the `Invoke-WebRequest` cmdlet. We saw that this is a complex cmdlet with many
    options, and we covered the parameters frequently used with it. We focused on
    authentication, as this will be a key technique required for retrieving and posting
    data. We also saw that it is difficult to manipulate the data we ingest using
    this cmdlet, as it is text-based.
  prefs: []
  type: TYPE_NORMAL
- en: We then talked about an easier way to ingest data from servers over a network,
    using an API. We discussed the common types of API, in particular the most common,
    REST APIs.
  prefs: []
  type: TYPE_NORMAL
- en: We then looked at the PowerShell cmdlet for working with REST – `Invoke-RestMethod`.
    We saw how similar this cmdlet is to `Invoke-WebRequest`, but that instead of
    producing a page of HTML, it outputs data in a structured format.
  prefs: []
  type: TYPE_NORMAL
- en: We went on to explore the most common format for this data, JSON. We looked
    at the three cmdlets in PowerShell for working with JSON data; `ConvertFrom-Json`,
    `ConvertTo-Json`, and `Test-Json`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we used our new knowledge to produce an HTML web page displaying the
    names of the astronauts currently on board the ISS.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter marks the end of the coding fundamentals section of this book;
    we’ve covered data structures, flow control, file manipulation, and connecting
    to the internet. In the next chapter, we are going to start looking at turning
    our lines of scruffy code into scripts and tools that we can share with other
    people. It’ll be fun.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'How would we send a delete request to the following URL: `https://httpbin.org/delete`?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What parameters would we need to use `Invoke-WebRequest` with a stateful endpoint?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We try to connect to a website and see the following error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Which type of API is stateful? What does this mean?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We sign up to a web service and get an authentication token. We encode the
    token using `ConvertTo-SecureString`, store it in a variable called `$token`,
    and then use the variable to create a web request like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We get an authentication error. Have we done something wrong, or is the token
    bad?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Get the latitude and longitude of the ISS right now. You can use [http://api.open-notify.org/iss-now.json](http://api.open-notify.org/iss-now.json).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many universities in the UK have the letter ‘*x*’ in their name? Use the
    API at [http://universities.hipolabs.com/search?country=United+Kingdom](http://universities.hipolabs.com/search?country=United+Kingdom)
    to find out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we use `Test-Json` to validate our generated JSON against a custom schema?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'More on APIs here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/product/understanding-apis-and-restful-apis-crash-course-video/9781800564121](https://www.packtpub.com/product/understanding-apis-and-restful-apis-crash-course-video/9781800564121)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[https://www.digitalfluency.guide/apis/introduction-to-apis](https://www.digitalfluency.guide/apis/introduction-to-apis)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Lots more on REST here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://restfulapi.net/](https://restfulapi.net/)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'A good JSON tutorial, but with some JavaScript:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.w3schools.com/js/js_json_intro.asp](https://www.w3schools.com/js/js_json_intro.asp)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'How to use JSON schemas:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://json-schema.org/understanding-json-schema](https://json-schema.org/understanding-json-schema)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Part 2: Scripting and Toolmaking'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This part walks you through turning a set of cmdlets into a script, introduces
    functional programming, shows you how to turn scripts into modules, and how to
    share those modules with colleagues and others using GitHub and GitLab. It also
    includes a chapter on PowerShell security, so that you don’t inadvertently distribute
    code that is less secure than it could be.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B17600_08.xhtml#_idTextAnchor162), *Writing Our First Script
    – Turning Simple Cmdlets into Reusable Code*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B17600_09.xhtml#_idTextAnchor184), *Don’t Repeat Yourself – Functions
    and Scriptblocks*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B17600_10.xhtml#_idTextAnchor201), *Error Handling – Oh No!
    It’s Gone Wrong!*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B17600_11.xhtml#_idTextAnchor218), *Creating Our First Module*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B17600_12.xhtml#_idTextAnchor236), *Securing PowerShell*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
