- en: '19'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Shell Script Portability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we’ll see in a bit, many different shells are available for Linux, Unix,
    and Unix-like operating systems. Thus far though, we’ve mainly just been working
    with `bash`. The big advantage of `bash` is that it comes already installed on
    most Linux distros, macOS, and OpenIndiana. It normally isn’t installed by default
    on the BSD-type distros, but you can install it yourself, if you need to.
  prefs: []
  type: TYPE_NORMAL
- en: The big advantage of `bash` is that it can use different scripting constructs
    that can make life easier for scripters. The big disadvantage of `bash` is that
    many of these `bash` constructs aren’t always available in non-`bash` shells.
    That’s not a big problem if you can install `bash` on all of your machines, but
    that’s not always possible. (I’ll explain why in just a bit.)
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I’ll show you some of the `bash` alternatives that you might
    encounter, and how to make your shell scripts run on a wide variety of these shells.
  prefs: []
  type: TYPE_NORMAL
- en: 'Topics in this chapter include:'
  prefs: []
  type: TYPE_NORMAL
- en: Running `bash` on non-Linux systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding POSIX compliance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the differences between shells
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding bashisms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing scripts for POSIX compliance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That about does it for the introduction. So now, let’s dig in.
  prefs: []
  type: TYPE_NORMAL
- en: Technical Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I’m using Fedora, Debian, and FreeBSD virtual machines for this chapter. If
    any of you are using a Mac, you can try the scripts on it as well, if you like.
    As always, you can get grab the scripts from GitHub by doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Running bash on Non-Linux Systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we talk about the alternatives to `bash`, let’s talk about using `bash`
    on non-Linux operating systems. I mean, the easiest way to make your shell scripts
    portable is to have the same shell everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'As I mentioned in the introduction, `bash` is already installed on most Linux-based
    operating systems, as well as on macOS and OpenIndiana. If you want to use `bash`
    on a BSD-type distro, such as FreeBSD or OpenBSD, you’ll need to install it yourself.
    I’ve already shown you how to install `bash` on FreeBSD in *Chapter 8, Basic Shell
    Script Construction*. To refresh your memory, I’ll show you again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s just as easy on any other BSD-type distro, except that they all use different
    package managers. Here’s the table of commands for the various BSDs:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **BSD Distro** | **Command to install bash** |'
  prefs: []
  type: TYPE_TB
- en: '| FreeBSD | `sudo pkg install bash` |'
  prefs: []
  type: TYPE_TB
- en: '| OpenBSD | `sudo pkg_add bash` |'
  prefs: []
  type: TYPE_TB
- en: '| DragonflyBSD | `sudo pkg install bash` |'
  prefs: []
  type: TYPE_TB
- en: '| NetBSD | `sudo pkgin install bash` |'
  prefs: []
  type: TYPE_TB
- en: 'Table 19.1: Commands to install bash on the BSD distros'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you were to run a script with the `#!/bin/bash` shebang line on any
    of these BSD distros, you would get an error message that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This message is a bit misleading because it gives the impression that the shell
    can’t find the script. In reality, the script can’t find `bash`. That’s because,
    unlike what you’re used to seeing on Linux and OpenIndiana, `bash` isn’t in the
    `/bin/` directory on BSD distros. Instead, the BSD distros have `bash` in the
    `/usr/local/bin/` directory. There are a couple of ways to fix this, which we’ll
    look at next.
  prefs: []
  type: TYPE_NORMAL
- en: Using env to Set the bash Environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first way to ensure that your scripts can always find `bash` is to replace
    the `#!/bin/bash` line in your scripts with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This causes the script to look for the `bash` executable in the user’s `PATH`
    environment, instead of in a specific, hard-coded location.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve shown you in *Chapter 3, Understanding Variables and Pipelines* how to
    use the `env` command to view the environmental variables that are set in `bash`.
    In this case, I’m using `env` to specify the shell that I want to use to interpret
    this script.
  prefs: []
  type: TYPE_NORMAL
- en: This is the easiest method, but there are a few potential problems with it.
  prefs: []
  type: TYPE_NORMAL
- en: If you specify an interpreter for which multiple versions are installed, you
    won’t know which version will be invoked by the script. If for some crazy reason
    a machine has multiple versions of `bash` installed, you won’t know which version
    that `#!/usr/bin/env bash` will invoke.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `#!/usr/bin/env bash` could be a security problem. The normal `bash` executable
    is always installed in a directory for which only someone with root privileges
    can add, remove, or modify files. But, let’s say that a malicious hacker were
    to gain access to your own normal user account. In that case, he or she wouldn’t
    need to obtain root privileges in order to plant a malicious fake `bash` in your
    own home directory, and to alter your `PATH` environment so that the fake `bash`
    would be invoked instead of the real `bash`. Using the hard-coded `#!/bin/bash`
    line would prevent that problem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With `#!/usr/bin/env bash`, you won’t be able to invoke any `bash` options on
    the shebang line. For example, let’s say that you need to troubleshoot a troublesome
    script, and you want to run the script in debug mode. Using `#!/bin/bash --debug`
    will work, but using `#!/usr/bin/env bash --debug` won’t work. That’s because
    the `env` command can only recognize one option parameter, which in this case
    would be `bash`. (It will never see the `--debug` option.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For now, don’t worry about what the `--debug` option is doing. I’ll show you
    more about debugging shell scripts in *Chapter 21, Debugging Shell Scripts*.
  prefs: []
  type: TYPE_NORMAL
- en: Although using `#!/usr/bin/env bash` seems like the simplest solution, I prefer
    to avoid it whenever possible. So, let’s look at another solution that’s a bit
    more secure and reliable.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Symbolic Link to bash
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'My preferred solution for ensuring that your scripts can find `bash` works
    the same on all of the BSD distros. You just have to create a symbolic link to
    the `bash` executable in the `/bin/` directory. Here’s how it looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To use the `ln -s` command to create a link, you would first specify the path
    to the file to which you want to link. Then, specify the path and name for the
    link that you want to create. Note how after I created the link, the `which` command
    now finds `bash` in the `/bin/` directory, instead of in the `/usr/local/bin/`
    directory. That’s because `/bin/` is listed before `/usr/local/bin/` in the default
    `PATH` setting, as you see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You can now use the `#!/bin/bash` shebang line on your BSD machine, the same
    as you would on a Linux machine.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, this is all good if you can have `bash` installed on all of your systems.
    But, what if you can’t? What if you need to write scripts that will run on `bash`
    as well as on alternate shells? To answer that, we’ll first need to look at something
    called **POSIX**.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding POSIX compliance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Way back in the Stone Age of Computing, there was no such thing as standardization.
    In order to keep things relevant, let’s begin our history with the advent of Unix.
  prefs: []
  type: TYPE_NORMAL
- en: AT&T, who created Unix in the early 1970s, wasn’t allowed to market it until
    1983\. This was due to an anti-trust legal case that the U.S. government had filed
    against AT&T back in 1956\. (I don’t know the details of the case, so please don’t
    ask.) But, they were allowed to license the code to other vendors so that they
    could sell their own modified implementations. Because of this, several different
    implementations of Unix emerged, which weren’t always completely compatible with
    each other. These different implementations included the **Berkeley Software Distribution**
    (**BSD**), **Microsoft Xenix**, and **SunOS**. In 1983, AT&T was finally allowed
    to market its own **System V Unix**. Making things more interesting was the wide
    variety of shells that eventually became available for these various Unix systems.
    The Thompson shell came first, and was superseded by the Bourne shell a few years
    later. Other shells, such as the C shell and the Korn shell, soon followed. Finally,
    in the early 1990s, Linus Torvalds created the Linux kernel, which was a clean
    slate reimplementation of the Unix kernel. Nowadays, Linux-based operating systems
    have mostly supplanted Unix-based systems, and the Bourne Again Shell (`bash`)
    is the dominant shell for Linux-based systems.
  prefs: []
  type: TYPE_NORMAL
- en: In the 1980s, customers began demanding some semblance of standardization between
    the various Unix vendors. This culminated in the creation of the **POSIX** standard
    by the **IEEE Computer Society** in 1988.
  prefs: []
  type: TYPE_NORMAL
- en: '**IEEE** stands for **Institute of Electrical and Electronics Engineers**.
    Curiously however, all you’ll see on their website is IEEE, with no explanation
    of what it stands for.'
  prefs: []
  type: TYPE_NORMAL
- en: POSIX stands for **Portable Operating System Interface**.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, for those of you who are outside the U.S., AT&T stands for **American
    Telephone and Telegraph**.
  prefs: []
  type: TYPE_NORMAL
- en: And yes, it really is true that Microsoft used to be a Unix vendor.
  prefs: []
  type: TYPE_NORMAL
- en: The main purpose of POSIX is to ensure that shells and utilities work the same
    way across all implementations of Unix. For example, if you know how to use the
    `ps` utility on Solaris/OpenIndiana, then you also know how to use it on FreeBSD.
    The big problem is that while many Unix implementations and their default shells
    are POSIX-compliant, some are only partially compliant. On the other hand, most
    Linux-based operating systems are only partially POSIX-compliant. That’s because
    many Linux utilities use different option switches that their Unix/Unix-like brethren
    don’t use, and `bash` itself has programming features that aren’t available in
    POSIX-compliant shells. For example, you can use an `if [ -f /bin/someprogram
    ]` type of construct to test for the presence of a file in a POSIX-compliant shell,
    but you can’t use `if [[ -f /bin/someprogram ]]`. (I’ll explain more about this
    in a few moments.)
  prefs: []
  type: TYPE_NORMAL
- en: POSIX also defines which programming libraries must come with any given implementation
    of Unix. However, this is mainly of interest to actual programmers, rather than
    to shell scripters.
  prefs: []
  type: TYPE_NORMAL
- en: To be fair, I’ll admit that POSIX compliance might never become an issue for
    you if you only work on Linux servers or workstations. But, let’s say that you
    work with a large fleet of servers with a mix of Unix, BSD, and Linux systems.
    Now, let’s say that some of those Unix and BSD servers are still running legacy
    systems for which `bash` isn’t available. You might find it necessary to create
    POSIX-compliant shell scripts that will run on every server in the fleet without
    modification. Also, **Internet of Things** (**IoT**) devices are generally very
    low-resource devices that might not be able to run `bash`. Instead, they’ll have
    something more lightweight, such as `ash` or `dash`. In general, these lightweight,
    non-`bash` shells will be POSIX-compliant, and won’t be able to run scripts that
    use `bash`-specific features.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a good understanding of what POSIX is all about, let’s talk
    about the differences between the various shells.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Differences Between Shells
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to defining a specific shell that you want to use, such as `/bin/bash`
    or `/bin/zsh`, you can also define the generic `/bin/sh` shell to make your scripts
    more portable, as you see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This generic `sh` shell allows you to run your scripts on different systems
    that might or might not have `bash` installed. But, here’s the problem. Years
    ago, `sh` used to always be the Bourne shell. Nowadays, `sh` is still the Bourne
    shell on some operating systems, but is something else entirely on other operating
    systems. Here’s the breakdown of how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: On most BSD-type systems, such as FreeBSD and OpenBSD, `sh` is the old-school
    Bourne shell. According to the `sh` man page, it only supports POSIX-compliant
    features, plus a few BSD extensions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On Red Hat-type systems, `sh` is a symbolic link that points to the `bash` executable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On Debian/Ubuntu-type systems, `sh` is a symbolic link that points to the `dash`
    executable. `dash` stands for **Debian Almquist Shell**, which is a faster, more
    lightweight implementation of the Bourne shell.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On Alpine Linux, `sh` is a symbolic link that points to `ash`, which is a lightweight
    shell that’s built into the `busybox` executable. (On Alpine Linux, `bash` is
    not installed by default.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On OpenIndiana, which is a **Free Open Source Software** fork of Oracle’s Solaris
    operating system, `sh` is a symbolic link that points to the `ksh93` shell. This
    shell, which is also known as the Korn shell, is somewhat compatible with `bash`.
    (It was created by a guy named David Korn, and has nothing to do with any vegetable.)
    However, the default login shell for OpenIndiana is `bash`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On macOS, `sh` points to the `bash` executable. Interestingly, `zsh` is now
    the default user login shell for macOS, but `bash` is still installed and available
    for use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `#!/bin/sh` will only work if you’re careful about making your scripts
    portable. If `sh` on your machine points to something other than `bash`, it won’t
    work for scripts that require advanced features that are specific to `bash`. So,
    if you use `sh`, be sure to test it on different systems to ensure that everything
    works as it should.
  prefs: []
  type: TYPE_NORMAL
- en: Before we get to the testing part though, let’s look at the concept of bashisms,
    and how to avoid them.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Bashisms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **bashism** is any feature that’s specific to `bash`, and that won’t work
    with other shells. Let’s look at a few examples.
  prefs: []
  type: TYPE_NORMAL
- en: Using Portable Tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For our first example, try running this command on your Fedora virtual machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, I’m testing for the presence of the `ls` executable file in the `/bin/`
    directory. The file is there, so the `echo` command is invoked. Now, let’s run
    the same command on a FreeBSD virtual machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This time I get an error, because the default user login shell on FreeBSD is
    `sh`, instead of `bash`. The problem here is that the `[[. . .]]` construct isn’t
    supported on the FreeBSD implementation of `sh`. Let’s see if we can fix that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Very cool, this works. So now, you’re wondering why anyone would use the non-POSIX
    `[[. . .]]` construct instead of the more portable `[. . .]`. Well, it’s mainly
    because certain types of tests don’t work with `[. . .]`. For example, let’s look
    at the `test-test-1.sh` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: When I invoke this script, I’ll supply a word as the `$1` positional parameter.
    If the first letter of the word is “z”, then the pattern will match.
  prefs: []
  type: TYPE_NORMAL
- en: In this script, `z*` is a regular expression. We’re using this regular expression
    to match all words that begin with the letter “z”. Any time you do regular expression
    matching within a test, you have to place it within a double square bracket, or
    `[[. . .]]`, construct.
  prefs: []
  type: TYPE_NORMAL
- en: (I explained about regular expressions in *Chapter 9, Filtering Text with grep,
    sed, and Regular Expressions*.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, look at the `test-test-2.sh` script, which uses `[. . .]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This is identical to the first script, except that it uses single square brackets
    for the test instead of double square brackets. Here’s what happens when I run
    the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You see that this test doesn’t work with the single square brackets. That’s
    because the single square bracket construct doesn’t recognize the use of regular
    expressions. But, if using double square brackets doesn’t work on certain implementations
    of `sh`, then how can I make this script portable? Well, here’s one solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Instead of using the `z*` regular expression to match any word that begins with
    the letter “z”, I’m just echoing the word into the `cut -c1` command in order
    to isolate the first letter. I also changed the `==` in the test to `=`, because
    `==` is also considered a bashism.
  prefs: []
  type: TYPE_NORMAL
- en: The `==` actually does work with the FreeBSD implementation of `sh`, but it
    might not work on other implementations. For example, it doesn’t work on `dash`,
    which is invoked by `#!/bin/sh` on Debian/Ubuntu-type distros.
  prefs: []
  type: TYPE_NORMAL
- en: 'While I was at it, I changed the shebang line to `#!/bin/sh`, because I’ll
    also want to test this on FreeBSD with the Bourne shell. So, will this work? Let’s
    try it on Fedora, on which `#!/bin/sh` points to `bash`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Yeah, it works fine on Fedora. Now, let’s see what happens on FreeBSD:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Yes indeed, it works like a champ. And, for the record, I also tested it on
    a Debian machine with `dash`, and it works fine on it, as well.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at our next portability problem.
  prefs: []
  type: TYPE_NORMAL
- en: Making Portable Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, you need to create and manipulate lists of items in your shell scripts.
    With `bash`, you can create variable arrays the same as you can with languages
    such a C, C++, or Java. For example, let’s look at the `ip-2.sh` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This is identical to the `ip.sh` script that I showed you in *Chapter 8, Basic
    Shell Script Construction*, except that I changed the shebang line to `#!/bin/sh`.
    To refresh your memory, I’m using the `declare -a` command to create the `ip`
    array, and the `ip=` line to populate the array. This should work fine on my Fedora
    machine, since the Fedora `sh` points to `bash`. Let’s see if it does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Yes, it does work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s see how it looks on FreeBSD:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem this time is that the Bourne (`sh`) shell on FreeBSD can’t use
    variable arrays. To make this script portable, we’ll need to find a work-around.
    So, let’s try this `ip-3.sh` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of building an actual array this time, I’m using the `set` command
    to create a list of IP addresses that I can access with positional parameters.
    I know, you thought that positional parameters were only for passing arguments
    in from the command line when you invoke the script. But what you see here is
    just another way to use them. The big question though is, does this work? Let’s
    see what it does on the FreeBSD machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we have achieved coolness.
  prefs: []
  type: TYPE_NORMAL
- en: Note that when using `set` and positional parameters, we’re not creating an
    actual array. Instead, we’re just *simulating* an array. But hey, whatever works,
    right?
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also build a simulated array from a text file, using the `cat` command.
    First, let’s create the `iplist.txt` file, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create the `ip-4.sh` script, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'And, here’s what I get when I run this on FreeBSD:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: So yeah, it’s looking good.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s address something that hasn’t been a problem for us yet, but could
    be in the future. That is, the use of `echo`.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Portability Problems with echo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we haven’t encountered any problems with using `echo` in our scripts.
    That’s only because we haven’t used any of `echo`''s advanced formatting features.
    To demonstrate, run this command on your Fedora virtual machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `\v` that you see in the `\vto the moon` string inserts a vertical tab,
    which causes the output to be broken into two lines, with preceding tabs on the
    second line.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the `\v` tag, I had to use `echo` with the `-e` option. Now, try this
    again without the `-e`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You see that without the `-e`, the `\v` doesn’t insert the vertical tab as it’s
    supposed to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'The big problem with `echo` is that there’s no consistency in how the various
    non-`bash` shells handle its option switches. For example, let’s open a `dash`
    session on our Debian machine to see what happens on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: You see that on `dash`, `echo -e` inserts a `-e` at the beginning of the output
    string. But, if we omit the `-e`, the output displays correctly. That’s because
    the POSIX standard doesn’t define the `-e` option for `echo`. Instead, it just
    allows `echo` to recognize the backslash formatting options, such as `\v`, by
    default.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best way to have consistent output from your scripts is to use `printf`
    instead of `echo`. Here’s what that looks like on `dash`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: When using `printf`, you need to place the formatting options ahead of the string
    that you want to output. In this case, the `%b` enables the use of the backslash
    formatting options within the output string, and the `\n` means to append a newline
    to the end of the output. You see that I’ve combined these two options within
    the `"%b\n"` construct. The cool part is that you can run this command on any
    of your virtual machines, with any shell, and the output will always be consistent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let’s look at the `ip-5.sh` script, which uses `printf` instead of
    echo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'For all but one of the `printf` lines, I used the `"%s\n"` formatting option,
    which just means to print out the specified text string with a newline at the
    end. In the fourth `printf` line, I used the `"%b\n"` option, which means to allow
    the use of backslash formatting options in the text. You then see that I surrounded
    the `$2` positional parameter with a pair of `\v` options in order to insert a
    pair of vertical tabs. Here’s how it looks when I run the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The cool part is, as I said before, the `printf` output will be consistent on
    all shells.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, now that you’ve seen some examples of bashisms, let’s look at how to test
    our scripts for POSIX compliance.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Scripts for POSIX Compliance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s always important to test your shell scripts before putting them into production.
    This becomes even more important when you create scripts that need to run on a
    wide variety of operating systems and shells. In this section, we’ll look at a
    few ways to perform that testing.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Scripts on a POSIX-compliant Shell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you first start creating your scripts, you might want to use an interpreter
    shell that’s completely POSIX-compliant. Be aware though, that some POSIX-compliant
    shells still allow you to use certain bashisms. That’s because POSIX defines a
    *minimum* standard that an operating system or shell must meet, and doesn’t prohibit
    adding extensions. For example, `sh` on FreeBSD allows these two bashisms:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `echo -e` for output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `==` for text string comparisons.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, I haven’t extensively tested `sh` on FreeBSD to see exactly how many bashisms
    it allows. But, the fact that it allows at least these two means that we can’t
    use it to determine if our scripts will work on our entire network.
  prefs: []
  type: TYPE_NORMAL
- en: The most fully POSIX-compliant shell that comes already installed on any operating
    system is `dash`. I’ve already mentioned that if you run a `#!/bin/sh` script
    on a Debian/Ubuntu-type system, it will use `dash` as the script interpreter.
    The benefit is that if you create a script that will run on `dash`, it will most
    likely also run correctly on every other shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, almost. Remember what I showed you just a while ago with `echo -e`. I
    showed you that on `bash`, you must use the `-e` option to include any backslash
    formatting options. Here’s what I mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'So on `bash`, the `\v` formatting option doesn’t work unless you use `echo`
    with the `-e` switch. On `dash`, it’s the opposite, as you see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: So, if you use `echo` commands in your scripts, they might work properly on
    `dash`, but not on `bash`. Your best bet, as I’ve mentioned before, is to use
    `printf` instead of `echo`. Aside from that though, if you do create scripts that
    will run on `dash`, you’ll also want to test them on `bash`. I don’t know how
    many POSIX-specific things there are that will run on `dash` but not on `bash`.
    But, we do know about this `echo -e` thing.
  prefs: []
  type: TYPE_NORMAL
- en: The **Policy-compliant Ordinary Shell** (`posh`) is a shell that’s even more
    strictly POSIX-compliant than `dash`. The main problem with it is that the Debian/Ubuntu-type
    distros appear to be the only ones that have it in their repositories. On the
    other hand, you can easily install `dash` on pretty much any Linux distro, as
    well as on some of the Unix-like distros, such as FreeBSD.
  prefs: []
  type: TYPE_NORMAL
- en: 'At any rate, you can read more about `posh` here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'How to check your shell scripts for portability: [https://people.redhat.com/~thuth/blog/general/2021/04/27/portable-shell.html](https://people.redhat.com/~thuth/blog/general/2021/04/27/portable-shell.html)'
  prefs: []
  type: TYPE_NORMAL
- en: And, speaking of testing, let’s look at ways to do that.
  prefs: []
  type: TYPE_NORMAL
- en: Using checkbashisms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This cool `checkbashisms` utility will look through your scripts for anything
    that might not work on non-`bash` shells. First though, you’ll need to install
    it. Here’s how to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On Fedora:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'On Debian/Ubuntu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'On FreeBSD:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'On macOS:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the Homebrew system, and then install the `checkbashisms` package with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'For directions on how to install the Homebrew system on your Mac, go to: [https://brew.sh](https://brew.sh)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Basic usage of `checkbashisms` is easy. If the script that you want to test
    has `#!/bin/sh` as its shebang line, then just enter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, `checkbashims` only checks scripts that have the `#!/bin/sh` shebang
    line. If your script uses something else as the shebang line, such as `#!/bin/bash`,
    then use the `-f` option to force it to check the script, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'For the first example, let’s take another look at the `ip-2.sh` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s see what `checkbashisms` has to say about it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Well, that’s certainly no surprise, because we already established that some
    non-`bash` shells can’t do arrays. And, I’ve already shown you how to deal with
    that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, here’s a bashism that you haven’t seen yet, in the `math6.sh` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a while loop that echoes the number 0 through 10, followed by a string
    of three dots, each on its own line. Here’s how its output looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'It looks good here on Fedora with `bash`. But, will it work on Debian with
    `dash`? Let’s see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'What’s the problem? Perhaps `checkbashisms` can tell us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem is in line 6\. It’s just that `bash` can use the `[. . .]` construct
    for performing integer math. But, other shells have to use the `((. . .))` construct.
    So, let’s fix that in the `math7.sh` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'That should work much better, right? Well, let’s see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'No, it’s still broken. So, let’s give it another `checkbashisms` scan:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Whoa, now. What’s going on here? The `checkbashisms` scan says that my code
    is good, yet the script is still clearly broken when running on `dash`. What’s
    up with that? Well, after a bit of experimentation, I discovered that surrounding
    the variable name that’s within the math expression with a pair of quotes is also
    a bashism. But, it’s one that `checkbashisms` doesn’t catch. Let’s fix that in
    the `math8.sh` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Okay, will this now finally work? Drum roll, please!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Indeed, it now works like a champ.
  prefs: []
  type: TYPE_NORMAL
- en: So, you’ve seen that `checkbashisms` is a great utility that can really help
    you out. But, as with most things that mankind has invented, it isn’t perfect.
    It can flag a lot of problematic, non-POSIX code, but it does allow some `bash`-specific
    things to slip through. (It would be nice if there were a list of things that
    `checkbashisms` misses, but there isn’t.)
  prefs: []
  type: TYPE_NORMAL
- en: All right, let’s move on to our next code-checking utility.
  prefs: []
  type: TYPE_NORMAL
- en: Using shellcheck
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `shellcheck` utility is another great code-checking tool that can also
    check for bashisms. It’s available on most Linux and BSD distros. Here’s how to
    install it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On Fedora:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'On Debian/Ubuntu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'On FreeBSD:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'On macOS with Homebrew installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'To demo this, let’s go back to the Debian machine, and scan the same scripts
    that we scanned with `checkbashisms`. We’ll begin with the `ip-2.sh` script. Here
    are the relevant parts of the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: You see that `shellcheck` does warn us that we can’t use arrays in POSIX-compliant
    scripts. It also warns us about issues involving good programming practices that
    aren’t necessarily POSIX issues. In this case, it reminds us that we should surround
    variable expansion constructs, `${ip[0]}` in this case, with a pair of double
    quotes in order to prevent whitespace problems. Of course, that’s a moot point
    here, because the `${ip[0]}` construct here is part of the array definition that
    we can’t use anyway.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s try the `math6.sh` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: As expected, `shellcheck` detects the non-POSIX way of doing math. So, that’s
    good.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scanning `math7.sh` gives us this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Here, we see the same problem that we saw with `checkbashisms`. That is, `math7.sh`
    has the variable name that’s within the math construct surrounded by a pair of
    double quotes, as you see in the `start=$(("$start"+1))` line. We’ve already established
    that this works on `bash` but not on `dash`, yet `shellcheck` doesn’t flag this
    as a problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let’s try this with `math8.sh`. As you’ll recall, this is the script
    that we finally got to work on `dash`. Here’s how that looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the script works perfectly well on our Debian/`dash` machine.
    Here, `shellcheck` is pointing out a stylistic issue that doesn’t affect whether
    the script will actually work. If you recall from *Chapter 11, Performing Mathematical
    Operations*, I showed you that when recalling the value of a variable that’s within
    a math construct, it’s not necessary to preface the variable name with a `$`.
    I mean, it doesn’t hurt anything if you do, but it’s not necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying a Shell with the -s Option
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another benefit of using `shellcheck` is that you can use the `-s` option to
    specify which shell that you want to use for testing your script. Even if the
    shebang line in your script is `#!/bin/sh`, and `sh` on your machine points to
    a non-`bash` shell, you can still test it against `bash`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: By testing against `bash`, we no longer get the warning about how we can’t use
    arrays. All we get this time is just a reminder that we should surround variable
    names with double quotes.
  prefs: []
  type: TYPE_NORMAL
- en: With the `-s` option, you can specify `sh`, `bash`, `dash`, or `ksh`. (Curiously,
    it doesn’t work with `zsh`.)
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on Lab – Using -s to Scan Function Libraries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also use the `-s` option to scan function library files that don’t have
    a shebang line. To see how that’s done, let’s scan the `sysinfo.lib` file that
    we last encountered back in *Chapter 14, Using awk-Part 1*.
  prefs: []
  type: TYPE_NORMAL
- en: The scripts and library files in this section are too large to show here in
    their entirety. So, be sure to download them from the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, copy the `sysinfo.lib` file to `sysinfo_posix.lib`, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, scan it for `bash`, since it was originally only meant to be used on
    `bash`. Here’s the relevant output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For `bash`, `shellcheck` didn’t find any show-stopping problems. But, it does
    suggest some improvements that could prevent problems. First, it suggests that
    I surround the `uname` command substitutions with double quotes, in case `uname`
    returns a text string that contains either white space or special characters that
    the shell could misinterpret. In reality, though, this will never be a problem
    in this script, because we know that `uname` will never return anything except
    for a plain-text, purely alphabetic string. But, let’s fix it anyway. In this
    case, the `if [ $(uname) = SunOS ]; then` line will become:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’ll do the same thing for every occurrence of the uname command substitution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second suggestion we see is to insert a graceful exit mechanism in case
    the script can’t `cd` into the /`Users/` directory. Again, we know that this won’t
    be a problem in this script, because we know that the specified directory will
    always be present. But again, let’s fix it anyway. Let’s take that `cd /Users`
    line and change it to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’ll do the same thing for all of the `cd` commands in the `open_files_users()`
    function. That way, if a `cd` command fails, the script will just continue running
    without this function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s say that we want to make this script portable, so that we won’t
    have to install `bash` on all of our systems. As I mentioned before, `dash` is
    the most POSIX-compliant shell that’s widely available for most Linux and BSD-type
    distros. So, let’s use `-s dash` to scan the file again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ve seen the first problem in previous scripts. It’s just that the `[[. .
    .]]` construct isn’t supported on some non-`bash` shells, such as `dash`. Fortunately,
    there’s no reason that requires us to use the double square brackets in this case,
    so we can just replace them with single square brackets. So, we’ll change the
    offending line to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The second problem is one that we haven’t seen yet. The `"${os:12}"` type of
    variable expansion is another bashism that won’t work on either Bourne shell or
    `dash`. To refresh your memory, the `os` variable is defined in the `system_info()`
    function that’s toward the end of the file. The variable definition, when done
    from the command-line, looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'But, we don’t want the `PRETTY_NAME=` part to show up in the report. All we
    want is just the name of the operating system. This `PRETTY_NAME=` string consists
    of 12 characters. On `bash`, we can strip those 12 characters away by doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'It looks good there, but watch what happens when I try this in a `dash` session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Oh dear, that doesn’t work at all. Fortunately, this is an easy fix. We’ll
    just use a POSIX-compliant form of variable expansion, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Instead of specifying the number of characters to strip from the beginning of
    the text string, we just specify the actual portion of the text string to strip.
    And, I replaced the `:` with a `#`. Easy, right?
  prefs: []
  type: TYPE_NORMAL
- en: This is one of the great mysteries of life that I haven’t yet figured out. Most
    bashisms were created as either a simpler way to do things, or to allow `bash`
    to do things that other shells can’t do at all. In this case, the `bash` way of
    performing variable expansion isn’t any easier than the POSIX way. So why did
    the `bash` developers even bother to give us this new, non-POSIX way? Your guess
    is as good as mine.
  prefs: []
  type: TYPE_NORMAL
- en: 'At any rate, you can read more about POSIX-compliant variable expansion here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'POSIX shell cheat sheet: [https://steinbaugh.com/posts/posix.html](https://steinbaugh.com/posts/posix.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to scan the script that uses this function library. Start by
    copying the `system_info.sh` to `system_info_posix.sh`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, scan the `system_info_posix.sh` script for `dash` compatibility:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The first thing we see is that “In dash, HOSTNAME is not supported.” That seems
    strange, because all I’m doing here is calling the value of an environmental variable.
    But, it says that it doesn’t work, so I’ll change it to use command substitution
    with the `hostname` command, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The next problem is the same old problem that we’ve seen before with the double
    square brackets. It’s another case where double square brackets aren’t necessary
    anyway, so I’ll change it to single square brackets, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let’s copy the `sysinfo_posix.lib` file to its proper place in the `/usr/local/lib/`
    directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, edit the `system_info_posix.sh` script so that it will source the new
    function library, and use `sh` as the interpreter shell. Make the top part of
    the script look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, copy the `system_info_posix.sh` script and the `sysinfo_posix.lib`
    file to other machines with other operating systems. You should find that this
    script and function library will work well on other Linux distros, as well as
    on FreeBSD, OpenIndiana, and macOS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: End of lab
  prefs: []
  type: TYPE_NORMAL
- en: So, we’ve covered `checkbashisms` and `shellcheck`. Shall we cover one more
    handy script-checking utility? Indeed we shall, and we shall do it now.
  prefs: []
  type: TYPE_NORMAL
- en: Using shall
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `checkbashisms` and `shellcheck` utilities act as **static code checkers**.
    This means that instead of actually running the scripts to see if they work, these
    two utilities just look through the code to detect problems. Sometimes though,
    it’s helpful to have a **dynamic code checker** that will actually run the code
    to see what happens. That’s where `shall` comes in.
  prefs: []
  type: TYPE_NORMAL
- en: '`shall` is a `bash` script that you can download from the author’s GitHub repository.
    The easiest way to install it is to clone the repository, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, go into the `shall/bin/` directory, and copy the `shall` script to the
    `/usr/local/bin/` directory, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Now, here’s the cool part. With only a single command, `shall` can test your
    scripts against `sh`, `bash`, `dash`, `zsh`, and `ksh`. (It doesn’t matter which
    interpreter shell you specify in the scripts’ shebang line.) Most Linux and BSD
    distros have these various shells in their package repositories, so you can install
    ones that aren’t installed already.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, `dash` and `bash` are already installed on our Debian machine, so
    let’s install `zsh` and `ksh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s begin by testing our `ip-2.sh` script. The output is too long to show
    in its entirety, so I’ll just show some relevant sections. Here’s the top part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The first check was for `sh`, which on Debian really means `dash`. You see
    here that the script couldn’t run, because `dash` can’t work with arrays. The
    next check is for `bash`, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The `zsh` and `ksh` checks that follow look the same. At the very bottom of
    the output, you’ll see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: This means that our `ip-2.sh` script runs fine on `bash`, `zsh`, and `ksh`,
    but it won’t run on `dash`.
  prefs: []
  type: TYPE_NORMAL
- en: 'But, as cool as `shall` is, it isn’t quite perfect. To see what I mean, create
    the `fly.sh` script, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'This is just a simple little script that demonstrates the problem with using
    `echo -e` in your scripts, as I showed you a few pages back. Here’s what happens
    when I test `fly.sh` with `shall`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: So, `shall` says that the script ran correctly on all four shells. But, at the
    top of the output, you see that the `-e` shows up in the `echo` output with `dash`,
    which is the problem that I showed you before. The bottom line here is that when
    you use `shall`, don’t just depend on what the status line at the bottom of the
    output says. Look at the output for all of the shells, and ensure that the output
    is what you really want to see.
  prefs: []
  type: TYPE_NORMAL
- en: The only other problem with `shall` isn’t really with `shall`, but with `sh`.
    Remember that `sh` points to a different shell on different Linux, BSD, and Unix
    distros. You can install `shall` on any of these distros, as long as you can install
    `bash` on them. Then, just copy the `shall` script to the machine on which you
    want to test `sh` scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'A man page is embedded into the `shall` script. To see it, just do:'
  prefs: []
  type: TYPE_NORMAL
- en: '`shall --man`'
  prefs: []
  type: TYPE_NORMAL
- en: Okay, I think that about does it for this chapter. Let’s summarize and move
    on.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Script portability is important if you need to create scripts that will run
    on a wide variety of Linux, Unix, or Unix-like operating systems. I began by showing
    you how to install bash on various BSD-type distros, and how to ensure that your
    scripts will find `bash` on them. After that, I explained the POSIX standard,
    and why it’s needed. Then, I showed you some bashisms, and some cool utilities
    that can test your scripts for them.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll talk about shell script security. I’ll see you there.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For shell scripters, what is the most important reason for following the POSIX
    standard?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To ensure that scripts will only run on Linux operating systems.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To ensure that scripts can run on a wide variety of Linux, Unix, and Unix-like
    operating systems.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To ensure that all operating systems are running `bash`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To ensure that scripts can use the advanced features of `bash`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following is a dynamic code checker?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`checkbashisms`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`shellcheck`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`shall`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`will`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following statements about `sh` is true?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On every operating system, `sh` is always the Bourne shell.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: On every operating system, `sh` is a symbolic link that points to `bash`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`sh` represents a different shell on different operating systems.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: You want to solve a math problem, and assign its value to a variable. Which
    of the following constructs would you use for best portability?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`var=$(3*4)`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`var=$[3*4]`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`var=$[[3*4]]`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`var=$((3*4))`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'UNIX Vs Linux: How Are They Different?: [https://www.maketecheasier.com/unix-vs-linux-how-are-they-different/](https://www.maketecheasier.com/unix-vs-linux-how-are-they-different/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What is the difference between “#!/usr/bin/env bash” and “#!/usr/bin/bash”?:
    [https://stackoverflow.com/questions/16365130/what-is-the-difference-between-usr-bin-env-bash-and-usr-bin-bash](https://stackoverflow.com/questions/16365130/what-is-the-difference-between-usr-bin-env-bash-and-usr-bin-bash)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Writing Bash Scripts that aren’t Only Bash: Checking for Bashisms and Using
    Dash: [https://www.bowmanjd.com/bash-not-bash-posix/](https://www.bowmanjd.com/bash-not-bash-posix/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A Brief POSIX Advocacy: [https://www.usenix.org/system/files/login/articles/login_spring16_09_tomei.pdf](https://www.usenix.org/system/files/login/articles/login_spring16_09_tomei.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A Guide to POSIX: [https://www.baeldung.com/linux/posix](https://www.baeldung.com/linux/posix)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How can I test for POSIX compliance of shell scripts?: [https://unix.stackexchange.com/questions/48786/how-can-i-test-for-posix-compliance-of-shell-scripts](https://unix.stackexchange.com/questions/48786/how-can-i-test-for-posix-compliance-of-shell-scripts)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Making Unix Shell Scripts POSIX-compliant: [https://stackoverflow.com/questions/40916071/making-unix-shell-scripts-posix-compliant](https://stackoverflow.com/questions/40916071/making-unix-shell-scripts-posix-compliant)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Rich’s sh (POSIX shell) Tricks: [http://www.etalabs.net/sh_tricks.html](http://www.etalabs.net/sh_tricks.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dash–ArchWiki: [https://wiki.archlinux.org/title/Dash](https://wiki.archlinux.org/title/Dash)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'POSIX shell cheat sheet: [https://steinbaugh.com/posts/posix.html](https://steinbaugh.com/posts/posix.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Is there a minimally POSIX.2 compliant shell?: [https://stackoverflow.com/questions/11376975/is-there-a-minimally-posix-2-compliant-shell](https://stackoverflow.com/questions/11376975/is-there-a-minimally-posix-2-compliant-shell)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: b
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: c
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: c
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: d
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Join our community on Discord!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Read this book alongside other users, Linux experts, and the author himself.
  prefs: []
  type: TYPE_NORMAL
- en: Ask questions, provide solutions to other readers, chat with the author via
    Ask Me Anything sessions, and much more. Scan the QR code or visit the link to
    join the community.
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/SecNet](https://packt.link/SecNet)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code10596186092701843.png)'
  prefs: []
  type: TYPE_IMG
